["import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    i = 0\n    q = [1]\n    p = [None] * (n + 1)\n    w = [True] * (n + 1)\n    while i < len(q):\n        x = q[i]\n        P = p[x]\n        i += 1\n        for v in g[x]:\n            if v != P:\n                q.append(v)\n                p[v] = x\n    r = 0\n    for i in range(len(q) - 1, 0, -1):\n        x = q[i]\n        P = p[x]\n        c = 0\n        for v in g[x]:\n            if v != P and w[v]:\n                c += 1\n        if c != 0:\n            r += c - 1\n            w[x] = False\n    c = 0\n    for v in g[1]:\n        if w[v]:\n            c += 1\n    if c == 0:\n        print(r + 1)\n    else:\n        print(r + c)\nfor i in range(int(input())):\n    solve()", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\nimport threading\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev):\n    (turn, count_buds, count_leaves) = (0, 0, 0)\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p)\n        turn = max(x[0], turn)\n        count_buds += x[1]\n        count_leaves += x[2]\n    if turn == 1:\n        count_buds += 1\n    else:\n        count_leaves += 1\n    return [turn ^ 1, count_buds, count_leaves]\n\ndef main():\n    global child\n    for T in range(int(input())):\n        n = int(input())\n        child = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = inp()\n            child[u].append(v)\n            child[v].append(u)\n        (turn, buds, leaves) = dfs(1, -1)\n        if turn == 0:\n            buds -= 1\n        else:\n            leaves -= 1\n        if turn == 0:\n            ans = leaves - buds\n        else:\n            ans = leaves - buds + 1\n        print(ans)\nthreading.stack_size(10 ** 8)\nthreading.Thread(target=main).start()", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(3 * 10 ** 5)\nimport threading\ninp = lambda : list(map(int, input().split()))\n\ndef dfs(p, prev):\n    (turn, count_buds, count_leaves) = (0, 0, 0)\n    for i in child[p]:\n        if i == prev:\n            continue\n        x = dfs(i, p)\n        turn = max(x[0], turn)\n        count_buds += x[1]\n        count_leaves += x[2]\n    if turn == 1:\n        count_buds += 1\n    else:\n        count_leaves += 1\n    return [turn ^ 1, count_buds, count_leaves]\n\ndef main():\n    global child\n    for T in range(int(input())):\n        n = int(input())\n        child = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = inp()\n            child[u].append(v)\n            child[v].append(u)\n        (turn, buds, leaves) = dfs(1, -1)\n        if turn == 0:\n            buds -= 1\n        else:\n            leaves -= 1\n        if turn == 0:\n            ans = leaves - buds\n        else:\n            ans = leaves - buds + 1\n        print(ans)\nthreading.stack_size(10 ** 8)\nthreading.Thread(target=main).start()", "import sys\ninput = sys.stdin.readline\nfor i in range(int(input())):\n    n = int(input())\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    i = 0\n    q = [1]\n    p = [None] * (n + 1)\n    w = [True] * (n + 1)\n    r = 0\n    while i < len(q):\n        x = q[i]\n        P = p[x]\n        i += 1\n        for v in g[x]:\n            if v != P:\n                q.append(v)\n                p[v] = x\n    for i in range(len(q) - 1, 0, -1):\n        x = q[i]\n        P = p[x]\n        c = len([1 for v in g[x] if v != P and w[v]])\n        if c != 0:\n            r += c - 1\n            w[x] = False\n    c = len([v for v in g[1] if w[v]])\n    print(r + 1) if c == 0 else print(r + c)", "import sys\ninput = sys.stdin.readline\nfor i in range(int(input())):\n    n = int(input())\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    i = 0\n    q = [1]\n    p = [None] * (n + 1)\n    w = [True] * (n + 1)\n    while i < len(q):\n        x = q[i]\n        P = p[x]\n        i += 1\n        for v in g[x]:\n            if v != P:\n                q.append(v)\n                p[v] = x\n    r = 0\n    for i in range(len(q) - 1, 0, -1):\n        x = q[i]\n        P = p[x]\n        c = 0\n        for v in g[x]:\n            if v != P and w[v]:\n                c += 1\n        if c != 0:\n            r += c - 1\n            w[x] = False\n    c = 0\n    for v in g[1]:\n        if w[v]:\n            c += 1\n    print(r + 1) if c == 0 else print(r + c)"]