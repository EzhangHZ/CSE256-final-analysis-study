["import sys\ninput = lambda : sys.stdin.readline()[:-1]\n\ndef replace_the_number(q, queries):\n    output = []\n    transformations = {}\n    for i in range(q - 1, -1, -1):\n        query = queries[i]\n        if query[0] == '1':\n            value = int(query[2:])\n            value = transformations.get(value, value)\n            output += [value]\n        else:\n            (x, y) = map(int, query[2:].split())\n            if y in transformations:\n                transformations[x] = transformations[y]\n            else:\n                transformations[x] = y\n    output = output[::-1]\n    return ' '.join(map(str, output))\nq = int(input())\nqueries = [None] * q\nfor i in range(q):\n    queries[i] = input()\nsys.stdout.write(f'{replace_the_number(q, queries)}\\n')", "import sys\n\ndef replace_the_number(q, queries):\n    output = []\n    transformations = {}\n    for i in range(q - 1, -1, -1):\n        query = queries[i]\n        if query[0] == '1':\n            value = int(query[2:])\n            value = transformations.get(value, value)\n            output += [value]\n        else:\n            (x, y) = map(int, query[2:].split())\n            if y in transformations:\n                transformations[x] = transformations[y]\n            else:\n                transformations[x] = y\n    output = output[::-1]\n    return ' '.join(map(str, output))\nq = int(input())\nqueries = [None] * q\nfor i in range(q):\n    queries[i] = input()\nsys.stdout.write(f'{replace_the_number(q, queries)}\\n')", "replaces = {}\nq = int(input())\nrequests = [input() for i in range(q)]\nans = []\nfor r in requests[::-1]:\n    if r[0] == '1':\n        v = int(r[2:])\n        ans.append(replaces.get(v, v))\n    else:\n        (u, w) = map(int, r[2:].split())\n        replaces[u] = replaces.get(w, w)\nprint(*ans[::-1])", "replaces = {}\nq = int(input())\nrequests = [input() for i in range(q)]\nans = []\nfor r in requests[::-1]:\n    if r[0] == '1':\n        v = int(r[2:])\n        ans.append(replaces.get(v, v))\n    else:\n        (u, w) = map(int, r[2:].split())\n        replaces[u] = replaces.get(w, w)\nprint(*ans[::-1])", "replaces = {}\nq = int(input())\nrequests = [input() for i in range(q)]\nans = []\nfor r in requests[::-1]:\n    if r[0] == '1':\n        v = int(r[2:])\n        ans.append(replaces.get(v, v))\n    else:\n        (u, w) = map(int, r[2:].split())\n        replaces[u] = replaces.get(w, w)\nprint(*ans[::-1])", "import sys\ninput = sys.stdin.readline\nparent = [i for i in range(500001)]\nq = []\nfor _ in range(int(input())):\n    q.append(tuple(map(int, input().split())))\nq.reverse()\nans = []\nfor j in q:\n    if j[0] == 1:\n        ans.append(parent[j[1]])\n    else:\n        parent[j[1]] = parent[j[2]]\nans.reverse()\nprint(*ans)", "replaces = {}\nq = int(input())\nrequests = [input() for i in range(q)]\nans = []\nfor r in requests[::-1]:\n    if r[0] == '1':\n        v = int(r[2:])\n        ans.append(replaces.get(v, v))\n    else:\n        (u, w) = map(int, r[2:].split())\n        replaces[u] = replaces.get(w, w)\nprint(*ans[::-1])", "import sys\ninput = sys.stdin.readline\nparent = [i for i in range(500001)]\nq = []\nfor _ in range(int(input())):\n    q.append(tuple(map(int, input().split())))\nq.reverse()\nans = []\nfor j in q:\n    if j[0] == 1:\n        ans.append(parent[j[1]])\n    else:\n        parent[j[1]] = parent[j[2]]\nans.reverse()\nprint(*ans)", "import sys\ninput = sys.stdin.readline\nparent = [i for i in range(500001)]\nq = []\nfor _ in range(int(input())):\n    q.append(tuple(map(int, input().split())))\nq.reverse()\nans = []\nfor j in q:\n    if j[0] == 1:\n        ans.append(parent[j[1]])\n    else:\n        parent[j[1]] = parent[j[2]]\nans.reverse()\nprint(*ans)", "import sys\npar = [i for i in range(500001)]\n\ndef calc(n, q):\n    ans = []\n    i = len(q) - 1\n    while i >= 0:\n        if len(q[i]) == 2:\n            x = q[i][1]\n            ans.append(par[x])\n        else:\n            x = q[i][1]\n            y = q[i][2]\n            par[x] = par[y]\n        i -= 1\n    ans = ans[::-1]\n    return ans\n\ndef solve():\n    q = int(sys.stdin.readline())\n    a = list((tuple(map(int, sys.stdin.readline().split())) for _ in range(q)))\n    res = calc(q, a)\n    print(*res)\nsolve()", "num_queries = int(input())\nqueries = []\nfor _ in range(num_queries):\n    queries.append(input())\nchanges = {}\nres = []\nfor query in queries[::-1]:\n    if query[0] == '2':\n        (key, value) = map(int, query[2:].split())\n        if value in changes:\n            changes[key] = changes[value]\n        else:\n            changes[key] = value\n    elif query[0] == '1':\n        num = int(query[2:])\n        if num in changes:\n            num = changes[num]\n        res.append(num)\nprint(*res[::-1])", "replaces = {}\nq = int(input())\nrequests = [input() for i in range(q)]\nans = []\nfor r in requests[::-1]:\n    if r[0] == '1':\n        v = int(r[2:])\n        ans.append(replaces.get(v, v))\n    else:\n        (u, w) = map(int, r[2:].split())\n        replaces[u] = replaces.get(w, w)\nprint(*ans[::-1])", "import sys\ninput = sys.stdin.readline\n\ndef sol():\n    ans = []\n    queries = []\n    allNumbers = {}\n    for _ in range(int(input())):\n        queries.append(tuple(map(int, input().split())))\n        if queries[-1][0] == 1:\n            allNumbers[queries[-1][1]] = queries[-1][1]\n            ans.append(0)\n        else:\n            allNumbers[queries[-1][1]] = queries[-1][1]\n            allNumbers[queries[-1][2]] = queries[-1][2]\n    lastIndex = len(ans) - 1\n    for query in range(len(queries) - 1, -1, -1):\n        if queries[query][0] == 2:\n            allNumbers[queries[query][1]] = allNumbers[queries[query][2]]\n        else:\n            ans[lastIndex] = allNumbers[queries[query][1]]\n            lastIndex -= 1\n    print(*ans)\nsol()", "T = 1\n\ndef solve():\n    positions = {}\n    cnt_numbers = 0\n    n = int(input())\n    for i in range(n):\n        line = list(map(int, input().split()))\n        if line[0] == 1:\n            x = line[1]\n            if not x in positions:\n                positions[x] = []\n            positions[x] += [cnt_numbers]\n            cnt_numbers += 1\n        else:\n            x = line[1]\n            y = line[2]\n            if y not in positions:\n                positions[y] = []\n            if y == x:\n                continue\n            if x in positions:\n                if len(positions[x]) > len(positions[y]):\n                    positions[x] += positions[y]\n                    positions[y] = positions[x]\n                else:\n                    positions[y] += positions[x]\n                del positions[x]\n    answer = [0] * cnt_numbers\n    for numb in positions:\n        for i in positions[numb]:\n            answer[i] = numb\n    return ' '.join([str(x) for x in answer])\nfor t in range(T):\n    print(solve())", "def main():\n    import sys\n    input = sys.stdin.readline\n    q = int(input())\n    query = [list(map(int, input().split())) for _ in range(q)]\n    query.reverse()\n    ans = []\n    from collections import defaultdict\n    D = defaultdict(lambda : -1)\n\n    def d(x):\n        if D[x] == -1:\n            return x\n        else:\n            return D[x]\n    for i in range(q):\n        tq = query[i]\n        if tq[0] == 2:\n            (x, y) = tq[1:]\n            D[x] = d(y)\n        else:\n            x = d(tq[1])\n            ans.append(x)\n    ans.reverse()\n    print(*ans)\nmain()", "import sys\ninput = lambda : sys.stdin.readline().strip()\nintput = lambda : map(int, input().split())\n(A, queries) = ([], [])\nf = [i for i in range(500001)]\n(Q,) = intput()\nfor _ in range(Q):\n    q = tuple(intput())\n    queries.append(q)\nfor q in reversed(queries):\n    if q[0] == 1:\n        A.append(f[q[1]])\n    if q[0] == 2:\n        f[q[1]] = f[q[2]]\nprint(*A[::-1])", "from collections import Counter, defaultdict, deque\nimport bisect\nfrom sys import stdin, stdout\nfrom itertools import repeat\nimport math\n\ndef inp(force_list=False):\n    re = list(map(int, input().split()))\n    if len(re) == 1 and (not force_list):\n        return re[0]\n    return re\n\ndef inst():\n    return input().strip()\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nMOD = 998244353\n\ndef query(a, b, c):\n    print('! %d %d %d' % (a + 1, b + 1, c + 1))\n    stdout.flush()\n    return inp()\n\ndef merge(a, b):\n    if len(a) < len(b):\n        (a, b) = (b, a)\n    a.extend(b)\n    return a\n\ndef my_main():\n    kase = 1\n    pans = []\n    for _ in range(kase):\n        q = inp()\n        mp = defaultdict(list)\n        idx = 0\n        for i in range(q):\n            qq = inp()\n            if qq[0] == 1:\n                mp[qq[1]].append(idx)\n                idx += 1\n            else:\n                (x, y) = qq[1:]\n                if x != y:\n                    mp[y] = merge(mp[y], mp[x])\n                    mp.pop(x, None)\n        ans = [0] * idx\n        for (k, v) in mp.items():\n            for idx in v:\n                ans[idx] = k\n        pans.append(' '.join(map(str, ans)))\n    print('\\n'.join(pans))\nmy_main()", "import sys\ninput = sys.stdin.readline\nn = 0\nans = []\nqueries = []\nfor _ in range(int(input())):\n    queries.append(tuple(map(int, input().split())))\n    if queries[-1][0] == 1:\n        ans.append(0)\n        n += 1\nallNumbers = {i: i for i in range(1, 5 * pow(10, 5) + 1)}\nlastIndex = n - 1\nfor query in range(len(queries) - 1, -1, -1):\n    if queries[query][0] == 2:\n        allNumbers[queries[query][1]] = allNumbers[queries[query][2]]\n    else:\n        ans[lastIndex] = allNumbers[queries[query][1]]\n        lastIndex -= 1\nprint(*ans)", "lines = int(input())\nresult = []\ntmp = {}\nl = []\nfor _ in range(lines):\n    l.append([int(i) for i in input().split()])\nfor i in reversed(l):\n    if i[0] == 1:\n        x = i[1]\n        if x in tmp:\n            result.append(tmp[x])\n        else:\n            result.append(x)\n    else:\n        x = i[1]\n        y = i[2]\n        if y in tmp:\n            tmp[x] = tmp[y]\n        else:\n            tmp[x] = y\nprint(' '.join([str(i) for i in result[::-1]]))", "import sys\nfrom collections import deque\nimport math\nfrom bisect import bisect_left\nfrom functools import cmp_to_key\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef SI():\n    return sys.stdin.readline().strip()\n\ndef FACT(n, mod):\n    s = 1\n    facts = [1]\n    for i in range(1, n + 1):\n        s *= i\n        s %= mod\n        facts.append(s)\n    return facts[n]\n\ndef C(n, k, mod):\n    return FACT(n, mod) * pow(FACT(k, mod) * FACT(n - k, mod) % mod, mod - 2, mod) % mod\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\na = []\nans = []\nfor _ in range(II()):\n    s = input().split()\n    t = int(s.pop(0))\n    if t == 1:\n        x = int(s[0])\n        a.append((x, -1))\n    else:\n        (x, y) = s\n        x = int(x)\n        y = int(y)\n        a.append((x, y))\nd = {}\na.reverse()\nfor (x, y) in a:\n    if y == -1:\n        if not d.get(x):\n            ans.append(x)\n        else:\n            ans.append(d[x])\n    elif d.get(y):\n        d[x] = d[y]\n    else:\n        d[x] = y\nans.reverse()\nprint(*ans)", "n = int(input())\nmapIndex = {}\narr = []\nfor i in range(n):\n    inpArr = [int(x) for x in input().split()]\n    if inpArr[0] == 1:\n        arr.append(inpArr[1])\n    else:\n        arr.append(inpArr[1:])\nans = []\nfor i in arr[::-1]:\n    if isinstance(i, list):\n        if i[1] not in mapIndex:\n            mapIndex[i[1]] = i[1]\n        if i[0] not in mapIndex:\n            mapIndex[i[0]] = i[0]\n        mapIndex[i[0]] = mapIndex[i[1]]\n    else:\n        if i not in mapIndex:\n            mapIndex[i] = i\n        ans.append(str(mapIndex[i]))\nprint(' '.join(ans[::-1]))", "import sys\nt = int(input())\nm = []\nd = {}\nfrom collections import deque\nans = []\nfor _ in range(t):\n    m.append(list(sys.stdin.readline().split()))\nfor i in range(t - 1, -1, -1):\n    if m[i][0] == '1':\n        if m[i][1] in d:\n            ans.append(d[m[i][1]])\n        else:\n            ans.append(m[i][1])\n    elif m[i][2] in d:\n        d[m[i][1]] = d[m[i][2]]\n    else:\n        d[m[i][1]] = m[i][2]\nfor i in range(len(ans) - 1, -1, -1):\n    print(ans[i], end=' ')", "import sys\ninput = sys.stdin.readline\np = list(range(5 * 10 ** 5 + 1))\narg = []\nq = int(input())\ns = []\nfor _ in range(q):\n    arg.append(list(map(int, input().split())))\narg.reverse()\nfor i in range(q):\n    if arg[i][0] == 1:\n        s.append(p[arg[i][1]])\n    else:\n        p[arg[i][1]] = p[arg[i][2]]\ns.reverse()\nprint(*s)", "a = []\nfor _ in range(int(input())):\n    g = [int(x) for x in input().split()]\n    a.append(g)\na = a[::-1]\nd = {}\nres = []\nfor q in a:\n    if len(q) == 2:\n        if q[1] in d.keys():\n            res.append(str(d[q[1]]))\n        else:\n            res.append(str(q[1]))\n    else:\n        y = q[2]\n        x = q[1]\n        if y in d:\n            d[x] = d[y]\n        else:\n            d[x] = y\nprint(' '.join(res[::-1]))", "def solver():\n    n = int(input())\n    final = []\n    writer = []\n    changer = {}\n    for i in range(n):\n        writer.append(list(map(int, input().split())))\n    for i in reversed(writer):\n        if i[0] == 1:\n            if i[1] not in changer:\n                dummy = i[1]\n            else:\n                dummy = changer[i[1]]\n            final.append(dummy)\n        elif i[2] not in changer:\n            changer[i[1]] = i[2]\n        else:\n            changer[i[1]] = changer[i[2]]\n    print(*final[::-1])\nsolver()", "from sys import *\ninput = stdin.readline\nlst = []\nd = []\nans = []\nn = int(input())\nd = [0] * 500002\nfor i in range(500002):\n    d[i] = i\nfor i in range(n):\n    lst2 = list(map(int, input().split()))\n    lst.append(lst2)\nfor i in range(n - 1, -1, -1):\n    if lst[i][0] == 1:\n        ans.append(d[lst[i][1]])\n    else:\n        d[lst[i][1]] = d[lst[i][2]]\nprint(*ans[::-1])", "from sys import *\ninput = stdin.readline\nq = int(input())\nr = list(range(500005))\ng = []\nans = []\nfor i in range(q):\n    qr = list(map(int, input().split()))\n    g.append(qr)\nfor x in g[::-1]:\n    if x[0] == 1:\n        ans.append(str(r[x[1]]))\n    else:\n        r[x[1]] = r[x[2]]\nprint(*ans[::-1])", "ql = []\nfor tt in range(int(input())):\n    ql.append(input())\nl = []\nd = [-1] * 1000000\nfor tt in range(1, len(ql) + 1):\n    q = list(map(int, ql[-tt].split()))\n    if len(q) == 2:\n        if d[q[1]] == -1:\n            l.append(q[1])\n        else:\n            l.append(d[q[1]])\n    elif d[q[2]] == -1:\n        d[q[1]] = q[2]\n    else:\n        d[q[1]] = d[q[2]]\nfor i in range(1, len(l) + 1):\n    print(l[-i], end=' ')", "q = int(input())\norder = [i for i in range(600000)]\nt = [0 for i in range(q)]\nx = [0 for i in range(q)]\ny = [0 for i in range(q)]\nfor i in range(q):\n    inp = list(map(int, input().split()))\n    t[i] = inp[0]\n    x[i] = inp[1]\n    if inp[0] == 2:\n        y[i] = inp[2]\nans = []\nfor i in range(q - 1, -1, -1):\n    if t[i] == 1:\n        ans.append(order[x[i]])\n    else:\n        order[x[i]] = order[y[i]]\nprint(*ans[::-1])", "q = int(input())\nl = []\nm = []\nd = {}\nfor _ in range(q):\n    a = input().split()\n    l.append(a)\nfor x in l[::-1]:\n    if x[0] == '1':\n        if x[1] in d:\n            m.append(d[x[1]])\n        else:\n            m.append(x[1])\n    elif x[2] in d:\n        d[x[1]] = d[x[2]]\n    else:\n        d[x[1]] = x[2]\nm = m[::-1]\nprint(*m)", "def sol():\n    ans = []\n    queries = []\n    allNumbers = {}\n    for _ in range(int(input())):\n        queries.append(tuple(map(int, input().split())))\n        if queries[-1][0] == 1:\n            allNumbers[queries[-1][1]] = queries[-1][1]\n            ans.append(0)\n        else:\n            allNumbers[queries[-1][1]] = queries[-1][1]\n            allNumbers[queries[-1][2]] = queries[-1][2]\n    lastIndex = len(ans) - 1\n    for query in range(len(queries) - 1, -1, -1):\n        if queries[query][0] == 2:\n            allNumbers[queries[query][1]] = allNumbers[queries[query][2]]\n        else:\n            ans[lastIndex] = allNumbers[queries[query][1]]\n            lastIndex -= 1\n    print(*ans)\nsol()", "q = int(input())\nl = []\nm = []\nd = {}\nfor _ in range(q):\n    a = input().split()\n    l.append(a)\nfor x in l[::-1]:\n    if x[0] == '1':\n        if x[1] in d:\n            m.append(d[x[1]])\n        else:\n            m.append(x[1])\n    elif x[2] in d:\n        d[x[1]] = d[x[2]]\n    else:\n        d[x[1]] = x[2]\nm = m[::-1]\nprint(*m)", "q = int(input())\nqueries = []\nfor i in range(q):\n    queries.append([int(x) for x in input().split()])\nqueries.reverse()\nperm = [0] * 500005\nfor i in range(500005):\n    perm[i] = i\nans = []\nfor query in queries:\n    if query[0] == 1:\n        ans.append(perm[query[1]])\n    else:\n        perm[query[1]] = perm[query[2]]\nans.reverse()\nprint(*ans)", "import sys\n\ndef rl():\n    return sys.stdin.readline()\n\ndef r_arr():\n    a = rl().split(' ')\n    a = [int(x) for x in a]\n    return a\nn = int(rl())\na = [0] * n\nb = [0] * n\nx = [0] * n\ny = [0] * n\nd = {}\nfor i in range(n):\n    arr = r_arr()\n    b[i] = arr[0]\n    if b[i] == 1:\n        a[i] = arr[1]\n    else:\n        x[i] = arr[1]\n        y[i] = arr[2]\nfor i in range(n - 1, -1, -1):\n    if b[i] == 1:\n        z = a[i]\n        if z in d:\n            a[i] = d[z]\n    else:\n        xx = x[i]\n        yy = y[i]\n        if yy in d:\n            d[xx] = d[yy]\n        else:\n            d[xx] = yy\nst = ''\nfor i in range(n):\n    if b[i] == 1:\n        st += str(a[i]) + ' '\nprint(st)", "q = int(input())\nlocations = dict()\nn = 0\nfor i in range(q):\n    case = list(map(int, input().split()))\n    (x, y) = (0, 0)\n    if case[0] == 1:\n        x = case[1]\n        current = locations.get(x, list())\n        current.append(n)\n        locations[x] = current\n        n += 1\n    else:\n        (x, y) = (case[1], case[2])\n        if x == y:\n            continue\n        xloc = locations.get(x, list())\n        if len(xloc) == 0:\n            continue\n        locations.pop(x)\n        yloc = locations.get(y, list())\n        if len(yloc) == 0:\n            locations[y] = xloc\n        elif len(yloc) > len(xloc):\n            yloc.extend(xloc)\n            locations[y] = yloc\n        else:\n            xloc.extend(yloc)\n            locations[y] = xloc\noutput = [0 for i in range(n)]\nfor (key, value) in locations.items():\n    for val in value:\n        output[val] = str(key)\nprint(' '.join(output))", "from collections import defaultdict\nn = int(input())\nd = defaultdict(list)\na = []\nmp = [i for i in range(0, 500001)]\nfor i in range(n):\n    A = list(map(int, input().split()))\n    if A[0] == 1:\n        a.append((A[0], A[1]))\n    else:\n        a.append((A[0], A[1], A[2]))\nans = []\nfor i in range(n - 1, -1, -1):\n    if len(a[i]) == 2:\n        ans.append(mp[a[i][1]])\n    else:\n        mp[a[i][1]] = mp[a[i][2]]\nans = ans[::-1]\nprint(*ans)", "import sys\ninput = sys.stdin.readline\nq = int(input())\nquery = [list(map(int, input().split())) for _ in range(q)]\nquery.reverse()\nans = []\nfrom collections import defaultdict\nD = defaultdict(lambda : -1)\n\ndef d(x):\n    if D[x] == -1:\n        return x\n    else:\n        return D[x]\nfor i in range(q):\n    tq = query[i]\n    if tq[0] == 2:\n        (x, y) = tq[1:]\n        D[x] = d(y)\n    else:\n        x = d(tq[1])\n        ans.append(x)\nans.reverse()\nprint(*ans)", "t = int(input())\nd = dict()\nans = []\nq = []\nfor i in range(t):\n    q.append(list(map(int, input().split())))\nfor x in reversed(q):\n    if x[0] == 1:\n        if x[1] not in d:\n            cur = x[1]\n        else:\n            cur = d[x[1]]\n        ans.append(cur)\n    elif x[2] not in d:\n        d[x[1]] = x[2]\n    else:\n        d[x[1]] = d[x[2]]\nprint(*ans[::-1])", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nMax = 5 * 100000 + 1\npar = [i for i in range(Max)]\nq = [list(input().split()) for i in range(int(input()))]\nans = []\nwhile q:\n    a = q.pop()\n    if a[0] == '1':\n        ans.append(par[int(a[1])])\n    else:\n        par[int(a[1])] = par[int(a[2])]\nprint(*ans[::-1])", "t = int(input())\nd = dict()\nans = []\nq = []\nfor i in range(t):\n    q.append(list(map(int, input().split())))\nfor x in reversed(q):\n    if x[0] == 1:\n        if x[1] not in d:\n            cur = x[1]\n        else:\n            cur = d[x[1]]\n        ans.append(cur)\n    elif x[2] not in d:\n        d[x[1]] = x[2]\n    else:\n        d[x[1]] = d[x[2]]\nprint(*ans[::-1])"]