["import sys\nDEBUG = False\n\ndef check(a, b, c):\n    a = [0] + a\n    b = [0] + b\n    c = [0] + c\n    m_ = [0] * len(a)\n    m = [0] * len(a)\n    for i in range(1, len(b)):\n        m_[b[i]] = i\n    for i in range(1, len(a)):\n        m[i] = m_[a[i]]\n    total_num = 1\n    used = [False] * len(m)\n    for i in range(1, len(m)):\n        if not used[i]:\n            j = i\n            c_zeros = True\n            while not used[j]:\n                if c[j] != 0:\n                    c_zeros = False\n                used[j] = True\n                j = m[j]\n            used[i] = True\n            if c_zeros and m[i] != i:\n                total_num = total_num * 2 % 1000000007\n    print(total_num)\n\ndef main(f):\n    t = int(f.readline())\n    for i in range(t):\n        n = int(f.readline())\n        a = list(map(int, f.readline().split()))\n        b = list(map(int, f.readline().split()))\n        c = list(map(int, f.readline().split()))\n        check(a, b, c)\nif DEBUG:\n    f = open('input.txt', 'r')\nelse:\n    f = sys.stdin\nmain(f)\nf.close()", "import sys\ninput = sys.stdin.readline\n\ndef find_cycles(A, B, N):\n    visited = [False] * N\n    nxt = dict(zip(A, B))\n    seen = set()\n    cycles = []\n    for a in A:\n        if a in seen:\n            continue\n        i = a\n        c = []\n        while i not in seen:\n            seen.add(i)\n            c.append(i)\n            i = nxt[i]\n        cycles.append(c)\n    return cycles\n\ndef count(cycle, known):\n    if any((c in known for c in cycle)):\n        return 1\n    elif len(cycle) == 1:\n        return 1\n    else:\n        return 2\n\ndef solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    D = list(map(int, input().split()))\n    cycles = find_cycles(A, B, N)\n    known = {i for i in D if i != 0}\n    ans = 1\n    for c in cycles:\n        ans *= count(c, known)\n        ans %= 1000000007\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "import sys\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, sys.stdin.readline().strip('\\n').split()))\n\ndef Solve():\n    n = ri()\n    a = rl()\n    b = rl()\n    d = rl()\n    tag = [0] * (n + 1)\n    for x in d:\n        if x and tag[x]:\n            print('0')\n            return\n        tag[x] = 1\n    tag = [0] * (n + 1)\n    posa = [0] * (n + 1)\n    tag = [0] * (n + 1)\n    for i in range(0, n):\n        posa[a[i]] = i\n    ans = 1\n    mod = int(1000000000.0 + 7)\n    for i in range(0, n):\n        if tag[i]:\n            continue\n        pos = i\n        flag = 2\n        while tag[pos] == 0:\n            if d[pos] or a[pos] == b[pos]:\n                flag = 1\n            tag[pos] = 1\n            nxt = posa[b[pos]]\n            pos = nxt\n        ans = ans * flag % mod\n    print(ans)\nT = ri()\nwhile T:\n    T -= 1\n    Solve()", "M = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    fixed = [0] * (n + 1)\n    for i in range(n):\n        if d[i] != 0:\n            fixed[a[i]] = 1\n    c = [0] * (n + 1)\n    for i in range(n):\n        c[a[i]] = b[i]\n    a = c\n    vis = [0] * (n + 1)\n\n    def dfs(i):\n        vis[i] = 1\n        c = i\n        if a[i] == i:\n            return False\n        while a[i] != c:\n            vis[a[i]] = 1\n            if fixed[i] or fixed[a[i]]:\n                return False\n            i = a[i]\n        return True\n    ans = 1\n    for i in range(1, n + 1):\n        if not vis[i] and dfs(i):\n            ans = ans * 2 % M\n    print(ans)", "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    poh = [0] * n\n    obr = 10 ** 9 + 7\n    otv = 0\n    dictt = dict()\n    for i in range(n):\n        dictt[a[i]] = b[i]\n        if c[i] != 0 or a[i] == b[i]:\n            poh[a[i] - 1] = 1\n    while dictt:\n        ahahah = 0\n        gg = dictt.popitem()\n        if poh[gg[0] - 1] == 1:\n            ahahah = 1\n        else:\n            ahahah = 0\n        ggb = gg[1]\n        while ggb in dictt:\n            if poh[ggb - 1] == 1:\n                ahahah = 1\n            ggb = dictt.pop(ggb)\n        if ahahah == 0:\n            otv += 1\n    print(2 ** otv % obr)", "m = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = {i: 0 for i in range(1, n + 1)}\n    for i in range(n):\n        d[c[i]] = 1\n    dd = {}\n    for i in range(n):\n        dd[a[i]] = i\n    ans = 1\n    for i in range(n):\n        if c[i] != 0 or a[i] == b[i] or d[a[i]] == 1 or (d[b[i]] == 1):\n            continue\n        j = dd[b[i]]\n        f = 2\n        while j != i:\n            if c[j] != 0:\n                f = 1\n            c[j] = 1\n            j = dd[b[j]]\n        ans = ans * f % m\n        k = 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\nI = lambda : int(input())\nA = lambda : [*map(int, input().split())]\nmod = 10 ** 9 + 7\nfor _ in range(I()):\n    n = I()\n    (a, b, c) = (A(), A(), A())\n    g = {a[i]: [b[i], c[i]] for i in range(n)}\n    (cycles, visi) = (0, [False] * (n + 1))\n    for u in range(1, n + 1):\n        need = True\n        cycle_size = 0\n        while not visi[g[u][0]]:\n            if g[u][1] != 0:\n                need = False\n            (visi[g[u][0]], u) = (True, g[u][0])\n            cycle_size += 1\n        if need and cycle_size > 1:\n            cycles += 1\n    print(pow(2, cycles, mod))", "import sys\ninput = sys.stdin.readline\nI = lambda : int(input())\nA = lambda : [*map(int, input().split())]\nmod = 10 ** 9 + 7\nfor _ in range(I()):\n    n = I()\n    (a, b, c) = (A(), A(), A())\n    g = {a[i]: [b[i], c[i]] for i in range(n)}\n    (cycles, visi) = (0, [False] * (n + 1))\n    for u in range(1, n + 1):\n        need = True\n        cycle_size = 0\n        while not visi[g[u][0]]:\n            if g[u][1] != 0:\n                need = False\n            (visi[g[u][0]], u) = (True, g[u][0])\n            cycle_size += 1\n        if need and cycle_size > 1:\n            cycles += 1\n    print(pow(2, cycles, mod))", "import sys\ninput = sys.stdin.readline\nM = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = [[-1, -1] for _ in range(n + 1)]\n    for i in range(n):\n        d[a[i]] = [b[i], c[i]]\n    x = [0] * (n + 1)\n    ans = 1\n    for i in range(1, n + 1):\n        if i == d[i][0]:\n            continue\n        elif x[d[i][0]] == 0:\n            c = 0\n            while x[d[i][0]] == 0:\n                c += d[i][1]\n                (x[d[i][0]], i) = (1, d[i][0])\n            if c == 0:\n                ans = ans * 2 % M\n    print(ans)", "import collections\nmod = 10 ** 9 + 7\n\ndef ff(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = ff(par[x])\n        return par[x]\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    ans = 1\n    par = [i for i in range(0, n + 1)]\n    vis = [0] * (n + 1)\n    sz = [0] * (n + 1)\n    for i in range(n):\n        par[ff(a[i])] = ff(b[i])\n    for i in range(n):\n        vis[ff(c[i])] = 1\n    for i in range(n):\n        if a[i] == b[i]:\n            vis[a[i]] = 1\n    for i in range(1, 1 + n):\n        if vis[ff(i)] == 0:\n            ans = ans * 2 % mod\n            vis[ff(i)] = 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    ai = list(map(int, input().split()))\n    bi = list(map(int, input().split()))\n    di = list(map(int, input().split()))\n    visited = set([])\n    arr = []\n    for i in di:\n        if i != 0:\n            arr.append(i)\n    graph = {i: 0 for i in range(1, n + 1)}\n    for i in range(n):\n        graph[ai[i]] = bi[i]\n\n    def dfs(i):\n        stack = [i]\n        while stack:\n            root = stack.pop()\n            visited.add(root)\n            if graph[root] not in visited:\n                stack.append(graph[root])\n    for i in arr:\n        if i not in visited:\n            dfs(i)\n    ans = 1\n    for i in range(1, n + 1):\n        if i not in visited and graph[i] != i:\n            dfs(i)\n            ans = ans * 2 % (10 ** 9 + 7)\n    print(ans)", "import sys\nimport math\nfrom bisect import bisect_right as br\nfrom collections import deque\nfrom itertools import combinations as cb\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    a = int_arr()\n    b = int_arr()\n    c = int_arr()\n    graph = {}\n    done = set()\n    ans = 1\n    for i in range(n):\n        graph[a[i]] = [b[i], i]\n    for i in range(n):\n        if a[i] in done:\n            continue\n        val = a[i]\n        flag = 1\n        while val not in done:\n            done.add(val)\n            if c[graph[val][1]] != 0 or val == graph[val][0]:\n                flag = 0\n            val = graph[val][0]\n        if flag == 1:\n            ans = ans % mod * 2\n            ans %= mod\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    ai = list(map(int, input().split()))\n    bi = list(map(int, input().split()))\n    di = list(map(int, input().split()))\n    visited = set([])\n    arr = []\n    for i in di:\n        if i != 0:\n            arr.append(i)\n    graph = {i: 0 for i in range(1, n + 1)}\n    for i in range(n):\n        graph[ai[i]] = bi[i]\n\n    def dfs(i):\n        stack = [i]\n        while stack:\n            root = stack.pop()\n            visited.add(root)\n            if graph[root] not in visited:\n                stack.append(graph[root])\n    for i in arr:\n        if i not in visited:\n            dfs(i)\n    ans = 0\n    for i in range(1, n + 1):\n        if i not in visited and graph[i] != i:\n            dfs(i)\n            ans += 1\n    print(pow(2, ans, 10 ** 9 + 7))", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    mo = 10 ** 9 + 7\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    idx = [[] for _ in range(n + 1)]\n    stack = []\n    for i in range(n):\n        idx[A[i]].append(i)\n        idx[B[i]].append(i)\n        if C[i] != 0:\n            stack.append(i)\n    for i in range(1, n + 1):\n        (j, k) = idx[i]\n        if j != k:\n            graph[j].append(k)\n            graph[k].append(j)\n    vis = set()\n    ans = 1\n    for i in stack:\n        if i not in vis:\n            vis.add(i)\n            stack = [i]\n            while stack:\n                curr = stack.pop()\n                for nei in graph[curr]:\n                    if nei not in vis:\n                        stack.append(nei)\n                        vis.add(nei)\n    for i in range(n):\n        if i not in vis:\n            vis.add(i)\n            stack = [i]\n            if A[i] != B[i]:\n                ans *= 2\n                ans %= mo\n                while stack:\n                    curr = stack.pop()\n                    for nei in graph[curr]:\n                        if nei not in vis:\n                            stack.append(nei)\n                            vis.add(nei)\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    mo = 10 ** 9 + 7\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    idx = [[] for _ in range(n + 1)]\n    stack = []\n    for i in range(n):\n        idx[A[i]].append(i)\n        idx[B[i]].append(i)\n        if C[i] != 0:\n            stack.append(i)\n    for i in range(1, n + 1):\n        (j, k) = idx[i]\n        if j != k:\n            graph[j].append(k)\n            graph[k].append(j)\n    vis = set()\n    ans = 1\n    for i in stack + [i for i in range(n)]:\n        if i not in vis:\n            vis.add(i)\n            stack = [i]\n            if C[i] == 0 and A[i] != B[i]:\n                ans *= 2\n                ans %= mo\n            while stack:\n                curr = stack.pop()\n                for nei in graph[curr]:\n                    if nei not in vis:\n                        stack.append(nei)\n                        vis.add(nei)\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "class dsu:\n\n    def __init__(self, n):\n        self.comp = n\n        self.id = list(range(n))\n        self.sz = [1] * n\n\n    def find(s, p):\n        rt = p\n        while rt != s.id[rt]:\n            rt = s.id[rt]\n        while p != rt:\n            (s.id[p], p) = (rt, s.id[p])\n        return rt\n\n    def join(s, a, b):\n        if not s.connected(a, b):\n            (r1, r2) = (s.find(b), s.find(a))\n            s.id[r1] = s.id[r2]\n            s.sz[r2] += s.sz[r1]\n            s.comp -= 1\n    connected = lambda this, a, b: this.find(a) == this.find(b)\n    size = lambda s: s.comp\n    compSize = lambda s, x: s.sz[s.find(x)]\nimport sys\nI = lambda : [*map(int, sys.stdin.readline().split())]\nO = sys.stdout.write\nm = int(1000000000.0) + 7\nfor _ in range(*I()):\n    n = I()[0]\n    (a, b, c) = (I(), I(), I())\n    d = dsu(n)\n    (grp1, grp2) = (set(), set())\n    for i in range(n):\n        d.join(a[i] - 1, b[i] - 1)\n    for i in range(n):\n        if a[i] != b[i] and c[i]:\n            grp1.add(d.find(c[i] - 1))\n        if d.compSize(i) > 1:\n            grp2.add(d.find(i))\n    O(str(pow(2, len(grp2) - len(grp1), m)))\n    O('\\n')"]