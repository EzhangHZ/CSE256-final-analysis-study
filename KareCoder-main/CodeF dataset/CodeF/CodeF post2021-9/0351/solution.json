["def solve(n, h, attacks):\n    gaps = [attacks[i] - attacks[i - 1] for i in range(1, n)]\n    gaps.sort()\n    mn = h // n + (1 if h % n else 0)\n    rem = h\n    spared = 0\n    for (i, gap) in enumerate(gaps):\n        if gap >= mn:\n            if mn * (n - i) < rem:\n                mn = min(gap, rem // (n - i) + (1 if rem % (n - i) else 0))\n                rem -= mn\n            else:\n                rem = 0\n                break\n        else:\n            rem -= gap\n    if rem - mn > 0:\n        mn += rem - mn\n    return mn\nans = []\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    ans.append(solve(n, h, list(map(int, input().split()))))\nprint(*ans, sep='\\n')", "def solve(n, h, attacks):\n    gaps = [attacks[i] - attacks[i - 1] for i in range(1, n)]\n    gaps.sort()\n    mn = h // n + (1 if h % n else 0)\n    rem = h\n    spared = 0\n    for (i, gap) in enumerate(gaps):\n        if gap >= mn:\n            if mn * (n - i) < rem:\n                mn = min(gap, rem // (n - i) + (1 if rem % (n - i) else 0))\n                rem -= mn\n            else:\n                rem = 0\n                break\n        else:\n            rem -= gap\n    if rem - mn > 0:\n        mn += rem - mn\n    return mn\nans = []\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    ans.append(solve(n, h, list(map(int, input().split()))))\nprint(*ans, sep='\\n')", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "from collections import Counter\nfrom math import ceil, floor, log\nimport bisect as bs\nimport sys\ninput = sys.stdin.readline\ninp_lis = lambda : list(map(int, input().split()))\ninp_multi = lambda : map(int, input().split())\ninp_int = lambda : int(input().strip())\nfor _ in range(int(input().strip())):\n    (n, h) = inp_multi()\n    a = inp_lis()\n    k = 0\n    if n == 1:\n        print(h)\n        continue\n    if h <= n:\n        print(1)\n        continue\n    l = [a[i + 1] - a[i] for i in range(n - 1)]\n    l.sort()\n    k = 0\n    for i in range(n - 1):\n        if l[i] * (n - i) >= h:\n            k = ceil(h / (n - i))\n            break\n        else:\n            h -= l[i]\n    print(k if k != 0 else h)", "from collections import Counter\nfrom math import ceil, floor, log\nimport bisect as bs\nimport sys\ninput = sys.stdin.readline\ninp_lis = lambda : list(map(int, input().split()))\ninp_multi = lambda : map(int, input().split())\ninp_int = lambda : int(input().strip())\nfor _ in range(int(input().strip())):\n    (n, h) = inp_multi()\n    a = inp_lis()\n    k = 0\n    if n == 1:\n        print(h)\n        continue\n    if h <= n:\n        print(1)\n        continue\n    l = [a[i + 1] - a[i] for i in range(n - 1)]\n    l.sort()\n    k = 0\n    for i in range(n - 1):\n        if l[i] * (n - i) >= h:\n            k = ceil(h / (n - i))\n            break\n        else:\n            h -= l[i]\n    print(k if k != 0 else h)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "import math\n\ndef Poison_damage_search(dragon_hp, poison_ticks, remaining_attacks):\n    if dragon_hp < remaining_attacks:\n        return 1\n    sum_damage = 0\n    for curr_damage in poison_ticks:\n        if curr_damage > (dragon_hp - sum_damage) // remaining_attacks:\n            break\n        sum_damage += curr_damage\n        remaining_attacks -= 1\n    return 0 - (sum_damage - dragon_hp) // remaining_attacks\namount_of_data = int(input())\ndragon_raids = []\nfor _ in range(amount_of_data):\n    (amount_attacks, dragon_hp) = map(int, input().split())\n    attacks = tuple(map(int, input().split()))\n    poison_ticks = [attacks[curr] - attacks[curr - 1] for curr in range(1, len(attacks))]\n    poison_ticks.sort()\n    dragon_raids.append(tuple([amount_attacks, dragon_hp, poison_ticks]))\nfor curr_try in dragon_raids:\n    amount_attacks = curr_try[0]\n    dragon_hp = curr_try[1]\n    poison_ticks = curr_try[2]\n    print(Poison_damage_search(dragon_hp, poison_ticks, amount_attacks))", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "def real_input_generator():\n    while True:\n        yield input()\n\ndef example_input_generator(example):\n    for line in example.split('\\n'):\n        yield line\nexamples = ['4\\n2 5\\n1 5\\n3 10\\n2 4 10\\n5 3\\n1 2 4 5 7\\n4 1000\\n3 25 64 1337']\n\ndef solve(test_case_num):\n    if test_case_num < 0:\n        ig = real_input_generator()\n    else:\n        print('TESTING NOW')\n        ig = example_input_generator(examples[test_case_num])\n    t = int(next(ig))\n    for _ in range(t):\n        [n, h] = list(map(int, next(ig).split()))\n        lst = list(map(int, next(ig).split()))\n        print(solution(n, h, lst))\n\ndef solution(n, h, lst):\n    if n >= h:\n        return 1\n        _hy_anon_var_2 = None\n    else:\n        _hy_anon_var_2 = None\n    for i in range(n - 1):\n        lst[i] = lst[i + 1] - lst[i]\n    lst[n - 1] = h\n    lst.sort()\n    for [i, v] in enumerate(lst):\n        if v * (n - i) >= h:\n            return (h - 1) // (n - i) + 1\n            _hy_anon_var_3 = None\n        else:\n            _hy_anon_var_3 = None\n        h -= v\n    return lst[-1] + h\nsolve(-1)", "tests = int(input())\nfor _ in range(tests):\n    [n, h] = [int(x) for x in input().split()]\n    attacks = [int(x) for x in input().split()]\n    dmgs = sorted((a2 - a1 for (a1, a2) in zip(attacks, attacks[1:])))\n    s = 0\n    for k in dmgs:\n        if k > (h - s) // n:\n            break\n        s += k\n        n -= 1\n    print(0 - (s - h) // n)", "import math as m\ni = input()\ninp = []\nfor a in range(0, int(i)):\n    inp.append([input(), input()])\n\ndef logic(n, h, diffs):\n    diffs_sum = 0\n    for step in range(0, n - 1):\n        if diffs_sum + (n - step) * diffs[step] >= h:\n            x = (h - diffs_sum) // (n - step)\n            y = (h - diffs_sum) % (n - step)\n            return [x + 1, x][y == 0]\n        diffs_sum += diffs[step]\n    return h - diffs_sum\nfor i in inp:\n    [n, h] = [int(x) for x in i[0].split()]\n    arr = [int(x) for x in i[1].split()]\n    diffs = []\n    i = arr[0]\n    for j in arr[1:]:\n        diffs.append(j - i)\n        i = j\n    diffs.sort()\n    print(logic(n, h, diffs))", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "s = int(input())\nwhile s:\n    s -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "m = int(input())\nwhile m:\n    m -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "import math\n\ndef Poison_damage(dragon_hp, poison_ticks, remaining_attacks):\n    if dragon_hp < remaining_attacks:\n        return 1\n    sum_damage = 0\n    for curr_damage in poison_ticks:\n        if curr_damage > (dragon_hp - sum_damage) // remaining_attacks:\n            break\n        sum_damage += curr_damage\n        remaining_attacks -= 1\n    return 0 - (sum_damage - dragon_hp) // remaining_attacks\namount_of_data = int(input())\ndragon_raids = []\nfor _ in range(amount_of_data):\n    (amount_attacks, dragon_hp) = map(int, input().split())\n    attacks = tuple(map(int, input().split()))\n    poison_ticks = [attacks[curr] - attacks[curr - 1] for curr in range(1, len(attacks))]\n    poison_ticks.sort()\n    dragon_raids.append(tuple([amount_attacks, dragon_hp, poison_ticks]))\nfor curr_try in dragon_raids:\n    amount_attacks = curr_try[0]\n    dragon_hp = curr_try[1]\n    poison_ticks = curr_try[2]\n    print(Poison_damage(dragon_hp, poison_ticks, amount_attacks))", "import math\n\ndef Poison_damage_search(dragon_hp, poison_ticks, remaining_attacks):\n    if dragon_hp < remaining_attacks:\n        return 1\n    sum_damage = 0\n    for curr_damage in poison_ticks:\n        if curr_damage > (dragon_hp - sum_damage) // remaining_attacks:\n            break\n        sum_damage += curr_damage\n        remaining_attacks -= 1\n    return 0 - (sum_damage - dragon_hp) // remaining_attacks\namount_of_data = int(input())\ndragon_raids = []\nfor _ in range(amount_of_data):\n    (amount_attacks, dragon_hp) = map(int, input().split())\n    attacks = tuple(map(int, input().split()))\n    poison_ticks = [attacks[curr] - attacks[curr - 1] for curr in range(1, len(attacks))]\n    poison_ticks.sort()\n    dragon_raids.append(tuple([amount_attacks, dragon_hp, poison_ticks]))\nfor curr_try in dragon_raids:\n    amount_attacks = curr_try[0]\n    dragon_hp = curr_try[1]\n    poison_ticks = curr_try[2]\n    print(Poison_damage_search(dragon_hp, poison_ticks, amount_attacks))", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    i = len(a)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * i > h:\n            break\n        s += x\n        i -= 1\n    print(0 - (s - h) // i)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "tests = int(input())\nfor _ in range(tests):\n    [n, h] = [int(x) for x in input().split()]\n    attacks = [int(x) for x in input().split()]\n    d = sorted((a2 - a1 for (a1, a2) in zip(attacks, attacks[1:])))\n    s = 0\n    for k in d:\n        if k > (h - s) // n:\n            break\n        s += k\n        n -= 1\n    print(0 - (s - h) // n)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "import math\n\ndef Poison_damage_search(dragon_hp, poison_ticks, remaining_attacks):\n    if dragon_hp < remaining_attacks:\n        return 1\n    sum_damage = 0\n    for curr_damage in poison_ticks:\n        if curr_damage > (dragon_hp - sum_damage) // remaining_attacks:\n            break\n        sum_damage += curr_damage\n        remaining_attacks -= 1\n    return 0 - (sum_damage - dragon_hp) // remaining_attacks\namount_of_data = int(input())\ndragon_raids = []\nfor _ in range(amount_of_data):\n    (amount_attacks, dragon_hp) = map(int, input().split())\n    attacks = tuple(map(int, input().split()))\n    poison_ticks = [attacks[curr] - attacks[curr - 1] for curr in range(1, len(attacks))]\n    poison_ticks.sort()\n    dragon_raids.append(tuple([amount_attacks, dragon_hp, poison_ticks]))\nfor curr_try in dragon_raids:\n    amount_attacks = curr_try[0]\n    dragon_hp = curr_try[1]\n    poison_ticks = curr_try[2]\n    print(Poison_damage_search(dragon_hp, poison_ticks, amount_attacks))", "import math\n\ndef P_d_s(dragon_hp, poison_ticks, remaining_attacks):\n    if dragon_hp < remaining_attacks:\n        return 1\n    sum_damage = 0\n    for curr_damage in poison_ticks:\n        if curr_damage > (dragon_hp - sum_damage) // remaining_attacks:\n            break\n        sum_damage += curr_damage\n        remaining_attacks -= 1\n    return 0 - (sum_damage - dragon_hp) // remaining_attacks\namount_of_data = int(input())\ndragon_raids = []\nfor _ in range(amount_of_data):\n    (amount_attacks, dragon_hp) = map(int, input().split())\n    attacks = tuple(map(int, input().split()))\n    poison_ticks = [attacks[curr] - attacks[curr - 1] for curr in range(1, len(attacks))]\n    poison_ticks.sort()\n    dragon_raids.append(tuple([amount_attacks, dragon_hp, poison_ticks]))\nfor curr_try in dragon_raids:\n    amount_attacks = curr_try[0]\n    dragon_hp = curr_try[1]\n    poison_ticks = curr_try[2]\n    print(P_d_s(dragon_hp, poison_ticks, amount_attacks))", "tests = int(input())\nfor i in range(tests):\n    [n, h] = list(map(int, input().split()))\n    attacks = list(map(int, input().split()))\n    damages = sorted((l - j for (j, l) in zip(attacks, attacks[1:])))\n    tmp = 0\n    for k in damages:\n        if k > (h - tmp) // n:\n            break\n        tmp += k\n        n -= 1\n    print(0 - (tmp - h) // n)", "import math\n\ndef main_function():\n    test_cases = range(int(input()))\n    for test_case in test_cases:\n        (n, h) = [int(i) for i in input().split(' ')]\n        a = [int(i) for i in input().split(' ')] + [10 ** 20]\n        b = []\n        for i in range(1, len(a)):\n            b.append(a[i] - a[i - 1])\n        b.sort()\n        length = len(b)\n        counter = 0\n        prev_val = 0\n        for i in range(len(b)):\n            another_counter = (length - i) * (b[i] - prev_val)\n            if counter + another_counter < h:\n                counter += another_counter\n            elif counter + another_counter == h:\n                k = b[i]\n                break\n            else:\n                another_counter = h - counter\n                k = prev_val + int(bool(another_counter % (length - i))) + another_counter // (length - i)\n                break\n            prev_val = b[i]\n        print(k)\nmain_function()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "def real_input_generator():\n    while True:\n        yield input()\n\ndef example_input_generator(example):\n    for line in example.split('\\n'):\n        yield line\nexamples = ['4\\n2 5\\n1 5\\n3 10\\n2 4 10\\n5 3\\n1 2 4 5 7\\n4 1000\\n3 25 64 1337']\n\ndef solve(test_case_num=-1):\n    if test_case_num < 0:\n        ig = real_input_generator()\n    else:\n        print('TESTING NOW')\n        ig = example_input_generator(examples[test_case_num])\n    t = int(next(ig))\n    for _ in range(t):\n        [n, h] = list(map(int, next(ig).split()))\n        lst = list(map(int, next(ig).split()))\n        print(solution(n, h, lst))\n\ndef solution(n, h, lst):\n    if n >= h:\n        return 1\n        _hy_anon_var_2 = None\n    else:\n        _hy_anon_var_2 = None\n    for i in range(n - 1):\n        lst[i] = lst[i + 1] - lst[i]\n    lst[n - 1] = h\n    lst.sort()\n    for [i, v] in enumerate(lst):\n        if v * (n - i) >= h:\n            return (h - 1) // (n - i) + 1\n            _hy_anon_var_3 = None\n        else:\n            _hy_anon_var_3 = None\n        h -= v\n    return lst[-1] + h\nsolve()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "import math\n\ndef Poison_damage(dragon_hp, poison_ticks, remaining_attacks):\n    if dragon_hp < remaining_attacks:\n        return 1\n    sum_damage = 0\n    for curr_damage in poison_ticks:\n        if curr_damage > (dragon_hp - sum_damage) // remaining_attacks:\n            break\n        sum_damage += curr_damage\n        remaining_attacks -= 1\n    return 0 - (sum_damage - dragon_hp) // remaining_attacks\namount_of_data = int(input())\ndragon_raids = []\nfor _ in range(amount_of_data):\n    (amount_attacks, dragon_hp) = map(int, input().split())\n    attacks = tuple(map(int, input().split()))\n    poison_ticks = [attacks[curr] - attacks[curr - 1] for curr in range(1, len(attacks))]\n    poison_ticks.sort()\n    dragon_raids.append(tuple([amount_attacks, dragon_hp, poison_ticks]))\nfor curr_try in dragon_raids:\n    amount_attacks = curr_try[0]\n    dragon_hp = curr_try[1]\n    poison_ticks = curr_try[2]\n    print(Poison_damage(dragon_hp, poison_ticks, amount_attacks))", "num = int(input())\nwhile num:\n    num -= 1\n    (n, h) = list(map(int, input().split()))\n    a = [int(x) for x in input().split()]\n    differ = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    sum = 0\n    for k in differ:\n        if k > (h - sum) // n:\n            break\n        sum += k\n        n -= 1\n    print(0 - (sum - h) // n)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "from math import *\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom collections import Counter as ctr\nfrom collections import deque as dq\nfrom array import array\nfrom re import search\nli = lambda : list(map(int, input().split()))\narr = lambda a: array('i', a)\nbi = lambda n: bin(n).replace('0b', '')\nyn = lambda f: print('NYOE S'[f::2])\nsbstr = lambda a, s: search('.*'.join(a), s)\n\ndef solve():\n    for _ in range(int(input())):\n        (n, h) = li()\n        a = li()\n        b = [a[i + 1] - a[i] for i in range(n - 1)]\n        b.sort()\n        k = 0\n        for i in range(n - 1):\n            if b[i] * (n - i) >= h:\n                k = ceil(h / (n - i))\n                break\n            else:\n                h -= b[i]\n        print(k if k != 0 else h)\nsolve()", "def solve():\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(h)\n        return\n    b = list()\n    for i in range(1, n):\n        b.append(a[i] - a[i - 1])\n    b.sort()\n    cnt = n\n    for i in range(len(b)):\n        check = h // cnt\n        if h % cnt != 0:\n            check += 1\n        if b[i] >= check:\n            print(check)\n            return\n        else:\n            h -= b[i]\n            cnt -= 1\n    print(h)\nfor _ in range(int(input())):\n    solve()", "t = int(input())\nwhile t:\n    t -= 1\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    dif = sorted((a2 - a1 for (a1, a2) in zip(a, a[1:])))\n    isum = 0\n    for k in dif:\n        if k > (h - isum) // n:\n            break\n        isum += k\n        n -= 1\n    print(0 - (isum - h) // n)", "tests = int(input())\nfor i in range(tests):\n    [n, h] = list(map(int, input().split()))\n    attacks = list(map(int, input().split()))\n    damages = sorted((l - j for (j, l) in zip(attacks, attacks[1:])))\n    tmp = 0\n    for k in damages:\n        if k > (h - tmp) // n:\n            break\n        tmp += k\n        n -= 1\n    print(0 - (tmp - h) // n)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, h) = R()\n    a = (*R(),)\n    s = 0\n    for x in sorted((y - x for (x, y) in zip(a, a[1:]))):\n        if s + x * n > h:\n            break\n        s += x\n        n -= 1\n    print(0 - (s - h) // n)", "n = int(input().split()[0])\nfor _ in range(n):\n    (l, h) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    k = h // l + (1 if h % l else 0)\n    df = []\n    for i in range(len(arr) - 1):\n        df.append(arr[i + 1] - arr[i])\n    df.sort()\n\n    def fun(df, k, h):\n        for d in range(len(df)):\n            if df[d] >= k:\n                if k * (l - d) < h:\n                    k = min(df[d], h // (l - d) + (1 if h % (l - d) else 0))\n                    h -= k\n                else:\n                    h = 0\n                    break\n            else:\n                h -= df[d]\n        if h - k > 0:\n            k += h - k\n        return k\n    print(fun(df, k, h))", "import math\nfor i in range(0, int(input())):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dist = list()\n    for j in range(0, len(a) - 1):\n        dist.append(a[j + 1] - a[j])\n    dist.sort()\n    if len(dist) == 0:\n        dist.append(a[0])\n    else:\n        dist.append(dist[len(dist) - 1])\n    sum = 0\n    pred_sum = 0\n    flag = 0\n    k = 0\n    for j in range(0, len(a)):\n        sum = pred_sum + (len(a) - j) * dist[j]\n        if sum >= h:\n            flag = 1\n            k = j\n            break\n        pred_sum += dist[j]\n    if flag == 0:\n        if len(dist) == 1:\n            print(h)\n        else:\n            print(h - pred_sum + dist[len(dist) - 1])\n    else:\n        sum = 0\n        sum = (h - pred_sum) // (len(a) - k)\n        if (h - pred_sum) % (len(a) - k):\n            sum += 1\n        print(sum)", "import math\nt = int(input())\nfor k in range(t):\n    inp = input().split()\n    n = int(inp[0])\n    h = int(inp[1])\n    arr = []\n    inp = input().split()\n    for i in inp:\n        arr.append(int(i))\n    arr1 = []\n    for i in range(len(arr) - 1):\n        arr1.append(arr[i + 1] - arr[i])\n    arr1.sort()\n    k = 0\n    for i in range(len(arr) - 1):\n        if arr1[i] * (n - i) >= h:\n            if h % (n - i) == 0:\n                k = h // (n - i)\n            else:\n                k = h // (n - i) + 1\n            break\n        else:\n            h -= arr1[i]\n    print(k if k != 0 else h)", "import math\nt = int(input())\nfor i in range(t):\n    a = []\n    d = []\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for k in range(n - 1):\n        d.append(a[1 + k] - a[k])\n    d.sort()\n    ans = 0\n    c = n\n    for k in range(n - 1):\n        if d[k] * c < h:\n            h -= d[k]\n            c -= 1\n        else:\n            ans = int(math.ceil(h / c))\n            h = 0\n            break\n    if h != 0:\n        ans = h\n    print(ans)", "numeroTestes = int(input())\nresults = []\nfor a in range(numeroTestes):\n    status = [int(t) for t in input().split()]\n    numeroAtaques = status[0]\n    vida = status[1]\n    hits = [int(t) for t in input().split()]\n    intervalos = []\n    for hit in range(len(hits) - 1):\n        intervalos.append(hits[hit + 1] - hits[hit])\n    intervalos = sorted(intervalos)\n    dano = 0\n    for intervalo in intervalos:\n        if dano + intervalo * numeroAtaques > vida:\n            break\n        dano += intervalo\n        numeroAtaques -= 1\n    results.append(0 - (dano - vida) // numeroAtaques)\nfor r in results:\n    print(r)", "test_case_count = int(input())\nfor i in range(test_case_count):\n    (attack_count, target_damage) = input().split(' ')\n    (attack_count, target_damage) = (int(attack_count), int(target_damage))\n    attacks = [int(value) for value in input().split()]\n    intervals = []\n    for i in range(len(attacks) - 1):\n        delta = attacks[i + 1] - attacks[i]\n        intervals.append(delta)\n    intervals.sort()\n    acc_damage = 0\n    for interval in intervals:\n        if acc_damage + interval * attack_count > target_damage:\n            break\n        acc_damage += interval\n        attack_count -= 1\n    result = (acc_damage - target_damage) // attack_count\n    print(-result)", "import math\nfor pratyush in range(int(input())):\n    d = []\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for k in range(n - 1):\n        d.append(a[1 + k] - a[k])\n    d.sort()\n    (ans, c) = (0, n)\n    for k in range(n - 1):\n        if d[k] * c < h:\n            h -= d[k]\n            c -= 1\n        else:\n            ans = int(math.ceil(h / c))\n            h = 0\n            break\n    if h != 0:\n        ans = h\n    print(ans)", "import math\nT = int(input())\nwhile T > 0:\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n    C = []\n    for i in range(A[0] - 1):\n        C.append(B[i + 1] - B[i])\n    C.sort()\n    k = -1\n    h = 0\n    i = 0\n    while i < A[0] - 1:\n        k = C[i]\n        h += C[i]\n        if A[1] <= h + (A[0] - i - 1) * k:\n            break\n        i += 1\n    if A[1] > h + (A[0] - i) * k:\n        k = A[1] - h\n    else:\n        k = math.ceil((A[1] - (h - C[i])) / (A[0] - i))\n    print(k)\n    T -= 1", "def ret():\n    (n, h) = [int(x) for x in input().split()]\n    lst = [int(x) for x in input().split()]\n    dicto = {}\n    for i in range(1, n):\n        dicto[lst[i] - lst[i - 1]] = 0\n    for i in range(1, n):\n        dicto[lst[i] - lst[i - 1]] += 1\n    num = 0\n    dicto[10 ** 18 + 100] = 1\n    keys = dicto.keys()\n    keys = sorted(keys)\n    for key in keys:\n        if key * (n - num) >= h:\n            if h % (n - num) == 0:\n                print(h // (n - num))\n                return\n            print(h // (n - num) + 1)\n            return\n        else:\n            h -= key * dicto[key]\n            num += dicto[key]\n    print(dicto)\nt = int(input())\nfor _ in range(t):\n    ret()", "import sys\n\ndef f(l, n, f):\n    a = 0\n    x = n - 1\n    while a <= x:\n        m = a + (x - a) // 2\n        if l[m] == f:\n            return m\n        elif l[m] > f:\n            x = m - 1\n        else:\n            a = m + 1\n    return None\nfor _ in range(int(sys.stdin.readline())):\n    (n, h) = map(int, sys.stdin.readline().split())\n    l = list(map(int, sys.stdin.readline().split()))\n    if n == 1:\n        print(h)\n    else:\n        a = []\n        for i in range(n - 1):\n            a.append(l[i + 1] - l[i])\n        a.sort()\n        if h % n == 0:\n            k = h // n\n        else:\n            k = h // n + 1\n        if a[0] >= k:\n            print(k)\n        else:\n            for i in range(1, n - 1):\n                h = h - a[i - 1]\n                n = n - 1\n                if h % n == 0:\n                    k = h // n\n                else:\n                    k = h // n + 1\n                if a[i] >= k:\n                    print(k)\n                    break\n            else:\n                print(max(h - a[-1], k))", "import math\nt = int(input())\nwhile t > 0:\n    (n, h) = input().split()\n    n = int(n)\n    h = int(h)\n    a = input().split()\n    attacks = [int(a[i]) - int(a[i - 1]) for i in range(1, n)]\n    attacks.sort()\n    dano = math.ceil(h / n)\n    i = 0\n    while i < n - 1 and attacks[i] <= dano:\n        h -= attacks[i]\n        i += 1\n    while i < n - 1:\n        if dano * (n - i) >= h:\n            h = 0\n            break\n        elif attacks[i] * (n - i) < h:\n            dano = attacks[i]\n            while i < n - 1 and attacks[i] == dano:\n                h -= dano\n                i += 1\n        else:\n            dano = math.ceil(h / (n - i))\n            h = 0\n            break\n    if dano < h:\n        print(h)\n    else:\n        print(dano)\n    t -= 1", "import sys\nt = int(sys.stdin.readline())\nfor i in range(t):\n    (n, h) = tuple(map(int, sys.stdin.readline().strip().split()))\n    arr = list(map(int, sys.stdin.readline().strip().split()))\n    if n == 1:\n        print(h)\n        continue\n    arr.sort()\n    arr_diff = [0] * (len(arr) - 1)\n    for j in range(len(arr) - 1):\n        arr_diff[j] = arr[j + 1] - arr[j]\n    arr_diff.sort()\n    (result, cur) = (0, arr_diff[0])\n    if h <= cur * len(arr):\n        result = h // len(arr) + (1 if h % len(arr) > 0 else 0)\n    else:\n        h -= cur * len(arr)\n        result = cur\n        for j in range(len(arr) - 1):\n            if arr_diff[j] == cur:\n                continue\n            diff = (arr_diff[j] - cur) * (len(arr) - j)\n            if h <= diff:\n                result += h // (len(arr) - j) + (1 if h % (len(arr) - j) > 0 else 0)\n                h = 0\n                break\n            else:\n                result = arr_diff[j]\n                cur = arr_diff[j]\n                h -= diff\n        result += h\n    print(result)", "import heapq\nimport sys\nimport math\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\nI = sys.stdin.readline\nII = lambda : int(I())\nIN = lambda x: map(int, x.split())\nFN = lambda x: map(float, x.split())\nL = lambda x: list(IN(x))\nM = 1000000007\nP = print\nT = True\nF = False\nfor _ in range(II()):\n    (n, h) = IN(I())\n    a = L(I())\n    diff = []\n    for i in range(n - 1):\n        diff.append(a[i + 1] - a[i])\n    diff.sort()\n    ans = 0\n    for i in range(n - 1):\n        if h <= 0:\n            break\n        if diff[i] == ans:\n            continue\n        cap = (n - i) * (diff[i] - ans)\n        if h <= cap:\n            ans += (h + n - i - 1) // (n - i)\n        else:\n            ans = diff[i]\n        h -= cap\n    if h > 0:\n        print(ans + h)\n    else:\n        print(ans)", "import math\n\ndef dagger(n, h, L):\n    if n == 1:\n        return h\n    dmg = int(h / n)\n    if h % n != 0:\n        dmg += 1\n    remain = []\n    for i in range(n):\n        if L[i] > dmg:\n            remain.append(L[i] - dmg)\n            h -= dmg\n        else:\n            h -= L[i]\n    if h <= 0:\n        return dmg\n    return dmg + dagger(len(remain), h, remain)\ncases = int(input())\nfor j in range(cases):\n    line = input().split()\n    n = int(line[0])\n    h = int(line[1])\n    get = input().split()\n    L = []\n    for i in range(n - 1):\n        L.append(int(get[i + 1]) - int(get[i]))\n    L.sort()\n    L.append(math.inf)\n    print(dagger(n, h, L))", "t = int(input())\nfor i in range(t):\n    [n, h] = [int(k) for k in input().split(' ')]\n    a = [int(k) for k in input().split(' ')]\n    b = [0 for k in range(n - 1)]\n    for k in range(1, n):\n        b[k - 1] += a[k] - a[k - 1]\n    b.sort()\n    c = h\n    d = 0\n    for j in range(n - 1):\n        if c == b[j] * (n - j):\n            print(b[j])\n            d = 1\n            break\n        elif c // (n - j) < b[j]:\n            print(c // (n - j) + (c % (n - j) != 0))\n            d = 1\n            break\n        c -= b[j]\n    if d == 0:\n        print(c)", "import math\nT = int(input())\nwhile T > 0:\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n    C = []\n    for i in range(A[0] - 1):\n        C.append(B[i + 1] - B[i])\n    C.sort()\n    k = -1\n    h = 0\n    i = 0\n    while i < A[0] - 1:\n        k = C[i]\n        h += C[i]\n        if A[1] <= h + (A[0] - i - 1) * k:\n            break\n        i += 1\n    if A[1] > h + (A[0] - i) * k:\n        k = A[1] - h\n    else:\n        k = math.ceil((A[1] - (h - C[i])) / (A[0] - i))\n    print(k)\n    T -= 1", "import math\nT = int(input())\nwhile T > 0:\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n    C = []\n    for i in range(A[0] - 1):\n        C.append(B[i + 1] - B[i])\n    C.sort()\n    k = -1\n    h = 0\n    i = 0\n    while i < A[0] - 1:\n        k = C[i]\n        h += C[i]\n        if A[1] <= h + (A[0] - i - 1) * k:\n            break\n        i += 1\n    if A[1] > h + (A[0] - i) * k:\n        k = A[1] - h\n    else:\n        k = math.ceil((A[1] - (h - C[i])) / (A[0] - i))\n    print(k)\n    T -= 1", "import math\nT = int(input())\nwhile T > 0:\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n    C = []\n    for i in range(A[0] - 1):\n        C.append(B[i + 1] - B[i])\n    C.sort()\n    k = -1\n    h = 0\n    i = 0\n    while i < A[0] - 1:\n        k = C[i]\n        h += C[i]\n        if A[1] <= h + (A[0] - i - 1) * k:\n            break\n        i += 1\n    if A[1] > h + (A[0] - i) * k:\n        k = A[1] - h\n    else:\n        k = math.ceil((A[1] - (h - C[i])) / (A[0] - i))\n    print(k)\n    T -= 1", "from sys import stdin\nimport math\nfrom collections import deque\nfrom heapq import heapify, heappop, heappush\nfrom bisect import bisect_left, bisect_right\ninput = stdin.readline\n\ndef ceil(m, n):\n    val = m // n\n    if m % n != 0:\n        return val + 1\n    return val\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    arr = sorted(list(map(int, input().split())))\n    (diff, heap) = (-1, [])\n    heapify(heap)\n    for i in range(1, n):\n        heappush(heap, arr[i] - arr[i - 1])\n    (present, val) = (n, ceil(h, n))\n    (done, prev) = (False, 0)\n    while present > 1 and heap:\n        val = heappop(heap) - prev\n        if val * present >= h:\n            print(prev + ceil(h, present))\n            done = True\n            break\n        h -= val * present\n        prev = val + prev\n        present -= 1\n    if done:\n        continue\n    print(h + prev)", "t = int(input())\nfor t1 in range(t):\n    (n, h) = (int(i) for i in input().split())\n    sts = [int(i) for i in input().split()]\n    if n == 1:\n        print(h)\n        continue\n    diffs = [sts[i] - sts[i - 1] for i in range(1, len(sts))]\n    diffs.sort()\n    s = 0\n    l = n\n    rem = 0\n    h1 = h - s\n    rem = h1 // l\n    f = 0\n    if h1 % l != 0:\n        rem += 1\n    if rem <= diffs[0]:\n        print(rem)\n        continue\n    for i in range(n - 2):\n        s += diffs[i]\n        l -= 1\n        h1 = h - s\n        rem = h1 // l\n        if h1 % l != 0:\n            rem += 1\n        if rem <= diffs[i + 1]:\n            print(rem)\n            f = 1\n            break\n    if f == 0:\n        s += diffs[-1]\n        rem = h - s\n        print(rem)", "def total_damage(intervals, pre_sum, k):\n    (low, high, out) = (0, len(intervals) - 1, 0)\n    while low <= high:\n        mid = (low + high) // 2\n        if intervals[mid] >= k:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return pre_sum[low] + (len(pre_sum) - low) * k\n\ndef bs(intervals, pre_sum, needed):\n    (low, high, out) = (0, needed, 0)\n    while low <= high:\n        mid = (low + high) // 2\n        damage = total_damage(intervals, pre_sum, mid)\n        if damage == needed:\n            return mid\n        elif damage < needed:\n            low = mid + 1\n            out = mid + 1\n        else:\n            high = mid - 1\n    return out\n\ndef solution():\n    n = int(input())\n    for i in range(0, n):\n        info = [int(num) for num in input().split(' ')]\n        needed = info[1]\n        attacks = [int(num) for num in input().split(' ')]\n        intervals = [attacks[i] - attacks[i - 1] for i in range(1, len(attacks))]\n        intervals.sort()\n        pre_sum = [0]\n        for (j, interval) in enumerate(intervals):\n            pre_sum.append(pre_sum[j] + interval)\n        print(bs(intervals, pre_sum, needed))\nsolution()", "for _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dif = []\n    for i in range(1, n):\n        dif.append(a[i] - a[i - 1])\n    dif.sort()\n    k = h // n\n    left = h % n\n    ans = k\n    for i in range(n - 1):\n        if dif[i] < k:\n            left += k - dif[i]\n            dif[i] = 0\n        else:\n            dif[i] -= k\n            x = left // (n - i)\n            if x <= dif[i]:\n                dif[i] -= x\n                if dif[i] > 0 and left % (n - i) > 0:\n                    dif[i] -= 1\n                    left -= x + 1\n                    ans = max(ans, k + x + 1)\n                else:\n                    left -= x\n                    ans = max(ans, k + x)\n            else:\n                left -= dif[i]\n                ans = max(ans, k + dif[i])\n                dif[i] = 0\n    print(max(ans, left + k))", "from collections import Counter\nfrom math import ceil\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = []\n    p = l[0]\n    for x in l[1:]:\n        c.append(x - p)\n        p = x\n    c = Counter(c)\n    c = [[x, c[x]] for x in c]\n    c.sort(key=lambda c: c[0])\n    cur = 0\n    ans = 0\n    for x in c:\n        if (x[0] - cur) * n + ans >= h:\n            cur += ceil((h - ans) / n)\n            ans = h\n        else:\n            ans += (x[0] - cur) * n\n            n -= x[1]\n            cur = x[0]\n    if ans < h:\n        cur += h - ans\n    print(cur)", "t = int(input())\nfor j in range(t):\n    s = input().split()\n    n = int(s[0])\n    h = int(s[1])\n    s = input().split()\n    a = []\n    count = n\n    for i in range(1, n):\n        a.append(int(s[i]) - int(s[i - 1]))\n    a.append(h)\n    if h % n == 0:\n        k = h // n\n    else:\n        k = h // n + 1\n    a.sort()\n    for i in range(n):\n        if a[i] >= k:\n            print(k)\n            break\n        else:\n            h = h - a[i]\n            count -= 1\n            if h % count == 0:\n                k = h // count\n            else:\n                k = h // count + 1", "def damage_amount(diffs, partial_sum, k):\n    l = 0\n    r = len(partial_sum) - 1\n    while l < r:\n        c = (l + r) // 2\n        if diffs[c] > k:\n            r = c\n        else:\n            l = c + 1\n    return partial_sum[l - 1] + k * (len(partial_sum) - l)\nt = int(input())\nfor _ in range(t):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    diffs = list(sorted([a[i + 1] - a[i] for i in range(n - 1)] + [h]))\n    partial_sum = []\n    s = 0\n    for v in diffs:\n        s += v\n        partial_sum.append(s)\n    min_k = (h - 1) // n + 1\n    max_k = h + 1 - n\n    k = None\n    damage = 0\n    while min_k < max_k:\n        k = (max_k + min_k) // max(2, damage // h)\n        damage = damage_amount(diffs, partial_sum, k)\n        if damage >= h:\n            max_k = k\n        else:\n            min_k = k + 1\n    print(min_k)", "def op():\n    (n, h) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    a.sort()\n    ans = h // n - 1\n    run = True\n    m = n\n    H = h\n    while run:\n        m = n\n        ans += 1\n        b = [a[n - 1]]\n        for i in range(n - 2, -1, -1):\n            if a[i] + ans >= a[i + 1]:\n                h -= a[i + 1] - a[i]\n                m -= 1\n            else:\n                b.append(a[i])\n        ans = max(ans, h // m - 1)\n        if h - m * ans <= 0:\n            run = False\n        h = H\n    print(ans)\nfor i in range(int(input())):\n    op()", "from bisect import bisect\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    a = []\n    for i in range(1, n):\n        a.append(arr[i] - arr[i - 1])\n    a.sort()\n\n    def sol(x):\n        i = bisect(a, x)\n        y = sum(a[:i])\n        y += (n - i) * x\n        if y >= h:\n            return True\n        return False\n\n    def bs(l, h):\n        if l == h:\n            return l\n        if h == l + 1:\n            if sol(l):\n                return l\n            return h\n        m = (l + h) // 2\n        if sol(m):\n            if sol(m - 1) == False:\n                return m\n            else:\n                return bs(l, m - 1)\n        else:\n            return bs(m + 1, h)\n    print(bs(1, h))", "from bisect import bisect_left as bl, bisect_right as br\nfrom heapq import heapify, heappop, heappush\nfrom collections import Counter as co\nfrom fractions import Fraction as fr\nfrom math import gcd, log, ceil\nmod = 1000000007\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    l = list(map(int, input().split()))\n    s = 0\n    (ma, mi) = (0, l[-1])\n    for i in range(1, n):\n        s += l[i] - l[i - 1]\n        ma = max(ma, l[i] - l[i - 1])\n        mi = min(mi, l[i] - l[i - 1])\n        l[i - 1] = l[i] - l[i - 1]\n    if mi * n >= h:\n        print(ceil(h / n))\n    elif ma + s <= h:\n        print(h - s)\n    else:\n        l = l[:-1]\n        l.sort()\n        pre = l[:]\n        pre = [0] + pre\n        for i in range(1, n - 1):\n            pre[i + 1] += pre[i]\n\n        def f(k):\n            i = bl(l, k)\n            if pre[i] + (n - i) * k >= h:\n                return True\n            return False\n        (beg, end) = (mi, ma)\n        while beg <= end:\n            m = beg + end >> 1\n            if f(m):\n                end = m - 1\n            else:\n                beg = m + 1\n        print(beg)", "import sys\nimport math\nfrom fractions import Fraction\nfrom decimal import *\ninput = sys.stdin.readline\nt = int(input())\nwhile t > 0:\n    inp = input().strip()\n    arr = [int(x) for x in inp.split(' ')]\n    n = arr[0]\n    h = arr[1]\n    inp = input().strip()\n    arr = [int(x) for x in inp.split(' ')]\n    maxd = []\n    i = 1\n    while i < len(arr):\n        maxd.append(arr[i] - arr[i - 1])\n        i += 1\n    maxd.append(10 ** 50)\n    maxd.sort()\n    ans = 0\n    d_left = h\n    curi = 0\n    while d_left > 0:\n        minreq = math.ceil(Decimal(d_left) / Decimal(len(maxd) - curi))\n        if minreq <= maxd[curi]:\n            ans = minreq\n            break\n        else:\n            i = curi\n            while maxd[i] == maxd[curi]:\n                d_left -= maxd[i]\n                i += 1\n            curi = i\n    print(ans)\n    t -= 1", "from queue import Queue\nt = int(input())\nans = []\nfor _ in range(t):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    diff = []\n    for i in range(1, n):\n        diff.append(a[i] - a[i - 1])\n    diff.sort()\n    que = Queue()\n    for d in diff:\n        que.put(d)\n    while not que.empty():\n        if h <= que.queue[0] * (que.qsize() + 1):\n            ans.append(int(h / (que.qsize() + 1)) + (h % (que.qsize() + 1) > 0))\n            break\n        h -= que.get()\n    else:\n        ans.append(h)\nfor i in ans:\n    print(i)", "def inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s)])\n\ndef invr():\n    return map(int, input().split())\n\ndef check(mid, diff):\n    add = 0\n    for i in range(len(diff)):\n        if diff[i] < mid:\n            add += diff[i]\n        else:\n            add += mid\n    return add + mid\n\ndef binarySearch(h, diff):\n    (start, end) = (1, h)\n    ans = 0\n    while start <= end:\n        mid = start + (end - start) // 2\n        if check(mid, diff) < h:\n            start = mid + 1\n        else:\n            end = mid - 1\n            ans = mid\n    return ans\nt = inp()\nfor _ in range(t):\n    (n, h) = invr()\n    time = inlt()\n    diff = []\n    for i in range(n - 1):\n        diff.append(time[i + 1] - time[i])\n    print(binarySearch(h, diff))", "for _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    l1 = [int(i) for i in input().split()]\n    l2 = []\n    for i in range(1, n):\n        l2 += [l1[i] - l1[i - 1]]\n    if n == 1:\n        print(h)\n        continue\n    l = -1\n    r = h + 1\n    m = 0\n    sm = sum(l2)\n    mn = min(l2)\n    mx = max(l2)\n    while r - l > 1:\n        m = 0\n        y = (l + r) // 2\n        if y >= mx:\n            m = sm + y\n        elif y <= mn:\n            m = n * y\n        else:\n            for i in l2:\n                m += min(i, y)\n            m += y\n        if m == h:\n            break\n        elif m < h:\n            l = (l + r) // 2\n        else:\n            r = (l + r) // 2\n    if m < h:\n        print(y + 1)\n        continue\n    print(y)", "from math import ceil\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if len(a) == 1:\n        print(h)\n        continue\n    x = int(ceil(h / n))\n    b = [a[i] - a[i - 1] for i in range(1, n)]\n    if min(b) >= x:\n        print(x)\n        continue\n    b.sort()\n    ans = 0\n    while len(b) > 0:\n        x = int(ceil(h / (len(b) + 1)))\n        c = min(b)\n        if x <= c:\n            print(ans + x)\n            break\n        else:\n            h -= (len(b) + 1) * c\n            ans += c\n            b = [i - c for i in b if i - c != 0]\n    else:\n        print(ans + h)", "from math import ceil\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [a[i] - a[i - 1] for i in range(1, n)]\n    ans = 0\n    while len(b) > 0:\n        x = int(ceil(h / (len(b) + 1)))\n        c = min(b)\n        if x <= c:\n            print(ans + x)\n            break\n        else:\n            h -= (len(b) + 1) * c\n            ans += c\n            b = [i - c for i in b if i - c != 0]\n    else:\n        print(ans + h)", "from math import *\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    m = [0 for i in range(n)]\n    p = 0\n    s = 0\n    for i in range(n - 1):\n        m[i] = a[i + 1] - a[i]\n        p = max(m[i], p)\n        s += m[i]\n    m[n - 1] = float('inf')\n    if h - s >= p:\n        print(h - s)\n    else:\n        q = 1\n        ans = p\n        while q <= p:\n            t = (q + p) // 2\n            s = 0\n            for i in range(n):\n                s += min(t, m[i])\n            if s >= h:\n                ans = min(t, ans)\n                p = t - 1\n            else:\n                q = t + 1\n        print(ans)", "for _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        print(h)\n        continue\n    dif = []\n    for i in range(1, n):\n        dif.append(arr[i] - arr[i - 1])\n    l = 1\n    r = h\n    while l <= r:\n        mid = (l + r) // 2\n        s = 0\n        for item in dif:\n            if item <= mid:\n                s += item\n            else:\n                s += mid\n        s += mid\n        if s >= h:\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(r + 1)", "t = int(input())\nfor _ in range(t):\n    (n, damage) = map(int, input().split())\n    time = list(map(int, input().split()))\n    diffs = []\n    for i in range(n - 1):\n        diffs.append(abs(time[i + 1] - time[i]))\n\n    def adder(mid):\n        sum = 0\n        for i in range(len(diffs)):\n            if diffs[i] < mid:\n                sum += diffs[i]\n            else:\n                sum += mid\n        return sum + mid\n    start = 1\n    end = damage\n    while start <= end:\n        mid = start + (end - start) // 2\n        if adder(mid) < damage:\n            start = mid + 1\n        elif adder(mid) >= damage:\n            end = mid - 1\n            ans = mid\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, h) = list(map(int, input().split(' ')))\n    attacks = list(map(int, input().split(' ')))\n\n    def check(k, attacks, h):\n        count = 0\n        for i in range(len(attacks) - 1):\n            val = attacks[i] + k\n            if val <= attacks[i + 1]:\n                count += k\n            else:\n                count += attacks[i + 1] - attacks[i]\n        count += k\n        if count < h:\n            return False\n        return True\n\n    def main(h, attacks):\n        n = len(attacks)\n        if n == 1:\n            return h\n        if h - attacks[n - 1] + attacks[0] > attacks[n - 1] - attacks[0]:\n            return h - attacks[n - 1] + attacks[0]\n        ans = float('inf')\n        (l, r) = (1, h)\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid, attacks, h):\n                ans = min(ans, mid)\n                r = mid\n            else:\n                l = mid + 1\n        return ans\n    print(main(h, attacks))", "import sys\nt = int(sys.stdin.readline())\nfor x in range(t):\n    (n, h) = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    l = 0\n    r = h\n    while r - l > 1:\n        mid = (l + r) // 2\n        damage = mid + sum([min(d, mid) for d in diff])\n        if damage >= h:\n            r = mid\n        else:\n            l = mid\n    print(r)", "def totalDamage(diff, k):\n    return k + sum([min(d, k) for d in diff])\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    (start, end) = (1, h)\n    while start <= end:\n        mid = (start + end) // 2\n        damage = totalDamage(diff, mid)\n        if damage < h:\n            start = mid + 1\n        else:\n            end = mid - 1\n    print(start)", "def tDamage(diff, k):\n    return k + sum([min(d, k) for d in diff])\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    (start, end) = (1, h)\n    while start <= end:\n        mid = (start + end) // 2\n        damage = tDamage(diff, mid)\n        if damage < h:\n            start = mid + 1\n        else:\n            end = mid - 1\n    print(start)", "def totalDamage(diff, k):\n    return k + sum([min(d, k) for d in diff])\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    (start, end) = (1, h)\n    while start <= end:\n        mid = (start + end) // 2\n        damage = totalDamage(diff, mid)\n        if damage < h:\n            start = mid + 1\n        else:\n            end = mid - 1\n    print(start)", "import sys\nt = int(sys.stdin.readline())\nfor x in range(t):\n    (n, h) = map(int, sys.stdin.readline().split())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    l = 0\n    r = h\n    while r - l > 1:\n        mid = (l + r) // 2\n        damage = mid + sum([min(d, mid) for d in diff])\n        if damage >= h:\n            r = mid\n        else:\n            l = mid\n    print(r)", "def totalDamage(diff, k):\n    return k + sum([min(d, k) for d in diff])\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    (start, end) = (1, h)\n    while start <= end:\n        mid = (start + end) // 2\n        damage = totalDamage(diff, mid)\n        if damage < h:\n            start = mid + 1\n        else:\n            end = mid - 1\n    print(start)", "t = int(input())\nfor _ in range(t):\n    (n, h) = [int(x) for x in input().split()]\n    a = [int(i) for i in input().split()]\n    dmg_dif = [a[i + 1] - a[i] for i in range(n - 1)]\n    (start, end) = (1, h)\n    while start <= end:\n        half = (start + end) // 2\n        damage = half + sum([min(d, half) for d in dmg_dif])\n        if damage < h:\n            start = half + 1\n        else:\n            end = half - 1\n    print(start)", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "def totalDamage(diff, k):\n    return k + sum([min(d, k) for d in diff])\nfor _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    diff = [a[i] - a[i - 1] for i in range(1, n)]\n    (start, end) = (1, h)\n    while start <= end:\n        mid = (start + end) // 2\n        damage = totalDamage(diff, mid)\n        if damage < h:\n            start = mid + 1\n        else:\n            end = mid - 1\n    print(start)", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "tests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(len(hits) - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "t = int(input())\n\ndef count(k, delay):\n    result = k\n    for time in delay:\n        result += min(k, time)\n    return result\nfor _ in range(t):\n    (n, h) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    gap = []\n    for i in range(1, n):\n        gap.append(arr[i] - arr[i - 1])\n    left = 1\n    right = h\n    while left < right:\n        k = (left + right) // 2\n        curr = count(k, gap)\n        if curr == h:\n            left = k\n            break\n        elif curr < h:\n            left = k + 1\n        else:\n            right = k\n    print(left)", "for _ in range(int(input())):\n    (n, h) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dif = []\n    for i in range(n - 1):\n        dif.append(a[i + 1] - a[i])\n\n    def check(num):\n        tot = 0\n        for d in dif:\n            tot += min(d, num)\n        return tot + num\n    ans = h\n    l = 1\n    r = h\n    while l <= r:\n        mid = (l + r) // 2\n        cur = check(mid)\n        if cur >= h:\n            ans = mid\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(ans)", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "from collections import deque\n\ndef solution(a, b, nums):\n    s = []\n    n = len(nums)\n    for i in range(1, n):\n        s.append(nums[i] - nums[i - 1])\n    s.append(int(1e+18))\n    s.sort()\n\n    def helper(s, k, b):\n        res = 0\n        for diff in s:\n            res += min(diff, k)\n        return res >= b\n    (left, right) = (1, int(1e+18))\n    curr = 0\n    while left < right:\n        curr = (left + right) // 2\n        if helper(s, curr, b):\n            right = curr\n        else:\n            left = curr + 1\n    return left\nt = int(input())\nfor _ in range(t):\n    a_b = input().split()\n    a = int(a_b[0])\n    b = int(a_b[1])\n    nums = [int(x) for x in input().split()]\n    print(solution(a, b, nums))", "def solution(a, b, nums):\n    s = []\n    n = len(nums)\n    for i in range(1, n):\n        s.append(nums[i] - nums[i - 1])\n    s.append(int(1e+18))\n\n    def helper(s, k, b):\n        res = 0\n        for diff in s:\n            res += min(diff, k)\n        return res >= b\n    (left, right) = (1, int(1e+18))\n    while left < right:\n        curr = (left + right) // 2\n        if helper(s, curr, b):\n            right = curr\n        else:\n            left = curr + 1\n    return left\nt = int(input())\nfor _ in range(t):\n    a_b = input().split()\n    a = int(a_b[0])\n    b = int(a_b[1])\n    nums = [int(x) for x in input().split()]\n    print(solution(a, b, nums))", "from math import e\n\ndef solve():\n    (n, h) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    if n > h:\n        print('1')\n    else:\n        start = 1\n        end = h\n        mid = 0\n        List = {}\n        for i in range(n - 1):\n            List[i] = arr[i + 1] - arr[i]\n        while start <= end:\n            mid = (start + end) // 2\n            summ = mid\n            for i in range(n - 1):\n                if mid > List.get(i):\n                    summ += List.get(i)\n                else:\n                    summ += mid\n            if summ < h:\n                start = mid + 1\n            else:\n                end = mid - 1\n        print(end + 1)\ncases = int(input())\nfor i in range(cases):\n    solve()", "from bisect import bisect\ntests = int(input())\n\ndef checkKill(k, h, gapSeconds):\n    soma = 0\n    for gap in gapSeconds:\n        soma += min(gap, k)\n    soma += k\n    return soma >= h\n\ndef binSearch(h, hits):\n    low = 1\n    high = h\n    k = h\n    gapSeconds = [hits[i + 1] - hits[i] for i in range(n - 1)]\n    while low <= high:\n        mid = (low + high) // 2\n        if checkKill(mid, h, gapSeconds):\n            high = mid - 1\n            k = mid\n        else:\n            low = mid + 1\n    return k\nfor test in range(tests):\n    (n, h) = list(map(int, input().split()))\n    hits = list(map(int, input().split()))\n    print(binSearch(h, hits))", "def check(d):\n    (t, ans) = (-int(1e+20), 0)\n    for x in v:\n        if x - t >= d:\n            ans += d\n        else:\n            ans += x - t\n        t = x\n    return ans >= k\nfor ssdhafj in range(int(input())):\n    (n, k) = map(int, input().split())\n    v = [int(x) for x in input().split()]\n    (l, r) = (0, int(1e+20))\n    while l < r:\n        mid = (l + r) // 2\n        if check(mid):\n            r = mid\n        else:\n            l = mid + 1\n    print(l)"]