["def solution(n, parents, perm):\n    res = [-1 for _ in range(len(parents))]\n    temp = 0\n    for (i, b) in enumerate(parents):\n        if i == b:\n            temp = i\n            break\n    res[temp] = 0\n    if perm[0] != temp:\n        print('-1')\n        return\n    for (i, p) in enumerate(perm):\n        if res[parents[p]] == -1:\n            print('-1')\n            return\n        res[p] = i\n    print(' '.join((str(res[p] - res[parents[p]]) for p in range(n))))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    parents = [int(x) - 1 for x in input().split()]\n    perm = [int(x) - 1 for x in input().split()]\n    solution(n, parents, perm)", "def solve(n, parent, permutation):\n    parent_edge_weight = [0] * n\n    distance = [0] * n\n    processed = [False] * n\n    if parent[permutation[0]] != permutation[0]:\n        return (False, parent_edge_weight)\n    processed[permutation[0]] = True\n    lower_bound = 0\n    for vertex in permutation[1:]:\n        if not processed[parent[vertex]]:\n            return (False, parent_edge_weight)\n        processed[vertex] = True\n        parent_edge_weight[vertex] = lower_bound + 1 - distance[parent[vertex]]\n        distance[vertex] = lower_bound + 1\n        lower_bound += 1\n    return (True, parent_edge_weight)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    parent = [int(q) - 1 for q in input().split(' ')]\n    permutation = [int(q) - 1 for q in input().split(' ')]\n    (possible, parent_edge_weight) = solve(n, parent, permutation)\n    if not possible:\n        print(-1)\n    else:\n        print(' '.join((str(w) for w in parent_edge_weight)))", "def solve():\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    b = [x - 1 for x in b]\n    p = [x - 1 for x in p]\n    if p[0] != b[p[0]]:\n        print(-1)\n        return\n    ans = [-1] * n\n    dis = [0] * n\n    ans[p[0]] = 0\n    s = 1\n    for i in range(1, n):\n        if ans[b[p[i]]] < 0:\n            print(-1)\n            return\n        dis[p[i]] = dis[p[i - 1]] + 1\n        ans[p[i]] = dis[p[i]] - dis[b[p[i]]]\n        s += 1\n    print(' '.join((str(x) for x in ans)))\nfor test in range(int(input())):\n    solve()", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    l = {int(x): i for (i, x) in enumerate(input().split())}\n    r = [l[x + 1] - l[b[x]] for x in range(n)]\n    print(*(r if min(r) == 0 else [-1]))", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    l = {int(x): i for (i, x) in enumerate(input().split())}\n    r = [l[i + 1] - l[b[i]] for i in range(n)]\n    if min(r) == 0:\n        print(*r, sep=' ')\n    else:\n        print(-1)", "import sys\nimport bisect\nimport math\nfrom collections import deque\ninput = lambda : sys.stdin.readline().strip()\nmod = 10 ** 9 + 9\n\ndef solve():\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    visited = [False] * n\n    weight = [0] * n\n    root = None\n    for i in range(n):\n        if b[i] == i + 1:\n            root = i\n            break\n    if p[0] != root + 1:\n        return -1\n    visited[root] = True\n    dist = [0] * n\n    for i in range(1, n):\n        x = p[i] - 1\n        if not visited[b[x] - 1]:\n            return -1\n        visited[x] = True\n        dist[x] = dist[p[i - 1] - 1] + 1\n        weight[x] = dist[p[i - 1] - 1] - dist[b[x] - 1] + 1\n    return ' '.join((str(x) for x in weight))\nt = 1\nt = int(input())\nfor _ in range(t):\n    print(solve())", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    l = {int(x): i for (i, x) in enumerate(input().split())}\n    r = [l[x + 1] - l[b[x]] for x in range(n)]\n    print(*r) if not min(r) else print('-1')", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    l = {int(x): i for (i, x) in enumerate(input().split())}\n    r = [l[x + 1] - l[b[x]] for x in range(n)]\n    print(*r) if min(r) == 0 else print('-1')", "def solve():\n    n = int(input())\n    par = list(map(int, input().split()))\n    per = list(map(int, input().split()))\n    par = [0] + par\n    per = [0] + per\n    for i in range(1, n + 1):\n        if par[i] == i:\n            root = i\n    dist = [-1] * (n + 1)\n    w = [0] * (n + 1)\n    dist[root] = 0\n    if per[1] != root:\n        print(-1)\n        return\n    for i in range(2, n + 1):\n        node = per[i]\n        p = par[node]\n        if dist[p] == -1:\n            print(-1)\n            return\n        dist[node] = i - 1\n        w[node] = dist[node] - dist[p]\n    print(*w[1:])\n    return\nfor _ in range(int(input())):\n    solve()", "for _ in range(int(input())):\n    n = int(input())\n    b = [0] + list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    if b[p[0]] != p[0]:\n        print(-1)\n        continue\n    dist = [None] * (n + 1)\n    dist[p[0]] = 0\n    prev_dist = 0\n    weights = [0] * n\n    for i in range(1, n):\n        x = p[i]\n        pdist = dist[b[x]]\n        if pdist is None:\n            print(-1)\n            break\n        weights[x - 1] = max(1, prev_dist - pdist + 1)\n        dist[x] = weights[x - 1] + pdist\n        prev_dist = dist[x]\n    else:\n        print(' '.join(map(str, weights)))", "for _ in range(int(input())):\n    n = input()\n    b = input().split()\n    l = {x: i for (i, x) in enumerate(input().split())}\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "for _ in range(int(input())):\n    (n, b, l) = (input(), input().split(), {x: i for (i, x) in enumerate(input().split())})\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    l = {int(x): i for (i, x) in enumerate(input().split())}\n    r = [l[i + 1] - l[b[i]] for i in range(n)]\n    if min(r) == 0:\n        print(*r, sep=' ')\n    else:\n        print(-1)", "def solve():\n    n = int(input())\n    bs = list(map(int, input().split()))\n    ps = list(map(int, input().split()))\n    (dist, visited, count) = ([0] * len(bs), set(), 0)\n    visited.add(ps[0])\n    for (arr_idx, node) in enumerate(ps):\n        parent = bs[node - 1]\n        if parent not in visited:\n            return [-1]\n        visited.add(node)\n        dist[node - 1] = count\n        count += 1\n    ans = []\n    for (idx, node_dist_from_root) in enumerate(dist):\n        parent_node = bs[idx]\n        parent_dist_from_root = dist[parent_node - 1]\n        ans.append(node_dist_from_root - parent_dist_from_root)\n    return ans\nfor _ in range(int(input())):\n    print(*solve())", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = {int(i): j for (j, i) in enumerate(input().split())}\n    for i in range(n):\n        if i + 1 == a[i]:\n            d = i\n            break\n    l = [b[i + 1] - b[a[i]] for i in range(n)]\n    if min(l) != 0:\n        print(-1)\n    else:\n        print(*l)", "for _ in range(int(input())):\n    (n, b, l) = (input(), input().split(), {x: i for (i, x) in enumerate(input().split())})\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "for h in range(int(input())):\n    (n, b, l) = (input(), input().split(), {x: i for (i, x) in enumerate(input().split())})\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "for _ in range(int(input())):\n    (n, b, l) = (input(), input().split(), {x: i for (i, x) in enumerate(input().split())})\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "def f():\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        b[i] -= 1\n        p[i] -= 1\n    root = p[0]\n    if b[root] != root:\n        return [-1]\n    ans = [-1] * n\n    dist = [-1] * n\n    d = 0\n    ans[root] = 0\n    dist[root] = 0\n    for nod in p:\n        if ans[b[nod]] == -1:\n            return [-1]\n        ans[nod] = d - dist[b[nod]]\n        dist[nod] = d\n        d += 1\n    return ans\nfor _ in range(int(input())):\n    print(*f())", "import itertools\nfrom math import floor, log, log2, ceil, sqrt\nfrom itertools import groupby\nfrom decimal import Decimal, getcontext\nimport sys\nt = int(input())\nres = []\nfor _t in range(t):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    b.insert(0, 0)\n    p.insert(0, 0)\n    ans = [-1] * (n + 1)\n    distances = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if i == 1:\n            if b[p[i]] != p[i]:\n                ans = [-1]\n                break\n            else:\n                ans[p[i]] = 0\n        elif ans[b[p[i]]] == -1:\n            ans = [-1]\n            break\n        else:\n            distances[p[i]] = distances[p[i - 1]] + 1\n            ans[p[i]] = distances[p[i]] - distances[b[p[i]]]\n    if len(ans) > 1:\n        del ans[0]\n    res.append(' '.join(map(str, ans)))\nfor i in range(t):\n    print(res[i])", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(lambda x: int(x) - 1, input().split()))\n    p = list(map(lambda x: int(x) - 1, input().split()))\n    d = [0] * n\n    for i in range(n):\n        d[p[i]] = i\n    dist = [0] * n\n    for i in range(n):\n        if d[i] >= d[b[i]]:\n            dist[i] = d[i] - d[b[i]]\n        else:\n            print(-1)\n            break\n    else:\n        print(*dist)", "for _ in range(int(input())):\n    (n, b, l) = (input(), input().split(), {x: i for (i, x) in enumerate(input().split())})\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "for _ in range(int(input())):\n    (n, b) = (input(), input().split())\n    l = {x: i for (i, x) in enumerate(input().split())}\n    r = [l[str(x + 1)] - l[b[x]] for x in range(int(n))]\n    print(*(r if min(r) == 0 else [-1]))", "import math\nfrom collections import Counter, defaultdict, deque\nfrom sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    b = [int(i) - 1 for i in input().split()]\n    for i in range(n):\n        if b[i] == i:\n            rt = b[i]\n            break\n    p = [int(i) - 1 for i in input().split()]\n    if p[0] != rt:\n        print(-1)\n        continue\n    ans = [-1] * n\n    sm = [-1] * n\n    key = 0\n    for (i, e) in enumerate(p):\n        if i == 0:\n            sm[e] = 0\n            ans[e] = 0\n            continue\n        parent = b[e]\n        if sm[parent] == -1:\n            key = 1\n            break\n        sm[e] = i\n        ans[e] = i - sm[parent]\n    if key == 0:\n        print(*ans)\n    else:\n        print(-1)", "def solve(n, t, p):\n    last = 0\n    ans = [0] * n\n    for i in range(n):\n        if t[i] == i + 1:\n            root = i + 1\n            break\n    perm = {root: 0}\n    if p[0] != root:\n        return [-1]\n    for i in range(1, n):\n        if t[p[i] - 1] not in perm:\n            return [-1]\n        else:\n            ans[p[i] - 1] = last + 1 - perm[t[p[i] - 1]]\n            last += 1\n            perm[p[i]] = last\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    t = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    print(*solve(n, t, p))", "for _ in range(int(input())):\n    n = int(input())\n    parents = list(map(int, input().split()))\n    perm = list(map(int, input().split()))\n    root = [num for (index, num) in enumerate(parents, start=1) if num == index][0]\n    curr = 0\n    dist = [-1] * n\n    dist[root - 1] = 0\n    if perm[0] != root:\n        print(-1)\n        continue\n    ptotal = [-1] * n\n    ptotal[root - 1] = 0\n    for num in perm:\n        if dist[parents[num - 1] - 1] == -1:\n            print(-1)\n            break\n        dist[num - 1] = curr - ptotal[parents[num - 1] - 1]\n        ptotal[num - 1] = curr\n        curr += 1\n    else:\n        print(*dist)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    b = [0] + b\n    p = [0] + p\n    ans = [-1 for i in range(n + 1)]\n    (root, flag) = (-1, 0)\n    for i in range(1, n + 1):\n        if b[i] == i:\n            root = i\n            break\n    if p[1] != root:\n        print(-1)\n        continue\n    som = [0 for i in range(n + 1)]\n    ans[p[1]] = 0\n    for i in range(2, n + 1):\n        if ans[b[p[i]]] == -1:\n            flag = 1\n            break\n        som[p[i]] = i - 1\n        ans[p[i]] = som[p[i]] - som[b[p[i]]]\n    if flag == 1:\n        print(-1)\n        continue\n    print(*ans[1:])", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    root = ''\n    for i in range(n):\n        if i + 1 == b[i]:\n            root = i + 1\n            break\n        else:\n            continue\n    if root != p[0]:\n        print(-1)\n        continue\n    di = dict()\n    for i in range(n):\n        di[p[i]] = i\n    weightList = list()\n    flag = True\n    for i in range(1, n + 1):\n        child_distance = di[i]\n        parent_distance = di[b[i - 1]]\n        weight = child_distance - parent_distance\n        if i == root or weight > 0:\n            weightList.append(weight)\n        else:\n            flag = False\n            break\n    if flag == False:\n        print(-1)\n    else:\n        print(*weightList)", "t = int(input())\n\ndef solve():\n    n = int(input())\n    tree = [x - 1 for x in list(map(int, input().split()))]\n    order = [x - 1 for x in list(map(int, input().split()))]\n    if tree[order[0]] != order[0]:\n        print(-1)\n        return\n    dist = [-1] * n\n    dist[order[0]] = 0\n    for i in range(1, n):\n        dist[order[i]] = dist[order[i - 1]] + 1\n        if dist[tree[order[i]]] > dist[order[i]] or dist[tree[order[i]]] < 0:\n            print(-1)\n            return\n    weight = [0] * n\n    for i in range(n):\n        weight[i] = dist[i] - dist[tree[i]]\n    print(*weight)\nfor _ in range(t):\n    solve()", "def weight(n):\n    b = [None] * (n + 1)\n    b[1:] = [int(j) for j in input().split()]\n    p = [None] * (n + 1)\n    p[1:] = [int(k) for k in input().split()]\n    distance = [None] * (n + 1)\n    distance[1:] = [-1] * n\n    if p[1] != b[p[1]]:\n        print('-1')\n        return\n    distance[p[1]] = 0\n    for ii in range(2, n + 1):\n        if distance[b[p[ii]]] == -1:\n            print('-1')\n            return\n        distance[p[ii]] = distance[p[ii - 1]] + 1\n    for jj in range(1, n + 1):\n        print(distance[jj] - distance[b[jj]], end=' ')\n    print()\nt = int(input())\nfor i in range(t):\n    number = int(input())\n    weight(number)", "from collections import defaultdict\nget_int = lambda : int(input())\nget_int_list = lambda : list(map(int, input().split()))\n\ndef solve():\n    n = get_int()\n    parent = [0] + get_int_list()\n    perm = get_int_list()\n    children = defaultdict(list)\n    for (i, v) in enumerate(parent):\n        children[v].append(i)\n        if i == v:\n            root = v\n    valid_set = {root}\n    weights = [0] * (n + 1)\n    distances = [0] * (n + 1)\n    next_dist = 0\n    for candid in perm:\n        if candid not in valid_set:\n            return [-1]\n        valid_set.remove(candid)\n        valid_set.update(children.get(candid, []))\n        par_dist = distances[parent[candid]]\n        weights[candid] = next_dist - par_dist\n        distances[candid] = next_dist\n        next_dist += 1\n    return weights[1:]\nt = get_int()\nfor _ in range(t):\n    print(' '.join(map(str, solve())))", "for _ in range(int(input())):\n    (n, b, l) = (int(input()), input().split(), {x: i for (i, x) in enumerate(input().split())})\n    r = [l[str(x + 1)] - l[b[x]] for x in range(n)]\n    print(*(r if not min(r) else [-1]))", "import sys\nimport math\nfrom bisect import bisect_right as br\nfrom collections import deque\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nfor _ in range(int(input())):\n    n = int(input())\n    arr = int_arr()\n    p = int_arr()\n    dict = {}\n    for i in range(n):\n        dict[p[i]] = i\n    mn = 0\n    ans = []\n    for i in range(n):\n        parent = arr[i]\n        child = i + 1\n        ans.append(dict[child] - dict[parent])\n    if min(ans) < 0:\n        print(-1)\n    else:\n        print(*ans)", "t = int(input())\nfor e in range(t):\n    n = int(input())\n    s1 = list(map(int, input().split()))\n    s2 = list(map(int, input().split()))\n    ans = [-1] * n\n    f = True\n    if s1[s2[0] - 1] != s2[0]:\n        print(-1)\n        continue\n    else:\n        y = 0\n        ans[s2[y] - 1] = 0\n        while y + 1 < n:\n            y += 1\n            if ans[s1[s2[y] - 1] - 1] != -1:\n                ans[s2[y] - 1] = ans[s2[y - 1] - 1] + 1\n            else:\n                print(-1)\n                f = False\n                break\n    if f:\n        ans1 = [ans[i] - ans[s1[i] - 1] for i in range(n)]\n        print(*ans1)", "for _ in range(int(input())):\n    n = int(input())\n    b = [None] + [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n    max_d = 0\n    d = {p[0]: 0}\n    w = [0] * (n + 1)\n    for i in range(1, n):\n        x = p[i]\n        if b[x] not in d:\n            print(-1)\n            break\n        d[x] = (max_d := (max_d + 1))\n        w[x] = max_d - d[b[x]]\n    else:\n        print(*w[1:])", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    b = [i - 1 for i in b]\n    p = list(map(int, input().split()))\n    p = [i - 1 for i in p]\n    if p[0] != b[p[0]]:\n        print(-1)\n    else:\n        dist = [-1 for i in range(n)]\n        dist[p[0]] = 0\n        flag = False\n        for i in range(1, n):\n            if dist[b[p[i]]] == -1:\n                print(-1)\n                flag = True\n                break\n            dist[p[i]] = dist[p[i - 1]] + 1\n        if not flag:\n            for i in range(0, n):\n                print(dist[i] - dist[b[i]], end=' ')\n            print()", "def solve():\n    vertex = int(input())\n    parent = [-1 for i in range(vertex + 1)]\n    b = list(map(int, input().split()))\n    perm = list(map(int, input().split()))\n    for i in range(vertex):\n        parent[i + 1] = b[i]\n    ongoing = 0\n    done = [False for i in range(vertex + 1)]\n    j = 0\n    distance = [-1 for i in range(vertex + 1)]\n    while j < vertex:\n        if j == 0:\n            if parent[perm[j]] != perm[j]:\n                return [-1]\n            distance[perm[j]] = ongoing\n            ongoing += 1\n            done[perm[j]] = True\n        else:\n            par1 = parent[perm[j]]\n            if done[par1]:\n                distance[perm[j]] = ongoing\n            else:\n                return [-1]\n            done[perm[j]] = True\n            ongoing += 1\n        j += 1\n    root = perm[0]\n    output = [-1 for i in range(vertex + 1)]\n    output[root] = 0\n    for i in range(vertex):\n        output[i + 1] = distance[i + 1] - distance[b[i]]\n    return output[1:]\nremained_test_cases = 1\nremained_test_cases = int(input())\nwhile remained_test_cases > 0:\n    print(*solve())\n    remained_test_cases -= 1", "for _ in range(int(input())):\n    n = int(input())\n    par = [-1] + list(map(int, input().split()))\n    per = [-1] + list(map(int, input().split()))\n    dist = [-1] * (n + 1)\n    w = [-1] * (n + 1)\n    root = -1\n    for i in range(1, n + 1):\n        if par[i] == i:\n            root = i\n    dist[root] = 0\n    w[root] = 0\n    if per[1] != root:\n        print(-1)\n        continue\n    ok = True\n    for i in range(2, n + 1):\n        node = per[i]\n        p = par[node]\n        if dist[p] == -1:\n            ok = False\n            break\n        dist[node] = i - 1\n        w[node] = dist[node] - dist[p]\n    if ok:\n        for i in range(n):\n            print(w[i + 1], end=' ')\n        print()\n    else:\n        print(-1)", "t = int(input())\nfor tst in range(t):\n    n = int(input())\n    b = [0]\n    p = [0]\n    dist = [-1] * (n + 1)\n    c = 0\n    b += list(map(int, input().split()))\n    p += list(map(int, input().split()))\n    if b[p[1]] != p[1]:\n        print(-1)\n    else:\n        dist[p[1]] = 0\n        for i in range(2, n + 1):\n            if dist[b[p[i]]] == -1:\n                print(-1)\n                c = -1\n                break\n            dist[p[i]] = dist[p[i - 1]] + 1\n        if c != -1:\n            for i in range(1, n):\n                print(dist[i] - dist[b[i]], end=' ')\n            print(dist[n] - dist[b[n]])", "T = int(input().strip())\n\ndef find_root(parent, n):\n    for i in range(n):\n        if parent[i] == i:\n            return i\n\ndef solve(root, dis, parent, per):\n    curr_weight = 1\n    dis[root] = 0\n    for i in range(1, n):\n        if dis[parent[per[i]]] is None or curr_weight <= dis[parent[per[i]]]:\n            return False\n        dis[per[i]] = curr_weight\n        curr_weight += 1\n    return True\nfor t in range(T):\n    n = int(input().strip())\n    parent = [int(x) - 1 for x in input().strip().split()]\n    per = [int(x) - 1 for x in input().strip().split()]\n    dis = [None for i in range(n)]\n    root = find_root(parent, n)\n    if per[0] != root:\n        print(-1)\n        continue\n    if solve(root, dis, parent, per):\n        for i in range(n):\n            print(dis[i] - dis[parent[i]], end=' ')\n        print()\n    else:\n        print(-1)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    w = [0] * n\n    dist = [-1] * n\n    flag = 0\n    for k in range(n):\n        if p[0] == b[p[0] - 1] and k == 0:\n            w[p[k] - 1] = 0\n            dist[p[k] - 1] = 0\n        elif dist[b[p[k] - 1] - 1] == -1:\n            print(-1)\n            flag = 1\n            break\n        else:\n            w[p[k] - 1] = k - dist[b[p[k] - 1] - 1]\n            dist[p[k] - 1] = k\n    if flag == 0:\n        print(*w)", "from collections import deque\nimport sys, threading\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tree = [[] for _ in range(n + 1)]\n        b = list(map(int, input().split()))\n        p = list(map(int, input().split()))\n        p = {p[i]: i for i in range(n)}\n        dists = [p[i + 1] for i in range(n)]\n        root = None\n        for i in range(n):\n            tree[b[i]].append(i + 1)\n            if b[i] == i + 1:\n                root = b[i]\n        weights = [0 for i in range(n)]\n\n        def dfs(node, parent):\n            if not node:\n                return True\n            if parent and dists[parent - 1] >= dists[node - 1]:\n                return False\n            if parent:\n                weights[node - 1] = dists[node - 1] - dists[parent - 1]\n            for v in tree[node]:\n                if v == node:\n                    continue\n                if not dfs(v, node):\n                    return False\n            return True\n        print(-1 if not dfs(root, None) else ' '.join((str(i) for i in weights)))\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "def solve():\n    n = int(input())\n    s = {i: [] for i in range(n)}\n    f = list(map(lambda x: int(x) - 1, input().split()))\n    for (i, f) in enumerate(f):\n        if i != f:\n            s[f].append(i)\n        else:\n            root = i\n    q = list(map(lambda x: int(x) - 1, input().split()))\n    if q[0] != root:\n        return -1\n    r = [0] * n\n    i = 1\n    p = {a: 0 for a in s[root]}\n    m = 1\n    while i < n:\n        if q[i] not in p:\n            return -1\n        r[q[i]] = m - p[q[i]]\n        for a in s[q[i]]:\n            p[a] = m\n        m += 1\n        i += 1\n    return ' '.join(map(str, r))\nn = int(input())\nfor i in range(n):\n    print(solve())", "for _ in range(int(input())):\n    n = int(input())\n    li = list(map(int, input().split()))\n    ai = list(map(int, input().split()))\n    for i in range(n):\n        if li[i] == i + 1:\n            r = i + 1\n            break\n    if ai[0] != r:\n        print(-1)\n    else:\n        di = [0] * n\n        b = 0\n        f = 0\n        for i in range(1, n):\n            if di[li[ai[i] - 1] - 1] > 0 or li[ai[i] - 1] == r:\n                di[ai[i] - 1] = b + 1\n                b = di[ai[i] - 1]\n            else:\n                f = 1\n                break\n        if f == 1:\n            print(-1)\n        else:\n            for i in range(n):\n                print(di[i] - di[li[i] - 1], end=' ')\n            print()", "for _ in range(int(input())):\n    n = int(input())\n    anc = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        anc[i] -= 1\n        p[i] -= 1\n    d = [-1] * n\n    w = [-1] * n\n    for i in range(n):\n        if anc[i] == i:\n            root = i\n    if p[0] != root:\n        print(-1)\n        continue\n    d[root] = 0\n    done = False\n    w[root] = 0\n    for i in range(1, n):\n        if anc[p[i]] == root:\n            d[p[i]] = d[p[i - 1]] + 1\n            w[p[i]] = d[p[i]]\n        elif d[anc[p[i]]] == -1:\n            print(-1)\n            done = True\n            break\n        else:\n            d[p[i]] = d[p[i - 1]] + 1\n            w[p[i]] = d[p[i]] - d[anc[p[i]]]\n    if not done:\n        print(*w)", "t = int(input())\n\ndef dec(x):\n    return int(x) - 1\nwhile t:\n    t -= 1\n    n = int(input())\n    b = list(map(dec, input().split()))\n    for i in range(n):\n        if b[i] == i:\n            root = i\n            break\n    p = list(map(dec, input().split()))\n    if p[0] != root:\n        print(-1)\n        continue\n    dist = [-1 for _ in range(n)]\n    wt = [-1 for _ in range(n)]\n    dist[root] = 0\n    wt[root] = 0\n    failed = False\n    for i in range(1, n):\n        prnt = b[p[i]]\n        if dist[prnt] == -1:\n            print(-1)\n            failed = True\n            break\n        else:\n            dist[p[i]] = max(dist[prnt], dist[p[i - 1]]) + 1\n            wt[p[i]] = dist[p[i]] - dist[prnt]\n    if not failed:\n        print(*wt, sep=' ')", "for _ in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    root = None\n    for (i, item) in enumerate(b):\n        if i + 1 == item:\n            root = item\n    weights = {}\n    weights[root] = 0\n    possible = True\n    distances = {root: 0}\n    for (i, item) in enumerate(p):\n        if i == 0:\n            if item != root:\n                possible = False\n                break\n        else:\n            dist_so_far = distances.get(b[item - 1])\n            if dist_so_far == None:\n                possible = False\n                break\n            to_add = distances.get(p[i - 1])\n            if to_add > dist_so_far:\n                weights[item] = to_add - dist_so_far + 1\n                distances[item] = dist_so_far + (to_add - dist_so_far) + 1\n            else:\n                weights[item] = 1\n                distances[item] = dist_so_far + 1\n    to_print = [None for _ in range(n)]\n    for item in weights:\n        to_print[item - 1] = weights[item]\n    if possible:\n        print(*to_print)\n    else:\n        print(-1)", "for _ in range(int(input())):\n    n = int(input())\n    seen = [0 for i in range(n)]\n    ans = [int(i) - 1 for i in input().split()]\n    l = [int(i) - 1 for i in input().split()]\n    flg = 1\n    for i in l:\n        seen[i] = 1\n        if seen[ans[i]] != 1:\n            flg = 0\n            break\n    if flg == 0:\n        print(-1)\n        continue\n    dist = [0 for i in range(n)]\n    w = [0 for i in range(n)]\n    for i in range(1, n):\n        w[l[i]] = dist[l[i - 1]] - dist[ans[l[i]]] + 1\n        dist[l[i]] = w[l[i]] + dist[ans[l[i]]]\n    for i in w:\n        print(i, end=' ')\n    print()", "t = int(input())\nfrom collections import deque\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[i + 1] = a[i]\n    if d[p[0]] != p[0]:\n        print(-1)\n    else:\n        ansd = dict()\n        y = 0\n        c = 0\n        ansd[p[0]] = c\n        c += 1\n        for i in range(1, n):\n            if d[p[i]] in ansd:\n                ansd[p[i]] = c\n                c += 1\n            else:\n                y = 1\n                break\n        if y == 1:\n            print(-1)\n        else:\n            ans = []\n            for i in range(n):\n                ans.append(ansd[i + 1] - ansd[d[i + 1]])\n            print(*ans)", "import math\nfrom collections import defaultdict\nmod = 10 ** 9 + 7\n\ndef bexp(a, b):\n    res = 1\n    while b:\n        if b % 2:\n            res = res * a % mod\n            b = b - 1\n        else:\n            a = a * a % mod\n            b = b // 2\n    return res\nfor cases in range(int(input())):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    tree = [-1] * (n + 1)\n    root = -1\n    for i in range(0, n):\n        if i + 1 != b[i]:\n            tree[i + 1] = b[i]\n        else:\n            root = b[i]\n    if p[0] != root:\n        print(-1)\n    else:\n        prev = 0\n        cnt = 1\n        d = defaultdict(lambda : -1)\n        dist = [0] * n\n        wt = [0] * n\n        d[p[0]] = 1\n        f = 0\n        for i in range(1, n):\n            if d[b[p[i] - 1]] == -1:\n                print(-1)\n                f = 1\n                break\n            else:\n                dist[p[i] - 1] = dist[p[i - 1] - 1] + 1\n                wt[p[i] - 1] = dist[p[i] - 1] - dist[b[p[i] - 1] - 1]\n                d[p[i]] = 1\n        if f == 0:\n            print(*wt)", "def solve(n, tree, order):\n    tree = [z - 1 for z in tree]\n    adj = [[] for _ in range(n)]\n    root = -1\n    for i in range(n):\n        if tree[i] == i:\n            root = i\n            continue\n        adj[tree[i]].append(i)\n    order = [z - 1 for z in order]\n    dis = dict()\n    new = set()\n    dis[root] = 0\n    for each in adj[root]:\n        new.add(each)\n    if order[0] != root:\n        return [-1]\n    curr = 1\n    for i in order[1:]:\n        if i not in new or tree[i] not in dis or dis[tree[i]] >= curr:\n            return [-1]\n        dis[i] = curr\n        curr += 1\n        for nei in adj[i]:\n            new.add(nei)\n    return [dis[i] - dis[tree[i]] for i in range(n)]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    tree = list(map(int, input().split()))\n    order = list(map(int, input().split()))\n    print(*solve(n, tree, order))", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    b = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    w = [0] * n\n    dist = [0] * n\n    root = -1\n    for i in range(n):\n        if b[i] - 1 == i:\n            root = i\n            break\n    edges = [[] for _ in range(n)]\n    for i in range(n):\n        edges[b[i] - 1].append(i)\n        edges[i].append(b[i] - 1)\n    set_ = {root}\n    flg = True\n    cnt = 0\n    for t in p:\n        t -= 1\n        if t in set_:\n            w[t] = cnt - dist[b[t] - 1]\n            dist[t] = cnt\n            for t2 in edges[t]:\n                set_.add(t2)\n        else:\n            flg = False\n            break\n        cnt += 1\n    if not flg:\n        print(-1)\n    else:\n        print(' '.join(map(str, w)))", "from sys import stdin\nimport math\nfrom collections import deque\nfrom heapq import heapify, heappop, heappush\ninput = stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    childs = {i: [] for i in range(1, n + 1)}\n    parents = {i: 0 for i in range(1, n + 1)}\n    data = {i: -1 for i in range(1, n + 1)}\n    ptotal = {i: 0 for i in range(1, n + 1)}\n    ancestors = list(map(int, input().split()))\n    root = None\n    for (i, a) in enumerate(ancestors):\n        if i + 1 == a:\n            root = a\n        childs[a].append(i + 1)\n    permute = list(map(int, input().split()))\n    (maxtillnow, okay) = (-1, True)\n    if permute[0] != root:\n        print(-1)\n        continue\n    data[root] = 0\n    maxtillnow = 0\n    for p in permute[1:]:\n        v = data[ancestors[p - 1]]\n        if v == -1:\n            okay = False\n            break\n        else:\n            data[p] = maxtillnow + 1 - ptotal[ancestors[p - 1]]\n            if maxtillnow > 1000000000:\n                okay = False\n                break\n            ptotal[p] = maxtillnow + 1\n            maxtillnow += 1\n    if okay:\n        res = [str(data[i]) for i in range(1, n + 1)]\n        print(' '.join(res))\n    else:\n        print(-1)", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10000000)\n\ndef dfs(cur):\n    flag = 0\n    if visited[cur] == True:\n        return 0\n    visited[cur] = True\n    for child in tree[cur]:\n        if not visited[child]:\n            if sol[cur] > sol[child]:\n                return 1\n            flag += dfs(child)\n    return flag\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    order = list(map(int, input().split()))\n    tree = [[] for _ in range(n + 1)]\n    for i in range(n):\n        if i + 1 == lst[i]:\n            root = i + 1\n        else:\n            tree[lst[i]].append(i + 1)\n    sol = [0] * (n + 1)\n    for i in range(n):\n        sol[order[i]] = i\n    visited = [False] * (n + 1)\n    flag = dfs(root)\n    if flag:\n        print(-1)\n    else:\n        tmp = []\n        for i in range(n):\n            tmp.append(sol[i + 1] - sol[lst[i]])\n        print(*tmp)", "import sys\nttime = int(input())\ne = []\nfor ccount in range(ttime):\n    n = int(input())\n    parents = list(map(lambda a: int(a) - 1, input().split()))\n    root = -1\n    for i in range(n):\n        if parents[i] == i:\n            root = i\n    e = [[] for i in range(n)]\n    for i in range(n):\n        e[parents[i]].append(i)\n    order = list(map(lambda a: int(a) - 1, input().split()))\n    place = [0 for i in range(n)]\n    w = [0 for i in range(n)]\n    for i in range(n):\n        place[order[i]] = i\n    marked = {root}\n    bad = False\n    for i in range(n):\n        if not order[i] in marked:\n            bad = True\n        w[order[i]] = i - place[parents[order[i]]]\n        for x in e[order[i]]:\n            marked.add(x)\n    if bad:\n        print(-1)\n    else:\n        for i in range(n):\n            sys.stdout.write(str(w[i]))\n            sys.stdout.write(' ')\n        print('')", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000000 + 7\nmod2 = 998244353\nfor _ in range(I()):\n    n = I()\n    b = L()\n    p = L()\n    d = [0] * n\n    for i in range(n):\n        d[p[i] - 1] = i\n    adj = [[] for i in range(n)]\n    k = 0\n    for i in range(n):\n        if b[i] != i + 1:\n            adj[i].append(b[i] - 1)\n            adj[b[i] - 1].append(i)\n        else:\n            k = i\n    ans = [0] * n\n\n    def bfs(i):\n        q = deque()\n        q.append(i)\n        v = [0] * n\n        while q:\n            r = q.popleft()\n            v[r] = 1\n            for j in adj[r]:\n                if v[j] == 0:\n                    ans[j] = d[j] - d[r]\n                    q.append(j)\n    bfs(k)\n    f = 0\n    for i in range(n):\n        if i != k and ans[i] <= 0:\n            f = 1\n    if f == 1:\n        print(-1)\n        continue\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    P = [0] + list(map(int, input().split()))\n    W = [0] + list(map(int, input().split()))\n    C = [set() for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        p = P[i]\n        if p == i:\n            root = p\n        else:\n            C[p].add(i)\n    ANS = [0 for _ in range(n + 1)]\n    total_w = [0 for _ in range(n + 1)]\n    if root != W[1]:\n        print(-1)\n        continue\n    next_point_set = C[root]\n    idx = 2\n    curr_w = 0\n    while next_point_set:\n        cp = W[idx]\n        if cp not in next_point_set:\n            break\n        next_point_set.remove(cp)\n        next_point_set |= C[cp]\n        pp = P[cp]\n        curr_w += 1\n        total_w[cp] = curr_w\n        ANS[cp] = total_w[cp] - total_w[pp]\n        idx += 1\n    if next_point_set:\n        print(-1)\n    else:\n        print(*ANS[1:])", "import sys\nsys.setrecursionlimit(200000)\nfor t in range(int(input())):\n    n = int(input())\n    b = [0] + list(map(int, input().split()))\n    p = [0] + list(map(int, input().split()))\n    pos = [0] * (n + 1)\n    root = int()\n    adj = list()\n    for i in range(n + 1):\n        adj.append([])\n    for i in range(1, n + 1):\n        if i == b[i]:\n            root = i\n        else:\n            adj[b[i]].append(i)\n        pos[p[i]] = i\n\n    def dfs(f, u):\n        if pos[u] < pos[f]:\n            return False\n        for v in adj[u]:\n            if dfs(u, v) == False:\n                return False\n        return True\n    if dfs(root, root) == False:\n        print(-1)\n        continue\n    sum = [0] * (n + 1)\n    res = [0] * (n + 1)\n    last = 0\n    for i in range(1, n + 1):\n        if p[i] == root:\n            continue\n        res[p[i]] = last - sum[b[p[i]]] + 1\n        sum[p[i]] = sum[b[p[i]]] + res[p[i]]\n        last = sum[p[i]]\n    for i in range(1, n + 1):\n        print(res[i], end=' ')\n    print('')", "import sys\nsys.setrecursionlimit(200000)\nfor t in range(int(input())):\n    n = int(input())\n    b = [0] + list(map(int, input().split()))\n    p = [0] + list(map(int, input().split()))\n    pos = [0] * (n + 1)\n    root = int()\n    adj = list()\n    for i in range(n + 1):\n        adj.append([])\n    for i in range(1, n + 1):\n        if i == b[i]:\n            root = i\n        else:\n            adj[b[i]].append(i)\n        pos[p[i]] = i\n\n    def dfs(f, u):\n        if pos[u] < pos[f]:\n            return False\n        for v in adj[u]:\n            if dfs(u, v) == False:\n                return False\n        return True\n    if dfs(root, root) == False:\n        print(-1)\n        continue\n    sum = [0] * (n + 1)\n    res = [0] * (n + 1)\n    last = 0\n    for i in range(1, n + 1):\n        if p[i] == root:\n            continue\n        res[p[i]] = last - sum[b[p[i]]] + 1\n        sum[p[i]] = sum[b[p[i]]] + res[p[i]]\n        last = sum[p[i]]\n    for i in range(1, n + 1):\n        print(res[i], end=' ')\n    print('')", "import collections\nfrom functools import partial\n\ndef solve() -> None:\n    n = int(input())\n    parents = [int(i) - 1 for i in input().split()]\n    edges = [set() for _ in range(n)]\n    permutation = [int(i) - 1 for i in input().split()]\n    for (index, parent) in enumerate(parents):\n        if index == parent:\n            root = index\n        edges[index].add(parent)\n        edges[parent].add(index)\n    ancestors = [set([i]) for i in range(n)]\n    discovered = set()\n\n    def discover(index: int, ancestor: int=None) -> None:\n        discovered.add(index)\n        if ancestor is not None:\n            ancestors[index].add(ancestor)\n        for edge in edges[index]:\n            if edge not in discovered:\n                queue.append(partial(discover, edge, index))\n    queue = collections.deque([partial(discover, root)])\n    while queue:\n        func = queue.popleft()\n        func()\n    discovered = set()\n    for p in permutation:\n        discovered.add(p)\n        if not ancestors[p].issubset(discovered):\n            print(-1)\n            return\n    results = [0] * n\n    distances = [0] * n\n\n    def distance(index: int) -> int:\n        if index == root:\n            return 0\n        if distances[index] > 0:\n            return distances[index]\n        distances[index] = results[index] + distance(parents[index])\n        return distances[index]\n    for i in range(len(permutation) - 1):\n        last = permutation[i]\n        current = permutation[i + 1]\n        results[current] = 1 + distance(last) - distance(parents[current])\n    print(*results)\nfor _ in range(int(input())):\n    solve()"]