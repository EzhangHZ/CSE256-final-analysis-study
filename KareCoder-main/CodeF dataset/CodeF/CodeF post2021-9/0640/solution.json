["def work(a, b, l, r):\n    for i in range(max(0, r - len(a)), min(l + 1, len(b) - len(a)) + 1):\n        if a == b[i:i + len(a)]:\n            print('YES')\n            exit(0)\n[x, y] = map(int, input().split())\n(a, b, c) = ([1], [], [])\nwhile x:\n    a.append(x % 2)\n    c.append(x % 2)\n    x //= 2\nwhile y:\n    b.append(y % 2)\n    y //= 2\nif c == b:\n    print('YES')\n    exit(0)\nc.reverse()\nwhile c[-1] == 0:\n    c.pop()\nl = -1\nr = len(b)\nwhile l + 1 < len(b) and b[l + 1] == 1:\n    l += 1\nwhile r - 1 >= 0 and b[r - 1] == 1:\n    r -= 1\nwork(a, b, l, r)\na.reverse()\nwork(a, b, l, r)\nwork(c, b, l, r)\nc.reverse()\nwork(c, b, l, r)\nprint('NO')", "def reverse(string):\n    string = string[::-1]\n    return string\n\ndef b(n):\n    return bin(n).replace('0b', '')\n\ndef z(a):\n    zeroes = 0\n    for i in a:\n        if i == '0':\n            zeroes += 1\n    return zeroes\n(x, y) = map(int, input().split())\n(x, y) = (b(x), b(y))\nif len(x) == len(y) and x in y:\n    print('YES')\nelif x in y and z(x) == z(y) and ((x[-1] == '0' and y[-1] == '0') == 0):\n    print('YES')\nelse:\n    (x1, x2, x3, cnt) = (reverse(x), reverse(x + '1'), '', 0)\n    for i in x1:\n        if i == '0':\n            cnt += 1\n        else:\n            break\n    x1 = x1[cnt:]\n    x3 = reverse(x1)\n    if len(x1) == len(y) and x1 in y:\n        print('YES')\n    elif len(x2) == len(y) and x2 in y:\n        print('YES')\n    elif len(x3) == len(y) and x3 in y:\n        print('YES')\n    elif x3 in y and z(x3) == z(y) and ((x3[-1] == '0' and y[-1] == '0') == 0):\n        print('YES')\n    elif x1 in y and z(x1) == z(y) and ((x1[-1] == '0' and y[-1] == '0') == 0):\n        print('YES')\n    elif x2 in y and z(x2) == z(y) and ((x2[-1] == '0' and y[-1] == '0') == 0):\n        print('YES')\n    else:\n        print('NO')", "def contain(a, b):\n    if not '0' in b:\n        if not '0' in a:\n            if len(a) <= len(b):\n                return True\n            return False\n        return False\n    if not '0' in a:\n        return False\n    listA = list(a)\n    listB = list(b)\n    Aleft = 0\n    Aright = 0\n    Bleft = 0\n    Bright = 0\n    while listA[0] == '1':\n        listA.remove('1')\n        Aleft += 1\n    while listA[-1] == '1':\n        listA.pop()\n        Aright += 1\n    while listB[0] == '1':\n        listB.remove('1')\n        Bleft += 1\n    while listB[-1] == '1':\n        listB.pop()\n        Bright += 1\n    reA = listA.copy()\n    reA.reverse()\n    return listA == listB and Aleft <= Bleft and (Aright <= Bright) or (reA == listB and Aright <= Bleft and (Aleft <= Bright))\n\ndef find(x, y):\n    a = bin(x)[2:]\n    b = bin(y)[2:]\n    if a == b:\n        return True\n    if a[-1] == '1':\n        return contain(a, b)\n    temp = list(a)\n    while temp[-1] == '0':\n        temp.pop()\n    aa = ''.join(temp)\n    aaa = a + '1'\n    return contain(aa, b) or contain(aaa, b)\nline = input().split()\nx = int(line[0])\ny = int(line[1])\nif find(x, y):\n    print('YES')\nelse:\n    print('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(x, y) = [int(x) for x in input().split()]\nif x == y:\n    print('YES')\n    exit()\n(a, b) = (bin(x), bin(y))\na = a.replace('0b', '')\nb = b.replace('0b', '')\nif b[-1] == '0':\n    print('NO')\n    exit()\nif a in b and a.count('0') == b.count('0'):\n    print('YES')\n    exit()\nb = b[::-1]\nif a in b and a.count('0') == b.count('0'):\n    print('YES')\n    exit()\nwhile a[-1] == '0':\n    a = a[:len(a) - 1]\nif a in b and a.count('0') == b.count('0'):\n    print('YES')\n    exit()\nb = b[::-1]\nif a in b and a.count('0') == b.count('0'):\n    print('YES')\nelse:\n    print('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(x, y) = [str(bin(int(i)))[2:] for i in input().split()]\nif x == y:\n    print('YES')\nelif y[-1] == '0':\n    print('NO')\nelse:\n    x += '1'\n    if (y.find(x) != -1 or y.find(x[::-1]) != -1) and y.count('1') - x.count('1') == len(y) - len(x):\n        print('YES')\n    else:\n        x = x[:-1]\n        while x[-1] == '0':\n            x = x[:-1]\n        print('YES') if (y.find(x) != -1 or y.find(x[::-1]) != -1) and y.count('1') - x.count('1') == len(y) - len(x) else print('NO')", "(x, y) = [str(bin(int(i)))[2:] for i in input().split()]\nif x == y:\n    print('YES')\nelif y[-1] == '0':\n    print('NO')\nelse:\n    x += '1'\n    if (y.find(x) != -1 or y.find(x[::-1]) != -1) and y.count('1') - x.count('1') == len(y) - len(x):\n        print('YES')\n    else:\n        x = x[:-1]\n        while x[-1] == '0':\n            x = x[:-1]\n        print('YES') if (y.find(x) != -1 or y.find(x[::-1]) != -1) and y.count('1') - x.count('1') == len(y) - len(x) else print('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\nst = bin(a)[2:]\ned = bin(b)[2:]\nif st == ed:\n    print('YES')\n    exit(0)\ns1 = st + '1'\ns2 = st.strip('0')\nfor s in [s1, s2, s1[::-1], s2[::-1]]:\n    for l in range(len(ed)):\n        r = len(ed) - len(s) - l\n        if r < 0:\n            continue\n        if '1' * l + s + '1' * r == ed:\n            print('YES')\n            exit(0)\nprint('NO')\nexit(0)", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "import sys as system_break\n\ndef Commonfinder(n, m, o, p):\n    return f'1*({n}|{m}|{o}|{p})1*'\nimport math as m\nimport re as MATCHING_DEVICE_pattern\nInput = input()\nInput = Input.split()\nablist = []\nfor i in range(len(Input)):\n    ablist.append(int(Input[i]))\na = ablist[0]\nb = ablist[1]\nBinofa = bin(a)[2:]\nBinofb = bin(b)[2:]\nExtended_A = Binofa + '1'\nStriped_A = Binofa.rstrip('0')\nFinalCF = Commonfinder(Extended_A, Striped_A, Extended_A[::-1], Striped_A[::-1])\nif len(FinalCF) == 1:\n    FinalCF = list(FinalCF)\n    FinalCF = FinalCF[0]\n    if MATCHING_DEVICE_pattern.fullmatch(FinalCF, Binofb) or Binofa == Binofb:\n        print('YES')\nelse:\n    answer = ''\n    FinalCF = FinalCF\n    if a == b or MATCHING_DEVICE_pattern.fullmatch(FinalCF, Binofb):\n        print('YES')\n    else:\n        print('NO')", "def solve(current, target):\n    queue = [current]\n    visited = set()\n    while len(queue):\n        currentNode = queue.pop(0)\n        currentIdx = 0\n        while currentNode[currentIdx] == '0':\n            currentIdx += 1\n        currentNode = currentNode[currentIdx:]\n        if currentNode in visited:\n            continue\n        visited.add(currentNode)\n        if currentNode == target:\n            return 'YES'\n        (newStringOne, newStringTwo) = (currentNode, currentNode + '1')\n        if len(currentNode) <= len(target):\n            queue.append(newStringTwo[::-1])\n        queue.append(newStringOne[::-1])\n    return 'NO'\n(x, y) = map(int, input().split())\nresult = solve('{0:b}'.format(x), '{0:b}'.format(y))\nprint(result)", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(x, y) = [int(i) for i in input().split(' ')]\n\ndef solve():\n    if x == y:\n        return True\n    a = bin(x)[2:]\n    b = bin(y)[2:]\n    if x == 0:\n        if b.count('0') == 1 and b[-1] != 0:\n            return True\n        else:\n            return False\n    n = len(a)\n    for i in range(n - 1, -1, -1):\n        if a[i] != '0':\n            c = a[:i + 1]\n            break\n    p = [a, '1' + a[::-1], c, c[::-1]]\n\n    def ck(aa, bb):\n        (mm, nn) = (len(aa), len(bb))\n        if mm > nn:\n            return False\n        if mm == nn:\n            return aa == bb\n        if bb[-1] == '0':\n            return False\n        for i in range(nn - mm + 1):\n            if bb[i] == '0':\n                return False\n            if bb[i:i + mm] == aa:\n                if set(bb[i + mm:]) == set('1') or set(bb[i + mm:]) == set():\n                    return True\n        return False\n    for i in p:\n        if ck(i, b):\n            return True\n    return False\nif solve():\n    print('YES')\nelse:\n    print('NO')", "def check(s: str, t: str):\n    index = s.find(t)\n    return False if index == -1 else s == '1' * index + t + '1' * (len(s) - index - len(t))\n\ndef CF_760(x, y):\n    if x == y:\n        return True\n    if y % 2 == 0:\n        return False\n    binX = bin(x)[2:]\n    binY = bin(y)[2:]\n    if x % 2:\n        return check(binY, binX) or check(binY, binX[::-1])\n    binXbina0 = binX[:binX.rfind('1') + 1]\n    return check(binY, binX) or check(binY, binX[::-1]) or check(binY, binXbina0) or check(binY, binXbina0[::-1])\nprint('YES' if CF_760(*map(int, input().split())) else 'NO')", "def check(s1, s2):\n    index = s2.find(s1)\n    return False if index == -1 else s2 == '1' * index + s1 + '1' * (len(s2) - index - len(s1))\n(x, y) = map(int, input().split())\nif y % 2 == 0:\n    print('YES' if y == x else 'NO')\nelif x % 2:\n    print('YES' if check(bin(x)[2:], bin(y)[2:]) or check(bin(x)[2:][::-1], bin(y)[2:]) else 'NO')\nelse:\n    a = check(bin(x)[2:] + '1', bin(y)[2:]) or check((bin(x)[2:] + '1')[::-1], bin(y)[2:])\n    xb = bin(x)[2:]\n    while xb[-1] == '0':\n        xb = xb[:-1]\n    b = check(xb, bin(y)[2:]) or check(xb[::-1], bin(y)[2:])\n    print('YES' if a or b else 'NO')", "def check(first, second):\n    idx = second.find(first)\n    if idx == -1:\n        return False\n    return '0' not in second[:idx] and '0' not in second[idx + len(first):]\n\ndef solve(x, y):\n    if x == y:\n        return True\n    x_bin = bin(x)[2:]\n    y_bin = bin(y)[2:]\n    first = '1' + x_bin[::-1]\n    second = x_bin[:x_bin.rfind('1') + 1]\n    return any((check(s, y_bin) for s in [first, first[::-1], second, second[::-1]]))\n(x, y) = map(int, input().split())\nprint('YES' if solve(x, y) else 'NO')", "def check_candidate(y, candidate):\n    if candidate in y:\n        a = set(list(y.replace(candidate, '', 1)))\n        if len(a) == 1 and '1' in a:\n            return True\n    return False\n\ndef slv(x, y):\n    if x == y:\n        return 'YES'\n    candidates = set()\n    candidates.add(x + '1')\n    candidates.add(x.rstrip('0'))\n    if y in candidates or y[::-1] in candidates:\n        return 'YES'\n    for candidate in candidates:\n        if check_candidate(y, candidate):\n            return 'YES'\n        if check_candidate(y, candidate[::-1]):\n            return 'YES'\n    return 'NO'\n(x, y) = [int(_) for _ in input().rstrip().split(' ')]\ny = bin(y)[2:]\nx = bin(x)[2:]\nprint(slv(x, y))", "(a, b) = list(map(int, input().strip().split()))\na_str = '{0:b}'.format(a)\nb_str = '{0:b}'.format(b)\na_str_1 = a_str + '1'\na_str_rev = a_str[::-1].strip('0')\na_str_rev_1 = a_str_1[::-1].strip('0')\na_strs = [a_str.strip('0'), a_str_1, a_str_rev, a_str_rev_1]\nans = a_str == b_str\nfor string in a_strs:\n    pos = b_str.find(string)\n    if pos == -1:\n        continue\n    b = b_str[:pos] + b_str[pos + len(string):]\n    if b == '1' * len(b):\n        ans = True\n        break\nprint('YES' if ans else 'NO')", "(x, y) = [str(bin(int(i)))[2:] for i in input().split()]\nif x == y:\n    print('YES')\nelif y[-1] == '0':\n    print('NO')\nelse:\n    x += '1'\n    if (y.find(x) != -1 or y.find(x[::-1]) != -1) and y.count('1') - x.count('1') == len(y) - len(x):\n        print('YES')\n    else:\n        x = x[:-1]\n        while x[-1] == '0':\n            x = x[:-1]\n        print('YES') if (y.find(x) != -1 or y.find(x[::-1]) != -1) and y.count('1') - x.count('1') == len(y) - len(x) else print('NO')", "import sys\nv = set()\n\ndef bfs(n):\n    if n in v:\n        return\n    v.add(n)\n    if len(n) == len(bb):\n        if n == bb:\n            print('YES')\n            sys.exit(0)\n        elif n[0] == '1' and n[-1] == '1':\n            bfs(n[::-1])\n            return\n    elif len(n) > len(bb):\n        if n[0] == '1' and n[-1] == '1':\n            return\n    (p1, p2) = (n + '1', n + '0')\n    bfs(p1[::-1])\n    bfs(p2[::-1].lstrip('0'))\n(a, b) = map(int, input().split())\nif a == b:\n    print('YES')\nelse:\n    ba = bin(a)[2:]\n    bb = bin(b)[2:]\n    bfs(ba)\n    print('NO')", "import math\n(x, y) = map(int, input().split())\nbin_x = bin(x)[2:]\nbin_y = bin(y)[2:]\nlst = [bin_x + '1', bin_x.strip('0')]\nflag = False\nnxt = False\nif bin_x == bin_y:\n    print('YES')\n    nxt = True\nif not nxt:\n    for q in lst:\n        div = len(bin_y) - len(q) + 1\n        for j in range(div):\n            if '1' * j + q + '1' * (div - j - 1) == bin_y or '1' * j + q[::-1] + '1' * (div - j - 1) == bin_y:\n                print('YES')\n                flag = True\n                break\n        if flag:\n            break\n    if not flag:\n        print('NO')", "(a, b) = map(int, input().split())\na = str(bin(a)[2:])\nb = str(bin(b)[2:])\nif b[-1] == '0' and a != b:\n    print('NO')\n    exit()\nelif a == b:\n    print('YES')\n    exit()\nx1 = ''\nflag = False\nfor el in a[::-1]:\n    if el == '1':\n        flag = True\n        x1 += el\n    if el == '0':\n        if flag:\n            x1 += el\nx2 = '1' + a[::-1]\nif x1 in b:\n    y1 = b[:b.find(x1)] + b[b.find(x1) + len(x1):]\n    if y1.count('0') == 0:\n        print('YES')\n        exit()\nx1 = x1[::-1]\nif x1 in b:\n    y1 = b[:b.find(x1)] + b[b.find(x1) + len(x1):]\n    if y1.count('0') == 0:\n        print('YES')\n        exit()\nx1 = x2\nif x1 in b:\n    y1 = b[:b.find(x1)] + b[b.find(x1) + len(x1):]\n    if y1.count('0') == 0:\n        print('YES')\n        exit()\nx1 = x1[::-1]\nif x1 in b:\n    y1 = b[:b.find(x1)] + b[b.find(x1) + len(x1):]\n    if y1.count('0') == 0:\n        print('YES')\n        exit()\nprint('NO')", "def check(s, t):\n    idx = t.find(s)\n    if idx != -1:\n        lft = t[:idx]\n        rght = t[idx + len(s):]\n        if lft.count('0') + rght.count('0') == 0:\n            return True\n        else:\n            return False\n    else:\n        return False\n(n, m) = map(int, input().split())\nsn = bin(n)[2:]\nsm = bin(m)[2:]\nif sn == sm:\n    print('YES')\n    exit()\nif sn[-1] != '0':\n    sn_d = sn\n    if check(sn_d, sm):\n        print('YES')\n        exit()\n    sn_d = sn[::-1]\n    if check(sn_d, sm):\n        print('YES')\n        exit()\nsn_d = sn + '1'\nif check(sn_d, sm):\n    print('YES')\n    exit()\nsn_d = '1' + sn[::-1]\nif check(sn_d, sm):\n    print('YES')\n    exit()\nsn_d = sn.rstrip('0')\nif check(sn_d, sm):\n    print('YES')\n    exit()\nsn_d = sn.rstrip('0')[::-1]\nif check(sn_d, sm):\n    print('YES')\n    exit()\nprint('NO')", "import sys as system_break\n\ndef Commonfinder(n, m):\n    if type(n) != set:\n        n = {n}\n    if type(m) != set:\n        m = {m}\n    Common_in_both = n | m\n    return Common_in_both\nimport math as m\nimport re as MATCHING_DEVICE\nInput = input()\nInput = Input.split()\nablist = []\nfor i in range(len(Input)):\n    ablist.append(int(Input[i]))\na = ablist[0]\nb = ablist[1]\nBinofa = bin(a)[2:]\nBinofb = bin(b)[2:]\nExtended_A = Binofa + '1'\nStriped_A = Binofa.rstrip('0')\nFirstCF = Commonfinder(Extended_A, Striped_A)\nSecondCF = Commonfinder(FirstCF, Extended_A[::-1])\nFinalCF = Commonfinder(SecondCF, Striped_A[::-1])\nFormated_Str = f'1*({Extended_A}|{Striped_A}|{Extended_A[::-1]}|{Striped_A[::-1]})1*'\nif len(FinalCF) == 1:\n    FinalCF = list(FinalCF)\n    FinalCF = FinalCF[0]\n    if MATCHING_DEVICE.fullmatch(FinalCF, Binofb) or Binofa == Binofb:\n        print('YES')\nelse:\n    answer = ''\n    if a == b or MATCHING_DEVICE.fullmatch(Formated_Str, Binofb):\n        print('YES')\n    else:\n        print('NO')", "import collections\n\ndef solve():\n\n    def add_one(val):\n        bs = bin(val)[2:] + '1'\n        bs = bs[::-1]\n        return int(bs, 2)\n\n    def add_zero(val):\n        bs = bin(val)[2:] + '0'\n        bs = bs[::-1]\n        return int(bs, 2)\n    (a, b) = list(map(int, input().split()))\n    deq = collections.deque()\n    deq.append(a)\n    ss = set()\n    ss.add(a)\n    while deq:\n        a = deq.popleft()\n        if a == b:\n            print('YES')\n            return\n        if a & 1:\n            na = add_zero(a)\n            if na <= b and na not in ss:\n                ss.add(na)\n                deq.append(na)\n            na = add_one(a)\n            if (na <= b or add_zero(na) <= b) and na not in ss:\n                ss.add(na)\n                deq.append(na)\n        else:\n            na = add_zero(a)\n            if na not in ss:\n                ss.add(na)\n                deq.append(na)\n            na = add_one(a)\n            if (na <= b or add_zero(na) <= b) and na not in ss:\n                ss.add(na)\n                deq.append(na)\n    print('NO')\nsolve()", "from collections import deque\n\ndef gs():\n    return input()\n\ndef gi():\n    return int(input())\n\ndef gl():\n    return list(map(int, input().split()))\n\ndef gt():\n    return map(int, input().split())\n(x, y) = gt()\nqueue = deque([bin(x)[2:]])\nvisited = set([x])\npossible = False\nwhile queue:\n    cur = queue.popleft()\n    if int(cur, 2) == y:\n        possible = True\n        break\n    if len(cur) > 60:\n        continue\n    one = cur[:] + '1'\n    onebit = int(one[::-1], 2)\n    if onebit not in visited:\n        queue.append(bin(onebit)[2:])\n        visited.add(onebit)\n    zero = cur[:] + '0'\n    zerobit = int(zero[::-1], 2)\n    if zerobit not in visited:\n        queue.append(bin(zerobit)[2:])\n        visited.add(zerobit)\nif possible:\n    print('YES')\nelse:\n    print('NO')", "def sol(t, s):\n    pos = t.find(s)\n    while pos != -1:\n        x = t[:pos]\n        y = t[pos + len(s):]\n        if '0' not in x and '0' not in y:\n            return True\n        pos = t.find(s, pos + 1)\n    return False\n\ndef solve():\n    [x, y] = [int(a) for a in input().split()]\n    if x == y:\n        print('YES')\n        return\n    s = list(bin(x)[2:])\n    t = bin(y)[2:]\n    s1 = list(bin(x)[2:])\n    while s1[-1] == '0':\n        s1.pop()\n    s2 = None\n    if s[-1] == '0':\n        s2 = s\n        s2.append('1')\n    if sol(t, ''.join(s1)):\n        print('YES')\n        return\n    if s2 is not None and sol(t, ''.join(s2)):\n        print('YES')\n        return\n    s3 = [x for x in s1]\n    s3.reverse()\n    if s2 is not None:\n        s4 = [x for x in s2]\n    else:\n        s4 = None\n    if sol(t, ''.join(s3)):\n        print('YES')\n        return\n    if s4 is not None:\n        s4.reverse()\n    if s4 is not None and sol(t, ''.join(s4)):\n        print('YES')\n        return\n    print('NO')\nsolve()", "import re\n\ndef do(x, y):\n    match = re.search(f'^1*{x}1*$', y)\n    if match:\n        return True\n    else:\n        return False\n(x, y) = map(int, input().split())\nx1 = bin(x)[2:]\nx2 = x1[::-1]\ni = 0\nwhile x2[i] == '0':\n    i = i + 1\nx3 = x2[i:]\nx4 = x3[::-1]\nif x1[-1] == '0':\n    x1 += '1'\ny = bin(y)[2:]\nif do(x1, y) or do(x2, y) or do(x3, y) or do(x4, y) or (bin(x)[2:] == y):\n    print('YES')\nelse:\n    print('NO')", "import re\n\ndef do(x, y):\n    match = re.search(f'^1*{x}1*$', y)\n    if match:\n        return True\n    else:\n        return False\n(x, y) = map(int, input().split())\nx1 = bin(x)[2:]\nx2 = x1[::-1]\ni = 0\nwhile x2[i] == '0':\n    i = i + 1\nx3 = x2[i:]\nx4 = x3[::-1]\nif x1[-1] == '0':\n    x1 += '1'\ny = bin(y)[2:]\nif do(x1, y) or do(x2, y) or do(x3, y) or do(x4, y) or (bin(x)[2:] == y):\n    print('YES')\nelse:\n    print('NO')", "import re\nfrom collections import deque\n(x, y) = map(int, input().split())\nbin_x = bin(x)[2:]\nbin_y = bin(y)[2:]\nvisited = {}\nq = deque([bin_x])\nwhile len(q):\n    new = q.popleft()\n    if new in visited or len(new.strip('0')) > len(bin_y):\n        continue\n    elif new == bin_y:\n        print('YES')\n        quit()\n    visited[new] = True\n    q.append(new[::-1].strip('0'))\n    q.append(('1' + new[::-1]).strip('0'))\nprint('NO')", "import re\n(a, b) = [int(i) for i in input().split()]\n\ndef binSlice(x):\n    return bin(x)[2:]\n\ndef removeLeadingZeros(s):\n    for k in range(len(s)):\n        if s[k] != '0':\n            break\n    return s[k:]\n\ndef reversed(s):\n    return s[::-1]\ntemp = reversed(binSlice(a))\ntemp2 = removeLeadingZeros(temp)\ncheck = re.fullmatch(f'1*(1{temp}|{temp2}|{reversed(temp)}1|{reversed(temp2)})1*', binSlice(b)) is not None\nprint('YES' if check or a == b else 'NO')", "from collections import deque\n(x, y) = map(int, input().split())\nbin_x = bin(x)[2:]\nbin_y = bin(y)[2:]\nvisited = {}\nq = deque([bin_x])\nwhile len(q):\n    new = q.popleft()\n    if new in visited or len(new.strip('0')) > len(bin_y):\n        continue\n    elif new == bin_y:\n        print('YES')\n        quit()\n    visited[new] = True\n    q.append(new[::-1].strip('0'))\n    q.append(('1' + new[::-1]).strip('0'))\nprint('NO')", "import math\n(x, y) = [bin(int(XXX))[2:] for XXX in input().split(' ')]\nif x == y:\n    print('YES')\n    quit()\nA = (x + '1')[::-1]\nB = str(int(x[::-1]))\nif A in y:\n    left = y.find(A)\n    right = left + len(A) - 1\n    if left != -1:\n        if not '0' in y[0:left] and (not '0' in y[right + 1:]):\n            print('YES')\n            quit()\nA = A[::-1]\nif A in y:\n    left = y.find(A)\n    right = left + len(A) - 1\n    if left != -1:\n        if not '0' in y[0:left] and (not '0' in y[right + 1:]):\n            print('YES')\n            quit()\nif B in y:\n    left = y.find(B)\n    right = left + len(B) - 1\n    if left != -1:\n        if not '0' in y[0:left] and (not '0' in y[right + 1:]):\n            print('YES')\n            quit()\nB = B[::-1]\nif B in y:\n    left = y.find(B)\n    right = left + len(B) - 1\n    if left != -1:\n        if not '0' in y[0:left] and (not '0' in y[right + 1:]):\n            print('YES')\n            quit()\nprint('NO')", "from math import log2\n(x, y) = map(lambda p: bin(int(p))[2:], input().split())\n(rx, rx2, rx3) = (bin(int(x[::-1], 2))[2:], '1' + x[::-1], bin(int(x, 2) >> int(log2(int(x, 2) & -int(x, 2))))[2:])\nif y in [x, rx, rx2, rx3]:\n    print('YES')\n    exit(0)\n(f1, f2, f3, f4) = (y.find(x), y.find(rx), y.find(rx2), y.find(rx3))\nif f1 != -1:\n    (l, r) = (f1, f1 + len(x))\n    if set(y[:l] or ['1']) == set(y[r:] or x[-1]) == set(['1']):\n        print('YES')\n        exit(0)\nif f2 != -1:\n    (l, r) = (f2, f2 + len(rx))\n    if set(y[:l] or ['1']) == set(y[r:] or y[-1]) == set(['1']):\n        print('YES')\n        exit(0)\nif f3 != -1:\n    (l, r) = (f3, f3 + len(rx2))\n    if set(y[:l] or ['1']) == set(y[r:] or y[-1]) == set(['1']):\n        print('YES')\n        exit(0)\nif f4 != -1:\n    (l, r) = (f4, f4 + len(rx3))\n    if set(y[:l] or ['1']) == set(y[r:] or y[-1]) == set(['1']):\n        print('YES')\n        exit(0)\nprint('NO')", "from math import log2\n(x, y) = map(lambda p: bin(int(p))[2:], input().split())\n(rx, rx2, rx3) = (bin(int(x[::-1], 2))[2:], '1' + x[::-1], bin(int(x, 2) >> int(log2(int(x, 2) & -int(x, 2))))[2:])\nif y in [x, rx, rx2, rx3]:\n    print('YES')\n    exit(0)\n(f1, f2, f3, f4) = (y.find(x), y.find(rx), y.find(rx2), y.find(rx3))\nx = [x, rx, rx2, rx3]\nf = [f1, f2, f3, f4]\nfor i in range(4):\n    (ff, xx) = (f[i], x[i])\n    if ff != -1:\n        (l, r) = (ff, ff + len(xx))\n        if set(y[:l] or ['1']) == set(y[r:] or y[-1]) == set(['1']):\n            print('YES')\n            exit(0)\nprint('NO')", "import io, os\n\ndef main(t):\n    (x, y) = [int(i) for i in input().split()]\n    if x == y:\n        print('YES')\n        return\n    if y % 2 == 0:\n        print('NO')\n        return\n    x = bin(x)[2:]\n    xx = x\n    y = bin(y)[2:]\n    while x[-1] == '0':\n        x = x[:-1]\n    x = x[::-1]\n    now = 0\n    while len(y) - now >= len(xx):\n        if xx == y[now:now + len(xx)]:\n            if not '0' in y[now + len(xx):]:\n                print('YES')\n                return\n        if xx[::-1] == y[now:now + len(xx)]:\n            if not '0' in y[now + len(xx):]:\n                print('YES')\n                return\n        if y[now] == '0':\n            break\n        now += 1\n    now = 0\n    while len(y) - now >= len(x):\n        if x == y[now:now + len(x)]:\n            if not '0' in y[now + len(x):]:\n                print('YES')\n                return\n        if x[::-1] == y[now:now + len(x)]:\n            if not '0' in y[now + len(x):]:\n                print('YES')\n                return\n        if y[now] == '0':\n            break\n        now += 1\n    print('NO')\nT = 1\nt = 1\nwhile t <= T:\n    main(t)\n    t += 1", "(x, y) = map(int, input().split(' '))\nans = 'NO'\nif x == y:\n    ans = 'YES'\n(bin_x, bin_y) = (str(bin(x))[2:], str(bin(y))[2:])\ntry:\n    i1 = bin_y.index(bin_x + '1')\n    re = set(bin_y[:i1] + bin_y[i1 + len(bin_x) + 1:])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\ntry:\n    i2 = bin_y.index((bin_x + '1')[::-1])\n    re = set(bin_y[:i2] + bin_y[i2 + len(bin_x) + 1:])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\nbin_x = bin_x.strip('0')\ntry:\n    i3 = bin_y.index(bin_x)\n    re = set(bin_y[:i3] + bin_y[i3 + len(bin_x):])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\ntry:\n    i4 = bin_y.index(bin_x[::-1])\n    re = set(bin_y[:i4] + bin_y[i4 + len(bin_x):])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\nprint(ans)", "(x, y) = [int(i) for i in input().split(' ')]\nans = 'NO'\nif x == y:\n    print('YES')\n    exit(0)\n(bin_x, bin_y) = (str(bin(x))[2:], str(bin(y))[2:])\ntry:\n    i1 = bin_y.index(bin_x + '1')\n    re = set(bin_y[:i1] + bin_y[i1 + len(bin_x) + 1:])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\ntry:\n    i2 = bin_y.index((bin_x + '1')[::-1])\n    re = set(bin_y[:i2] + bin_y[i2 + len(bin_x) + 1:])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\nbin_x = bin_x.strip('0')\ntry:\n    i3 = bin_y.index(bin_x)\n    re = set(bin_y[:i3] + bin_y[i3 + len(bin_x):])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\ntry:\n    i4 = bin_y.index(bin_x[::-1])\n    re = set(bin_y[:i4] + bin_y[i4 + len(bin_x):])\n    if len(re) == 0 or (len(re) == 1 and '1' in re):\n        ans = 'YES'\nexcept:\n    pass\nprint(ans)", "def prov(z, x):\n    l = len(x)\n    m = len(z)\n    e = 0\n    for i in range(l - m + 1):\n        if z == x[i:m + i]:\n            e = 1\n            x = x[:i] + x[m + i:]\n            break\n    if e == 1:\n        for i in x:\n            if i == '0':\n                e = -1\n                break\n    return e\na = []\n(x, y) = map(int, input().split())\nz = str(bin(x))[2:]\nzz = z + '1'\nwhile z[-1] == '0':\n    z = z[:-1]\na.append(z)\na.append(zz)\na.append(zz[::-1])\na.append(z[::-1])\nv = str(bin(y))[2:]\nt = 0\nfor i in a:\n    if prov(i, v) == 1:\n        t = 1\n        break\nif x == y:\n    print('YES')\nelif t == 1:\n    print('YES')\nelse:\n    print('NO')", "(x, y) = map(int, input().split())\ns = set()\ns.add(x)\na = [x]\nfor u in a:\n    if u > 10 ** 20:\n        continue\n    k = 2 * u + 0\n    b = bin(k)[2:][::-1]\n    v = int(b, 2)\n    if v not in s:\n        s.add(v)\n        a.append(v)\n    k = 2 * u + 1\n    b = bin(k)[2:][::-1]\n    v = int(b, 2)\n    if v not in s:\n        s.add(v)\n        a.append(v)\nprint('YES' if y in s else 'NO')", "(x, y) = map(int, input().split())\ns = bin(y)[2:]\nt = bin(x)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "L = input().split(' ')\ns1 = str(bin(int(L[0])))[2:]\ns2 = str(bin(int(L[1])))[2:]\nn1 = 0\nn2 = 0\nfor i in range(len(s1)):\n    if s1[i] == '0':\n        n1 += 1\nfor i in range(len(s2)):\n    if s2[i] == '0':\n        n2 += 1\nif s1 == s2:\n    print('YES')\nelse:\n    if s1[-1] == '0':\n        if n1 == n2:\n            s1 += '1'\n        else:\n            while s1[-1] == '0':\n                n1 -= 1\n                s1 = s1[:-1]\n    if n1 != n2:\n        print('NO')\n    elif s2.find(s1) != -1 or s2.find(s1[::-1]) != -1:\n        print('YES')\n    else:\n        print('NO')", "from collections import deque\n(x, y) = map(int, input().split())\nbin_x = bin(x)[2:]\nbin_y = bin(y)[2:]\nvisited = {}\nq = deque([bin_x])\nwhile len(q):\n    new = q.popleft()\n    if new in visited or len(new.strip('0')) > len(bin_y):\n        continue\n    elif new == bin_y:\n        print('YES')\n        quit()\n    visited[new] = True\n    q.append(new[::-1].strip('0'))\n    q.append(('1' + new[::-1]).strip('0'))\nprint('NO')", "(x, y) = map(int, input().split())\n(x_bin, y_bin) = (bin(x)[2:], bin(y)[2:])\nif x_bin == y_bin:\n    print('YES')\nelif y_bin[-1] == '0':\n    print('NO')\nelse:\n    x_bin += '1'\n    if (y_bin.find(x_bin) != -1 or y_bin.find(x_bin[::-1]) != -1) and y_bin.count('1') - x_bin.count('1') == len(y_bin) - len(x_bin):\n        print('YES')\n    else:\n        x_bin = x_bin[:-1]\n        while x_bin[-1] == '0':\n            x_bin = x_bin[:-1]\n        print('YES') if (y_bin.find(x_bin) != -1 or y_bin.find(x_bin[::-1]) != -1) and y_bin.count('1') - x_bin.count('1') == len(y_bin) - len(x_bin) else print('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(x, y) = map(int, input().split())\nx = str(bin(x))[2:]\ny = str(bin(y))[2:]\n(x1, x2) = (x.rstrip('0'), x + '1')\nif x == y or __import__('re').fullmatch(f'1*({x1}|{x2}|{x1[::-1]}|{x2[::-1]})1*', y):\n    print('YES')\nelse:\n    print('NO')", "(a, b) = [int(i) for i in input().split(' ')]\na = bin(a)[2:]\nb = bin(b)[2:]\ngood = lambda a, b: b.replace(a, '', 1) == (len(b) - len(a)) * '1'\ncheck = a == b\ncheck = check or good(a + '1', b)\ncheck = check or good((a + '1')[::-1], b)\nwhile a[-1] == '0':\n    a = a[:-1]\ncheck = check or good(a, b)\ncheck = check or good(a[::-1], b)\nif check:\n    print('YES')\nelse:\n    print('NO')", "(x, y) = map(int, input().split())\nnum1 = bin(x)[2:]\nnum2 = bin(y)[2:]\nif num2 == num1:\n    print('YES')\nelse:\n    ans = ''\n    for num in (num1 + '1', str(int(num1[::-1]))[::-1]):\n        for i in range(len(num2) - len(num) + 1):\n            j = len(num2) - len(num) - i\n            if '1' * i + num + '1' * j == num2 or '1' * i + num[::-1] + '1' * j == num2:\n                ans = 'YES'\n    if ans:\n        print(ans)\n    else:\n        print('NO')", "(a, b) = map(int, input().split())\ns = bin(b)[2:]\nt = bin(a)[2:]\nif s == t:\n    print('YES')\n    exit(0)\nfor q in [t + '1', t.strip('0')]:\n    for l in range(len(s) - len(q) + 1):\n        r = len(s) - len(q) - l\n        if '1' * l + q + '1' * r == s or '1' * l + q[::-1] + '1' * r == s:\n            print('YES')\n            exit(0)\nprint('NO')", "(a, b) = map(lambda s: bin(int(s))[2:], input().split())\n(a0, a1) = (a + '1', a.rstrip('0'))\nif a == b or __import__('re').fullmatch(f'1*({a0}|{a1}|{a0[::-1]}|{a1[::-1]})1*', b):\n    print('YES')\nelse:\n    print('NO')", "import re\n(a, b) = [int(i) for i in input().split()]\n\ndef binSlice(x):\n    return bin(x)[2:]\n\ndef removeLeadingZeros(s):\n    for k in range(len(s)):\n        if s[k] != '0':\n            break\n    return s[k:]\n\ndef reversed(s):\n    return s[::-1]\ntemp = reversed(binSlice(a))\ntemp2 = removeLeadingZeros(temp)\ncheck = re.fullmatch(f'1*(1{temp}|{temp2}|{reversed(temp)}1|{reversed(temp2)})1*', binSlice(b)) is not None\nprint('YES' if check or a == b else 'NO')", "(a, b) = map(lambda s: bin(int(s))[2:], input().split())\n(a0, a1) = (a + '1', a.rstrip('0'))\nif a == b or __import__('re').fullmatch(f'1*({a0}|{a1}|{a0[::-1]}|{a1[::-1]})1*', b):\n    print('YES')\nelse:\n    print('NO')", "(a, b) = map(lambda s: bin(int(s))[2:], input().split())\n(a0, a1) = (a + '1', a.rstrip('0'))\nif a == b or __import__('re').fullmatch(f'1*({a0}|{a1}|{a0[::-1]}|{a1[::-1]})1*', b):\n    print('YES')\nelse:\n    print('NO')", "import itertools\nimport functools\n\ndef op0(x):\n    return int(bin(x)[2:][::-1], 2)\n\ndef op1(x):\n    return int('1' + bin(x)[2:][::-1], 2)\n\ndef solve(x, y, x_nums):\n    if x == y:\n        return True\n    if x > 1e+20:\n        return False\n    if x in x_nums:\n        return False\n    x_nums.add(x)\n    return solve(op0(x), y, x_nums) or solve(op1(x), y, x_nums)\n\ndef main():\n    (x, y) = map(int, input().split())\n    if solve(x, y, set()):\n        print('YES')\n    else:\n        print('NO')\nmain()", "import heapq\nimport sys\nimport math\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\nI = sys.stdin.readline\nII = lambda : int(I())\nIN = lambda x: map(int, x.split())\nFN = lambda x: map(float, x.split())\nL = lambda x: list(IN(x))\nM = 1000000007\nP = print\nT = True\nF = False\n\ndef cal(x, y):\n    while x & 1 == 1 and y & 1 == 1:\n        x = x >> 1\n        y = y >> 1\n    if x & 1 == 1:\n        return False\n    while y & 1 == 1:\n        y = y >> 1\n    while x > 0 and y > 0 and (x & 1 == y & 1):\n        x = x >> 1\n        y = y >> 1\n    if x > 0 or (y > 0 and y & y + 1 != 0):\n        return False\n    return True\n\ndef rev(x):\n    return int(bin(x)[:1:-1], 2)\nfor _ in range(1):\n    (x, y) = IN(I())\n    ye = 'YES'\n    n = 'NO'\n    if x == y:\n        print(ye)\n        break\n    if y & 1 == 0:\n        print(n)\n        break\n    t = x\n    while t & 1 == 0:\n        t = t >> 1\n    if t == x:\n        res = cal(t, y) or cal(rev(t), y)\n    else:\n        x = (x << 1) + 1\n        res = cal(t, y) or cal(x, y) or cal(rev(t), y) or cal(rev(x), y)\n    if res:\n        print(ye)\n    else:\n        print(n)", "import re\n\ndef do(x, y):\n    match = re.search(f'^1*{x}1*$', y)\n    if match:\n        return True\n    else:\n        return False\n(x, y) = map(int, input().split())\nx1 = bin(x)[2:]\nx2 = x1[::-1]\ni = 0\nwhile x2[i] == '0':\n    i = i + 1\nx3 = x2[i:]\nx4 = x3[::-1]\nif x1[-1] == '0':\n    x1 += '1'\ny = bin(y)[2:]\nif do(x1, y) or do(x2, y) or do(x3, y) or do(x4, y) or (bin(x)[2:] == y):\n    print('YES')\nelse:\n    print('NO')", "(a, b) = map(lambda s: bin(int(s))[2:], input().split())\n(a0, a1) = (a + '1', a.rstrip('0'))\nif a == b or __import__('re').fullmatch(f'1*({a0}|{a1}|{a0[::-1]}|{a1[::-1]})1*', b):\n    print('YES')\nelse:\n    print('NO')", "import sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\ndef input():\n    return sys.stdin.readline()[:-1]\nsys.setrecursionlimit(1000000)\nINF = 10 ** 10\nYES = 'YES'\nNO = 'NO'\n\ndef solve(X, Y):\n    if X == Y:\n        return 'YES'\n    SX = bin(X)[2:]\n    SY = bin(Y)[2:]\n    seen = set()\n    seen.add(SX)\n    q = []\n    q.append(SX)\n    while q:\n        s = q.pop()\n        for s1 in [str(int(s[::-1])), (s + '1')[::-1]]:\n            if s1 in seen or len(s1) > 100:\n                continue\n            if s1 == SY:\n                return 'YES'\n            seen.add(s1)\n            q.append(s1)\n    return 'NO'\n(X, Y) = map(int, input().split())\nprint(solve(X, Y))", "import sys\nimport typing\nfrom typing import Callable, Dict, List, Set, Tuple\nsys.setrecursionlimit(10 ** 6)\nVec = List[int]\nVecVec = List[Vec]\nsinput: Callable[..., str] = sys.stdin.readline\nMOD: int = 998244353\nINF: float = float('Inf')\nIINF: int = sys.maxsize // 2\n\ndef check(bx: str, by: str) -> bool:\n    s = by.find(bx)\n    if s != -1:\n        if '0' not in by[:s] and '0' not in by[s + len(bx):]:\n            return True\n    return False\n\ndef main() -> None:\n    (x, y) = map(int, sinput().split())\n    if x == y:\n        print('YES')\n        return\n    bx = bin(x)[2:]\n    by = bin(y)[2:]\n    if by[-1] == '0':\n        print('NO')\n        return\n    if check(bx, by) or check(bx[::-1], by):\n        print('YES')\n        print(1, file=sys.stderr)\n        return\n    if bx[-1] == '0':\n        print(bx, file=sys.stderr)\n        last_z = bx.rfind('1')\n        bx = bx[:last_z + 1]\n        if check(bx, by) or check(bx[::-1], by):\n            print(bx, bx[::-1], by, file=sys.stderr)\n            print('YES')\n            return\n    print('NO')\nmain()", "import sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\ndef input():\n    return sys.stdin.readline()[:-1]\nsys.setrecursionlimit(1000000)\nINF = 10 ** 10\nYES = 'YES'\nNO = 'NO'\n\ndef dfs(s, SY):\n    if s == SY:\n        return True\n    n = int(s)\n    if n in ng:\n        return False\n    if len(s) > 100:\n        return False\n    ng.add(n)\n    for s1 in [str(int(s[::-1])), (s + '1')[::-1]]:\n        if s1 in ng:\n            continue\n        if dfs(s1, SY):\n            return True\n    return False\nng = set()\n\ndef solve(X, Y):\n    if X == Y:\n        return 'YES'\n    SX = bin(X)[2:]\n    SY = bin(Y)[2:]\n    if dfs(SX, SY):\n        return 'YES'\n    return 'NO'\n(X, Y) = map(int, input().split())\nprint(solve(X, Y))", "import sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\ndef input():\n    return sys.stdin.readline()[:-1]\nsys.setrecursionlimit(1000000)\nINF = 10 ** 10\nYES = 'YES'\nNO = 'NO'\n\ndef dfs(s, SY):\n    if s == SY:\n        return True\n    n = int(s)\n    if n in ng:\n        return False\n    if len(s) > 100:\n        return False\n    ng.add(n)\n    for s1 in [str(int(s[::-1])), (s + '1')[::-1]]:\n        if s1 in ng:\n            continue\n        if dfs(s1, SY):\n            return True\n    return False\nng = set()\n\ndef solve(X, Y):\n    if X == Y:\n        return 'YES'\n    SX = bin(X)[2:]\n    SY = bin(Y)[2:]\n    if dfs(SX, SY):\n        return 'YES'\n    return 'NO'\n(X, Y) = map(int, input().split())\nprint(solve(X, Y))", "from collections import deque\n(x, y) = map(int, input().split())\nx = bin(x)\nx = x[2:]\ny = bin(y)\ny = y[2:]\nused = set()\nqueue = deque()\nqueue.append(x)\nalarm = False\nwhile len(queue) > 0:\n    temp = queue.popleft()\n    used.add(temp)\n    if temp == y:\n        alarm = True\n        break\n    n1 = str(int(temp[::-1]))\n    n2 = temp + '1'\n    n2 = str(int(n2))\n    if n1 not in used and len(n1) <= len(y):\n        queue.append(n1)\n    if n2 not in used and len(n2) <= len(y):\n        queue.append(n2)\nif alarm:\n    print('YES')\nelse:\n    print('NO')", "(x, y) = map(int, input().split())\nused = set()\ns = [x]\nf = False\nfor _ in range(10000):\n    if len(s) == 0:\n        break\n    a = s[0]\n    del s[0]\n    if a == y:\n        f = True\n        break\n    b = bin(a).lstrip('0b')\n    y1 = int('0b' + (b + '0')[::-1], 2)\n    y2 = int('0b' + (b + '1')[::-1], 2)\n    if y1 == y or y2 == y:\n        f = True\n        break\n    if y1 not in used:\n        used.add(y1)\n        s.append(y1)\n    if y2 not in used:\n        used.add(y2)\n        s.append(y2)\nif f:\n    print('YES')\nelse:\n    print('NO')"]