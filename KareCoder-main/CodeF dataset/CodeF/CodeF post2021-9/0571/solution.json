["import sys, heapq\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [[] for i in range(n)]\n    h = []\n    l = []\n    for i in range(n):\n        y = [int(i) for i in sys.stdin.readline().split()]\n        l.append(y[0])\n        if y[0] == 0:\n            heapq.heappush(h, i)\n        for j in range(1, y[0] + 1):\n            d[y[j] - 1].append(i)\n    c = t = 0\n    while h:\n        i = heapq.heappop(h)\n        t += 1\n        c = i // n\n        i = i % n\n        for j in d[i]:\n            l[j] -= 1\n            if l[j] == 0:\n                heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n    sys.stdout.write('%d\\n' % (c + 1 if t == n else -1))", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    arr = [list(map(int, input().split())) for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    incoming = [0] * n\n    vals = [1] * n\n    for i in range(n):\n        for j in range(1, len(arr[i])):\n            incoming[i] += 1\n            graph[arr[i][j] - 1].append(i)\n    q = []\n    ordering = []\n    for i in range(n):\n        if incoming[i] == 0:\n            q.append(i)\n    while q:\n        node = q.pop()\n        ordering.append(node)\n        for nei in graph[node]:\n            incoming[nei] -= 1\n            vals[nei] = max(vals[nei], vals[node] + 1 if nei < node else vals[node])\n            if incoming[nei] == 0:\n                q.append(nei)\n    return -1 if len(ordering) < n else max(vals)\nfor _ in range(int(input())):\n    print(solve())", "import sys, heapq\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [[] for i in range(n)]\n    h = []\n    l = []\n    for i in range(n):\n        y = [int(i) for i in sys.stdin.readline().split()]\n        l.append(y[0])\n        if y[0] == 0:\n            heapq.heappush(h, i)\n        for j in range(1, y[0] + 1):\n            d[y[j] - 1].append(i)\n    c = t = 0\n    while h:\n        i = heapq.heappop(h)\n        t += 1\n        c = i // n\n        i = i % n\n        for j in d[i]:\n            l[j] -= 1\n            if l[j] == 0:\n                heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n    sys.stdout.write('%d\\n' % (c + 1 if t == n else -1))", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = [[] for i in range(n + 1)]\n    d = [0 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        l = list(map(int, input().split()))\n        d[i] = l[0]\n        for j in l[1:]:\n            b[j].append(i)\n    count = 0\n    cursum = sum(d)\n    if cursum == 0:\n        print(1)\n    else:\n        possible = True\n        canread = []\n        for i in range(1, n + 1):\n            if d[i] == 0:\n                heappush(canread, i)\n        while True:\n            if len(canread) == 0:\n                break\n            count += 1\n            nextread = []\n            while len(canread) > 0:\n                x = heappop(canread)\n                for c in b[x]:\n                    d[c] -= 1\n                    if d[c] == 0:\n                        if c > x:\n                            heappush(canread, c)\n                        else:\n                            heappush(nextread, c)\n            canread = nextread\n        print(count if sum(d) == 0 else -1)", "from collections import deque\nimport heapq\n\ndef inp():\n    n = int(input())\n    reqs = [0 for _ in range(n + 1)]\n    affects = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        temp = list(map(int, input().split()))\n        if temp[0] == 0:\n            continue\n        reqs[i] = temp[0]\n        for chapter in temp[1:]:\n            affects[chapter].append(i)\n    return (reqs, affects, n)\n\ndef solve(reqs, affects, n):\n    to_read = [i for i in range(1, n + 1) if not reqs[i]]\n    heapq.heapify(to_read)\n    chapters_read = 0\n    count = 0\n    cur = 0\n    while to_read:\n        next_read = []\n        while to_read:\n            next_chapter = heapq.heappop(to_read)\n            reqs[next_chapter] = -1\n            chapters_read += 1\n            for affected in affects[next_chapter]:\n                reqs[affected] -= 1\n                if not reqs[affected] and affected > next_chapter:\n                    heapq.heappush(to_read, affected)\n                elif not reqs[affected]:\n                    next_read.append(affected)\n        count += 1\n        to_read = next_read\n        heapq.heapify(to_read)\n    if chapters_read == n:\n        return count\n    else:\n        return -1\nt = int(input())\nfor _ in range(t):\n    (reqs, affects, n) = inp()\n    ans = solve(reqs, affects, n)\n    print(ans)", "import sys, heapq\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [[] for i in range(n)]\n    h = []\n    l = []\n    for i in range(n):\n        y = [int(i) for i in sys.stdin.readline().split()]\n        l.append(y[0])\n        if y[0] == 0:\n            heapq.heappush(h, i)\n        for j in range(1, y[0] + 1):\n            d[y[j] - 1].append(i)\n    c = t = 0\n    while h:\n        i = heapq.heappop(h)\n        t += 1\n        c = i // n\n        i = i % n\n        for j in d[i]:\n            l[j] -= 1\n            if l[j] == 0:\n                heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n    sys.stdout.write('%d\\n' % (c + 1 if t == n else -1))", "import sys, heapq\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [[] for i in range(n)]\n    h = []\n    l = []\n    for i in range(n):\n        y = [int(i) for i in sys.stdin.readline().split()]\n        l.append(y[0])\n        if y[0] == 0:\n            heapq.heappush(h, i)\n        for j in range(1, y[0] + 1):\n            d[y[j] - 1].append(i)\n    c = t = 0\n    while h:\n        i = heapq.heappop(h)\n        t += 1\n        c = i // n\n        i = i % n\n        for j in d[i]:\n            l[j] -= 1\n            if l[j] == 0:\n                heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n    sys.stdout.write('%d\\n' % (c + 1 if t == n else -1))", "import sys, heapq\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [[] for i in range(n)]\n    h = []\n    l = []\n    for i in range(n):\n        y = [int(i) for i in sys.stdin.readline().split()]\n        l.append(y[0])\n        if y[0] == 0:\n            heapq.heappush(h, i)\n        for j in range(1, y[0] + 1):\n            d[y[j] - 1].append(i)\n    c = t = 0\n    while h:\n        i = heapq.heappop(h)\n        t += 1\n        c = i // n\n        i = i % n\n        for j in d[i]:\n            l[j] -= 1\n            if l[j] == 0:\n                heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n    sys.stdout.write('%d\\n' % (c + 1 if t == n else -1))", "import sys, heapq\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    d = [[] for i in range(n)]\n    h = []\n    l = []\n    for i in range(n):\n        y = [int(i) for i in sys.stdin.readline().split()]\n        l.append(y[0])\n        if y[0] == 0:\n            heapq.heappush(h, i)\n        for j in range(1, y[0] + 1):\n            d[y[j] - 1].append(i)\n    c = t = 0\n    while h:\n        i = heapq.heappop(h)\n        t += 1\n        c = i // n\n        i = i % n\n        for j in d[i]:\n            l[j] -= 1\n            if l[j] == 0:\n                heapq.heappush(h, j + c * n if j > i else j + n + c * n)\n    sys.stdout.write('%d\\n' % (c + 1 if t == n else -1))", "def solve(_num=0):\n    n = int(input())\n    chapters = []\n    c___deps = [[] for _ in range(n)]\n    for i in range(n):\n        c = [int(x) - 1 for x in input().split()]\n        c.pop(0)\n        for neigh in c:\n            c___deps[neigh].append(i)\n        chapters.append(c)\n    stack = []\n    c___rnr = [0 for _ in range(n)]\n    c___ans = [-1 for _ in range(n)]\n    for (i, c) in enumerate(chapters):\n        if c___rnr[i] == len(c):\n            stack.append(i)\n            c___ans[i] = 1\n    while stack:\n        curr = stack.pop()\n        for dep in c___deps[curr]:\n            c___rnr[dep] += 1\n            if c___rnr[dep] == len(chapters[dep]):\n                ans = -1\n                for dd in chapters[dep]:\n                    ca = c___ans[dd]\n                    if dd > dep:\n                        ca += 1\n                    ans = max(ca, ans)\n                c___ans[dep] = ans\n                stack.append(dep)\n    if -1 in c___ans:\n        print(-1)\n    else:\n        print(max(c___ans))\nfor i in range(int(input())):\n    solve(i)", "t = int(input())\nwhile t:\n    n = int(input())\n    ct = [1] * n\n    pre_req = [0] * n\n    dt = {i: [] for i in range(n)}\n    queue = []\n    for j in range(n):\n        a = list(map(int, input().split()))\n        for i in range(1, a[0] + 1):\n            dt[a[i] - 1].append(j)\n        pre_req[j] = a[0]\n        if a[0] == 0:\n            queue += [j]\n    ind = 0\n    while ind < len(queue):\n        g = queue[ind]\n        for i in dt[g]:\n            pre_req[i] -= 1\n            ct[i] = max(ct[i], ct[g] + [0, 1][i < g])\n            if pre_req[i] == 0:\n                queue.append(i)\n        ind += 1\n    if max(pre_req) != 0:\n        print(-1)\n    else:\n        print(max(ct))\n    t -= 1", "import sys\ninput = sys.stdin.readline\nfor i in range(int(input())):\n    n = int(input())\n    l = [1] * n\n    d = {i: [] for i in range(n)}\n    q = []\n    m = [0] * n\n    for j in range(n):\n        a = [*map(int, input().split())]\n        for i in range(1, a[0] + 1):\n            d[a[i] - 1].append(j)\n        m[j] = a[0]\n        if a[0] == 0:\n            q += [[a[0], j]]\n    y = 0\n    while y < len(q):\n        g = q[y]\n        for i in d[g[1]]:\n            m[i] -= 1\n            l[i] = max(l[i], l[g[1]] + [0, 1][i < g[1]])\n            if m[i] == 0:\n                q += [[0, i]]\n        y += 1\n    if max(m) != 0:\n        print(-1)\n    else:\n        print(max(l))", "from collections import defaultdict\nfrom heapq import heappush, heappop\nt = int(input().strip())\ninputs = []\nfor _ in range(t):\n    n = int(input().strip())\n    prereqs = []\n    for _ in range(n):\n        ls = list(map(int, input().strip().split()))\n        prereqs.append(ls)\n    inputs.append((n, prereqs))\nfor (n, prereqs) in inputs:\n    required = [0] * (n + 1)\n    required_by = defaultdict(list)\n    for i in range(1, n + 1):\n        for p in prereqs[i - 1][1:]:\n            required_by[p].append(i)\n            required[i] += 1\n    q = []\n    for i in range(1, n + 1):\n        if required[i] == 0:\n            heappush(q, i)\n    if not q:\n        print(-1)\n        continue\n    read_count = 0\n    ans = 0\n    next_q = []\n    while q:\n        i = heappop(q)\n        read_count += 1\n        for j in required_by[i]:\n            required[j] -= 1\n            if required[j] != 0:\n                continue\n            if j > i:\n                heappush(q, j)\n            else:\n                heappush(next_q, j)\n        if not q:\n            q = next_q\n            next_q = []\n            ans += 1\n    if read_count < n:\n        print(-1)\n    else:\n        print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = [1] * n\n    d = {i: [] for i in range(n)}\n    q = []\n    m = [0] * n\n    for j in range(n):\n        a = [*map(int, input().split())]\n        for i in range(1, a[0] + 1):\n            d[a[i] - 1].append(j)\n        m[j] = a[0]\n        if a[0] == 0:\n            q += [[a[0], j]]\n    y = 0\n    while y < len(q):\n        g = q[y]\n        for i in d[g[1]]:\n            m[i] -= 1\n            l[i] = max(l[i], l[g[1]] + [0, 1][i < g[1]])\n            if m[i] == 0:\n                q += [[0, i]]\n        y += 1\n    if max(m) != 0:\n        print(-1)\n    else:\n        print(max(l))", "for i in range(int(input())):\n    n = int(input())\n    l = [1] * n\n    d = {i: [] for i in range(n)}\n    q = []\n    m = [0] * n\n    for j in range(n):\n        a = [*map(int, input().split())]\n        for i in range(1, a[0] + 1):\n            d[a[i] - 1].append(j)\n        m[j] = a[0]\n        if a[0] == 0:\n            q += [[a[0], j]]\n    y = 0\n    while y < len(q):\n        g = q[y]\n        for i in d[g[1]]:\n            m[i] -= 1\n            l[i] = max(l[i], l[g[1]] + [0, 1][i < g[1]])\n            if m[i] == 0:\n                q += [[0, i]]\n        y += 1\n    if max(m) != 0:\n        print(-1)\n    else:\n        print(max(l))", "def func2(datalist, n):\n    fished = [0] * (n + 1)\n    sid = 1\n    eid = 1\n    xlist = [[]]\n    children = [[] for i in range(n + 1)]\n    xn = 0\n    for i in range(1, n + 1):\n        if datalist[i][0] == 0:\n            fished[eid] = i\n            eid += 1\n            xlist.append([1, 0])\n            xn += 1\n        else:\n            for id in datalist[i][1:]:\n                children[id].append(i)\n            xlist.append([1, datalist[i][0]])\n    maxstep = 1\n    while sid != eid:\n        cid = fished[sid]\n        sid += 1\n        for id in children[cid]:\n            xlist[id][1] -= 1\n            if cid < id:\n                xlist[id][0] = max(xlist[id][0], xlist[cid][0])\n            else:\n                xlist[id][0] = max(xlist[id][0], xlist[cid][0] + 1)\n            if xlist[id][1] == 0:\n                xn += 1\n                maxstep = max(maxstep, xlist[id][0])\n                if children[id]:\n                    fished[eid] = id\n                    eid += 1\n    if xn != n:\n        return -1\n    return maxstep\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    datalist = [0]\n    for i in range(n):\n        datalist.append([int(x) for x in input().split()])\n    print(func2(datalist, n))", "from collections import defaultdict as dd, deque\nimport sys\ninput = sys.stdin.readline\n\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda : 1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n)\n    if res == False:\n        print(-1)\n    else:\n        print(res)", "from collections import defaultdict as dd, deque\n\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda : 1)\n    d += [i + 1 for i in range(n) if indegree[i + 1] == 0]\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            ans[v] = max(ans[v], ans[u] + 1) if v < u else max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n)\n    print(-1) if not res else print(res)", "from collections import defaultdict as dd, deque\n\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda : 1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n)\n    if res == False:\n        print(-1)\n    else:\n        print(res)", "from collections import defaultdict as dd, deque\n\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda : 1)\n    for i in range(n):\n        if indegree[i + 1] == 0:\n            d.append(i + 1)\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            if v < u:\n                ans[v] = max(ans[v], ans[u] + 1)\n            else:\n                ans[v] = max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n)\n    print(-1) if not res else print(res)", "from collections import defaultdict as dd, deque\n\ndef check_cycle(g, indegree, n):\n    c = 0\n    d = deque([])\n    ans = dd(lambda : 1)\n    d += [i + 1 for i in range(n) if indegree[i + 1] == 0]\n    while d:\n        u = d.popleft()\n        c += 1\n        for v in g[u]:\n            indegree[v] -= 1\n            ans[v] = max(ans[v], ans[u] + 1) if v < u else max(ans[v], ans[u])\n            if indegree[v] == 0:\n                d.append(v)\n    if c != n:\n        return False\n    if ans:\n        return max(ans.values())\n    return 1\nfor _ in range(int(input())):\n    n = int(input())\n    g = dd(set)\n    indegree = dd(int)\n    for i in range(n):\n        a = list(map(int, input().split()))\n        for j in range(1, a[0] + 1):\n            indegree[i + 1] += 1\n            g[a[j]].add(i + 1)\n    res = check_cycle(g, indegree, n)\n    print(-1) if not res else print(res)", "from collections import defaultdict, deque\n\ndef book_turn(indegree, graph):\n    queue = deque([(x, 1) for x in indegree if indegree[x] == 0])\n    if not queue:\n        return -1\n    visited = set(queue)\n    (turns, read_chapters) = (0, 0)\n    chapter_turns = [0 for _ in range(len(indegree))]\n    while queue:\n        for _ in range(len(queue)):\n            (node, turn) = queue.popleft()\n            read_chapters += 1\n            turns = max(turns, turn)\n            for neighbour in graph[node]:\n                indegree[neighbour] -= 1\n                cur_turn = turn if neighbour > node else turn + 1\n                chapter_turns[neighbour - 1] = max(chapter_turns[neighbour - 1], cur_turn)\n                if indegree[neighbour] == 0:\n                    queue.append((neighbour, chapter_turns[neighbour - 1]))\n    if read_chapters != len(indegree):\n        return -1\n    return turns\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    indegree = defaultdict(int)\n    graph = defaultdict(set)\n    for i in range(1, n + 1):\n        dependent = list(map(int, input().split()))\n        if dependent[0] == 0:\n            indegree[i] = 0\n        for j in range(1, len(dependent)):\n            indegree[i] += 1\n            graph[dependent[j]].add(i)\n    print(book_turn(indegree, graph))", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    rl = {}\n    l = {i: [] for i in range(1, n + 1)}\n    q = deque([])\n    kl = {}\n    vist = {i: False for i in range(1, n + 1)}\n    for i in range(1, n + 1):\n        t = list(map(int, input().split()))\n        rl[i] = t[1:]\n        for j in rl[i]:\n            l[j].append(i)\n        if t[0] == 0:\n            q.append(i)\n        kl[i] = t[0]\n    topo = []\n    while len(q) != 0:\n        u = q[0]\n        q.popleft()\n        vist[u] = True\n        topo.append(u)\n        for v in l[u]:\n            if kl[v] - 1 == 0:\n                q.append(v)\n            kl[v] -= 1\n    f = 0\n    for i in range(1, n + 1):\n        if vist[i] == False:\n            f = 1\n            break\n    if f == 1:\n        print(-1)\n        continue\n    dp = [1] * (n + 1)\n    ans = 0\n    for i in topo:\n        for j in rl[i]:\n            if i > j:\n                dp[i] = max(dp[i], dp[j])\n            else:\n                dp[i] = max(dp[i], dp[j] + 1)\n        ans = max(ans, dp[i])\n    print(ans)"]