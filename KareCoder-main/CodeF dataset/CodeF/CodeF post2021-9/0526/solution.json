["import sys\ninput = sys.stdin.readline\np = 998244353\n\ndef fermat_binom(n, k, p):\n    if k > n:\n        return 0\n    num = 1\n    for i in range(n, n - k, -1):\n        num = num * i % p\n    denom = 1\n    for i in range(1, k + 1):\n        denom = denom * i % p\n    return num * pow(denom, p - 2, p) % p\nn = int(input())\na = list(map(int, input().split()))\nans = 1\nfor i in range(n // 3):\n    test = a[i * 3:i * 3 + 3]\n    test.sort()\n    if test[0] == test[1]:\n        if test[1] == test[2]:\n            ans *= 3\n            ans %= p\n        else:\n            ans *= 2\n            ans %= p\nans *= fermat_binom(n // 3, n // 6, p)\nans %= p\nprint(ans)", "mod = 998244353\n\ndef factor(x):\n    ans = 1\n    for i in range(1, x + 1):\n        ans = ans * i % mod\n    return ans\nn = int(input())\na = list(map(int, input().split()))\nd = []\nans = 1\nfor i in range(n // 3):\n    one = a[i * 3]\n    two = a[i * 3 + 1]\n    three = a[i * 3 + 2]\n    if one == two == three:\n        ans *= 3\n    elif one == two and one < three or (one == three and one < two) or (three == two and two < one):\n        ans *= 2\n    ans = ans % mod\nn //= 3\ndele = factor(n // 2)\ndele = dele * dele % mod\ndele = pow(dele, mod - 2, mod)\ncnk = factor(n) * dele % mod\nprint(ans * cnk % mod)", "def comb(n, r, p):\n    den = 1\n    num = n\n    for i in range(2, r + 1):\n        den = i * den % p\n        num = (n - i + 1) * num % p\n    return num * pow(den, p - 2, p) % p\np = 998244353\nn = int(input())\nw = [int(x) for x in input().split()]\nans = comb(n // 3, n // 6, p)\ni = 0\nwhile i <= n - 3:\n    a = w[i]\n    b = w[i + 1]\n    c = w[i + 2]\n    if a == b:\n        if a == c:\n            ans *= 3\n            ans = ans % p\n        elif max(a, b, c) != a:\n            ans *= 2\n            ans = ans % p\n    elif a == c:\n        if max(a, b, c) != a:\n            ans *= 2\n            ans = ans % p\n    elif b == c:\n        if max(a, b, c) != b:\n            ans *= 2\n            ans = ans % p\n    i += 3\nprint(ans)", "def comb(n, r, p):\n    den = 1\n    num = n\n    for i in range(2, r + 1):\n        den = i * den % p\n        num = (n - i + 1) * num % p\n    return num * pow(den, p - 2, p) % p\np = 998244353\nn = int(input())\nw = [int(x) for x in input().split()]\nans = comb(n // 3, n // 6, p)\ni = 0\nwhile i <= n - 3:\n    a = w[i]\n    b = w[i + 1]\n    c = w[i + 2]\n    if a == b:\n        if a == c:\n            ans *= 3\n            ans = ans % p\n        elif max(a, b, c) != a:\n            ans *= 2\n            ans = ans % p\n    elif a == c:\n        if max(a, b, c) != a:\n            ans *= 2\n            ans = ans % p\n    elif b == c:\n        if max(a, b, c) != b:\n            ans *= 2\n            ans = ans % p\n    i += 3\nprint(ans)", "cons = 998244353\nn = int(input())\ntemp = list(map(int, input().split()))\ntotal = 1\nfor i in range(n // 3):\n    (a, b, c) = (temp[3 * i], temp[3 * i + 1], temp[3 * i + 2])\n    (a, b, c) = sorted([a, b, c])\n    if a == b and b == c:\n        total = total * 3 % cons\n    elif a == b and b < c:\n        total = total * 2 % cons\nk = n // 3\nz = n // 6\nwhile k > z:\n    total = total * k % cons\n    k -= 1\nwhile z > 0:\n    total = total * pow(z, -1, cons) % cons\n    z -= 1\nprint(total)", "n = int(input())\nm = n // 3\nMOD = 998244353\ninv = [1 for i in range(n + 1)]\nfor i in range(2, n + 1):\n    inv[i] = inv[MOD % i] * (MOD - MOD // i) % MOD\nans = 1\nfor i in range(1, m // 2 + 1):\n    ans *= (m + 1 - i) * inv[i]\n    ans %= MOD\na = input().split()\nfor i in range(n):\n    a[i] = int(a[i])\nnumMax = 0\nvalueMin = 0\nfor i in range(0, n, 3):\n    valueMin = min(a[i], a[i + 1], a[i + 2])\n    numMax = (a[i] == valueMin) + (a[i + 1] == valueMin) + (a[i + 2] == valueMin)\n    ans *= numMax\n    ans %= MOD\nprint(ans)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef rev_func(string):\n    revstr = ''\n    count = len(string) - 1\n    while count >= 0:\n        print('String Index: ', string[count], ' - ', count)\n        revstr = revstr + string[count]\n        count = count - 1\n    return revstr\n\ndef mod_inverse(x, p):\n    return pow(x, p - 2, p)\n\ndef comb(n, k, mod):\n    result = 1\n    for i in range(n - k + 1, n + 1):\n        result = result * i % mod\n    for i in range(2, k + 1):\n        result = result * mod_inverse(i, mod) % mod\n    return result\np = 998244353\nn = int(input())\nw = list(map(int, input().split()))\nresult = comb(n // 3, n // 6, p)\nit = iter(w)\nfor (w1, w2, w3) in zip(it, it, it):\n    ws = sorted([w1, w2, w3])\n    if w1 == w2 == w3:\n        result = result * 3 % p\n    elif ws[0] == ws[1]:\n        result = result * 2 % p\nprint(result)", "import sys\ninput = sys.stdin.readline\n\ndef sol(arr, n):\n    res = 1\n    mod = 998244353\n    for i in range(0, n, 3):\n        mx = min(arr[i], arr[i + 1], arr[i + 2])\n        cnt = 0\n        if arr[i] == mx:\n            cnt += 1\n        if arr[i + 1] == mx:\n            cnt += 1\n        if arr[i + 2] == mx:\n            cnt += 1\n        res *= cnt\n        res %= mod\n    for i in range(n // 6 + 1, n // 3 + 1):\n        res *= i\n        res %= mod\n    for i in range(1, n // 6 + 1):\n        res *= pow(i, mod - 2, mod)\n        res %= mod\n    return res\nn = int(input())\narr = list(map(int, input().split()))\nprint(sol(arr, n))", "import bisect\nfrom collections import defaultdict, Counter\nfrom fractions import Fraction\nimport heapq\nimport math\n\ndef mod_inverse(x, p):\n    return pow(x, p - 2, p)\n\ndef comb(n, k, mod):\n    result = 1\n    for i in range(n - k + 1, n + 1):\n        result = result * i % mod\n    for i in range(2, k + 1):\n        result = result * mod_inverse(i, mod) % mod\n    return result\np = 998244353\nn = int(input())\nw = list(map(int, input().split()))\nresult = comb(n // 3, n // 6, p)\nit = iter(w)\nfor (w1, w2, w3) in zip(it, it, it):\n    ws = sorted([w1, w2, w3])\n    if w1 == w2 == w3:\n        result = result * 3 % p\n    elif ws[0] == ws[1]:\n        result = result * 2 % p\nprint(result)", "from collections import Counter\nM = 998244353\n\ndef windows(it, n):\n    for i in range(0, len(it), n):\n        yield tuple(it[i:i + n])\nres = 1\nn = int(input())\nedges = list(map(int, input().split()))\nfor weights in windows(edges, 3):\n    if len(set(weights)) == 1:\n        res *= 3\n    elif len(set(weights)) == 2 and Counter(weights)[max(weights)] == 1:\n        res *= 2\nk = n // 6\nfor x in range(1, k + 1):\n    res = res * (x + k) * pow(x, M - 2, M) % M\nprint(res)", "import math\n\ndef getExponent(base, exponent, modulo):\n    if exponent == 0:\n        return 1\n    p = getExponent(base, exponent // 2, modulo) % modulo\n    p = p * p % modulo\n    if exponent % 2 == 0:\n        return p\n    else:\n        return base * p % modulo\n\ndef modInverse(value, modulo):\n    return getExponent(value, modulo - 2, modulo)\nnumCases = int(input())\nhold = input().split()\nvalues = [int(i) for i in hold]\ncurrent = []\nways = 1\nfor i in range(len(values)):\n    if i % 3 == 0 and i != 0:\n        current.sort()\n        if current[0] == current[1] and current[1] == current[2]:\n            ways *= 3\n        elif current[0] == current[1]:\n            ways *= 2\n        else:\n            ways *= 1\n        current = []\n    current.append(values[i])\ncurrent.sort()\nif current[0] == current[1] and current[1] == current[2]:\n    ways *= 3\nelif current[0] == current[1]:\n    ways *= 2\nelse:\n    ways *= 1\ngraphs = numCases / 3\ngraph2 = graphs / 2\ninv1 = modInverse(math.factorial(int(graph2)), 998244353)\nprint(ways * inv1 * inv1 * math.factorial(int(graphs)) % 998244353)", "n = int(input())\np = list(map(int, input().split()))\ndo = 0\ntr = 0\nm = int(n // 3)\nv = int(n // 6)\nfor i in range(0, n, 3):\n    d = p[i:i + 3]\n    d.sort()\n    if d[0] == d[1] == d[2]:\n        tr += 1\n    elif d[0] == d[1]:\n        do += 1\nimport math\ngh = math.factorial(m) // math.factorial(v) ** 2 * 3 ** tr * 2 ** do % 998244353\nprint(int(gh))", "import math\n\ndef nCr(n, r):\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\nn = int(input())\nl1 = list(map(int, input().split()))\ni = 0\nans = 1\nx = 998244353\nwhile i < n:\n    l2 = l1[i:i + 3]\n    l2.sort()\n    if l2[0] == l2[1] and l2[1] != l2[2]:\n        ans = ans * 2 % x\n    elif l2[0] == l2[1] and l2[1] == l2[2]:\n        ans = ans * 3 % x\n    i += 3\nans = ans * (nCr(int(n / 3), int(n / 6)) % x) % x\nprint(int(ans))", "import math\na = int(input())\nb = input().split()\nn = 998244353\nwt = 1\nfor x in range(0, a, 3):\n    d = int(b[x])\n    e = int(b[x + 1])\n    f = int(b[x + 2])\n    k = [d, e, f]\n    k.sort()\n    if d == e and e == f:\n        wt = 3 * wt\n    elif k[0] == k[1] and k[1] != k[2]:\n        wt = 2 * wt\nwt = wt % n\nq = a // 3\nw = a // 6\ny = math.factorial(q) // math.factorial(w) ** 2 % n\nprint(int(y * wt % n))", "from math import factorial as f\nn = int(input())\narr = list(map(int, input().split()))\np = 1\nfor a in zip(arr[::3], arr[1::3], arr[2::3]):\n    p *= a.count(min(a))\nprint(f(n // 3) // f(n // 6) ** 2 * p % 998244353)", "import math\nmod = 998244353\nn = int(input())\nt1 = math.factorial(n // 3)\nt2 = math.factorial(n // 6)\nans = t1 // t2 ** 2\nans %= mod\ndata = list(map(int, input().split()))\nfor i in range(0, n, 3):\n    a = data[i]\n    b = data[i + 1]\n    c = data[i + 2]\n    mini = min(a, min(b, c))\n    temp = 0\n    if a == mini:\n        temp += 1\n    if b == mini:\n        temp += 1\n    if c == mini:\n        temp += 1\n    ans *= temp\nprint(int(ans % mod))", "a = int(input())\nb = input().split()\nn = 998244353\nwt = 1\nimport math\nfor x in range(0, a, 3):\n    d = int(b[x])\n    e = int(b[x + 1])\n    f = int(b[x + 2])\n    k = [d, e, f]\n    k.sort()\n    if d == e and e == f:\n        wt = 3 * wt\n    elif k[0] == k[1] and k[1] != k[2]:\n        wt = 2 * wt\nwt = wt % n\nq = a // 3\nw = a // 6\ny = math.factorial(q) // math.factorial(w) ** 2 % n\nprint(int(y * wt % n))", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nresult = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    result *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * result % 998244353)", "from math import factorial as fact\nn = int(input())\nlst = list(map(int, input().split()))\np = 1\nfor i in range(0, n - 2, 3):\n    (a, b, c) = (lst[i], lst[i + 1], lst[i + 2])\n    if a == b == c:\n        p *= 3\n        continue\n    if a != b and b != c and (a != c):\n        continue\n    seg = lst[i:i + 3]\n    if seg.count(max(seg)) == 2:\n        continue\n    if seg.count(min(seg)) == 2:\n        p *= 2\n        continue\nx = n // 3\nh = n // 6\nnum = fact(x)\ndeno = fact(h) * fact(h)\np *= int(num // deno)\nprint(p % 998244353)", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "import math\nmod = 998244353\nn = int(input())\nl = list(map(int, input().split()))\nans = 1\nd = {}\nq = 1001\nfor i in range(0, n):\n    if l[i] in d:\n        d[l[i]] += 1\n    else:\n        d[l[i]] = 1\n    q = min(q, l[i])\n    if i % 3 == 2:\n        ans = ans * d[q]\n        d = {}\n        q = 1001\nn = n // 3\nr = math.factorial(n)\ns = math.factorial(n // 2)\ns = s * s\nr = r // s\nr = r\nans = ans * r\nans = ans % mod\nprint(ans)", "import math\nn = int(input())\nl1 = list(map(int, input().split()))\ni = 0\nans = 1\nx = int(998244353)\nwhile i + 2 < n:\n    l2 = l1[i:i + 3]\n    l2.sort()\n    if l2[0] == l2[1] and l2[1] != l2[2]:\n        ans = ans * 2\n    elif l2[0] == l2[1] and l2[1] == l2[2]:\n        ans = ans * 3\n    i += 3\nprint(math.factorial(n // 3) // (math.factorial(n // 6) * math.factorial(n // 6)) * ans % 998244353)", "import math\nimport sys\nf = lambda x: math.factorial(x)\nn = int(sys.stdin.readline())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nsys.stdout.writelines(str(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353) + '\\n')", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "import math\nimport sys\nf = lambda x: math.factorial(x)\nn = int(sys.stdin.readline())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nsys.stdout.writelines(str(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353) + '\\n')", "import math\nf = lambda x: math.factorial(x)\nn = int(input())\narr = list(map(int, input().split()))\ni = 0\nans = 1\nwhile i + 2 < n:\n    t = sorted(arr[i:i + 3])\n    ans *= 3 if t[0] == t[1] == t[2] else 2 if t[0] == t[1] else 1\n    i += 3\nprint(f(n // 3) // (f(n // 6) * f(n // 6)) * ans % 998244353)", "a = int(input())\nsize = int(a / 3)\nb = list(map(int, input().split()))\nm = 0\nvi = []\nimport math\nf = lambda x: math.factorial(x)\n\ndef prod_list(li, size):\n    a = 1\n    for i in range(size):\n        a = a * li[i]\n    return a\nfor j in range(size):\n    temp = []\n    for i in range(m, m + 3):\n        temp.append(b[i])\n    vi.append(temp)\n    m += 3\nans_prod = 1\nfor t in range(size):\n    h = set(vi[t])\n    if len(h) == 1:\n        ans_prod = ans_prod * 3\n    elif len(h) == 2:\n        vi[t].sort()\n        if vi[t][0] == vi[t][1]:\n            ans_prod = ans_prod * 2\nans_prod = ans_prod * (f(size) // (f(size // 2) * f(size // 2)))\nprint(ans_prod % 998244353)"]