["import sys\nimport math\nfrom bisect import bisect_right as br\nfrom collections import deque, Counter\nfrom itertools import combinations as cb\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef check(val):\n    if track[val] > 0:\n        track[val] -= 1\n        return 1\n    if val == 1:\n        return 0\n    return check(val // 2) and check((val + 1) // 2)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = int_arr()\n    track = Counter(arr)\n    if check(sum(arr)):\n        print('YES')\n    else:\n        print('NO')", "from collections import Counter\ntests = int(input())\nresults = []\n\ndef pedacoPossivel(tamanhoBolo):\n    if boloCounter[tamanhoBolo]:\n        boloCounter[tamanhoBolo] -= 1\n        return True\n    return tamanhoBolo > 1 and pedacoPossivel(tamanhoBolo // 2) and pedacoPossivel(tamanhoBolo - tamanhoBolo // 2)\nfor a in range(tests):\n    numeroPedacos = int(input())\n    pedacos = [int(t) for t in input().split()]\n    boloCounter = Counter(pedacos)\n    tamanhoBolo = sum(pedacos)\n    if pedacoPossivel(tamanhoBolo):\n        results.append('YES')\n    else:\n        results.append('NO')\nfor r in results:\n    print(r)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\ndef solve(n, arr):\n    count = {}\n    for num in arr:\n        if num not in count:\n            count[num] = 0\n        count[num] += 1\n    S = sum(arr)\n    q = deque([S])\n    cnt = n - 1\n    while q and cnt >= 0:\n        node = q.popleft()\n        if node in count and count[node] > 0:\n            count[node] -= 1\n            continue\n        val1 = node // 2 + node % 2\n        val2 = node // 2\n        cnt -= 1\n        q.append(val1)\n        q.append(val2)\n    if cnt == 0 and len(q) == 0 and all([count[key] == 0 for key in count]):\n        print('YES')\n    else:\n        print('NO')\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    solve(n, arr)", "from collections import defaultdict\n\ndef solve(x, d):\n    if d[x] > 0:\n        d[x] -= 1\n        return True\n    if x == 1:\n        return False\n    return solve(x // 2, d) and solve((x + 1) // 2, d)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = defaultdict(int)\n    sum_1 = 0\n    for i in a:\n        f[i] += 1\n        sum_1 += i\n    if solve(sum_1, f):\n        print('YES')\n    else:\n        print('NO')", "from collections import Counter\n\ndef solve(x, d):\n    if d[x] > 0:\n        d[x] -= 1\n        return True\n    if x == 1:\n        return False\n    return solve(x // 2, d) and solve((x + 1) // 2, d)\nfor t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = Counter(arr)\n    sm = sum(arr)\n    ans = solve(sm, d)\n    print('YES') if ans else print('NO')", "from collections import defaultdict\n\ndef solve(x, d):\n    if d[x] > 0:\n        d[x] -= 1\n        return True\n    if x == 1:\n        return False\n    return solve(x // 2, d) and solve((x + 1) // 2, d)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = defaultdict(int)\n    sum_1 = 0\n    for i in a:\n        f[i] += 1\n        sum_1 += i\n    if solve(sum_1, f):\n        print('YES')\n    else:\n        print('NO')", "from collections import Counter\n\ndef f(s):\n    if d[s]:\n        d[s] -= 1\n        return True\n    return s > 1 and f(s // 2) and f(s - s // 2)\nfor a in [0] * int(input()):\n    input()\n    r = [*map(int, input().split())]\n    d = Counter(r)\n    print('NYOE S'[f(sum(r))::2])", "from collections import Counter\n\ndef f(s):\n    if d[s]:\n        d[s] -= 1\n        return True\n    return s > 1 and f(s // 2) and f(s - s // 2)\nfor _ in [0] * int(input()):\n    input()\n    r = [*map(int, input().split())]\n    d = Counter(r)\n    print('NYOE S'[f(sum(r))::2])", "from collections import Counter\n\ndef f(s):\n    if d[s]:\n        d[s] -= 1\n        return True\n    return s > 1 and f(s // 2) and f(s - s // 2)\nfor _ in [0] * int(input()):\n    input()\n    r = [*map(int, input().split())]\n    d = Counter(r)\n    print('NYOE S'[f(sum(r))::2])", "from collections import Counter\n\ndef f(s):\n    if d[s]:\n        d[s] -= 1\n        return True\n    return s > 1 and f(s // 2) and f(s - s // 2)\nfor _ in [0] * int(input()):\n    input()\n    r = [*map(int, input().split())]\n    d = Counter(r)\n    print('NYOE S'[f(sum(r))::2])", "def solve():\n    n = int(input())\n    a = []\n    counts = {}\n    for x in input().split():\n        x = int(x)\n        a.append(x)\n        counts.setdefault(x, 0)\n        counts[x] += 1\n    initial = sum(a)\n    stop = min(a)\n    unwanted = [initial]\n    while unwanted != []:\n        sl = unwanted.pop(0)\n        if sl in counts and counts[sl] > 0:\n            counts[sl] -= 1\n        else:\n            (w, y) = (sl // 2, sl // 2 + sl % 2)\n            if w < stop:\n                print('NO')\n                return\n            unwanted = [w, y] + unwanted\n    print('YES')\nfor tc in range(int(input())):\n    solve()", "from collections import Counter\nfor i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    c = Counter(l)\n    s = sum(l)\n\n    def solve(x):\n        if x in c and c[x] > 0:\n            c[x] -= 1\n            return True\n        elif x == 1:\n            return False\n        else:\n            return solve(x // 2) and solve((x + 1) // 2)\n    if solve(s):\n        print('YES')\n    else:\n        print('NO')", "from collections import Counter\n\ndef f(s):\n    if d[s]:\n        d[s] -= 1\n        return True\n    return s > 1 and f(s // 2) and f(s - s // 2)\nfor _ in [0] * int(input()):\n    input()\n    r = [*map(int, input().split())]\n    d = Counter(r)\n    print('NYOE S'[f(sum(r))::2])", "import heapq\n_ = int(input())\nfor i in range(_):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dic = {}\n    for i in a:\n        if i not in dic:\n            dic[i] = 0\n        dic[i] += 1\n    s = sum(a)\n    cs = [0]\n\n    def dfs(x):\n        if x <= 1:\n            if x not in dic:\n                dic[x] = 0\n            dic[x] -= 1\n            return\n        if x in dic and dic[x] > 0:\n            dic[x] -= 1\n            return\n        else:\n            t1 = x // 2\n            t2 = x - t1\n            cs[0] += 1\n            if cs[0] < n:\n                dfs(t1)\n                dfs(t2)\n            else:\n                dic[-1] = -1\n                return\n    dfs(s)\n    ans = 'YES'\n    for i in dic:\n        if dic[i] != 0:\n            ans = 'NO'\n    print(ans)", "import heapq\nfrom math import ceil, floor\nR = lambda : map(int, input().split())\narr = []\nd = dict()\n\ndef tes(t):\n    if not t:\n        return False\n    if t in d and d[t]:\n        d[t] -= 1\n        return True\n    return tes(floor(t / 2)) and tes(ceil(t / 2))\n(t,) = R()\nfor _ in range(t):\n    (n,) = R()\n    arr = list(R())\n    d = dict()\n    for k in arr:\n        d[k] = d.get(k, 0) + 1\n    print('YES' if tes(sum(arr)) else 'NO')", "from collections import Counter\ntestCases = int(input())\n\ndef check(value):\n    if count[value] > 0:\n        count[value] -= 1\n        return True\n    if value == 1:\n        return False\n    return check(value // 2) and check((value + 1) // 2)\nfor _ in range(testCases):\n    n = int(input())\n    q = [int(x) for x in input().split()]\n    count = Counter(q)\n    if check(sum(q)):\n        print('YES')\n    else:\n        print('NO')", "from collections import Counter\n\ndef solve(s):\n    if C[s]:\n        C[s] -= 1\n        return True\n    return s > 1 and solve(s // 2) and solve(s - s // 2)\nfor _ in range(int(input())):\n    n = int(input())\n    L = list(map(int, input().split()))\n    C = Counter(L)\n    s = sum(L)\n    if solve(s):\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict\n\ndef solve(x, d):\n    if d[x] > 0:\n        d[x] -= 1\n        return True\n    if x == 1:\n        return False\n    return solve(x // 2, d) and solve((x + 1) // 2, d)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = defaultdict(int)\n    sum_1 = 0\n    for i in a:\n        f[i] += 1\n        sum_1 += i\n    if solve(sum_1, f):\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict\n\ndef solve(x, d):\n    if d[x] > 0:\n        d[x] -= 1\n        return True\n    if x == 1:\n        return False\n    return solve(x // 2, d) and solve((x + 1) // 2, d)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = defaultdict(int)\n    sum_1 = 0\n    for i in a:\n        f[i] += 1\n        sum_1 += i\n    if solve(sum_1, f):\n        print('YES')\n    else:\n        print('NO')", "def ANS(y, d):\n    if d[y] > 0:\n        d[y] -= 1\n        return True\n    if y == 1:\n        return False\n    return ANS(y // 2, d) and ANS((y + 1) // 2, d)\nimport math\nfrom collections import Counter\nfor k in range(int(input())):\n    n = int(input())\n    A = [int(k) for k in input().split()]\n    s = sum(A)\n    d = Counter(A)\n    ans = ANS(s, d)\n    if ans:\n        print('YES')\n    else:\n        print('NO')", "import heapq as hq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    q = [-sum(a)]\n    flag = 0\n    while a:\n        v = -hq.heappop(q)\n        if v == a[-1]:\n            a.pop()\n        elif v < a[-1]:\n            print('NO')\n            flag = 1\n            break\n        else:\n            hq.heappush(q, -(v // 2))\n            hq.heappush(q, -((v + 1) // 2))\n    if flag == 0:\n        print('YES')", "from collections import Counter\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    c = Counter(l)\n    sum1 = sum(l)\n\n    def solve(sum1):\n        if sum1 in c and c[sum1] > 0:\n            c[sum1] -= 1\n            return True\n        elif sum1 == 1:\n            return False\n        else:\n            return solve(sum1 // 2) and solve((sum1 + 1) // 2)\n    if solve(sum1):\n        print('YES')\n    else:\n        print('NO')", "from math import ceil, floor\nmap_counts = {}\n\ndef can_i_slice_it(tot):\n    if tot == 0:\n        return False\n    if map_counts.get(tot, False):\n        map_counts[tot] -= 1\n        return True\n    return can_i_slice_it(floor(tot / 2)) and can_i_slice_it(ceil(tot / 2))\n\ndef value_counts(array):\n    a = {}\n    for i in array:\n        a[i] = a.get(i, 0) + 1\n    return a\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input().split(' ')\n    a = list(map(lambda x: int(x), a))\n    map_counts = value_counts(a)\n    tot = sum(a)\n    if can_i_slice_it(tot):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    pieces = [sum(a)]\n    frequency = {}\n    for i in a:\n        frequency[i] = frequency.get(i, 0) + 1\n    operation = 0\n    while pieces and operation < n:\n        piece = pieces.pop()\n        if frequency.get(piece):\n            frequency[piece] -= 1\n            continue\n        pieces.append(piece // 2)\n        pieces.append((piece + 1) // 2)\n        operation += 1\n    print('YES') if operation == n - 1 else print('NO')", "import collections\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    nums = list(map(int, input().split()))\n    count = collections.Counter(nums)\n    q = collections.deque([sum(nums)])\n    if N == 1:\n        print('YES')\n        continue\n    divide = N - 1\n    while q and divide > 0:\n        divide -= 1\n        num = q.popleft()\n        if num == 1:\n            continue\n        num1 = num2 = num // 2\n        if num % 2 == 1:\n            num2 += 1\n        if count[num1] > 0:\n            count[num1] -= 1\n            N -= 1\n        else:\n            q.append(num1)\n        if count[num2] > 0:\n            count[num2] -= 1\n            N -= 1\n        else:\n            q.append(num2)\n    if N == 0:\n        print('YES')\n    else:\n        print('NO')", "from collections import Counter\n\ndef solve(x, d):\n    if d[x] > 0:\n        d[x] -= 1\n        return True\n    if x == 1:\n        return False\n    return solve(x // 2, d) and solve((x + 1) // 2, d)\nfor t in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = Counter()\n    sm = 0\n    for i in arr:\n        d[i] += 1\n        sm += i\n    ans = solve(sm, d)\n    print('YES') if ans else print('NO')", "import heapq\nimport math\n\ndef solve(s):\n    n = len(s)\n    s.sort(reverse=True)\n    d = dict()\n    total = sum(s)\n    h = []\n    heapq.heappush(h, -total)\n    for c in s:\n        curr_max = total\n        while c < curr_max:\n            curr_max = -heapq.heappop(h)\n            if c == curr_max:\n                continue\n            elif c < curr_max:\n                heapq.heappush(h, math.ceil(-curr_max / 2))\n                heapq.heappush(h, math.floor(-curr_max / 2))\n            else:\n                print('NO')\n                return\n    print('YES')\n    return\ntest = int(input())\nfor te in range(0, test):\n    n = int(input())\n    s = list(map(int, input().split()))\n    solve(s)", "import math\nt = int(input())\nres = []\nfor _ in range(t):\n    input()\n    a = [int(x) for x in input().split(' ')]\n    (d, s) = ({}, 0)\n    for v in a:\n        s += v\n        if v in d:\n            d[v] += 1\n        else:\n            d[v] = 1\n    (lst, count) = ([s], 0)\n    while lst and count < len(a):\n        cur = lst.pop()\n        if cur in d:\n            d[cur] -= 1\n            if d[cur] == 0:\n                del d[cur]\n        else:\n            count += 1\n            if cur % 2:\n                lst.append(math.ceil(cur / 2))\n            else:\n                lst.append(cur // 2)\n            lst.append(cur // 2)\n    if lst:\n        res.append(False)\n    else:\n        res.append(True)\nfor i in range(t):\n    if res[i]:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    weight = sum(a)\n    pieces = [weight]\n    frequency = {}\n    for i in a:\n        frequency[i] = frequency.get(i, 0) + 1\n    operation = 0\n    while pieces and operation < n:\n        piece = pieces.pop()\n        if frequency.get(piece, 0):\n            frequency[piece] -= 1\n            continue\n        pieces.append(piece // 2)\n        pieces.append((piece + 1) // 2)\n        operation += 1\n    print('YES') if operation == n - 1 else print('NO')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    pieces = [sum(a)]\n    frequency = {}\n    for i in a:\n        frequency[i] = frequency.get(i, 0) + 1\n    operation = 0\n    while pieces and operation < n:\n        piece = pieces.pop()\n        if frequency.get(piece):\n            frequency[piece] -= 1\n            continue\n        pieces.append(piece // 2)\n        pieces.append((piece + 1) // 2)\n        operation += 1\n    print('YES') if operation == n - 1 else print('NO')", "from collections import Counter, defaultdict, deque, namedtuple\nfrom email.policy import default\nfrom functools import lru_cache\nfrom typing import List, Dict\nimport bisect as b\nimport heapq as h\nimport math as m\n\ndef ints():\n    return [int(x) for x in input().split()]\n\ndef main_tc():\n    n = int(input())\n    pieces = ints()\n    total = 0\n    for piece in pieces:\n        total += piece\n    counter = defaultdict(int)\n    for piece in pieces:\n        counter[piece] += 1\n    queue = deque()\n    queue.append(total)\n    cut = 0\n    while len(queue) > 0:\n        if cut == n:\n            print('NO')\n            return\n        piece = queue.popleft()\n        if counter[piece] > 0:\n            counter[piece] -= 1\n            continue\n        cut += 1\n        p1 = piece // 2\n        p2 = piece // 2 + piece % 2\n        queue.append(p1)\n        queue.append(p2)\n    print('YES')\n\ndef main():\n    tc = int(input())\n    for _ in range(tc):\n        main_tc()\nmain()", "from collections import Counter\n\ndef solve(n):\n    (s, n) = (Counter(n), [sum(n)])\n    while s:\n        t = n[-1]\n        if 0 in n:\n            return False\n        elif t in s:\n            if s[t] == 1:\n                s.pop(t)\n            else:\n                s[t] -= 1\n        else:\n            n.append(t + 1 >> 1)\n            n.append(t >> 1)\n        n.remove(t)\n    return True\nfor i in range(int(input())):\n    int(input())\n    print('YES' if solve([int(i) for i in input().split()]) else 'NO')", "from collections import Counter\n\ndef solve(n):\n    (s, n) = (Counter(n), [sum(n)])\n    while s:\n        if (t := n[-1]) == 0:\n            return False\n        elif t in s:\n            if s[t] == 1:\n                s.pop(t)\n            else:\n                s[t] -= 1\n        else:\n            n.append(t + 1 >> 1)\n            n.append(t >> 1)\n        n.remove(t)\n    return True\nfor i in range(int(input())):\n    int(input())\n    print('YES' if solve([int(i) for i in input().split()]) else 'NO')", "from collections import defaultdict\nimport math\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        print('YES')\n    else:\n        total = 0\n        d = {}\n        for x in arr:\n            total += x\n            try:\n                d[x] += 1\n            except:\n                d[x] = 1\n        q = [total]\n        while len(q) < n:\n            x = q.pop()\n            (a, b) = (x // 2, x - x // 2)\n            if a in d:\n                d[a] -= 1\n                n -= 1\n                if d[a] == 0:\n                    del d[a]\n            else:\n                q.append(a)\n            if b in d:\n                d[b] -= 1\n                n -= 1\n                if d[b] == 0:\n                    del d[b]\n            else:\n                q.append(b)\n        if len(q) == 0:\n            print('YES')\n        else:\n            print('NO')", "import heapq as h\nfrom collections import Counter\n\ndef solve(n: list) -> bool:\n    s = Counter(n)\n    n = [sum(n)]\n    while s:\n        if (t := n[0]) == 0:\n            return False\n        elif t in s:\n            if s[t] == 1:\n                s.pop(t)\n            else:\n                s[t] -= 1\n            h.heappop(n)\n        else:\n            h.heapreplace(n, t >> 1)\n            h.heappush(n, t + 1 >> 1)\n    return True\n\ndef go() -> None:\n    for i in range(int(input())):\n        int(input())\n        print('YES' if solve([int(i) for i in input().split()]) else 'NO')\ngo()", "from collections import Counter\n\ndef solve(n):\n    (s, n) = (Counter(n), [sum(n)])\n    while s:\n        t = n[-1]\n        if 0 in n:\n            return False\n        elif t in s:\n            if s[t] == 1:\n                s.pop(t)\n            else:\n                s[t] -= 1\n        else:\n            n.append(t >> 1)\n            n.append(t + 1 >> 1)\n        n.remove(t)\n    return True\nfor i in range(int(input())):\n    int(input())\n    print('YES' if solve([int(i) for i in input().split()]) else 'NO')", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    final = []\n    heapq.heappush(final, -1 * sum(arr))\n    i = 0\n    while i < n:\n        cur = heapq.heappop(final) * -1\n        if cur > arr[i]:\n            a = cur // 2\n            b = cur - a\n            heapq.heappush(final, -1 * a)\n            heapq.heappush(final, -1 * b)\n        elif cur == arr[i]:\n            i += 1\n        else:\n            break\n    print('YES' if i == n else 'NO')", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    init = sum(a)\n    vis = {}\n    for i in a:\n        if i not in vis:\n            vis[i] = 1\n        else:\n            vis[i] += 1\n    que = [init]\n    while que:\n        temp = que.pop()\n        if temp in vis and vis[temp] > 0:\n            vis[temp] -= 1\n        else:\n            if temp == 1:\n                break\n            que.append(temp // 2)\n            que.append((temp + 1) // 2)\n    ans = 'YES'\n    for i in vis:\n        if vis[i] > 0:\n            ans = 'NO'\n            break\n    print(ans)", "from collections import Counter\n\ndef cal():\n    q = [tot]\n    i = 0\n    while q and i < n:\n        k = q.pop()\n        if k in c:\n            c[k] -= 1\n            if c[k] == 0:\n                del c[k]\n            continue\n        if k == 1:\n            return False\n        if k % 2 == 0:\n            q += [k // 2, k // 2]\n        else:\n            q += [k // 2, k // 2 + 1]\n        i += 1\n    if len(c) == 0:\n        return True\n    return False\nfor jj in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    c = Counter(arr)\n    tot = sum(arr)\n    if cal():\n        print('YES')\n    else:\n        print('NO')", "import math as m\nfor _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    s = sum(lst)\n    a_dict = {}\n    for i in lst:\n        a_dict[i] = 1 if i not in a_dict else a_dict[i] + 1\n    ans = [s]\n    pos = True\n    while ans:\n        x = ans.pop()\n        if x == 0:\n            pos = False\n            break\n        if x in a_dict:\n            a_dict[x] -= 1\n            if a_dict[x] == 0:\n                a_dict.pop(x)\n        else:\n            ans += [m.ceil(x / 2), m.floor(x / 2)]\n    print('YES' if pos else 'NO')", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfrom collections import defaultdict\nfor _ in range(I()):\n    n = I()\n    arr = L()\n    if n == 1:\n        print('YES')\n        continue\n    sm = 0\n    C = defaultdict(int)\n    for i in range(len(arr)):\n        C[arr[i]] += 1\n        sm += arr[i]\n    sums = [sm]\n    cnt = 0\n    while sums:\n        p = sums.pop()\n        (a, b) = (p // 2, p - p // 2)\n        if a == 0 or b == 0:\n            break\n        if C[a] > 0:\n            C[a] -= 1\n            cnt += 1\n        else:\n            sums.append(a)\n        if C[b] > 0:\n            C[b] -= 1\n            cnt += 1\n        else:\n            sums.append(b)\n        if cnt >= n:\n            break\n    flag = 1\n    for e in C:\n        if C[e] > 0:\n            flag = 0\n            break\n    if flag:\n        print('YES')\n    else:\n        print('NO')", "import heapq\nfrom math import ceil\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    a.sort(reverse=True)\n    h = []\n    heapq.heappush(h, s * -1)\n    i = 0\n    flag = True\n    while i < n:\n        x = heapq.heappop(h) * -1\n        if x == a[i]:\n            i += 1\n        elif x > a[i]:\n            heapq.heappush(h, ceil(x / 2) * -1)\n            heapq.heappush(h, x // 2 * -1)\n        else:\n            flag = False\n            break\n    if flag:\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict as dd\nfor _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    cake = 0\n    dk = dd(int)\n    for x in lst:\n        dk[x] += 1\n        cake += x\n    queue = [cake]\n    cut = 0\n    while queue and cut < n:\n        piece = queue.pop()\n        if dk[piece]:\n            dk[piece] -= 1\n            continue\n        queue.append(piece // 2)\n        queue.append(piece // 2 + piece % 2)\n        cut += 1\n    if cut == n - 1:\n        print('YES')\n    else:\n        print('NO')", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().strip().split()))\n    a = sum(l)\n    lk = [a]\n    d = {}\n    b = min(l)\n    for i in l:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    while len(lk) > 0:\n        a = lk[0]\n        (p, q) = (a // 2, a // 2 + a % 2)\n        if a in d and d[a] > 0:\n            d[a] -= 1\n            del lk[0]\n        elif p < b:\n            print('NO')\n            break\n        else:\n            del lk[0]\n            lk = [p, q] + lk\n    else:\n        print('YES')", "import heapq\nfrom collections import Counter\nimport math\n\ndef ans(n, l, c):\n    if n == 1:\n        return 'YES'\n    heap = [-sum(l)]\n    heapq.heapify(heap)\n    while len(heap) < n:\n        x = heapq.heappop(heap)\n        y = math.floor(x / 2) * -1\n        z = math.ceil(x / 2) * -1\n        if c[z]:\n            c[z] -= 1\n            n -= 1\n        else:\n            heapq.heappush(heap, -z)\n        if c[y]:\n            c[y] -= 1\n            n -= 1\n        else:\n            heapq.heappush(heap, -y)\n    if len(heap) == 0:\n        return 'YES'\n    else:\n        return 'NO'\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    c = Counter(l)\n    print(ans(n, l, c))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    total = sum(a)\n    st = dict()\n    for i in a:\n        st[i] = st.get(i, 0) + 1\n    nums = [total]\n    ans = True\n    while len(st) > 0 and len(nums) > 0:\n        lt = nums.pop()\n        if st.get(lt, 0) > 0:\n            st[lt] = st.get(lt) - 1\n            if st[lt] == 0:\n                st.pop(lt)\n            continue\n        if lt == 1:\n            ans = False\n            break\n        nums.append(lt // 2)\n        nums.append((lt + 1) // 2)\n    if len(st) > 0 or len(nums) > 0:\n        ans = False\n    print('YES' if ans else 'NO')", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    o = sum(nums)\n    nums_count = {x: 0 for x in nums}\n    for item in nums:\n        nums_count[item] += 1\n    stack = [o]\n    valid = [o]\n    done = {o: 1}\n    can = False\n    if n == 1:\n        can = True\n    times = 0\n    while times < n:\n        if not stack:\n            break\n        tmp = stack\n        stack = []\n        for current in tmp:\n            node1 = math.ceil(current / 2)\n            node2 = current // 2\n            if nums_count.get(node1):\n                nums_count[node1] -= 1\n            elif node1 > 1:\n                stack.append(node1)\n            if nums_count.get(node2):\n                nums_count[node2] -= 1\n            elif node2 > 1:\n                stack.append(node2)\n        if len(stack) > n:\n            break\n        times += 1\n    if sum(nums_count.values()) == 0:\n        can = True\n    if can:\n        print('YES')\n    else:\n        print('NO')", "import sys\nimport heapq as hq\n\ndef _input_iter():\n    for line in sys.stdin:\n        for part in line.strip().split(' '):\n            stripped = part.strip()\n            if stripped:\n                yield stripped\nstream = _input_iter()\n\ndef read_int():\n    return int(next(stream))\n\ndef read_str():\n    return next(stream)\n\ndef run():\n    n = read_int()\n    a_h = []\n    hq.heapify(a_h)\n    for _ in range(n):\n        hq.heappush(a_h, -read_int())\n    h = []\n    hq.heappush(h, sum(a_h))\n    while len(a_h) > 0:\n        if a_h[0] == h[0]:\n            hq.heappop(a_h)\n            hq.heappop(h)\n        elif a_h[0] < h[0]:\n            print('NO')\n            return\n        else:\n            curr_elem = h[0]\n            hq.heappop(h)\n            hq.heappush(h, curr_elem // 2)\n            hq.heappush(h, curr_elem // 2 + curr_elem % 2)\n    print('YES')\ntest_cases = read_int()\nfor _ in range(test_cases):\n    run()", "import heapq\n\ndef main():\n    length = int(input())\n    for _ in range(length):\n        no_piece = int(input())\n        lst = list(map(int, input().split()))\n        isDivisible(no_piece, lst)\n\ndef isDivisible(length, lst):\n    if length != len(lst):\n        print('NO')\n        return\n    sum_val = sum(lst)\n    heap1 = [-sum_val]\n    heap2 = []\n    for val in lst:\n        heapq.heappush(heap2, -val)\n    while heap2:\n        while -heap1[0] > -heap2[0]:\n            top = heapq.heappop(heap1)\n            if top % 2 == 0:\n                heapq.heappush(heap1, top // 2)\n                heapq.heappush(heap1, top // 2)\n            else:\n                heapq.heappush(heap1, top // 2)\n                heapq.heappush(heap1, top // 2 + 1)\n        if heap1[0] == heap2[0]:\n            heapq.heappop(heap1)\n            heapq.heappop(heap2)\n        else:\n            print('NO')\n            return\n    print('YES')\nmain()", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    o = sum(nums)\n    nums_count = {x: 0 for x in nums}\n    for item in nums:\n        nums_count[item] += 1\n    stack = [o]\n    valid = [o]\n    done = {o: 1}\n    can = False\n    if n == 1:\n        can = True\n    times = 0\n    while times < n:\n        if not stack:\n            break\n        tmp = stack\n        stack = []\n        for current in tmp:\n            node1 = math.ceil(current / 2)\n            node2 = current // 2\n            if nums_count.get(node1):\n                nums_count[node1] -= 1\n            elif node1 > 1:\n                stack.append(node1)\n            if nums_count.get(node2):\n                nums_count[node2] -= 1\n            elif node2 > 1:\n                stack.append(node2)\n        if len(stack) > n:\n            break\n        times += 1\n    if sum(nums_count.values()) == 0:\n        can = True\n    if can:\n        print('YES')\n    else:\n        print('NO')", "import math\nimport heapq as h\n\ndef solve(A, B):\n    w = sum(A)\n    B.append(w * -1)\n    A = [i * -1 for i in A]\n    h.heapify(A)\n    h.heapify(B)\n    while A and B and (A[0] >= B[0]):\n        if A[0] == B[0]:\n            h.heappop(A)\n            h.heappop(B)\n        elif A[0] != B[0]:\n            b = h.heappop(B)\n            h.heappush(B, math.ceil(b / 2))\n            h.heappush(B, math.floor(b / 2))\n    if not A:\n        print('YES')\n    else:\n        print('NO')\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = list(map(int, input().strip().split()))\n    B = []\n    solve(A, B)", "from collections import defaultdict, deque\nimport math\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    temp = deque()\n    d = defaultdict(lambda : 0)\n    s = 0\n    flag = 0\n    ops = 0\n    for x in range(n):\n        d[a[x]] += 1\n        s += a[x]\n    temp.append(s)\n    while len(temp) > 0:\n        v = temp.popleft()\n        if d[v] <= 0:\n            if ops == n - 1:\n                flag = 1\n                break\n            if math.floor(v / 2) <= 0:\n                flag = 1\n                break\n            ops += 1\n            temp.appendleft(math.floor(v / 2))\n            temp.appendleft(math.ceil(v / 2))\n        else:\n            d[v] = d[v] - 1\n    if flag == 1:\n        print('NO')\n    else:\n        print('YES')\n    t -= 1", "import sys\nimport heapq as hq\n\ndef _input_iter():\n    for line in sys.stdin:\n        for part in line.strip().split(' '):\n            stripped = part.strip()\n            if stripped:\n                yield stripped\nstream = _input_iter()\n\ndef read_int():\n    return int(next(stream))\n\ndef read_str():\n    return next(stream)\n\ndef run():\n    n = read_int()\n    a_h = []\n    hq.heapify(a_h)\n    for _ in range(n):\n        hq.heappush(a_h, -read_int())\n    h = []\n    hq.heappush(h, sum(a_h))\n    while len(a_h) > 0:\n        if a_h[0] == h[0]:\n            hq.heappop(a_h)\n            hq.heappop(h)\n        elif a_h[0] != h[0] and a_h[0] < h[0]:\n            print('NO')\n            return\n        else:\n            curr_elem = h[0]\n            hq.heappop(h)\n            hq.heappush(h, curr_elem // 2)\n            hq.heappush(h, curr_elem // 2 + curr_elem % 2)\n    print('YES')\ntest_cases = read_int()\nfor _ in range(test_cases):\n    run()", "import sys\nimport heapq as hq\n\ndef _input_iter():\n    for line in sys.stdin:\n        for part in line.strip().split(' '):\n            stripped = part.strip()\n            if stripped:\n                yield stripped\nstream = _input_iter()\n\ndef read_int():\n    return int(next(stream))\n\ndef read_str():\n    return next(stream)\n\ndef run():\n    n = read_int()\n    a_h = []\n    hq.heapify(a_h)\n    for _ in range(n):\n        hq.heappush(a_h, -read_int())\n    h = []\n    hq.heappush(h, sum(a_h))\n    while len(a_h) > 0:\n        if a_h[0] == h[0]:\n            hq.heappop(a_h)\n            hq.heappop(h)\n        elif a_h[0] < h[0]:\n            print('NO')\n            return\n        else:\n            curr_elem = hq.heappop(h)\n            hq.heappush(h, curr_elem // 2)\n            hq.heappush(h, curr_elem // 2 + curr_elem % 2)\n    print('YES')\ntest_cases = read_int()\nfor _ in range(test_cases):\n    run()", "import heapq\nfrom math import ceil, floor\n\ndef resolve():\n    npedacos = int(input())\n    pedacos = [-int(x) for x in input().split(' ')]\n    heapq.heapify(pedacos)\n    tentativa = [sum(pedacos)]\n    while len(pedacos) > 0:\n        maior_tentativa = -heapq.heappop(tentativa)\n        maior_atual = -pedacos[0]\n        if maior_tentativa == maior_atual:\n            heapq.heappop(pedacos)\n        elif maior_tentativa > maior_atual:\n            heapq.heappush(tentativa, -ceil(maior_tentativa / 2.0))\n            heapq.heappush(tentativa, -floor(maior_tentativa / 2.0))\n        else:\n            print('NO')\n            return\n    print('YES')\nncasos = int(input())\nfor _ in range(ncasos):\n    resolve()", "import heapq\nfrom math import ceil, floor\n\ndef resolve():\n    npedacos = int(input())\n    pedacos = [-int(x) for x in input().split(' ')]\n    heapq.heapify(pedacos)\n    tentativa = [sum(pedacos)]\n    while len(pedacos) > 0:\n        maior_tentativa = -heapq.heappop(tentativa)\n        maior_atual = -pedacos[0]\n        if maior_tentativa == maior_atual:\n            heapq.heappop(pedacos)\n        elif maior_tentativa > maior_atual:\n            heapq.heappush(tentativa, -ceil(maior_tentativa / 2.0))\n            heapq.heappush(tentativa, -floor(maior_tentativa / 2.0))\n        else:\n            print('NO')\n            return\n    print('YES')\nncasos = int(input())\nfor _ in range(ncasos):\n    resolve()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = set()\n    k = {}\n    su = 0\n    for i in a:\n        if i in s:\n            k[i] += 1\n        else:\n            k[i] = 1\n            s.add(i)\n        su += i\n    vec = [su]\n    p = 0\n    i = 0\n    flag = True\n    while flag and i < len(vec) and (n >= 0):\n        c = vec[i]\n        if c in s and k[c] > 0:\n            k[c] -= 1\n            if k[c] == 0:\n                p += 1\n        else:\n            if c == 1:\n                flag = False\n                break\n            vec.append(int(c / 2))\n            vec.append(round(c / 2 + 0.1))\n            n -= 1\n        i += 1\n    if flag and p == len(s):\n        print('YES')\n    else:\n        print('NO')", "ts = int(input())\nwhile ts > 0:\n    ts -= 1\n    n = int(input())\n    l = list(map(int, input().split()))\n    total = sum(l)\n    st = dict()\n    for i in l:\n        st[i] = st.get(i, 0) + 1\n    nums = [total]\n    ans = True\n    while len(st) > 0 and len(nums) > 0:\n        lt = nums.pop()\n        if st.get(lt, 0) > 0:\n            st[lt] = st.get(lt) - 1\n            if st[lt] == 0:\n                st.pop(lt)\n            continue\n        if lt == 1:\n            ans = False\n            break\n        nums.append(lt // 2)\n        nums.append((lt + 1) // 2)\n    if len(st) > 0 or len(nums) > 0:\n        ans = False\n    print('YES' if ans else 'NO')", "import heapq\n\ndef solve():\n    _ = int(input())\n    fin = list(map(int, input().strip().split()))\n    fin = [-x for x in fin]\n    heapq.heapify(fin)\n    curr = [sum(fin)]\n    while fin:\n        while -curr[0] > -fin[0]:\n            x = -heapq.heappop(curr)\n            if x < 2:\n                return False\n            heapq.heappush(curr, -(x // 2))\n            heapq.heappush(curr, -(x - x // 2))\n        if -curr[0] != -fin[0]:\n            return False\n        heapq.heappop(fin)\n        heapq.heappop(curr)\n    return True\nt = int(input())\nfor _ in range(t):\n    res = 'NO'\n    if solve():\n        res = 'YES'\n    print(res)", "for _ in range(int(input())):\n    length = int(input())\n    l = list(map(int, input().split()))\n    from collections import Counter\n    freq = Counter(l)\n    stack = []\n    total = sum(l)\n    stack.append(total)\n    while len(stack):\n        if stack[-1] in freq and freq[stack[-1]] > 0:\n            freq[stack[-1]] -= 1\n            stack.pop()\n        else:\n            temp = stack.pop()\n            if temp == 1:\n                break\n            stack.append(temp // 2)\n            stack.append((temp + 1) // 2)\n    if len(stack):\n        print('NO')\n    else:\n        print('YES')", "import bisect\nimport math\n\ndef task10(w1):\n    w1.sort()\n    w2 = [sum(w1)]\n    while len(w1) != 0 and len(w2) != 0:\n        if w1[-1] > w2[-1]:\n            return 'NO'\n        elif w1[-1] == w2[-1]:\n            w1.pop(-1)\n            w2.pop(-1)\n        else:\n            item = w2.pop(-1)\n            bisect.insort(w2, math.ceil(item / 2))\n            bisect.insort(w2, math.floor(item / 2))\n    return 'YES'\nimport heapq\n\ndef task10(w1):\n    w1 = [-item for item in w1]\n    w2 = [sum(w1)]\n    heapq.heapify(w1)\n    heapq.heapify(w2)\n    while len(w1) != 0 and len(w2) != 0:\n        if w1[0] < w2[0]:\n            return 'NO'\n        elif w1[0] == w2[0]:\n            heapq.heappop(w1)\n            heapq.heappop(w2)\n        else:\n            item = heapq.heappop(w2)\n            heapq.heappush(w2, math.ceil(item / 2))\n            heapq.heappush(w2, math.floor(item / 2))\n    return 'YES'\nresult = []\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = input().split()\n    arr = [int(arr[i]) for i in range(len(arr))]\n    result.append(task10(arr))\nfor item in result:\n    print(item)", "import math\nimport heapq\n\ndef task10(w1):\n    w1 = [-item for item in w1]\n    w2 = [sum(w1)]\n    heapq.heapify(w1)\n    heapq.heapify(w2)\n    while len(w1) != 0 and len(w2) != 0:\n        if w1[0] < w2[0]:\n            return 'NO'\n        elif w1[0] == w2[0]:\n            heapq.heappop(w1)\n            heapq.heappop(w2)\n        else:\n            item = heapq.heappop(w2)\n            heapq.heappush(w2, math.ceil(item / 2))\n            heapq.heappush(w2, math.floor(item / 2))\n    return 'YES'\nresult = []\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = input().split()\n    arr = [int(arr[i]) for i in range(len(arr))]\n    result.append(task10(arr))\nfor item in result:\n    print(item)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    s = sum(l)\n    h = {}\n    do = n - 1\n    if l.count(1) == len(l):\n        print('YES')\n        continue\n    if len(l) == 2 and abs(l[0] - l[1]) > 1:\n        print('NO')\n        continue\n    for i in l:\n        if i in h:\n            h[i] += 1\n        else:\n            h[i] = 1\n    arr = [s]\n    ct = 0\n    while ct < do and sum(h.values()) != 0:\n        ll = len(arr)\n        for i in range(len(arr)):\n            if arr[i] in h and h[arr[i]] > 0:\n                h[arr[i]] -= 1\n            else:\n                ct += 1\n                arr.append(math.floor(arr[i] / 2))\n                arr.append(math.ceil(arr[i] / 2))\n        arr = arr[ll:]\n    for i in range(len(arr)):\n        if arr[i] in h and h[arr[i]] > 0:\n            h[arr[i]] -= 1\n    if sum(h.values()) == 0:\n        print('YES')\n    else:\n        print('NO')", "import math as m\nfor _ in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    s = sum(lst)\n    a_dict = {}\n    for i in lst:\n        if i in a_dict:\n            a_dict[i] += 1\n        else:\n            a_dict[i] = 1\n    ans = [s]\n    while ans:\n        x = ans[0]\n        if x == 0:\n            break\n        elif a_dict.get(ans[0], 'np') != 'np' and a_dict[ans[0]] != 0:\n            a_dict[ans[0]] -= 1\n            ans.pop(0)\n        elif a_dict.get(ans[0], 'np') == 0:\n            a_dict.pop(ans[0])\n        else:\n            r = ans[0]\n            ans.pop(0)\n            ans.insert(0, m.floor(r / 2))\n            ans.insert(1, m.ceil(r / 2))\n    q = 0\n    fa = 'YES'\n    for k in a_dict:\n        q += a_dict[k]\n        if q > 0:\n            fa = 'NO'\n            break\n    print(fa)", "import math\nfrom heapq import heapify, heappush, heappop\n\ndef solution(k, cakes):\n    current = [-sum(cakes)]\n    numbers = [-i for i in cakes]\n    heapify(numbers)\n    i = 1\n    while i < k:\n        (c, n) = (-1 * heappop(current), -1 * heappop(numbers))\n        if c > n:\n            (a, b) = (-1 * math.floor(c / 2), -1 * math.ceil(c / 2))\n            heappush(current, a)\n            heappush(current, b)\n            heappush(numbers, -1 * n)\n            i += 1\n        elif c == n:\n            continue\n        else:\n            return 'NO'\n    while current and numbers and (current[0] == numbers[0]):\n        heappop(current)\n        heappop(numbers)\n    if len(numbers) == 0:\n        return 'YES'\n    else:\n        return 'NO'\nfor _ in range(int(input())):\n    n = int(input())\n    cakes = list(map(int, input().split()))\n    print(solution(n, cakes))", "from collections import Counter\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    sum1 = sum(a)\n    x = Counter(a)\n    q = []\n    q.append(sum1)\n    flag = 0\n    while q:\n        if max(x) > max(q):\n            flag = 1\n            break\n        if 1 in q and 1 not in x:\n            flag = 1\n            break\n        x1 = q.pop()\n        if x1 in x:\n            x[x1] -= 1\n            if x[x1] == 0:\n                x.pop(x1)\n        elif x1 % 2 == 0:\n            q.append(x1 // 2)\n            q.append(x1 // 2)\n        else:\n            q.append(x1 // 2)\n            q.append(x1 // 2 + 1)\n    if x or flag == 1:\n        print('NO')\n    else:\n        print('YES')", "import sys, math, queue, bisect\ninput = sys.stdin.readline\n\ndef f(n):\n    nums_length = len(nums)\n    q = queue.PriorityQueue()\n    q.put([-n, 1])\n    while q.qsize() != 0:\n        (cur_node, cur_count) = q.get()\n        while q.qsize() != 0:\n            (tmp_node, tmp_count) = q.get()\n            if tmp_node == cur_node:\n                cur_count += tmp_count\n            else:\n                q.put([tmp_node, tmp_count])\n                break\n        cur_node *= -1\n        if cur_node < nums[nums_length - 1]:\n            return False\n        length_to_remove = min(nums_length - bisect.bisect_right(nums, cur_node - 1), cur_count)\n        nums_length -= length_to_remove\n        cur_count -= length_to_remove\n        if nums_length <= 0:\n            return True\n        if cur_node >= 2 and cur_count > 0:\n            if cur_node % 2 == 0:\n                q.put([-cur_node // 2, cur_count * 2])\n            else:\n                q.put([-math.ceil(cur_node / 2), cur_count])\n                q.put([-math.floor(cur_node / 2), cur_count])\n    return False\nfor _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    nums.sort()\n    if f(sum(nums)):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\n\nclass Node:\n\n    def __init__(self, val, r=None, l=None):\n        self.value = val\n        self.right = r\n        self.left = l\nfor _ in range(t):\n    nuuu = int(input())\n    nums = [int(x) for x in input().split()]\n    mp = {}\n    for num in nums:\n        if num not in mp:\n            mp[num] = 1\n        else:\n            mp[num] += 1\n    tot = sum(nums)\n    from collections import deque\n    s = Node(tot)\n    q = deque()\n    q.append(s)\n    d = False\n    moves = 0\n    while len(q):\n        n = q.popleft()\n        if moves > nuuu - 1:\n            d = True\n            break\n        if n.value in mp and mp[n.value] > 0:\n            mp[n.value] -= 1\n        elif n.value == 1:\n            d = True\n            break\n        else:\n            n.left = Node(n.value // 2)\n            n.right = Node((n.value + 1) // 2)\n            q.append(n.right)\n            q.append(n.left)\n            moves += 1\n    if d:\n        print('NO')\n    else:\n        print('YES')"]