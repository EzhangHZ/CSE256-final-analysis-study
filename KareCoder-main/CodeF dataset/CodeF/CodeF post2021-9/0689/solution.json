["from sys import stdin\n\ndef solve_case():\n    n = int(stdin.readline())\n    segs = [tuple(map(int, stdin.readline().split())) + (i,) for i in range(n)]\n    segs.sort(key=lambda x: x[1])\n    par = [-1] * n\n    cnt_comp = n\n\n    def find_set(u):\n        p = u\n        while par[p] >= 0:\n            p = par[p]\n        while u != p:\n            t = par[u]\n            par[u] = p\n            u = t\n        return p\n\n    def join(u, v):\n        nonlocal cnt_comp\n        nonlocal par\n        u = find_set(u)\n        v = find_set(v)\n        if u == v:\n            return\n        if -par[u] < -par[v]:\n            (u, v) = (v, u)\n        par[u] += par[v]\n        par[v] = u\n        cnt_comp -= 1\n    hp = [[], []]\n    for (col, l, r, id) in segs:\n        for elm in hp[1 - col]:\n            if elm[0] < l:\n                continue\n            join(elm[1], id)\n        if len(hp[1 - col]):\n            hp[1 - col] = [max(hp[1 - col])]\n        hp[col].append((r, id))\n    return cnt_comp\nfor testcase in range(int(stdin.readline())):\n    print(solve_case())", "from collections import deque\ntc = int(input())\nfor t in range(tc):\n    n = int(input())\n    red = []\n    blue = []\n    for j in range(n):\n        (c, s, f) = map(int, input().split())\n        if c == 0:\n            red.append([s, f, 'r'])\n        else:\n            blue.append([s, f, 'b'])\n    red.sort(reverse=True)\n    blue.sort(reverse=True)\n    stck = deque()\n    coun = 0\n    while 1:\n        if len(stck) == 0 and blue and red:\n            coun = coun + 1\n            if red[-1][1] <= blue[-1][1]:\n                stck.append(red.pop())\n            else:\n                stck.append(blue.pop())\n        elif len(stck) == 0 and (len(blue) == 0 or len(red) == 0):\n            if len(blue) == 0:\n                coun = coun + len(red)\n                break\n            else:\n                coun = coun + len(blue)\n                break\n        q = stck.popleft()\n        if q[-1] == 'r':\n            while blue and blue[-1][0] <= q[1]:\n                if blue[-1][1] < q[0]:\n                    blue.pop()\n                    coun += 1\n                    continue\n                stck.append(blue.pop())\n        else:\n            while red and red[-1][0] <= q[1]:\n                if red[-1][1] < q[0]:\n                    red.pop()\n                    coun += 1\n                    continue\n                stck.append(red.pop())\n    print(coun)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ends = []\n    for i in range(n):\n        (c, l, r) = map(int, input().split())\n        ends.append((l, 0, c, i))\n        ends.append((r, 1, c, i))\n    ends.sort()\n    groups = n\n    wait = [set(), set()]\n    combined = [0, 0]\n    totals = [0, 0]\n    for (bound, is_closed, color, i) in ends:\n        if not is_closed:\n            if totals[1 - color] == 0:\n                wait[color].add(i)\n            elif len(wait[1 - color]) > 0:\n                L = len(wait[1 - color])\n                groups -= combined[1 - color] > 0\n                combined[1 - color] += L\n                wait[1 - color] = set()\n                combined[color] += 1\n                groups -= L\n            else:\n                combined[color] += 1\n                groups -= 1\n            totals[color] += 1\n        else:\n            if i in wait[color]:\n                wait[color].remove(i)\n            else:\n                combined[color] -= 1\n            totals[color] -= 1\n    print(groups)"]