["import functools\nimport sys\ninput = sys.stdin.readline\nMAX = sys.maxsize\nsys.setrecursionlimit(10 ** 9)\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef solve(l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = MAX\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])\n(n, l, k) = read()\nd = read()\na = read()\nprint(solve(l, k, d, a))", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmul = lambda : map(int, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\n\ndef f(n, k, l, d, a):\n    dp = {}\n\n    def sol(i, k, s):\n        if i >= n:\n            return 0\n        if dp.get((i, k, s)) != None:\n            return dp[i, k, s]\n        t = (d[i + 1] - d[i]) * a[i] + sol(i + 1, k, a[i])\n        if k > 0 and a[i] > s:\n            t = min((d[i + 1] - d[i]) * s + sol(i + 1, k - 1, s), t)\n        dp[i, k, s] = t\n        return t\n    ans = (d[1] - d[0]) * a[0] + sol(1, k, a[0])\n    print(ans)\n(n, l, k) = mul()\nd = seq()\na = seq()\nd.append(l)\nf(n, k, l, d, a)", "import functools\nimport sys\ninput = sys.stdin.readline\nMAX = sys.maxsize\nsys.setrecursionlimit(10 ** 9)\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef solve(l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = MAX\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])\n(n, l, k) = read()\nd = read()\na = read()\nprint(solve(l, k, d, a))", "import collections\n\ndef problem3(n, l, k, distance, speedLimit):\n    memo = collections.defaultdict(int)\n\n    def topdownDP(idx, numSings, v):\n        if numSings < 0:\n            return float('inf')\n        if idx == n:\n            return 0\n        if (idx, numSings, v) in memo:\n            return memo[idx, numSings, v]\n        if idx == 0:\n            memo[idx, numSings, v] = (distance[idx + 1] - distance[idx]) * v + topdownDP(idx + 1, numSings, v)\n        elif speedLimit[idx] < v:\n            memo[idx, numSings, v] = (distance[idx + 1] - distance[idx]) * speedLimit[idx] + topdownDP(idx + 1, numSings, speedLimit[idx])\n        else:\n            memo[idx, numSings, v] = min((distance[idx + 1] - distance[idx]) * speedLimit[idx] + topdownDP(idx + 1, numSings, speedLimit[idx]), (distance[idx + 1] - distance[idx]) * v + topdownDP(idx + 1, numSings - 1, v))\n        return memo[idx, numSings, v]\n    print(topdownDP(0, k, speedLimit[0]))\n(n, l, k) = [int(num) for num in input().split(' ')]\ndistance = [int(num) for num in input().split(' ')]\ndistance.append(l)\nspeedLimit = [int(num) for num in input().split(' ')]\nproblem3(n, l, k, distance, speedLimit)", "import functools\nimport sys\ninput = sys.stdin.readline\nMAX = sys.maxsize\nsys.setrecursionlimit(10 ** 9)\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef solve(l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = MAX\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return d[1] * a[0] + solve_rec(1, k, a[0])\n(n, l, k) = read()\nd = read()\na = read()\nprint(solve(l, k, d, a))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\nd = list(map(int, input().split()))\na = list(map(int, input().split()))\nd.append(l)\na.append(0)\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and a[i] > p:\n        res = min(res, p * (d[i + 1] - d[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, a[i] * (d[i + 1] - d[i]) + dfs(i + 1, k, a[i]))\n    dp[i, k, p] = res\n    return res\nprint(d[1] * a[0] + dfs(1, k, a[0]))", "import sys\nsys.setrecursionlimit(10 ** 9)\nfrom functools import lru_cache\n\ndef solve(l, k, d, a):\n    d.append(l)\n\n    @lru_cache(maxsize=None)\n    def dp(pos, k, speed):\n        if pos >= len(a):\n            return 0\n        res = float('inf')\n        if k > 0 and a[pos] > speed:\n            res = min(res, speed * (d[pos + 1] - d[pos]) + dp(pos + 1, k - 1, speed))\n        res = min(res, a[pos] * (d[pos + 1] - d[pos]) + dp(pos + 1, k, a[pos]))\n        return res\n    return dp(0, k, a[0])\n(n, l, k) = map(int, input().split())\nd = list(map(int, input().split()))\na = list(map(int, input().split()))\nprint(solve(l, k, d, a))", "(n, l, k) = map(int, input().split())\nsecond = list(map(int, input().split())) + [l]\nthird = list(map(int, input().split())) + [0]\ndict = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dict:\n        return dict[i, k, p]\n    if i == n:\n        return 0\n    result = float('inf')\n    if k > 0 and third[i] > p:\n        result = min(result, p * (second[i + 1] - second[i]) + dfs(i + 1, k - 1, p))\n    result = min(result, third[i] * (second[i + 1] - second[i]) + dfs(i + 1, k, third[i]))\n    dict[i, k, p] = result\n    return result\nprint(second[1] * third[0] + dfs(1, k, third[0]))", "import threading\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    (n, l, k) = map(int, input().split())\n    a = list(map(int, input().split())) + [l]\n    b = list(map(int, input().split())) + [0]\n    dp = {}\n\n    def dfs(i, k, p):\n        if (i, k, p) in dp:\n            return dp[i, k, p]\n        if i == n:\n            return 0\n        res = float('inf')\n        if k > 0 and b[i] > p:\n            res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n        res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n        dp[i, k, p] = res\n        return res\n    print(a[1] * b[0] + dfs(1, k, b[0]))\nthreading.stack_size(10 ** 6)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\ncoor = list(map(int, input().split())) + [l]\nlimits = list(map(int, input().split())) + [0]\nmemo = {}\n\ndef dfs(i, k, s):\n    if (i, k, s) in memo:\n        return memo[i, k, s]\n    if i == len(coor) - 1:\n        return 0\n    res = float('inf')\n    if i == 0:\n        res = (coor[i + 1] - coor[i]) * limits[i] + dfs(i + 1, k, limits[i])\n    elif k > 0 and limits[i] > s:\n        take = (coor[i + 1] - coor[i]) * s + dfs(i + 1, k - 1, s)\n        leave = (coor[i + 1] - coor[i]) * limits[i] + dfs(i + 1, k, limits[i])\n        res = min(take, leave)\n    else:\n        leave = (coor[i + 1] - coor[i]) * limits[i] + dfs(i + 1, k, limits[i])\n        res = leave\n    memo[i, k, s] = res\n    return memo[i, k, s]\nprint(dfs(0, k, None))", "import threading\nimport sys\nsys.setrecursionlimit(10 ** 8)\n\ndef main():\n    (n, l, k) = map(int, input().split())\n    a = list(map(int, input().split())) + [l]\n    b = list(map(int, input().split())) + [0]\n    dp = {}\n\n    def dfs(i, k, p):\n        if (i, k, p) in dp:\n            return dp[i, k, p]\n        if i == n:\n            return 0\n        res = float('inf')\n        if k > 0 and b[i] > p:\n            res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n        res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n        dp[i, k, p] = res\n        return res\n    print(a[1] * b[0] + dfs(1, k, b[0]))\nthreading.stack_size(10 ** 5)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\n\ndef main():\n    (n, l, k) = map(int, input().split())\n    a = list(map(int, input().split())) + [l]\n    b = list(map(int, input().split())) + [0]\n    dp = {}\n\n    def dfs(i, k, p):\n        if (i, k, p) in dp:\n            return dp[i, k, p]\n        if i == n:\n            return 0\n        res = float('inf')\n        if k > 0 and b[i] > p:\n            res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n        res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n        dp[i, k, p] = res\n        return res\n    print(a[1] * b[0] + dfs(1, k, b[0]))\nthreading.stack_size(10 ** 5)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import functools\nimport sys\ninput = sys.stdin.readline\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef solve(l, k, d, a):\n    d.append(l)\n    cache = {}\n\n    def solve_rec(position, drops, speed):\n        if (position, drops, speed) in cache:\n            return cache[position, drops, speed]\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        cache[position, drops, speed] = res\n        return res\n    return d[1] * a[0] + solve_rec(1, k, a[0])\n(n, l, k) = read()\nd = read()\na = read()\nprint(solve(l, k, d, a))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "import threading\nimport sys\nsys.setrecursionlimit(10 ** 5)\n\ndef main():\n    (n, l, k) = map(int, input().split())\n    a = list(map(int, input().split())) + [l]\n    b = list(map(int, input().split())) + [0]\n    dp = {}\n\n    def dfs(i, k, p):\n        if (i, k, p) in dp:\n            return dp[i, k, p]\n        if i == n:\n            return 0\n        res = float('inf')\n        if k > 0 and b[i] > p:\n            res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n        res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n        dp[i, k, p] = res\n        return res\n    print(a[1] * b[0] + dfs(1, k, b[0]))\nthreading.stack_size(10 ** 5)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "(n, l, k) = map(int, input().split())\na = list(map(int, input().split())) + [l]\nb = list(map(int, input().split())) + [0]\ndp = {}\n\ndef dfs(i, k, p):\n    if (i, k, p) in dp:\n        return dp[i, k, p]\n    if i == n:\n        return 0\n    res = float('inf')\n    if k > 0 and b[i] > p:\n        res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n    res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n    dp[i, k, p] = res\n    return res\nprint(a[1] * b[0] + dfs(1, k, b[0]))", "import threading\nimport sys\nsys.setrecursionlimit(10 ** 8)\n\ndef main():\n    (n, l, k) = map(int, input().split())\n    a = list(map(int, input().split())) + [l]\n    b = list(map(int, input().split())) + [0]\n    dp = {}\n\n    def dfs(i, k, p):\n        if (i, k, p) in dp:\n            return dp[i, k, p]\n        if i == n:\n            return 0\n        res = float('inf')\n        if k > 0 and b[i] > p:\n            res = min(res, p * (a[i + 1] - a[i]) + dfs(i + 1, k - 1, p))\n        res = min(res, b[i] * (a[i + 1] - a[i]) + dfs(i + 1, k, b[i]))\n        dp[i, k, p] = res\n        return res\n    print(a[1] * b[0] + dfs(1, k, b[0]))\nthreading.stack_size(10 ** 7)\nt = threading.Thread(target=main)\nt.start()\nt.join()"]