["import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    n = int(inp())\n    a = list(map(int, inp().split()))\n    b = list(map(int, inp().split()))\n    st = [(int(1000000000.0 + 7), n)]\n    next = [None] * n\n    for i in range(n - 1, -1, -1):\n        v = b[i]\n        while st[-1][0] <= v:\n            st.pop()\n        next[i] = st[-1][1]\n        st.append((v, i))\n    m = int(inp())\n    have = dict()\n    for v in map(int, inp().split()):\n        have[v] = have.get(v, 0) + 1\n    need = dict()\n    last = dict()\n    for i in range(n):\n        if a[i] < b[i]:\n            print('NO')\n            return\n        if a[i] == b[i]:\n            continue\n        v = b[i]\n        val = last.get(v, None)\n        if val is None:\n            need[v] = 1\n        elif next[val] < i:\n            need[v] += 1\n        last[v] = i\n    for (k, v) in need.items():\n        if have.get(k, 0) < v:\n            print('NO')\n            return\n    print('YES')\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    have = list(map(int, input().split(' ')))\n    req = list(map(int, input().split(' ')))\n    m = int(input())\n    razors = list(map(int, input().split(' ')))\n    razors = Counter(razors)\n\n    def solve(n):\n        for i in range(n):\n            if req[i] > have[i]:\n                return False\n        stack = []\n        for i in range(n):\n            while stack and stack[-1] < req[i]:\n                stack.pop()\n            if req[i] == have[i]:\n                continue\n            if stack and stack[-1] == req[i]:\n                continue\n            if req[i] not in razors or razors[req[i]] == 0:\n                return False\n            razors[req[i]] -= 1\n            stack.append(req[i])\n        return True\n    ans = solve(n)\n    if ans:\n        print('YES')\n    else:\n        print('NO')", "import heapq\nT = int(input())\nimport collections\nwhile T > 0:\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = int(input())\n    X = list(map(int, input().split()))\n    counter = collections.Counter(X)\n    sign = 1\n    heap = []\n    for i in range(n):\n        if B[i] > A[i]:\n            print('NO')\n            sign = 0\n            break\n        while heap and heap[0] < B[i]:\n            heapq.heappop(heap)\n        if B[i] < A[i] and (not heap or heap[0] > B[i]):\n            if counter[B[i]] == 0:\n                print('NO')\n                sign = 0\n                break\n            else:\n                counter[B[i]] -= 1\n                heapq.heappush(heap, B[i])\n    if sign:\n        print('YES')\n    T -= 1", "import heapq\nT = int(input())\nimport collections\nwhile T > 0:\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = int(input())\n    X = list(map(int, input().split()))\n    counter = collections.Counter(X)\n    sign = 1\n    heap = []\n    for i in range(n):\n        if B[i] > A[i]:\n            print('NO')\n            sign = 0\n            break\n        while heap and heap[0] < B[i]:\n            heapq.heappop(heap)\n        if B[i] < A[i] and (not heap or heap[0] > B[i]):\n            if counter[B[i]] == 0:\n                print('NO')\n                sign = 0\n                break\n            else:\n                counter[B[i]] -= 1\n                heapq.heappush(heap, B[i])\n    if sign:\n        print('YES')\n    T -= 1", "import heapq\nT = int(input())\nimport collections\nwhile T > 0:\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = int(input())\n    X = list(map(int, input().split()))\n    counter = collections.Counter(X)\n    sign = 1\n    heap = []\n    for i in range(n):\n        if B[i] > A[i]:\n            print('NO')\n            sign = 0\n            break\n        while heap and heap[0] < B[i]:\n            heapq.heappop(heap)\n        if B[i] < A[i] and (not heap or heap[0] > B[i]):\n            if counter[B[i]] == 0:\n                print('NO')\n                sign = 0\n                break\n            else:\n                counter[B[i]] -= 1\n                heapq.heappush(heap, B[i])\n    if sign:\n        print('YES')\n    T -= 1", "import heapq\nT = int(input())\nimport collections\nwhile T > 0:\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    m = int(input())\n    X = list(map(int, input().split()))\n    counter = collections.Counter(X)\n    sign = 1\n    heap = []\n    for i in range(n):\n        if B[i] > A[i]:\n            print('NO')\n            sign = 0\n            break\n        while heap and heap[0] < B[i]:\n            heapq.heappop(heap)\n        if B[i] < A[i] and (not heap or heap[0] > B[i]):\n            if counter[B[i]] == 0:\n                print('NO')\n                sign = 0\n                break\n            else:\n                counter[B[i]] -= 1\n                heapq.heappush(heap, B[i])\n    if sign:\n        print('YES')\n    T -= 1", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) for i in input().strip().split()]\n    b = [int(i) for i in input().strip().split()]\n    m = int(input())\n    x = [int(i) for i in input().strip().split()]\n    d = {}\n    for xi in x:\n        d[xi] = d.get(xi, 0) + 1\n    del x\n    check = True\n    for i in range(n):\n        if b[i] > a[i] or (b[i] not in d and a[i] != b[i]):\n            check = False\n            break\n    if not check:\n        print('NO')\n    else:\n        right_max = [n] * n\n        s = deque()\n        for i in range(n):\n            while s and b[s[-1]] < b[i]:\n                right_max[s.pop()] = i\n            s.append(i)\n        done = {}\n        check = True\n        for i in range(n):\n            if a[i] != b[i]:\n                if b[i] in done and done[b[i]] > i:\n                    continue\n                if d[b[i]] == 0:\n                    check = False\n                    break\n                done[b[i]] = right_max[i]\n                d[b[i]] -= 1\n        if not check:\n            print('NO')\n        else:\n            print('YES')", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    m = int(input())\n    x = Counter([int(i) for i in input().split()])\n    stack = list()\n    flag = True\n    for i in range(n):\n        if a[i] < b[i]:\n            flag = False\n            break\n        for j in range(len(stack) - 1, -1, -1):\n            if b[i] > stack[j]:\n                stack.pop()\n            else:\n                break\n        if b[i] == a[i]:\n            continue\n        if len(stack) == 0 or b[i] != stack[len(stack) - 1]:\n            if x[b[i]] == 0:\n                flag = False\n                break\n            x[b[i]] -= 1\n            stack.append(b[i])\n    if flag:\n        print('YES')\n    else:\n        print('NO')", "import heapq\niter = int(input())\nfor i in range(iter):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    b = list(map(int, input().split(' ')))\n    m = input()\n    x = list(map(int, input().split(' ')))\n    razor_sizes = {}\n    for i in x:\n        razor_sizes[i] = razor_sizes.get(i, 0) + 1\n    heap = []\n    heapq.heapify(heap)\n    ans = 1\n    for i in range(n):\n        ex = 0\n        while len(heap):\n            val = heapq.heappop(heap)\n            if val < b[i]:\n                if razor_sizes.get(val, 0) == 0:\n                    ans = 0\n                    break\n                else:\n                    razor_sizes[val] -= 1\n            if val == b[i]:\n                ex = 1\n                heapq.heappush(heap, val)\n                break\n            if val > b[i]:\n                heapq.heappush(heap, val)\n                break\n        if ans == 0:\n            break\n        if a[i] < b[i]:\n            ans = 0\n        elif a[i] > b[i] and (not ex):\n            heapq.heappush(heap, b[i])\n    while len(heap):\n        val = heapq.heappop(heap)\n        if razor_sizes.get(val, 0) == 0:\n            ans = 0\n            break\n        else:\n            razor_sizes[val] -= 1\n    if ans == 0:\n        print('NO')\n    else:\n        print('YES')", "t = int(input(''))\nfor _ in range(t):\n    n = int(input(''))\n    a = [int(x) for x in input('').split(' ')]\n    b = [int(x) for x in input('').split(' ')]\n    m = int(input(''))\n    x = [int(x) for x in input('').split(' ')]\n    bad = False\n    for i in range(n):\n        if a[i] < b[i]:\n            bad = True\n            break\n    if bad:\n        print('NO')\n        continue\n    stack = []\n    right = [-1] * n\n    for i in range(n):\n        while stack and b[stack[-1]] < b[i]:\n            stack.pop()\n        if stack and b[stack[-1]] == b[i]:\n            right[stack[-1]] = i\n            stack[-1] = i\n        stack.append(i)\n    h = {}\n    for i in range(m):\n        if x[i] in h:\n            h[x[i]] += 1\n        else:\n            h[x[i]] = 1\n    v = [a[i] != b[i] for i in range(n)]\n    out = 'YES'\n    for i in range(n):\n        if v[i]:\n            cur = i\n            u = b[cur]\n            if u not in h or h[u] == 0:\n                out = 'NO'\n                break\n            h[u] -= 1\n            while cur != -1:\n                v[cur] = False\n                cur = right[cur]\n    print(out)"]