["import sys\ninput = lambda : sys.stdin.readline().rstrip('\\n\\r')\nsys.setrecursionlimit(10 ** 6)\nfrom collections import Counter, defaultdict, deque\nfrom itertools import accumulate, chain, zip_longest, product, repeat\nfrom bisect import bisect_left, bisect_right\nfrom math import gcd\nfrom string import ascii_lowercase\nfrom functools import cmp_to_key\nmod = 10 ** 9 + 7\nmod_2 = 998244353\n\ndef node_cost(tree, root):\n    if root << 1 >= len(tree):\n        return (0, tree[root])\n    (cx, sx) = node_cost(tree, root << 1)\n    (cy, sy) = node_cost(tree, root << 1 | 1)\n    if sx != sy:\n        if sx < sy:\n            return (cx + cy + 1, tree[root] + sx + sy)\n        else:\n            return (cx + cy + 1, tree[root] + sy + sx)\n    else:\n        return (cx + cy, tree[root] + sx + sy)\n\ndef solve():\n    n = int(input())\n    tree = ['$'] + list(input())\n    (ans, _) = node_cost(tree, 1)\n    return pow(2, ans, mod_2)\nval = solve()\nprint(val)", "import sys\nN = int(sys.stdin.readline().strip())\ns = sys.stdin.readline().strip()\nm = 1 << N\nmod = 998244353\n\ndef dfs(i):\n    if i >= m:\n        return (1, '')\n    (ln, ls) = dfs(i * 2)\n    (rn, rs) = dfs(i * 2 + 1)\n    if ls < rs:\n        return (ln * rn * 2 % mod, ls + s[i - 1] + rs)\n    elif ls > rs:\n        return (ln * rn * 2 % mod, rs + s[i - 1] + ls)\n    else:\n        return (ln * rn % mod, ls + s[i - 1] + rs)\n(n, _) = dfs(1)\nprint(n)", "if True:\n\n    def compute_hashes(v):\n        if v < nodes_count:\n            (l, r) = sorted([compute_hashes(2 * v), compute_hashes(2 * v + 1)])\n            b[v] = l + b[v] + r\n            return b[v]\n        return b[v]\n    n = int(input())\n    nodes_count = 2 ** (n - 1)\n    s = input()\n    b = ['dum']\n    for c in s:\n        b.append(c)\n    compute_hashes(1)\n    res = sum([1 for i in range(1, nodes_count) if b[2 * i] != b[2 * i + 1]])\n    print(2 ** res % 998244353)", "import sys\nN = int(sys.stdin.readline().strip())\ns = sys.stdin.readline().strip()\nm = 1 << N\nmod = 998244353\n\ndef dfs(i):\n    if i >= m:\n        return (1, '')\n    (ln, ls) = dfs(i * 2)\n    (rn, rs) = dfs(i * 2 + 1)\n    ln = ln % mod\n    rn = rn % mod\n    if ls < rs:\n        return (ln * rn * 2, ls + s[i - 1] + rs)\n    elif ls > rs:\n        return (ln * rn * 2, rs + s[i - 1] + ls)\n    else:\n        return (ln * rn, ls + s[i - 1] + rs)\n(n, _) = dfs(1)\nprint(n % mod)", "mod = 998244353\ncnt = 0\nn = int(input())\ns = input()\nimport random\nq = random.randint(10 ** 9, 2 * 10 ** 9)\np = random.randint(10 ** 9, 2 * 10 ** 9)\nr = 10 ** 9 + 7\na = [-1]\nfor i in s:\n    if i == 'A':\n        a.append(p)\n    else:\n        a.append(q)\nfor i in range(2 ** (n - 1) - 1, 0, -1):\n    if a[2 * i] != a[2 * i + 1]:\n        cnt += 1\n    a[i] = a[i] ^ 2 * a[2 * i] + 2 * a[2 * i + 1]\n    a[i] %= r\nprint(pow(2, cnt, mod))", "n = int(input())\ns = input()\na = [-1]\nfor i in range(0, 2 ** n - 1):\n    if s[i] == 'A':\n        a.append('A')\n    else:\n        a.append('B')\nres = 1\nfor i in range(2 ** (n - 1) - 1, 0, -1):\n    if a[2 * i] == a[2 * i + 1]:\n        a[i] = a[i] + a[2 * i] + a[2 * i + 1]\n    elif a[2 * i] < a[2 * i + 1]:\n        res = res * 2 % 998244353\n        a[i] = a[i] + a[2 * i] + a[2 * i + 1]\n    else:\n        res = res * 2 % 998244353\n        a[i] = a[i] + a[2 * i + 1] + a[2 * i]\nprint(res)", "if True:\n\n    def compute_hashes(v):\n        (l, r) = sorted([compute_hashes(2 * v), compute_hashes(2 * v + 1)] if v < nodes_count else ('', ''))\n        b[v] = l + b[v] + r\n        return b[v]\n    n = int(input())\n    nodes_count = 2 ** (n - 1)\n    s = input()\n    b = ['dum']\n    for c in s:\n        b.append(c)\n    compute_hashes(1)\n    res = sum([1 for i in range(1, nodes_count) if b[2 * i] != b[2 * i + 1]])\n    print(2 ** res % 998244353)", "MOD = 998244353\n(n, s) = (int(input()), input())\n\ndef calc(u: int) -> tuple:\n    if u >= 1 << n:\n        return (0, 0)\n    (t1, t2) = (calc(u * 2), calc(u * 2 + 1))\n    return (t1[0] + t2[0] + (t1[1] != t2[1]), hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))\nprint(pow(2, calc(1)[0], MOD))", "MOD = 998244353\n(n, s) = (int(input()), input())\n\ndef calc(u: int) -> tuple:\n    if u >= 1 << n:\n        return (0, 0)\n    (t1, t2) = (calc(u * 2), calc(u * 2 + 1))\n    return (t1[0] + t2[0] + (t1[1] != t2[1]), hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))\nprint(pow(2, calc(1)[0], MOD))", "MOD = 998244353\n(n, s) = (int(input()), input())\n\ndef calc(u: int) -> tuple:\n    if u >= 1 << n:\n        return (0, 0)\n    (t1, t2) = (calc(u * 2), calc(u * 2 + 1))\n    return (t1[0] + t2[0] + (t1[1] != t2[1]), hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))\nprint(pow(2, calc(1)[0], MOD))", "MOD = 998244353\n(n, s) = (int(input()), input())\n\ndef calc(u: int) -> tuple:\n    if u >= 1 << n:\n        return (0, 0)\n    (t1, t2) = (calc(u * 2), calc(u * 2 + 1))\n    return (t1[0] + t2[0] + (t1[1] != t2[1]), hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))\nprint(pow(2, calc(1)[0], MOD))", "MOD = 998244353\n(n, s) = (int(input()), input())\n\ndef calc(u: int) -> tuple:\n    if u >= 1 << n:\n        return (1, 0)\n    (t1, t2) = (calc(u * 2), calc(u * 2 + 1))\n    return (t1[0] * t2[0] * (2 if t1[1] != t2[1] else 1) % MOD, hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))\nprint(calc(1)[0])", "MOD = 998244353\n(n, s) = (int(input()), input())\n\ndef calc(u: int) -> tuple:\n    if u >= 1 << n:\n        return (0, 0)\n    (t1, t2) = (calc(u * 2), calc(u * 2 + 1))\n    return (t1[0] + t2[0] + (t1[1] != t2[1]), hash((min(t1[1], t2[1]), max(t1[1], t2[1]), s[u - 1])))\nprint(pow(2, calc(1)[0], MOD))", "N = int(input())\nN = 2 ** N\nS = input()\nU = [0] * N\ncnt = 0\nfor i in range(N - 2, -1, -1):\n    a = 2 * i + 1\n    b = 2 * i + 2\n    if b >= N:\n        U[i] = ord(S[i])\n        continue\n    if U[a] != U[b]:\n        cnt += 1\n    U[i] = ord(S[i]) + 331 * min(U[a], U[b]) + 3331 * max(U[a], U[b]) + min(U[a], U[b]) ** 2\n    U[i] %= 2 ** 104\nprint(pow(2, cnt, 998244353))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\ninp = lambda : list(map(int, input().split()))\nmod = 998244353\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef solve(i):\n    if i >= (1 << n) - 1:\n        return ['', 1]\n    left = solve(2 * i + 1)\n    right = solve(2 * i + 2)\n    if left[0] == right[0]:\n        ans = mul(left[1], right[1])\n    else:\n        ans = mul(2 * left[1], right[1])\n    st = a[i] + min(left[0], right[0]) + max(left[0], right[0])\n    return [st, ans]\n\ndef answer():\n    ans = solve(0)\n    return ans[1]\nfor T in range(1):\n    n = int(input())\n    a = input().strip()\n    print(answer())", "import sys\nMOD = 998244353\nn = int(next(sys.stdin))\ns = next(sys.stdin)\nm = len(s) - 1\nh = [0 for i in range(m)]\nf = [[0, 0] for i in range(m)]\nfor i in range(m - 1, -1, -1):\n    l = (i + 1) * 2 - 1\n    r = (i + 1) * 2\n    c = int(s[i] == 'B')\n    if l < m:\n        h[i] = h[l] * 2 + 1\n        p1 = min(f[l][0], f[r][0])\n        p2 = max(f[l][0], f[r][0])\n        f[i][0] = (p1 << h[l]) + p2 + (c << h[i] - 1)\n        f[i][1] = f[l][1] * f[r][1] % MOD\n        if p1 != p2:\n            f[i][1] = f[i][1] * 2 % MOD\n    else:\n        f[i][0] = c\n        f[i][1] = 1\n        h[i] = 1\nprint(f[0][1])", "class Node:\n\n    def __init__(self, v, left, right):\n        self.v = v\n        self.left = left\n        self.right = right\n\n    def f(self):\n        if self.left is None:\n            return (1, self.v)\n        (lc, lp) = self.left.f()\n        (rc, rp) = self.right.f()\n        return ((1 + int(lp != rp)) * lc * rc % 998244353, self.v + ''.join(sorted([lp, rp])))\n\ndef construct(s, i):\n    if i >= len(s):\n        return None\n    return Node(s[i], construct(s, i * 2 + 1), construct(s, i * 2 + 2))\nn = int(input())\ns = input().strip()\nprint(construct(s, 0).f()[0])", "import sys\nsys.setrecursionlimit(int(10000000.0))\nimport functools\nn = int(input())\ns = input()\n\nclass Node:\n\n    def __init__(self, v, left, right):\n        self.left = left\n        self.right = right\n        self.v = v\n\n    @functools.lru_cache(maxsize=None)\n    def get_subtree_string(self):\n        if not self.left or not self.right:\n            return self.v\n        if self.left.get_subtree_string() > self.right.get_subtree_string():\n            (self.left, self.right) = (self.right, self.left)\n        return self.left.get_subtree_string() + self.v + self.right.get_subtree_string()\n\ndef cnt_diff(root):\n    if not root.left or not root.right:\n        return 1\n    ret = cnt_diff(root.left) * cnt_diff(root.right)\n    ret *= 2 if root.left.get_subtree_string() != root.right.get_subtree_string() else 1\n    ret %= 998244353\n    return ret\nnodes = [None, Node(s[0], None, None)]\n\ndef create_tree_from_string(s):\n    s = 'x' + s\n    for i in range(1, 2 ** n // 2):\n        (j, k) = (i * 2, i * 2 + 1)\n        nodes.extend([Node(s[j], None, None), Node(s[k], None, None)])\n        root = nodes[i]\n        (root.left, root.right) = (nodes[j], nodes[k])\n    return nodes[1]\nroot = create_tree_from_string(s)\nres = cnt_diff(root)\nprint(res)"]