["from collections import defaultdict, Counter, deque\nimport threading\nimport sys\ninput = sys.stdin.readline\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    (n, d) = rl()\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = rl()\n        g[u].append(v)\n        g[v].append(u)\n    a = rl()\n    b = rl()\n    for i in a[1:]:\n        vis_a[i] = 1\n    for i in b[1:]:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    print(res[0])\n    pass\nthreading.Thread(target=main).start()"]