["MAX_BITS = 32\n\ndef to_bin(dec_number):\n    return bin(dec_number).replace('0b', '')\n\ndef pick_best(dec_numbers, or_prefix_dec):\n    best_result = 0\n    best_dec_pick = None\n    best_pick_index = None\n    for (index, dec_number) in dec_numbers.items():\n        result = or_prefix_dec | dec_number\n        if result > best_result:\n            best_result = result\n            best_dec_pick = dec_number\n            best_pick_index = index\n    return (best_dec_pick, best_pick_index)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        _ = int(input())\n        dec_numbers = list(map(int, input().split()))\n        dec_numbers = {index: number for (index, number) in enumerate(dec_numbers)}\n        ordered_numbers = list()\n        or_prefix_dec = 0\n        or_prefix_bin = to_bin(or_prefix_dec).zfill(MAX_BITS)\n        bit_index = 0\n        while bit_index < MAX_BITS:\n            if or_prefix_bin[bit_index] == '1':\n                bit_index += 1\n                continue\n            (best_dec_pick, best_pick_index) = pick_best(dec_numbers, or_prefix_dec)\n            if best_pick_index is not None:\n                or_prefix_dec = or_prefix_dec | best_dec_pick\n                or_prefix_bin = to_bin(or_prefix_dec).zfill(MAX_BITS)\n                ordered_numbers.append(best_dec_pick)\n                del dec_numbers[best_pick_index]\n            bit_index += 1\n        ordered_numbers += list(dec_numbers.values())\n        print(' '.join([str(number) for number in ordered_numbers]))\nsolve()", "MAX_BITS = 32\n\ndef to_bin(dec_number):\n    return bin(dec_number).replace('0b', '')\n\ndef pick_best(dec_numbers, or_prefix_dec):\n    best_result = 0\n    best_dec_pick = None\n    best_pick_index = None\n    for (index, dec_number) in dec_numbers.items():\n        result = or_prefix_dec | dec_number\n        if result > best_result:\n            best_result = result\n            best_dec_pick = dec_number\n            best_pick_index = index\n    return (best_dec_pick, best_pick_index)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        _ = int(input())\n        dec_numbers = list(map(int, input().split()))\n        dec_numbers = {index: number for (index, number) in enumerate(dec_numbers)}\n        ordered_numbers = list()\n        or_prefix_dec = 0\n        or_prefix_bin = to_bin(or_prefix_dec).zfill(MAX_BITS)\n        bit_index = 0\n        while bit_index < MAX_BITS:\n            if or_prefix_bin[bit_index] == '1':\n                bit_index += 1\n                continue\n            (best_dec_pick, best_pick_index) = pick_best(dec_numbers, or_prefix_dec)\n            if best_pick_index is not None:\n                or_prefix_dec = or_prefix_dec | best_dec_pick\n                or_prefix_bin = to_bin(or_prefix_dec).zfill(MAX_BITS)\n                ordered_numbers.append(best_dec_pick)\n                del dec_numbers[best_pick_index]\n            bit_index += 1\n        ordered_numbers += list(dec_numbers.values())\n        print(' '.join([str(number) for number in ordered_numbers]))\nsolve()", "def f():\n    P = int(input())\n    (*a,) = map(int, input().split())\n    tek = 0\n    ans = []\n    z = []\n    b = a + []\n    while b:\n        c = []\n        best = 0\n        for i in b:\n            if best == 0:\n                best = i\n            elif i | tek > tek and i | tek > best | tek and (best > -1):\n                c += [best]\n                best = i\n            elif i | tek > tek and i | tek <= best | tek:\n                c += [i]\n            else:\n                z += [i]\n        b = c + []\n        tek |= best\n        ans += [best]\n    print(*ans + z)\nfor i in range(int(input())):\n    f()", "def solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        bits = 32\n        mask = 0\n        rearranged = []\n        for i in range(bits):\n            bitmask = 1 << bits - 1 - i\n            if mask & bitmask:\n                continue\n            best = None\n            for (idx, v) in enumerate(a):\n                if not v & bitmask:\n                    continue\n                if best is None:\n                    best = idx\n                    continue\n                if v & (v ^ mask) > a[best] & (a[best] ^ mask):\n                    best = idx\n            if best is not None:\n                rearranged.append(a[best])\n                mask |= a[best]\n        for r in rearranged:\n            a.remove(r)\n        rearranged += a\n        print(' '.join(map(str, rearranged)))\nsolve()", "def f():\n    n = int(input())\n    (*a,) = map(int, input().split())\n    tek = 0\n    ans = []\n    z = []\n    b = a + []\n    while b:\n        c = []\n        best = 0\n        for i in b:\n            if best == 0:\n                best = i\n            elif i | tek > tek and i | tek > best | tek and (best > -1):\n                c += [best]\n                best = i\n            elif i | tek > tek and i | tek <= best | tek:\n                c += [i]\n            else:\n                z += [i]\n        b = c + []\n        tek |= best\n        ans += [best]\n    print(*ans + z)\nfor i in range(int(input())):\n    f()", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    m = int(input())\n    f = [*map(int, input().split())]\n    pre = 0\n    answ = []\n    while f:\n        f.sort(key=lambda x: x | pre)\n        answ.append(f.pop())\n        if pre == pre | answ[-1]:\n            break\n        pre |= answ[-1]\n    print(*answ, *f)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "test = int(input())\nfor _ in range(test):\n    noice = int(input())\n    asta = list(map(int, input().split()))\n    asta.sort()\n    (resque, curras) = ([asta[-1]], asta[-1])\n    asta.pop()\n    while asta:\n        asta.sort(key=lambda x: x | curras)\n        resque.append(asta.pop())\n        if curras == resque[-1] | curras:\n            break\n        else:\n            curras = resque[-1] | curras\n    resque += asta\n    print(*resque)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    num = [*read()]\n    (res, cur) = ([], 0)\n    while num:\n        num.sort(key=lambda i: i | cur)\n        res.append(num.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *num)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    diff = []\n    same = []\n    st = set()\n    for i in range(n):\n        if arr[i] in st:\n            same.append(arr[i])\n        else:\n            diff.append(arr[i])\n            st.add(arr[i])\n    curr = 0\n    max = 0\n    max_idx = 0\n    st2 = set()\n    ans = []\n    flag = False\n    while len(st2) < len(diff):\n        for i in range(len(diff)):\n            if diff[i] not in st2:\n                if curr | diff[i] == curr:\n                    st2.add(diff[i])\n                    same.append(diff[i])\n                elif curr | diff[i] > max:\n                    max = curr | diff[i]\n                    max_idx = i\n                    flag = True\n        curr = max\n        if flag:\n            ans.append(diff[max_idx])\n            st2.add(diff[max_idx])\n        flag = False\n    main = ans + same\n    print(*main)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "import sys\nread = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(int(input())):\n    n = int(input())\n    nums = [*read()]\n    (res, cur) = ([], 0)\n    while nums:\n        nums.sort(key=lambda i: i | cur)\n        res.append(nums.pop())\n        check = cur | res[-1]\n        if check == cur:\n            break\n        cur = check\n    print(*res, *nums)", "for _ in range(int(input())):\n    n = int(input())\n    a = [*map(int, input().split())]\n    pre = 0\n    ans = []\n    while a:\n        a.sort(key=lambda x: x | pre)\n        ans.append(a.pop())\n        if pre == pre | ans[-1]:\n            break\n        pre |= ans[-1]\n    print(*ans, *a)", "t = int(input())\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    num = 0\n    ans = []\n    while arr:\n        arr.sort(key=lambda x: x | num)\n        ans += [arr.pop()]\n        if num == num | ans[-1]:\n            break\n        num |= ans[-1]\n    print(*ans, *arr)\nwhile t:\n    solve()\n    t -= 1", "import sys\nR = sys.stdin.readline\nfor _ in range(int(R())):\n    n = int(R())\n    arr = [*map(int, R().split())]\n    s = 0\n    for m in arr:\n        s |= m\n    arr.sort(reverse=True)\n    (temp, i) = (s - (s & arr[0]), 1)\n    while temp:\n        arr[i:] = sorted(arr[i:], key=lambda x: x & temp, reverse=True)\n        temp -= arr[i] & temp\n        i += 1\n    print(*arr)", "import sys\nR = sys.stdin.readline\nfor _ in range(int(R())):\n    n = int(R())\n    arr = [*map(int, R().split())]\n    s = 0\n    for m in arr:\n        s |= m\n    arr.sort(reverse=True)\n    (temp, i) = (s - (s & arr[0]), 1)\n    while temp:\n        arr[i:] = sorted(arr[i:], key=lambda x: x & temp, reverse=True)\n        temp -= arr[i] & temp\n        i += 1\n    print(*arr)", "def solve(A):\n    n = len(A)\n    mask = 0\n    res = []\n    while n:\n        best_i = -1\n        for i in range(n):\n            if best_i == -1 or A[i] | mask > A[best_i] | mask:\n                best_i = i\n        if mask | A[best_i] == mask:\n            break\n        mask |= A[best_i]\n        res.append(A[best_i])\n        A = A[:best_i] + A[best_i + 1:]\n        n -= 1\n    res.extend(A)\n    return ' '.join([str(e) for e in res])\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        A = [int(e) for e in input().split()]\n        print(solve(A))\nmain()", "def solve(A):\n    n = len(A)\n    mask = 0\n    res = []\n    while n:\n        best_i = -1\n        for i in range(n):\n            if best_i == -1 or A[i] | mask > A[best_i] | mask:\n                best_i = i\n        if mask | A[best_i] == mask:\n            break\n        mask |= A[best_i]\n        res.append(A[best_i])\n        A = A[:best_i] + A[best_i + 1:]\n        n -= 1\n    res.extend(A)\n    return ' '.join([str(e) for e in res])\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        A = [int(e) for e in input().split()]\n        print(solve(A))\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = []\n    prefix = 0\n    for i in range(32):\n        f = True\n        d = prefix\n        idx = 0\n        for j in range(len(arr)):\n            if arr[j] | prefix > d:\n                d = arr[j] | prefix\n                f = False\n                idx = j\n        if f:\n            ans += arr\n            break\n        ans.append(arr[idx])\n        prefix = d\n        arr.pop(idx)\n    print(*ans)", "f = lambda x: (31 - len(bin(int(x))[2:])) * '0' + bin(int(x))[2:]\nf2 = lambda x: int(x, 2)\nfor cc in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ret = []\n    cur = 0\n    for x in range(32):\n        if not arr:\n            break\n        mx = max(arr, key=lambda b: b | cur)\n        ret.append(mx)\n        arr.remove(mx)\n        cur = mx | cur\n    print(*ret + arr)", "t = int(input())\n\ndef indx(X):\n    nx = 0\n    for i in range(len(X)):\n        if X[i] > X[nx]:\n            nx = i\n    return nx\nfor _ in range(t):\n    n = int(input())\n    A = list(map(int, input().split(' ')))\n    B = A.copy()\n    C = [0] * n\n    D = []\n    nx = indx(A)\n    while A[nx] > 0:\n        C[nx] = 1\n        D.append(nx)\n        dx = ~A[nx]\n        for i in range(n):\n            A[i] &= dx\n        nx = indx(A)\n    for i in D:\n        print(B[i], end=' ')\n    for i in range(n):\n        if C[i] == 0:\n            print(B[i], end=' ')\n    print()", "for _ in range(int(input())):\n    n = int(input())\n    arr = [*map(int, input().split())]\n    curr = 0\n    for j in range(31):\n        arr = sorted(arr, key=lambda x: x | curr)\n        x = arr.pop()\n        curr |= x\n        print(x, end=' ')\n        if len(arr) == 0:\n            break\n    print(*arr)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n):\n    a = sorted(a)[::-1]\n    cur = 0\n    ans = []\n    visited = [False] * n\n    for i in range(30):\n        (mx, idx) = (0, -1)\n        for (j, x) in enumerate(a):\n            if visited[j]:\n                continue\n            v = cur | x\n            if v > mx:\n                mx = v\n                idx = j\n        if idx == -1:\n            continue\n        cur |= a[idx]\n        visited[idx] = True\n        ans.append(a[idx])\n    for (i, x) in enumerate(a):\n        if not visited[i]:\n            ans.append(x)\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(' '.join((str(x) for x in solve(a, n))))", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n):\n    a = sorted(a)[::-1]\n    cur = 0\n    ans = []\n    visited = [False] * n\n    for i in range(30, -1, -1):\n        (mx, idx) = (0, -1)\n        for (j, x) in enumerate(a):\n            if visited[j]:\n                continue\n            v = cur | x\n            if v > mx:\n                mx = v\n                idx = j\n        if idx == -1:\n            continue\n        cur |= a[idx]\n        visited[idx] = True\n        ans.append(a[idx])\n    for (i, x) in enumerate(a):\n        if not visited[i]:\n            ans.append(x)\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(' '.join((str(x) for x in solve(a, n))))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    done = [False] * n\n    (res, val, idx, temp) = (0, 0, 0, 0)\n    ans = []\n    while not all(done):\n        changed = False\n        for i in range(n):\n            if not done[i]:\n                val = res | nums[i]\n                if val > temp:\n                    changed = True\n                    temp = val\n                    idx = i\n        if changed:\n            res = temp\n            ans.append(nums[idx])\n            done[idx] = True\n        else:\n            break\n    for i in range(n):\n        if not done[i]:\n            ans.append(nums[i])\n    for i in ans:\n        print(i, end=' ')\n    print('')", "for _ in range(int(input())):\n    n = int(input())\n    a = sorted([int(x) for x in input().split()])\n    res = [a[-1]]\n    m = a[-1]\n    ans = []\n    a = a[:-1]\n    for j in range(0, min(31, len(a))):\n        t = -1\n        ind = -1\n        for i in range(len(a)):\n            if m | a[i] > t:\n                t = m | a[i]\n                ind = i\n        ans.append(a[ind])\n        del a[ind]\n        m = t\n    res.extend(ans)\n    res.extend(a)\n    print(*res)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n):\n    a = sorted(a)[::-1]\n    cur = 0\n    ans = []\n    visited = [False] * n\n    for i in range(30, -1, -1):\n        (mx, idx) = (0, -1)\n        for (j, x) in enumerate(a):\n            if cur & 1 << i or visited[j]:\n                continue\n            v = cur | x\n            if v > mx:\n                mx = v\n                idx = j\n        if idx == -1:\n            continue\n        cur |= a[idx]\n        visited[idx] = True\n        ans.append(a[idx])\n    for (i, x) in enumerate(a):\n        if not visited[i]:\n            ans.append(x)\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(' '.join((str(x) for x in solve(a, n))))", "tc = int(input())\nfor i in range(tc):\n    n = int(input())\n    m = list(map(int, input().split()))\n    nums = list(zip(m, m))\n    solution = []\n    ma = max(nums)\n    while ma[0] > 0:\n        solution.append(ma[1])\n        nums.remove(ma)\n        nums = list(map(lambda p: (p[0] - (p[0] & ma[0]), p[1]), nums))\n        if len(nums) == 0:\n            break\n        ma = max(nums)\n    for num in nums:\n        solution.append(num[1])\n    print(*solution)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input().split()\n    for i in range(n):\n        a[i] = [int(a[i]), int(a[i])]\n    a.sort(reverse=True)\n    ANS = 0\n    b = []\n    while n > 0 and a[0][0] > 0:\n        b.append(a[0][1])\n        ANS = ANS | a[0][0]\n        a.pop(0)\n        n -= 1\n        for i in range(n):\n            a[i][0] -= a[i][0] & ANS\n        a.sort(reverse=True)\n    st = str(b[0])\n    for i in range(1, len(b)):\n        st += ' ' + str(b[i])\n    for i in range(n):\n        st += ' ' + str(a[i][1])\n    print(st)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [*map(int, input().split())]\n    curr = 0\n    for j in range(31):\n        (best, z) = (-1, -1)\n        for x in arr:\n            y = (x | curr) ^ curr\n            if y > best:\n                (best, z) = (y, x)\n        if best == -1:\n            break\n        arr.remove(z)\n        print(z, end=' ')\n        curr = curr | z\n    print(*arr)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    ans = [max(a)]\n    done = defaultdict(lambda : 0)\n    cur_or = ans[0]\n    done[ans[0]] = 1\n    for k in range(32):\n        m = cur_or\n        ele = -1\n        for i in a:\n            if i in done:\n                continue\n            new_or = cur_or | i\n            if new_or > m:\n                m = new_or\n                ele = i\n        if ele != -1:\n            ans.append(ele)\n            done[ele] = 1\n            cur_or |= ele\n    for i in a:\n        if i in done and done[i] == 1:\n            done[i] -= 1\n            continue\n        ans.append(i)\n    print(*ans)"]