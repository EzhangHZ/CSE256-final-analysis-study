["import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\ndef solve(n, k, adj):\n    ver = n\n    indeg = [len(adj[z]) for z in range(n + 1)]\n    bfs = deque()\n    for i in range(1, n + 1):\n        if indeg[i] == 1:\n            bfs.append(i)\n    bfs.append(-1)\n    while k:\n        if ver < 3:\n            return 0\n        ver -= len(bfs) - 1\n        while bfs[0] != -1:\n            node = bfs.popleft()\n            for each in adj[node]:\n                indeg[each] -= 1\n                if indeg[each] == 1:\n                    bfs.append(each)\n        bfs.popleft()\n        bfs.append(-1)\n        k -= 1\n    return ver\nt = int(input())\nfor _ in range(t):\n    emp = input()\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    print(solve(n, k, adj))", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    input()\n    (N, K) = map(int, input().split())\n    if N == 1:\n        print(0)\n        return\n    G = [set() for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1].add(v - 1)\n        G[v - 1].add(u - 1)\n    ans = N\n    rm = set((u for u in range(N) if len(G[u]) == 1))\n    for _ in range(K):\n        if not rm:\n            break\n        ans -= len(rm)\n        rm2 = set()\n        for u in rm:\n            if len(G[u]) == 0:\n                continue\n            v = next(iter(G[u]))\n            G[v].remove(u)\n            if len(G[v]) == 1:\n                rm2.add(v)\n        rm = rm2 - rm\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "from collections import deque, defaultdict\n\ndef ans(n, k):\n    graph = defaultdict(list)\n    incoming = [0] * (n + 1)\n    for _ in range(n - 1):\n        (t1, t2) = map(int, input().split())\n        graph[t1].append(t2)\n        graph[t2].append(t1)\n        incoming[t1] += 1\n        incoming[t2] += 1\n    if n < 3:\n        return 0\n    pq = deque()\n    visited = set()\n    for node in graph:\n        if incoming[node] == 1:\n            pq.append(node)\n            visited.add(node)\n    while pq and k > 1:\n        for _ in range(len(pq)):\n            cur = pq.popleft()\n            for negbour in graph[cur]:\n                if negbour in visited:\n                    continue\n                incoming[negbour] -= 1\n                if incoming[negbour] == 1:\n                    pq.append(negbour)\n                    visited.add(negbour)\n        k -= 1\n    return n - len(visited)\nfor _ in range(int(input())):\n    _ = input()\n    (n, k) = map(int, input().split())\n    print(ans(n, k))", "import sys\nN = int(1000000.0 + 5)\nsys.setrecursionlimit(N)\n(n, k) = (int(), int())\nadj = list()\n\ndef charming():\n    global n, k, adj\n    input()\n    (n, k) = map(int, input().split())\n    adj = list((list() for i in range(n + 1)))\n    vis = set()\n    du = [0] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        du[u] += 1\n        du[v] += 1\n    leaf = list()\n    for i in range(1, n + 1):\n        if du[i] <= 1:\n            leaf.append(i)\n            vis.add(i)\n    nleaf = list()\n    for i in range(k - 1):\n        nleaf = list()\n        for u in leaf:\n            for v in adj[u]:\n                if v in vis:\n                    continue\n                du[v] -= 1\n                if du[v] <= 1:\n                    vis.add(v)\n                    nleaf.append(v)\n        leaf = nleaf\n        if len(leaf) <= 0:\n            break\n    print(n - len(vis))\nfor t in range(int(input())):\n    charming()", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0 if k else 1)\n        return\n    g = [set() for i in range(n)]\n    q = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].add(b)\n        g[b].add(a)\n    for i in range(n):\n        if len(g[i]) == 1:\n            q.add(i)\n    ans = set()\n    while k and q:\n        k -= 1\n        p = set()\n        for i in q:\n            ans.add(i)\n            if len(g[i]) == 0:\n                continue\n            t = list(g[i])[0]\n            g[t].discard(i)\n            if len(g[t]) == 1:\n                p.add(t)\n        q = p - q\n    print(n - len(ans))\nfor _ in range(int(input())):\n    f()", "import sys\nfrom collections import deque\nread = sys.stdin.readline\nfor _ in range(int(read())):\n    read()\n    (n, k) = map(int, read().split())\n    data = [[] for _ in range(n + 1)]\n    in_degree = [0] * (n + 1)\n    for _ in range(n - 1):\n        (v, w) = map(int, read().split())\n        data[v].append(w)\n        data[w].append(v)\n        in_degree[v] += 1\n        in_degree[w] += 1\n    q = deque()\n    size = 0\n    for v in range(1, n + 1):\n        if in_degree[v] == 1:\n            q.append(v)\n            size += 1\n    deleted = [0] * (n + 1)\n    num = n\n    for _ in range(k):\n        if num == 1 or num == 2 or num == 0:\n            num = 0\n            break\n        new_size = 0\n        for _ in range(size):\n            v = q.popleft()\n            deleted[v] = 1\n            num -= 1\n            for w in data[v]:\n                if not deleted[w]:\n                    in_degree[w] -= 1\n                    if in_degree[w] == 1:\n                        q.append(w)\n                        new_size += 1\n        size = new_size\n    print(num)", "import sys\nN = int(1000000.0 + 5)\nsys.setrecursionlimit(N)\n(n, k) = (int(), int())\nadj = list()\n\ndef charming():\n    global n, k, adj\n    input()\n    (n, k) = map(int, input().split())\n    adj = list((list() for i in range(n + 1)))\n    vis = set()\n    du = [0] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        du[u] += 1\n        du[v] += 1\n    leaf = set()\n    for i in range(1, n + 1):\n        if du[i] <= 1:\n            leaf.add(i)\n            vis.add(i)\n    nleaf = set()\n    for i in range(k - 1):\n        nleaf = set()\n        for u in leaf:\n            for v in adj[u]:\n                if v in vis:\n                    continue\n                du[v] -= 1\n                if du[v] <= 1:\n                    nleaf.add(v)\n                    vis.add(v)\n        leaf = nleaf\n        if len(leaf) <= 0:\n            break\n    print(n - len(vis))\nfor t in range(int(input())):\n    charming()", "import sys\ninput = sys.stdin.readline\n\ndef solution(edges: list, n, k):\n    if k > n / 2:\n        return 0\n    adj_list = [set() for _ in range(n)]\n    for (u, v) in edges:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    n_removed = 0\n    degree = [len(adj_list[v]) for v in range(n)]\n    leaves = [v for v in range(n) if degree[v] == 1]\n    for _ in range(k):\n        if n_removed == n - 1:\n            return 0\n        neighbors = set()\n        for leaf in leaves:\n            neighbors.update(adj_list[leaf])\n            degree[leaf] = 0\n            n_removed += 1\n            for neighbor in adj_list[leaf]:\n                degree[neighbor] -= 1\n        leaves = [v for v in neighbors if degree[v] == 1]\n    return n - n_removed\n\ndef main():\n    for _ in range(int(input())):\n        input()\n        (n, k) = map(int, input().split())\n        edges = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(n - 1)]\n        print(solution(edges, n, k))\n\ndef test():\n    edges = [(1, 0), (2, 1)]\n    print(solution(edges, 3, 2))\nmain()", "import sys\nN = int(1000000.0 + 5)\nsys.setrecursionlimit(N)\n(n, k) = (int(), int())\nadj = list()\n\ndef charming():\n    global n, k, adj\n    input()\n    (n, k) = map(int, input().split())\n    adj = list((list() for i in range(n + 1)))\n    vis = set()\n    du = [0] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        du[u] += 1\n        du[v] += 1\n    leaf = set()\n    for i in range(1, n + 1):\n        if du[i] <= 1:\n            leaf.add(i)\n            vis.add(i)\n    nleaf = set()\n    for i in range(k - 1):\n        nleaf.clear()\n        for u in leaf:\n            for v in adj[u]:\n                if v in vis:\n                    continue\n                du[v] -= 1\n                if du[v] <= 1:\n                    nleaf.add(v)\n                    vis.add(v)\n        leaf = nleaf - leaf\n        if len(leaf) <= 0:\n            break\n    print(n - len(vis))\nfor t in range(int(input())):\n    charming()", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0 if k else 1)\n        return\n    g = [set() for i in range(n)]\n    q = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].add(b)\n        g[b].add(a)\n    for i in range(n):\n        if len(g[i]) == 1:\n            q.add(i)\n    ans = set()\n    while k and q:\n        k -= 1\n        p = set()\n        for i in q:\n            ans.add(i)\n            if len(g[i]) == 0:\n                continue\n            t = list(g[i])[0]\n            g[t].discard(i)\n            if len(g[t]) == 1:\n                p.add(t)\n        q = p - q\n    print(n - len(ans))\nfor _ in range(int(input())):\n    f()", "T = int(input())\nfor t in range(T):\n    input()\n    (V, K) = map(int, input().split())\n    adj = [set() for i in range(V)]\n    for i in range(V - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    leaves = []\n    for i in range(V):\n        if len(adj[i]) == 1:\n            leaves.append(i)\n    rem = V\n    while rem > 2 and K > 0:\n        K -= 1\n        rem -= len(leaves)\n        temp = []\n        while leaves:\n            leaf = leaves.pop()\n            succ = adj[leaf].pop()\n            adj[succ].remove(leaf)\n            if len(adj[succ]) == 1:\n                temp.append(succ)\n        leaves = temp\n    if K == 0:\n        print(rem)\n    else:\n        print(0)", "for _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    remain = [0] * (n + 1)\n    layer = [0] * (n + 1)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        remain[u] += 1\n        remain[v] += 1\n    leaves = []\n    for i in range(1, n + 1):\n        if remain[i] == 1:\n            leaves.append(i)\n            layer[i] = 1\n    for i in leaves:\n        for j in graph[i]:\n            if remain[j] != 1:\n                remain[j] -= 1\n                if remain[j] == 1:\n                    layer[j] = layer[i] + 1\n                    leaves.append(j)\n    ans = 0\n    for i in range(1, n + 1):\n        if layer[i] > k:\n            ans += 1\n    print(ans)", "def remove_leaves(graph, leaves, removed_leaves, removed_neighbours_count, beginning_neighbours_count):\n    removed_leaves.update(leaves)\n    new_leaves = set()\n    for leave in leaves:\n        for neighbour in graph[leave]:\n            if neighbour not in removed_leaves:\n                removed_neighbours_count[neighbour] += 1\n                if removed_neighbours_count[neighbour] >= beginning_neighbours_count[neighbour] - 1:\n                    new_leaves.add(neighbour)\n    return list(new_leaves)\ntests = int(input())\nfor i in range(tests):\n    empty_line = input()\n    [vertex_count, operations] = [int(el) for el in input().split()]\n    graph = [[] for t in range(vertex_count)]\n    for j in range(vertex_count - 1):\n        [u, w] = [int(el) for el in input().split()]\n        graph[u - 1].append(w - 1)\n        graph[w - 1].append(u - 1)\n    visited = [False] * vertex_count\n    leaves = [idx for (idx, el) in enumerate(graph) if len(el) in [0, 1]]\n    beginning_neighbours_count = [len(el) for el in graph]\n    removed_neighbours_count = [0] * vertex_count\n    removed_leaves = set()\n    for _ in range(operations):\n        leaves = remove_leaves(graph, leaves, removed_leaves, removed_neighbours_count, beginning_neighbours_count)\n        if len(graph) == len(removed_leaves):\n            break\n    print(len(graph) - len(removed_leaves))", "from collections import deque\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    depth = [0]\n    for i in range(1, n + 1):\n        depth.append(len(adj[i]))\n    tree = [0]\n    for i in range(1, n + 1):\n        tree.append(1) if depth[i] == 1 else tree.append(-1)\n    arr = [i for i in range(n + 1) if tree[i] == 1]\n    queue = deque(arr)\n    while queue:\n        node = queue.popleft()\n        for i in adj[node]:\n            depth[i] -= 1\n            if depth[i] == 1:\n                tree[i] = tree[node] + 1\n                queue.append(i)\n    cnt = -1\n    for v in tree:\n        if v <= k:\n            cnt += 1\n    print(n - cnt)", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0 if k else 1)\n        return\n    g = [set() for i in range(n)]\n    q = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].add(b)\n        g[b].add(a)\n    for i in range(n):\n        if len(g[i]) == 1:\n            q.add(i)\n    ans = set()\n    while k and q:\n        k -= 1\n        p = set()\n        for i in q:\n            ans.add(i)\n            if len(g[i]) == 0:\n                continue\n            t = list(g[i])[0]\n            g[t].discard(i)\n            if len(g[t]) == 1:\n                p.add(t)\n        q = p - q\n    print(n - len(ans))\nfor _ in range(int(input())):\n    f()", "def solution(edges: list, n, k):\n    if k > n / 2:\n        return 0\n    adj_list = [set() for _ in range(n)]\n    for (u, v) in edges:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    n_removed = 0\n    degree = [len(adj_list[v]) for v in range(n)]\n    leaves = [v for v in range(n) if degree[v] == 1]\n    for _ in range(k):\n        if n_removed == n - 1:\n            return 0\n        neighbors = set()\n        for leaf in leaves:\n            neighbors.update(adj_list[leaf])\n            degree[leaf] = 0\n            n_removed += 1\n            for neighbor in adj_list[leaf]:\n                degree[neighbor] -= 1\n        leaves = [v for v in neighbors if degree[v] == 1]\n    return n - n_removed\n\ndef main():\n    for _ in range(int(input())):\n        input()\n        (n, k) = map(int, input().split())\n        edges = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(n - 1)]\n        print(solution(edges, n, k))\n\ndef test():\n    edges = [(1, 0), (2, 1)]\n    print(solution(edges, 3, 2))\nmain()", "import math\nimport heapq\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nfor _ in range(I()):\n    s = S()\n    (n, k) = M()\n    adj = [[] for i in range(n)]\n    d = [0] * n\n    for i in range(n - 1):\n        (a, b) = M()\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n        d[a - 1] += 1\n        d[b - 1] += 1\n    ans = n\n    q = deque()\n    for i in range(n):\n        if d[i] == 1:\n            q.append(i)\n    for p in range(k):\n        if len(q) == 0 or ans == 1:\n            ans = 0\n            break\n        for i in range(len(q)):\n            t = q.popleft()\n            d[t] = 0\n            ans -= 1\n            for j in adj[t]:\n                d[j] -= 1\n                if d[j] == 1:\n                    q.append(j)\n    print(ans)", "def gardener_and_tree(edges, n, k):\n    next_step = []\n    for vertex in edges:\n        if len(edges[vertex]) <= 1:\n            next_step += [vertex]\n    for j in range(k):\n        to_remove = next_step\n        if len(to_remove) == 0:\n            return 0\n        next_step = []\n        for vertex_to_remove in to_remove:\n            try:\n                connected = edges[vertex_to_remove].pop()\n                edges[connected].remove(vertex_to_remove)\n                if len(edges[connected]) == 1:\n                    next_step += [connected]\n            except KeyError:\n                pass\n            del edges[vertex_to_remove]\n    count = len(edges.keys())\n    return count\nt = int(input())\nfor _ in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    edges = {}\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split(' '))\n        if a in edges:\n            edges[a].add(b)\n        else:\n            edges[a] = {b}\n        if b in edges:\n            edges[b].add(a)\n        else:\n            edges[b] = {a}\n    print(gardener_and_tree(edges, n, k))", "from collections import deque\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    layer = [-1 for _ in range(n)]\n    rem = [len(adj[i]) for i in range(n)]\n    q = deque()\n    for node in range(n):\n        if len(adj[node]) <= 1:\n            q.append(node)\n            layer[node] = 1\n    while q:\n        current = q.popleft()\n        for nei in adj[current]:\n            if rem[nei] != 1:\n                rem[nei] -= 1\n                if rem[nei] == 1:\n                    q.append(nei)\n                    layer[nei] = layer[current] + 1\n    count = 0\n    for i in range(n):\n        if layer[i] > k:\n            count += 1\n    print(count)", "for _ in range(int(input())):\n    __ = input()\n    (n, k) = map(int, input().split())\n    tt = k\n    d = {i: [] for i in range(n)}\n    ideg = [0 for _ in range(n)]\n    v = [0 for _ in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        d[a - 1].append(b - 1)\n        d[b - 1].append(a - 1)\n        ideg[b - 1] += 1\n        ideg[a - 1] += 1\n    q = []\n    if k:\n        for i in range(n):\n            if ideg[i] == 1:\n                q.append(i)\n                v[i] = 1\n    k -= 1\n    while q and k:\n        q1 = []\n        for node in q:\n            for child in d[node]:\n                if v[child] == 0:\n                    ideg[child] -= 1\n                    if ideg[child] == 1:\n                        v[child] = 1\n                        q1.append(child)\n        q = q1\n        k -= 1\n    if n == 1:\n        if tt:\n            print(0)\n        else:\n            print(1)\n    else:\n        print(v.count(0))", "from sys import stdin\nfrom collections import deque\ninput = stdin.readline\ntest = int(input())\nfor _ in range(test):\n    _ = input()\n    (n, k) = map(int, input().split())\n    edges = {i: [] for i in range(1, n + 1)}\n    degree = {i: 0 for i in range(1, n + 1)}\n    queue = deque()\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        edges[a].append(b)\n        edges[b].append(a)\n        degree[a] += 1\n        degree[b] += 1\n    (remove, total, step, current) = (set(), 0, 0, 0)\n    for i in range(1, n + 1):\n        if degree[i] <= 1:\n            remove.add(i)\n            degree.pop(i)\n            current += 1\n    k -= 1\n    while degree and step < k:\n        newremove = set()\n        for r in remove:\n            for edge in edges[r]:\n                if edge in degree and edge not in remove:\n                    degree[edge] -= 1\n                    if degree[edge] <= 1:\n                        degree.pop(edge)\n                        newremove.add(edge)\n        (remove, step) = (newremove.copy(), step + 1)\n    print(len(degree))", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n    sys.stderr = open('error.txt', 'w')\ndepth = 1000000\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nlinp = lambda : list(minp())\nminp = lambda : map(int, input().split())\nfrom math import inf, ceil, sqrt, log2, gcd\nfrom collections import defaultdict, deque\ndxy = [(1, 0), (-1, 0), (0, 1), (0, -1)]\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    deg = [0 for _ in range(n + 1)]\n    lay = [0 for _ in range(n + 1)]\n    for _ in range(1, n):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        deg[u] += 1\n        deg[v] += 1\n    q = deque()\n    for i in range(1, n + 1):\n        if deg[i] == 1:\n            lay[i] = 1\n            q.append(i)\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            deg[v] -= 1\n            if deg[v] == 1:\n                lay[v] = lay[u] + 1\n                q.append(v)\n    ans = 0\n    for i in range(1, n + 1):\n        if lay[i] > k:\n            ans += 1\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    aaa = input()\n    (n, k) = map(int, input().split())\n    d = defaultdict(list)\n    deg = [0] * (n + 1)\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x].append(y)\n        d[y].append(x)\n        deg[x] += 1\n        deg[y] += 1\n    leaf = []\n    for i in range(1, 1 + n):\n        if deg[i] == 1:\n            leaf.append(i)\n    ans = n\n    while len(leaf) and k:\n        ans -= len(leaf)\n        k -= 1\n        st = []\n        for i in leaf:\n            for j in d[i]:\n                deg[j] -= 1\n                if deg[j] == 1:\n                    st.append(j)\n        leaf = st\n    if n == 1:\n        print(0)\n    else:\n        print(ans)", "from collections import defaultdict, deque\nfrom sys import stdin, stdout\nt = int(stdin.readline().strip())\nfor _ in range(t):\n    stdin.readline().strip()\n    (n, k) = map(int, stdin.readline().split())\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for _ in range(n - 1):\n        (u, v) = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        in_degree[u] += 1\n        in_degree[v] += 1\n    starting_nodes = list(map(lambda x: (x, 0), filter(lambda x: in_degree[x] <= 1, range(1, n + 1))))\n    deleted = 0\n    starting_nodes = deque(starting_nodes)\n    while starting_nodes:\n        (node, depth) = starting_nodes.popleft()\n        deleted += 1\n        for nei in graph[node]:\n            in_degree[nei] -= 1\n            if in_degree[nei] == 1 and depth + 1 < k:\n                starting_nodes.append((nei, depth + 1))\n    print(n - deleted)", "from collections import defaultdict, deque\nfor t in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    graph = defaultdict(list)\n    visited = set()\n    degree = [0] * n\n    for _ in range(n - 1):\n        (s, e) = map(int, input().split())\n        degree[s - 1] += 1\n        graph[e].append(s)\n        degree[e - 1] += 1\n        graph[s].append(e)\n    if k >= n:\n        print(0)\n        continue\n    todo = deque([])\n    for (index, count) in enumerate(degree):\n        if count == 1:\n            todo.append(index + 1)\n            degree[index] -= 1\n    while todo and k:\n        for _ in range(len(todo)):\n            node = todo.popleft()\n            n -= 1\n            for neighbour in graph[node]:\n                degree[neighbour - 1] -= 1\n                if degree[neighbour - 1] == 1:\n                    todo.append(neighbour)\n        k -= 1\n    print(n)", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    v = [[] for _ in range(n + 1)]\n    d = [0 for _ in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        v[a].append(b)\n        v[b].append(a)\n        d[a] += 1\n        d[b] += 1\n    q = deque()\n    for i in range(1, n + 1):\n        if d[i] < 2:\n            q.append(i)\n    did = [0 for _ in range(n + 1)]\n    res = n\n    for _ in range(k):\n        p = deque()\n        if len(q) == 0:\n            break\n        while len(q):\n            x = q.popleft()\n            if did[x] > 0:\n                continue\n            did[x] = 1\n            res -= 1\n            for i in v[x]:\n                d[i] -= 1\n                if d[i] == 1:\n                    p.append(i)\n        q = p\n    print(res)", "import sys, heapq\nfrom collections import defaultdict, deque\nimport math\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\ntest = inp()\nfor k in range(test):\n    input()\n    (n, k) = invr()\n    edges = defaultdict(list)\n    indegree = [0] * (n + 1)\n    for e in range(n - 1):\n        (u, v) = invr()\n        edges[u].append(v)\n        indegree[u] += 1\n        edges[v].append(u)\n        indegree[v] += 1\n    q = deque()\n    for i in range(1, n + 1):\n        if indegree[i] <= 1:\n            q.append(i)\n    count = 0\n    removed = set()\n    while q:\n        if k:\n            length = len(q)\n            while length:\n                node = q.popleft()\n                if node not in removed:\n                    count += 1\n                    removed.add(node)\n                    for neigh in edges[node]:\n                        indegree[neigh] -= 1\n                        if indegree[neigh] <= 1:\n                            q.append(neigh)\n                length -= 1\n            k -= 1\n        else:\n            q = None\n    print(n - count)", "from collections import defaultdict\n\ndef read_nums():\n    return [int(x) for x in input().split()]\n\ndef solve():\n    (n, k) = read_nums()\n    graph = defaultdict(set)\n    for _ in range(n - 1):\n        (u, v) = read_nums()\n        graph[u].add(v)\n        graph[v].add(u)\n    leaves = {node for (node, neighbors) in graph.items() if len(neighbors) == 1}\n    for _ in range(k):\n        if len(graph) <= 2:\n            print(0)\n            return\n        new_leaf_candidates = set()\n        for leaf in leaves:\n            (parent,) = graph[leaf]\n            graph[parent].remove(leaf)\n            del graph[leaf]\n            new_leaf_candidates.add(parent)\n        leaves = {p for p in new_leaf_candidates if len(graph[p]) == 1}\n    print(len(graph))\n\ndef main():\n    (t,) = read_nums()\n    for _ in range(t):\n        input()\n        solve()\nmain()", "from collections import defaultdict, deque\ntest = int(input())\nfor _ in range(test):\n    val = input()\n    graph = defaultdict(list)\n    (n, k) = [int(x) for x in input().split()]\n    if n == 1:\n        graph[1].append(1)\n        graph[1].pop()\n    for _ in range(n - 1):\n        (x, y) = [int(x) for x in input().split()]\n        graph[x].append(y)\n        graph[y].append(x)\n    leaves = deque([])\n    neigbour = defaultdict(int)\n    for i in graph:\n        if len(graph[i]) == 1 or len(graph[i]) == 0:\n            leaves.append(i)\n        else:\n            neigbour[i] += len(graph[i])\n    ans = 0\n    while leaves and k:\n        for _ in range(len(leaves)):\n            new = leaves.popleft()\n            ans += 1\n            for val in graph[new]:\n                neigbour[val] -= 1\n                if neigbour[val] == 1:\n                    leaves.append(val)\n        k -= 1\n    print(n - ans)", "from collections import defaultdict, deque\nfor t in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    graph = defaultdict(list)\n    visited = set()\n    degree = [0] * n\n    for _ in range(n - 1):\n        (s, e) = map(int, input().split())\n        degree[s - 1] += 1\n        graph[e].append(s)\n        degree[e - 1] += 1\n        graph[s].append(e)\n    if k >= n:\n        print(0)\n        continue\n    todo = deque([])\n    for (index, count) in enumerate(degree):\n        if count == 1:\n            todo.append(index + 1)\n            degree[index] -= 1\n    while todo and k:\n        for _ in range(len(todo)):\n            node = todo.popleft()\n            n -= 1\n            for neighbour in graph[node]:\n                degree[neighbour - 1] -= 1\n                if degree[neighbour - 1] == 1:\n                    todo.append(neighbour)\n        k -= 1\n    print(n)", "from math import gcd\nfrom collections import defaultdict\nfrom collections import deque\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        input()\n        (n, k) = map(int, input().split())\n        d = defaultdict(list)\n        l = defaultdict(int)\n        if n == 1:\n            print(0)\n            continue\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            d[u].append(v)\n            d[v].append(u)\n            l[u] += 1\n            l[v] += 1\n        q = deque()\n        visited = set()\n        cnt = 0\n        for i in range(1, n + 1):\n            if len(d[i]) == 1:\n                q.append((i, k))\n                visited.add(i)\n        while len(q) != 0:\n            (v, curr_k) = q.popleft()\n            if curr_k == 0:\n                break\n            cnt += 1\n            for e in d[v]:\n                if e not in visited:\n                    if l[e] == 2:\n                        q.append((e, curr_k - 1))\n                        visited.add(e)\n                    else:\n                        l[e] -= 1\n        print(n - cnt)\nmain()", "from collections import defaultdict\nfrom collections import deque\ntc = int(input())\nfor _ in range(tc):\n    input()\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    (n, k) = map(int, input().split())\n    for _ in range(n - 1):\n        (n1, n2) = map(int, input().split())\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n        indegree[n1] += 1\n        indegree[n2] += 1\n    q = deque()\n    for (key, v) in indegree.items():\n        if v == 1:\n            q.append(key)\n    count = 0\n    while k > 0 and q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            count += 1\n            for ne in graph[cur]:\n                indegree[ne] -= 1\n                if indegree[ne] == 1:\n                    q.append(ne)\n        k -= 1\n    if n <= 2:\n        print(0)\n    else:\n        print(n - count)", "from collections import defaultdict, deque\n\ndef solve():\n    input()\n    (n, k) = list(map(int, input().split()))\n    edges = [list(map(int, input().split())) for _ in range(n - 1)]\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    indegrees = defaultdict(int)\n    for (node, neighbours) in graph.items():\n        for neighbour in neighbours:\n            indegrees[neighbour] += 1\n    with_1 = deque([])\n    for x in range(1, n + 1):\n        if indegrees[x] <= 1:\n            with_1.append(x)\n    pro = 0\n    for x in range(k):\n        if not with_1:\n            break\n        nex = deque([])\n        while with_1:\n            node = with_1.popleft()\n            pro += 1\n            for neighbor in graph[node]:\n                indegrees[neighbor] -= 1\n                if indegrees[neighbor] == 1:\n                    nex.append(neighbor)\n        with_1 = nex\n    print(n - pro)\nfor i in range(int(input())):\n    solve()", "import sys\nimport math\n\ndef readln_str():\n    return input().split(' ')\n\ndef readln_int():\n    return [int(i) for i in readln_str()]\nT = eval(input())\nfor _ in range(T):\n    input()\n    (N, K) = readln_int()\n    edges = [set() for _ in range(N)]\n    deleted = [False] * N\n    for _ in range(N - 1):\n        (u, v) = readln_int()\n        (u, v) = (u - 1, v - 1)\n        edges[u].add(v)\n        edges[v].add(u)\n    (head, tail) = (0, 0)\n    queue = set()\n    for i in range(N):\n        if len(edges[i]) <= 1:\n            queue.add(i)\n    for _ in range(K):\n        if len(queue) == 0:\n            break\n        new_queue = set()\n        for u in queue:\n            deleted[u] = True\n            for v in edges[u]:\n                edges[v].discard(u)\n                if not deleted[v] and len(edges[v]) <= 1:\n                    new_queue.add(v)\n        queue = new_queue\n    ans = sum((1 for u in range(N) if not deleted[u]))\n    print(ans)", "from collections import defaultdict, deque\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0)\n        continue\n    p = defaultdict(int)\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (s, d) = map(int, input().split())\n        graph[s].append(d)\n        graph[d].append(s)\n        p[d] += 1\n        p[s] += 1\n    q = deque()\n    seen = set()\n    for node in range(1, n + 1):\n        if len(graph[node]) <= 1:\n            q.append(node)\n            seen.add(node)\n    total = n\n    for op in range(k):\n        total -= len(q)\n        temp = deque()\n        for el in q:\n            for src in graph[el]:\n                if src not in seen:\n                    p[src] -= 1\n                    if p[src] == 1:\n                        temp.append(src)\n                        seen.add(src)\n        q = temp\n        if not q:\n            break\n    print(total)", "from collections import defaultdict\nfrom collections import deque\nt = int(input())\nfor i in range(t):\n    line = input()\n    n_k = list(map(int, input().split()))\n    (n, k) = (n_k[0], n_k[1])\n    adjList = {}\n    for m in range(1, n + 1):\n        adjList[m] = []\n    for j in range(n - 1):\n        a_b = list(map(int, input().split()))\n        adjList[a_b[0]].append(a_b[1])\n        adjList[a_b[1]].append(a_b[0])\n    queue = deque([])\n    edgeCount = {}\n    for node in adjList:\n        edgeCount[node] = len(adjList[node])\n        if edgeCount[node] == 1 or edgeCount[node] == 0:\n            queue.append(node)\n    totalRemoved = 0\n    while queue and k > 0:\n        curLevel = len(queue)\n        totalRemoved += curLevel\n        while curLevel > 0:\n            curNode = queue.popleft()\n            edgeCount[curNode] -= 1\n            for nibr in adjList[curNode]:\n                edgeCount[nibr] -= 1\n                if edgeCount[nibr] == 1:\n                    queue.append(nibr)\n            curLevel -= 1\n        k -= 1\n    print(n - totalRemoved)", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    if n == 1:\n        if k:\n            print(0)\n        else:\n            print(1)\n        return\n    g = [set() for i in range(n)]\n    q = set()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].add(b)\n        g[b].add(a)\n    for i in range(n):\n        if len(g[i]) == 1:\n            q.add(i)\n    ans = set()\n    while k and q:\n        k -= 1\n        p = set()\n        for i in q:\n            ans.add(i)\n            if len(g[i]) == 0:\n                continue\n            t = list(g[i])[0]\n            g[t].discard(i)\n            if len(g[t]) == 1:\n                p.add(t)\n        q = p - q\n    print(n - len(ans))\nfor _ in range(int(input())):\n    f()", "from collections import defaultdict, deque\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    if n == 1:\n        print(0)\n        continue\n    p = defaultdict(int)\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (s, d) = map(int, input().split())\n        graph[s].append(d)\n        graph[d].append(s)\n        p[d] += 1\n        p[s] += 1\n    q = deque()\n    seen = set()\n    for node in range(1, n + 1):\n        if len(graph[node]) <= 1:\n            q.append(node)\n            seen.add(node)\n    total = n\n    for op in range(k):\n        total -= len(q)\n        temp = deque()\n        for el in q:\n            for src in graph[el]:\n                if src not in seen:\n                    p[src] -= 1\n                    if p[src] == 1:\n                        temp.append(src)\n                        seen.add(src)\n        q = temp\n        if not q:\n            break\n    print(total)", "from collections import defaultdict, deque\n\ndef solve():\n    input()\n    (n, k) = [int(x) for x in input().split()]\n    edges = [list(map(int, input().split())) for _ in range(n - 1)]\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    indegrees = defaultdict(int)\n    for node in graph:\n        for neighbour in graph[node]:\n            indegrees[neighbour] += 1\n    with_1 = deque([])\n    for x in range(1, n + 1):\n        if indegrees[x] <= 1:\n            with_1.append(x)\n    pro = 0\n    for x in range(k):\n        if len(with_1) == 0:\n            break\n        nex = deque([])\n        while len(with_1) != 0:\n            node = with_1.popleft()\n            pro += 1\n            for neighbor in graph[node]:\n                indegrees[neighbor] -= 1\n                if indegrees[neighbor] == 1:\n                    nex.append(neighbor)\n        with_1 = nex\n    print(n - pro)\nfor i in range(int(input())):\n    solve()", "from queue import deque\nt = int(input())\nfor _ in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    edge_count = [0] * (n + 1)\n    graph = {}\n    for _1 in range(n - 1):\n        (u, v) = map(int, input().split())\n        if v not in graph:\n            graph[v] = []\n        if u not in graph:\n            graph[u] = []\n        graph[u].append(v)\n        graph[v].append(u)\n        edge_count[u] += 1\n        edge_count[v] += 1\n    q = deque()\n    visited = set()\n    for i in range(1, n + 1):\n        if len(graph.get(i, [])) < 2:\n            visited.add(i)\n            q.append(i)\n    nodes_left = n\n    for i in range(k):\n        if nodes_left <= 0:\n            break\n        l = len(q)\n        for ij in range(l):\n            v = q.popleft()\n            for ngh in graph.get(v, []):\n                edge_count[ngh] -= 1\n                if edge_count[ngh] < 2 and ngh not in visited:\n                    visited.add(ngh)\n                    q.append(ngh)\n        nodes_left -= l\n    print(nodes_left)", "t = int(input())\nfor _ in range(t):\n    empty = input()\n    (ni, k) = map(int, input().split())\n    neighbors = {i: [] for i in range(ni)}\n    for i in range(ni - 1):\n        (v, w) = map(int, input().split())\n        neighbors[v - 1].append(w - 1)\n        neighbors[w - 1].append(v - 1)\n    time = {}\n    layer = []\n    for i in range(ni):\n        if len(neighbors[i]) <= 1:\n            time[i] = 1\n            layer.append(i)\n    dist = 2\n    while len(time) < ni and dist <= k:\n        newlayer = set()\n        for v in layer:\n            for n in neighbors[v]:\n                if n not in newlayer and n not in time:\n                    alive = 0\n                    for nn in neighbors[n]:\n                        if nn not in time or time[nn] == dist:\n                            alive += 1\n                            if alive == 2:\n                                break\n                    if alive < 2:\n                        newlayer.add(n)\n                        time[n] = dist\n        dist += 1\n        layer = newlayer\n    print(ni - len(time))", "from collections import deque\nt = int(input())\nfor tt in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    tree = [set() for x in range(n + 1)]\n    levels = [0 for x in range(n + 1)]\n    visited = [False for x in range(n + 1)]\n    lens = levels.copy()\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        tree[a].add(b)\n        tree[b].add(a)\n        lens[a] += 1\n        lens[b] += 1\n    q = deque()\n    for (idx, v) in enumerate(tree):\n        if len(v) <= 1:\n            q.append(idx)\n            levels[idx] = 1\n            visited[idx] = True\n    while len(q) > 0:\n        node = q.popleft()\n        if lens[node] == 0:\n            continue\n        v = tree[node].pop()\n        tree[node].clear()\n        lens[node] = 0\n        tree[v].remove(node)\n        lens[v] -= 1\n        if levels[node] + 1 <= k and lens[v] == 1 and (not visited[v]):\n            visited[v] = True\n            levels[v] = levels[node] + 1\n            q.append(v)\n    print(sum([1 for (idx, level) in enumerate(levels) if idx != 0 and (level > k or level == 0)]))", "from collections import deque\n\ndef getLeaves(g):\n    res = []\n    for i in g.keys():\n        if len(g[i]) < 2:\n            res.append(i)\n    return res\nn1 = int(input())\nfor i in range(n1):\n    input()\n    (n, k) = [int(k) for k in input().split()]\n    g = {}\n    for j in range(n - 1):\n        (n1, n2) = [int(k) for k in input().split()]\n        if n1 not in g.keys():\n            g[n1] = []\n        if n2 not in g.keys():\n            g[n2] = []\n        g[n1].append(n2)\n        g[n2].append(n1)\n    leaves = getLeaves(g)\n    q = deque()\n    layer = {}\n    rem = {}\n    for node in g.keys():\n        rem[node] = len(g[node])\n        layer[node] = 1\n    for leave in leaves:\n        q.append(leave)\n    while q:\n        node = q.popleft()\n        for nei in g[node]:\n            if rem[nei] > 1:\n                layer[nei] = layer[node] + 1\n                rem[nei] -= 1\n                if rem[nei] == 1:\n                    q.append(nei)\n    c = 0\n    for val in layer.values():\n        if val > k:\n            c += 1\n    print(c)", "from collections import deque\nt = int(input())\nfor c in range(t):\n    input()\n    (n, k) = [int(x) for x in input().split(' ')]\n    adj = [set() for x in range(n)]\n    conn = [0 for x in range(n)]\n    dist = [1 for x in range(n)]\n    visited = [False for x in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split(' ')]\n        adj[u].add(v)\n        adj[v].add(u)\n        conn[u] += 1\n        conn[v] += 1\n    pending = deque()\n    for (idx, val) in enumerate(conn):\n        if val == 1:\n            pending.append(idx)\n            visited[idx] = True\n    while len(pending):\n        current = pending.popleft()\n        for v in adj[current]:\n            if not visited[v]:\n                dist[v] = dist[current] + 1 if dist[current] + 1 > dist[v] else dist[v]\n                conn[v] -= 1\n                if conn[v] == 1:\n                    pending.append(v)\n                    visited[v] = True\n    print(f'{len([x for x in dist if x > k])}')", "from collections import defaultdict, deque\n\nclass Solution:\n\n    def trimTree(self, n, k, edges):\n        graph = defaultdict(list)\n        if not edges:\n            return 0\n        indegree = {i: 0 for i in range(1, n + 1)}\n        for (node1, node2) in edges:\n            graph[node1].append(node2)\n            graph[node2].append(node1)\n            indegree[node1] += 1\n            indegree[node2] += 1\n        queue = deque()\n        for node in graph:\n            if indegree[node] == 1:\n                queue.append(node)\n        while queue and k > 0:\n            size = len(queue)\n            k -= 1\n            for i in range(size):\n                node = queue.popleft()\n                n -= 1\n                for neigh in graph[node]:\n                    indegree[neigh] -= 1\n                    if indegree[neigh] == 1:\n                        queue.append(neigh)\n        return n\nsol = Solution()\nt = int(input())\ninputs = []\nfor _ in range(t):\n    input()\n    (n, k) = list(map(int, input().split()))\n    edges = []\n    for i in range(n - 1):\n        edges.append(list(map(int, input().split())))\n    inputs.append([n, k, edges])\nfor (n, k, edges) in inputs:\n    print(sol.trimTree(n, k, edges))", "from collections import defaultdict, deque\nfrom email.policy import default\nt = int(input())\nfor tt in range(t):\n    just = input()\n    (n, ope) = list(map(int, input().split(' ')))\n    graph = defaultdict(list)\n    inDegree = defaultdict(int)\n    for _ in range(n - 1):\n        (first, second) = list(map(int, input().split(' ')))\n        graph[first].append(second)\n        graph[second].append(first)\n        inDegree[first] += 1\n        inDegree[second] += 1\n    if n == 1:\n        print(0)\n    else:\n        count = 0\n        queue = deque()\n        for i in range(1, n + 1):\n            if inDegree[i] == 1:\n                queue.append((i, 1))\n        level = 1\n        while queue:\n            (cur, cur_level) = queue.popleft()\n            if cur_level - 1 >= ope:\n                break\n            count += 1\n            for neighbour in graph[cur]:\n                inDegree[neighbour] -= 1\n                if inDegree[neighbour] == 1:\n                    queue.append((neighbour, cur_level + 1))\n        if cur_level - 1 < ope:\n            print(0)\n        else:\n            print(n - count)", "from collections import defaultdict, deque\nt = int(input())\nop = defaultdict(int)\nfor z in range(t):\n    indgree = defaultdict(int)\n    input()\n    graph = defaultdict(list)\n    (n, k) = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n        continue\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        indgree[u] += 1\n        indgree[v] += 1\n        graph[u].append(v)\n        graph[v].append(u)\n    queue = deque()\n    indCount = defaultdict(int)\n    visited = set()\n    for (node, ct) in indgree.items():\n        if ct == 1:\n            queue.append(node)\n            visited.add(node)\n    level = 0\n    ct = 0\n    while queue and level != k:\n        for i in range(len(queue)):\n            node = queue.popleft()\n            if indgree[node] == 1:\n                n -= 1\n            for nxt in graph[node]:\n                if nxt not in visited:\n                    indgree[nxt] -= 1\n                    if indgree[nxt] <= 1:\n                        queue.append(nxt)\n                        visited.add(nxt)\n        level += 1\n    print(n)", "import sys\nimport copy\nN = int(1000000.0 + 5)\nsys.setrecursionlimit(N)\n(n, k) = (int(), int())\nadj = list()\n\ndef charming():\n    global n, k, adj\n    input()\n    (n, k) = map(int, input().split())\n    adj = list((list() for i in range(n + 1)))\n    vis = set()\n    du = [0] * (n + 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        du[u] += 1\n        du[v] += 1\n    leaf = set()\n    for i in range(1, n + 1):\n        if du[i] <= 1:\n            leaf.add(i)\n            vis.add(i)\n    nleaf = set()\n    for i in range(k - 1):\n        nleaf.clear()\n        for u in leaf:\n            for v in adj[u]:\n                if v in vis:\n                    continue\n                du[v] -= 1\n                if du[v] <= 1:\n                    nleaf.add(v)\n                    vis.add(v)\n        leaf = copy.deepcopy(nleaf)\n        if len(leaf) <= 0:\n            break\n    print(n - len(vis))\nfor t in range(int(input())):\n    charming()", "import sys\nfrom collections import deque\nfor _ in range(int(input())):\n    sys.stdin.readline()\n    (n, k) = map(int, input().split())\n    graph = {}\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        (x, y) = (x - 1, y - 1)\n        if x in graph:\n            graph[x].add(y)\n        else:\n            graph[x] = {y}\n        if y in graph:\n            graph[y].add(x)\n        else:\n            graph[y] = {x}\n    level = [0] * n\n    for i in graph:\n        for j in graph[i]:\n            level[j] += 1\n    queue = deque([])\n    visited = [False] * n\n    s = [0] * n\n    for i in range(n):\n        if level[i] in [0, 1]:\n            queue.append(i)\n            visited[i] = True\n            s[i] = 1\n            level[i] -= 1\n    while len(queue) != 0:\n        x = queue.popleft()\n        if x in graph:\n            for i in graph[x]:\n                level[i] -= 1\n                if not visited[i] and level[i] in [0, 1]:\n                    visited[i] = True\n                    s[i] = s[x] + 1\n                    queue.append(i)\n    ans = 0\n    for i in s:\n        if i > k:\n            ans += 1\n    print(ans)", "import sys\nfrom math import factorial, gcd\nfrom collections import Counter, deque, defaultdict\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heappop, heappush, heapify, nlargest, nsmallest\nfrom itertools import groupby, accumulate\nfrom copy import deepcopy\nMOD = 10 ** 9 + 7\nINF = float('inf')\ninput = sys.stdin.readline\nrl = lambda : list(map(int, input().split()))\nrs = lambda : sys.stdin.readline().strip()\nfor _ in range(int(input())):\n    input()\n    (n, k) = rl()\n    graph = defaultdict(set)\n    indegree = Counter()\n    for _ in range(n - 1):\n        (u, v) = rl()\n        graph[u].add(v)\n        graph[v].add(u)\n        indegree[u] += 1\n        indegree[v] += 1\n    dc = 0\n    done = False\n    leaves = [i for i in range(1, n + 1) if indegree[i] == 1]\n    for _ in range(k):\n        if n - dc == 1 or n - dc == 2:\n            res = 0\n            done = True\n            break\n        nl = []\n        for u in leaves:\n            dc += 1\n            v = graph[u].pop()\n            indegree[v] -= 1\n            graph[v] -= {u}\n            if indegree[v] == 1:\n                nl.append(v)\n        leaves = nl\n    print(res if done else n - dc)", "from collections import deque\nimport sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\nt = int(input())\nfor _ in range(t):\n    flag = True\n    waste = input()\n    (n, k) = map(int, input().split())\n    tree = [[0, set()] for z in range(n + 1)]\n    for z in range(n - 1):\n        (x, y) = map(int, input().split())\n        tree[x][1].add(y)\n        tree[y][1].add(x)\n    leaf = deque([])\n    tmp_leaf = deque([])\n    for idx in range(n + 1):\n        if len(tree[idx][1]) == 1:\n            leaf.append(idx)\n    sol = 0\n    while k:\n        while leaf:\n            idx = leaf.popleft()\n            if tree[idx][1]:\n                parent = list(tree[idx][1])[0]\n                tree[idx][1].remove(parent)\n            if tree[parent][1]:\n                tree[parent][1].remove(idx)\n                tree[parent][0] = max(tree[parent][0], tree[idx][0] + 1)\n                sol += 1\n            if len(tree[parent][1]) == 1:\n                tmp_leaf.append(parent)\n        if not tmp_leaf:\n            print(0)\n            flag = False\n            break\n        leaf = tmp_leaf\n        tmp_leaf = deque([])\n        k -= 1\n    if flag:\n        print(n - sol)", "import queue\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    l = [[] for i in range(n)]\n    deg = [0] * n\n    dis = [1000000000.0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n    q = queue.Queue()\n    for i in range(n):\n        deg[i] = len(l[i])\n        if deg[i] <= 1:\n            dis[i] = 0\n            q.put(i)\n    while not q.empty():\n        u = q.get()\n        for v in l[u]:\n            deg[v] -= 1\n            if deg[v] == 1:\n                dis[v] = dis[u] + 1\n                q.put(v)\n    print(sum((1 for i in dis if i >= k)))", "from collections import defaultdict, deque\nfrom email.policy import default\nt = int(input())\nfor tt in range(t):\n    just = input()\n    (n, ope) = list(map(int, input().split(' ')))\n    graph = defaultdict(list)\n    inDegree = defaultdict(int)\n    for _ in range(n - 1):\n        (first, second) = list(map(int, input().split(' ')))\n        graph[first].append(second)\n        graph[second].append(first)\n        inDegree[first] += 1\n        inDegree[second] += 1\n    count = 0\n    queue = deque()\n    for i in range(1, n + 1):\n        if inDegree[i] == 1:\n            queue.append((i, 1))\n        if inDegree[i] == 0:\n            queue.append((i, 1))\n    level = 1\n    while queue:\n        (cur, cur_level) = queue.popleft()\n        if cur_level - 1 >= ope:\n            break\n        count += 1\n        for neighbour in graph[cur]:\n            inDegree[neighbour] -= 1\n            if inDegree[neighbour] == 1:\n                queue.append((neighbour, cur_level + 1))\n    if cur_level - 1 < ope:\n        print(0)\n    else:\n        print(n - count)", "import queue\ntest = int(input())\nfor _ in range(test):\n    blank = str(input())\n    (P, k) = map(int, input().split())\n    graph = [[] for _ in range(P)]\n    for _ in range(P - 1):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    deg = [0] * P\n    dis = [1000000000.0] * P\n    q = queue.Queue()\n    for i in range(P):\n        deg[i] = len(graph[i])\n        if deg[i] <= 1:\n            dis[i] = 0\n            q.put(i)\n    while not q.empty():\n        u = q.get()\n        for v in graph[u]:\n            deg[v] -= 1\n            if deg[v] == 1:\n                dis[v] = dis[u] + 1\n                q.put(v)\n    print(sum((1 for i in dis if i >= k)))", "import queue\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    l = [[] for i in range(n)]\n    deg = [0] * n\n    dis = [1000000000.0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n    q = queue.Queue()\n    for i in range(n):\n        deg[i] = len(l[i])\n        if deg[i] <= 1:\n            dis[i] = 0\n            q.put(i)\n    while not q.empty():\n        u = q.get()\n        for v in l[u]:\n            deg[v] -= 1\n            if deg[v] == 1:\n                dis[v] = dis[u] + 1\n                q.put(v)\n    print(sum((1 for i in dis if i >= k)))", "import queue\ntest = int(input())\nfor _ in range(test):\n    blank = str(input())\n    (n, k) = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    deg = [0] * n\n    dis = [1000000000.0] * n\n    q = queue.Queue()\n    for i in range(n):\n        deg[i] = len(graph[i])\n        if deg[i] <= 1:\n            dis[i] = 0\n            q.put(i)\n    while not q.empty():\n        u = q.get()\n        for v in graph[u]:\n            deg[v] -= 1\n            if deg[v] == 1:\n                dis[v] = dis[u] + 1\n                q.put(v)\n    print(sum((1 for i in dis if i >= k)))", "import queue\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    l = [[] for i in range(n)]\n    deg = [0] * n\n    dis = [1000000000.0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        l[u - 1].append(v - 1)\n        l[v - 1].append(u - 1)\n    q = queue.Queue()\n    for i in range(n):\n        deg[i] = len(l[i])\n        if deg[i] <= 1:\n            dis[i] = 0\n            q.put(i)\n    while not q.empty():\n        u = q.get()\n        for v in l[u]:\n            deg[v] -= 1\n            if deg[v] == 1:\n                dis[v] = dis[u] + 1\n                q.put(v)\n    print(sum((1 for i in dis if i >= k)))", "from queue import Queue\nfor _ in range(int(input())):\n    uu = input()\n    (n, k) = map(int, input().split())\n    graph = {}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        if a not in graph:\n            graph[a] = set()\n        if b not in graph:\n            graph[b] = set()\n        graph[a].add(b)\n        graph[b].add(a)\n    if n <= 2:\n        print(0)\n        continue\n    q = Queue()\n    for ke in graph:\n        neighbours = len(graph[ke])\n        if neighbours == 1:\n            q.put(ke)\n    while q.qsize():\n        for i in range(q.qsize()):\n            curr = q.get()\n            n -= 1\n            for neighbour in graph[curr]:\n                graph[neighbour].remove(curr)\n                if len(graph[neighbour]) == 1:\n                    q.put(neighbour)\n        k -= 1\n        if k == 0 or n == 0:\n            break\n    print(n)"]