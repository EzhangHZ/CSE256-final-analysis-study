["import sys, threading\n\ndef main():\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    q = int(input())\n    for _ in range(q):\n        input()\n        queries = set(map(int, input().split()))\n        root = node = list(queries)[0]\n        visited = {root}\n        counts = [0] * (n + 1)\n        counts[node] = -1\n        mels = [True]\n\n        def dfs(node):\n            ans = False\n            count = 0\n            for v in graph[node]:\n                if v not in visited:\n                    visited.add(v)\n                    cur = dfs(v)\n                    if cur:\n                        count += 1\n                    if count > (2 if node == root else 1):\n                        mels[0] = False\n                    ans = ans or cur\n            return ans or node in queries\n        dfs(root)\n        print('YES' if mels[0] else 'NO')\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "from collections import defaultdict, deque\nfrom functools import lru_cache\nfrom heapq import heappush, heappop\n\ndef input_int():\n    return int(input())\n\ndef input_arr():\n    return list(map(int, input().split()))\n\ndef input_tupple():\n    return map(int, input().split())\n\ndef solution():\n    n = input_int()\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        (a, b) = input_tupple()\n        graph[a].append(b)\n        graph[b].append(a)\n    t = input_int()\n    for _ in range(t):\n        input()\n        arr = set(input_arr())\n\n        def deepest(cur, parent):\n            mx = 0\n            node = cur if cur in arr else None\n            for nbr in graph[cur]:\n                if nbr == parent:\n                    continue\n                (d, v) = deepest(nbr, cur)\n                if v in arr and d > mx:\n                    mx = d\n                    node = v\n            return (mx + 1, node)\n        cur = arr.pop()\n        arr.add(cur)\n        (_, first) = deepest(cur, -1)\n\n        def dfs(cur, parent):\n            count = 0\n            for nbr in graph[cur]:\n                if nbr == parent:\n                    continue\n                (ans, contain) = dfs(nbr, cur)\n                count += contain\n                if ans == False:\n                    return (False, 0)\n            return (count < 2, count + (cur in arr) > 0)\n        (ans, _) = dfs(first, -1)\n        if ans:\n            print('YES')\n        else:\n            print('NO')\nimport sys\nimport threading\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=solution)\nthread.start()\nthread.join()", "import sys\nfrom collections import defaultdict\nfrom math import sqrt, ceil, floor, factorial, log\nfrom bisect import bisect_left, bisect_right\nfrom io import BytesIO, IOBase, StringIO\ninput = lambda : sys.stdin.readline().rstrip()\nimport threading\n\ndef main():\n\n    def inlt():\n        return list(map(int, input().split()))\n    t = int(input())\n    dic = defaultdict(list)\n    for i in range(t - 1):\n        (a, b) = map(int, input().split())\n        dic[a].append(b)\n        dic[b].append(a)\n    root = 1\n    q = int(input())\n\n    def recur(root):\n        visited.add(root)\n        ans = 1 if s[root] > 0 else 0\n        new = []\n        for j in dic[root]:\n            if j not in visited:\n                vayu = recur(j)\n                if vayu:\n                    new.append(vayu)\n        if len(new) == 1:\n            if new[0] + ans == len(lis):\n                final[0] = True\n            return new[0] + ans\n        if len(new) == 2:\n            if new[0] + new[1] + ans == len(lis):\n                final[0] = True\n            else:\n                return 0\n        if len(new) > 2:\n            return 0\n        if len(new) == 0:\n            if ans == len(lis):\n                final[0] = True\n            return ans\n    while q:\n        q -= 1\n        n = int(input())\n        lis = inlt()\n        visited = set()\n        s = defaultdict(int)\n        final = [False]\n        for j in lis:\n            s[j] += 1\n        recur(1)\n        print('YES') if final[0] else print('NO')\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()"]