["import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    n = int(inp())\n    p = list(map(int, inp().split()))\n    q = list(map(int, inp().split()))\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    print(res + 1)\n\ndef main():\n    solve()\nmain()", "import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    n = int(inp())\n    p = list(map(int, inp().split()))\n    q = list(map(int, inp().split()))\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    print(res + 1)\n\ndef main():\n    solve()\nmain()", "from collections import deque\n\ndef getint():\n    return int(input())\n\ndef getfloat():\n    return float(input())\n\ndef getints():\n    return list(map(int, input().split()))\n\ndef getfloats():\n    return list(map(float, input().split()))\n\ndef getcomb(i):\n    return i * (i + 1) // 2\n\ndef answer():\n    n = getint()\n    p = getints()\n    q = getints()\n    pp = [0] * (n + 1)\n    qq = [0] * (n + 1)\n    for (i, _p) in enumerate(p):\n        pp[_p] = i\n    for (i, _q) in enumerate(q):\n        qq[_q] = i\n    left = min(pp[1], qq[1])\n    right = max(pp[1], qq[1])\n    ans = getcomb(left) + getcomb(right - left - 1) + getcomb(n - 1 - right)\n    for i in range(2, n):\n        if left <= pp[i] <= right or left <= qq[i] <= right:\n            left = min(pp[i], left, qq[i])\n            right = max(pp[i], right, qq[i])\n            continue\n        leftbound = -1\n        rightbound = n\n        if pp[i] < left:\n            leftbound = max(leftbound, pp[i])\n        if pp[i] > right:\n            rightbound = min(rightbound, pp[i])\n        if qq[i] < left:\n            leftbound = max(leftbound, qq[i])\n        if qq[i] > right:\n            rightbound = min(rightbound, qq[i])\n        ans += (left - leftbound) * (rightbound - right)\n        left = min(pp[i], left, qq[i])\n        right = max(pp[i], right, qq[i])\n    print(ans + 1)\nT = 1\nfor i in range(T):\n    answer()", "def f(l, r, x1, x2, n):\n    if x2 < l:\n        return (l - x2) * (n - r)\n    elif x1 > r:\n        return (l + 1) * (x1 - r)\n    elif x1 < l and x2 > r:\n        return (l - x1) * (x2 - r)\n    return 0\n\ndef f1(l):\n    res = l * (l + 1) // 2\n    return res\n\ndef solve(p, q):\n    n = len(p)\n    p_pos = [0] * n\n    q_pos = [0] * n\n    for ni in range(n):\n        p_pos[p[ni] - 1] = ni\n        q_pos[q[ni] - 1] = ni\n    (x1, x2) = sorted([p_pos[0], q_pos[0]])\n    res = 0\n    if x1 > 0:\n        res += f1(x1)\n    if x2 > x1 + 1:\n        res += f1(x2 - x1 - 1)\n    if x2 < n - 1:\n        res += f1(n - 1 - x2)\n    l = x1\n    r = x2\n    for v in range(2, n - 1):\n        (x1, x2) = sorted([p_pos[v - 1], q_pos[v - 1]])\n        res += f(l, r, x1, x2, n)\n        l = min(x1, x2, l)\n        r = max(x1, x2, r)\n    res += 1\n    return res\nn = int(input())\np = [int(x) for x in input().split()]\nq = [int(x) for x in input().split()]\nprint(solve(p, q))", "from sys import stderr\n\ndef main(p, q) -> int:\n    result = 1\n    n = len(p)\n    p_inds = {v: i for (i, v) in enumerate(p)}\n    q_inds = {v: i for (i, v) in enumerate(q)}\n    (one1, one2) = sorted((p_inds[1], q_inds[1]))\n    a = one1\n    b = one2 - one1 - 1\n    c = n - one2 - 1\n    result += a * (a + 1) // 2 + b * (b + 1) // 2 + c * (c + 1) // 2\n    (left, right) = (one1, one2)\n    for mex in range(2, n):\n        (mex1, mex2) = sorted((p_inds[mex], q_inds[mex]))\n        if mex2 < left:\n            result += (left - mex2) * (n - right)\n        elif mex1 > right:\n            result += (mex1 - right) * (left + 1)\n        elif mex1 < left and mex2 > right:\n            result += (left - mex1) * (mex2 - right)\n        (left, right) = (min(mex1, mex2, left), max(mex1, mex2, right))\n    return result\n(_, p, q) = (list(map(int, input().split())) for _ in range(3))\nassert len(p) == len(q) and set(p) == set(q)\nlrs = main(p, q)\nprint(lrs)", "n = int(input())\np = [int(x) for x in input().split(' ')]\nq = [int(x) for x in input().split(' ')]\ndicp = {}\ndicq = {}\nfor i in range(n):\n    dicp[p[i]] = i\n    dicq[q[i]] = i\nans = 0\nfor i in range(1, n + 1):\n    if i == 1:\n        left = min(dicp[i], dicq[i])\n        right = max(dicp[i], dicq[i])\n        ans += left * (left - 1) // 2 + left\n        ans += (n - 1 - right) * (n - 2 - right) // 2 + (n - 1 - right)\n        if left != right:\n            ans += (right - 1 - left) * (right - 2 - left) // 2 + (right - 1 - left)\n    else:\n        l = min(dicp[i], dicq[i])\n        r = max(dicp[i], dicq[i])\n        if l == r:\n            if 0 <= left and right <= l - 1:\n                ans += (left + 1) * (l - right)\n            if r + 1 <= left and right <= n - 1:\n                ans += (left - r) * (n - right)\n        else:\n            if 0 <= left and right <= l - 1:\n                ans += (left + 1) * (l - right)\n            if r + 1 <= left and right <= n - 1:\n                ans += (left - r) * (n - right)\n            if l + 1 <= left and right <= r - 1:\n                ans += (left - l) * (r - right)\n        left = min(l, left)\n        right = max(r, right)\nprint(ans + 1)", "n = int(input())\nxs = [int(a) - 1 for a in input().split()]\nys = [int(a) - 1 for a in input().split()]\n\ndef invert(xs):\n    ret = [0] * len(xs)\n    for (i, x) in enumerate(xs):\n        ret[x] = i\n    return ret\nxs = invert(xs)\nys = invert(ys)\nintervals = [(min(x, y), max(x, y)) for (x, y) in zip(xs, ys)]\n(i, j) = intervals[0]\n\ndef c2(x):\n    return x * (x - 1) // 2\nres = c2(i + 1) + c2(n - j) + c2(abs(xs[0] - ys[0]))\n\ndef overlap(r1, r2):\n    if r1 > r2:\n        (r1, r2) = (r2, r1)\n    (a, b) = r1\n    (c, d) = r2\n    return c <= b\ncur = intervals[0]\nfor i in range(1, n):\n    (a, b) = cur\n    (c, d) = intervals[i]\n    if not overlap(cur, intervals[i]):\n        if cur < intervals[i]:\n            res += (a + 1) * (c - b)\n        else:\n            res += (n - b) * (a - d)\n    elif c < a and b < d:\n        res += (a - c) * (d - b)\n    cur = (min(a, c), max(b, d))\nres += 1\nprint(res)", "n = int(input())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n(first, last) = ([n - 1] * (n + 1), [0] * (n + 1))\nfor (j, v) in enumerate(a):\n    first[v] = min(first[v], j)\n    last[v] = max(last[v], j)\nfor (j, v) in enumerate(b):\n    first[v] = min(first[v], j)\n    last[v] = max(last[v], j)\nfirstp = first[:]\nlastp = last[:]\nfor j in range(1, n + 1):\n    firstp[j] = min(firstp[j - 1], first[j])\n    lastp[j] = max(lastp[j - 1], last[j])\ncounts = [0] * (n + 1)\ncounts[0] = (first[1] + 1) * first[1] // 2 + (n - last[1] - 1) * (n - last[1]) // 2 + (last[1] - first[1]) * (last[1] - first[1] - 1) // 2\nfor j in range(n, 1, -1):\n    if last[j] < firstp[j - 1]:\n        a = firstp[j - 1] - last[j]\n        b = n - lastp[j - 1]\n    elif first[j] < firstp[j - 1] and last[j] > lastp[j - 1]:\n        a = firstp[j - 1] - first[j]\n        b = last[j] - lastp[j - 1]\n    elif first[j] > lastp[j - 1]:\n        a = firstp[j - 1] + 1\n        b = first[j] - lastp[j - 1]\n    else:\n        continue\n    counts[j] = a * b\nprint(sum(counts) + 1)", "import sys\nimport math\ninput = lambda : sys.stdin.readline().rstrip()\n(res, n) = (1, int(input()))\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n(P, Q) = (sorted(((p, i) for (i, p) in enumerate(P))), sorted(((p, i) for (i, p) in enumerate(Q))))\nreq = [n, -1]\n(pi, qi) = (P[0][1], Q[0][1])\n(minI, maxI) = (min(pi, qi), max(pi, qi))\nres += math.comb(minI + 1, 2)\nres += math.comb(maxI - minI, 2)\nres += math.comb(n - maxI, 2)\nfor j in range(1, n):\n    req[0] = min(req[0], minI)\n    req[1] = max(req[1], maxI)\n    (pi, qi) = (P[j][1], Q[j][1])\n    (minI, maxI) = (min(pi, qi), max(pi, qi))\n    if minI > req[1]:\n        res += (1 + req[0]) * (minI - req[1])\n    elif maxI < req[0]:\n        res += (n - req[1]) * (req[0] - maxI)\n    elif minI < req[0] and maxI > req[1]:\n        res += (req[0] - minI) * (maxI - req[1])\nprint(res)"]