["import sys, heapq\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef calc(A):\n    (q, s, ans) = ([], 0, 0)\n    for i in A:\n        s += i\n        heapq.heappush(q, i)\n        while s < 0:\n            s -= 2 * heapq.heappop(q)\n            ans += 1\n    return ans\n\ndef solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    return calc(list(map(lambda a: -a, A[m - 1:0:-1]))) + calc(A[m:])\nT = int(input())\nfor i in range(T):\n    print(solve())", "import sys\nimport heapq\n\ndef solve():\n    inp = sys.stdin.readline\n    push = heapq.heappush\n    pop = heapq.heappop\n    (n, m) = map(int, inp().split())\n    a = list(map(int, inp().split()))\n    res = 0\n    if m != 1 and a[m - 1] > 0:\n        res += 1\n        a[m - 1] = -a[m - 1]\n    if m != 1:\n        cur = 0\n        can = []\n        for i in range(m - 1, 0, -1):\n            v = a[i]\n            cur -= v\n            if v > 0:\n                push(can, -v)\n            while cur < 0:\n                mm = -can[0]\n                pop(can)\n                cur += 2 * mm\n                res += 1\n    can = []\n    cur = 0\n    for i in range(m, n):\n        v = a[i]\n        cur += v\n        if v < 0:\n            push(can, v)\n        while cur < 0:\n            mm = can[0]\n            pop(can)\n            cur -= 2 * mm\n            res += 1\n    print(res)\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "import sys, heapq\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef calc(A):\n    (q, s, ans) = ([], 0, 0)\n    for i in A:\n        s += i\n        heapq.heappush(q, i)\n        while s < 0:\n            s -= 2 * heapq.heappop(q)\n            ans += 1\n    return ans\n\ndef solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    return calc(list(map(lambda a: -a, A[m - 1:0:-1]))) + calc(A[m:])\nT = int(input())\nfor i in range(T):\n    print(solve())", "import sys, heapq\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef calc(K):\n    (q, s, ans) = ([], 0, 0)\n    for i in K:\n        s += i\n        heapq.heappush(q, i)\n        while s < 0:\n            s -= 2 * heapq.heappop(q)\n            ans += 1\n    return ans\n\ndef solve():\n    (n, m) = map(int, input().split())\n    K = list(map(int, input().split()))\n    return calc(list(map(lambda a: -a, K[m - 1:0:-1]))) + calc(K[m:])\nT = int(input())\nfor i in range(T):\n    print(solve())", "import sys, heapq\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef calc(A):\n    (q, s, ans) = ([], 0, 0)\n    for i in A:\n        s += i\n        heapq.heappush(q, i)\n        while s < 0:\n            s -= 2 * heapq.heappop(q)\n            ans += 1\n    return ans\n\ndef solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    return calc(list(map(lambda a: -a, A[m - 1:0:-1]))) + calc(A[m:])\nT = int(input())\nfor i in range(T):\n    print(solve())", "import sys, heapq\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef calc(A):\n    (q, s, ans) = ([], 0, 0)\n    for i in A:\n        s += i\n        heapq.heappush(q, i)\n        while s < 0:\n            s -= 2 * heapq.heappop(q)\n            ans += 1\n    return ans\n\ndef solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    return calc(list(map(lambda a: -a, A[m - 1:0:-1]))) + calc(A[m:])\nT = int(input())\nfor i in range(T):\n    print(solve())", "import sys\nimport heapq\ninput = sys.stdin.readline\n\ndef findminlen(a):\n    s = 0\n    h = []\n    ans = 0\n    for i in range(len(a) - 1, -1, -1):\n        s += a[i]\n        if a[i] > 0:\n            heapq.heappush(h, -1 * a[i])\n        while s > 0:\n            if len(h) == 0:\n                break\n            g = heapq.heappop(h)\n            s += 2 * g\n            ans += 1\n    return ans\n\ndef findmnlen(a):\n    s = 0\n    h = []\n    ans = 0\n    for i in range(len(a)):\n        s += a[i]\n        if a[i] < 0:\n            heapq.heappush(h, a[i])\n        while s < 0:\n            if len(h) == 0:\n                break\n            g = heapq.heappop(h)\n            s += -2 * g\n            ans += 1\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    ans += findminlen(a[1:m])\n    ans += findmnlen(a[m:])\n    print(ans)", "import sys\nfrom heapq import *\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        cnt = 0\n        i = m\n        sum = 0\n        H = []\n        while i < n:\n            sum += A[i]\n            heappush(H, A[i])\n            while sum < 0:\n                cnt += 1\n                sum += -2 * heappop(H)\n            i += 1\n        i = m - 1\n        sum = 0\n        H = []\n        while i >= 1:\n            sum += A[i]\n            heappush(H, -A[i])\n            while sum > 0:\n                cnt += 1\n                sum += 2 * heappop(H)\n            i -= 1\n        print(cnt)", "import heapq\n\ndef fun(n, m, l):\n    if n == 1:\n        print(0)\n        return\n    hp = []\n    heapq.heapify(hp)\n    cnt = 0\n    sum = 0\n    for i in range(m, n):\n        sum = sum + l[i]\n        heapq.heappush(hp, l[i])\n        while sum < 0:\n            sum = sum - 2 * hp[0]\n            cnt = cnt + 1\n            d = hp[0]\n            heapq.heappop(hp)\n    hp = []\n    heapq.heapify(hp)\n    sum = 0\n    for i in range(m - 1):\n        sum = sum + l[m - 1 - i]\n        heapq.heappush(hp, -l[m - 1 - i])\n        while sum > 0:\n            sum = sum + 2 * hp[0]\n            cnt = cnt + 1\n            d = hp[0]\n            heapq.heappop(hp)\n    print(cnt)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    fun(n, m, l)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n, m):\n    if n == 1:\n        return 0\n    ans = 0\n    if m > 1 and a[m - 1] > 0:\n        ans += 1\n        a[m - 1] *= -1\n    sm = sum(a[:m])\n    si = sm\n    q = []\n    for i in range(m - 1, 0, -1):\n        si -= a[i]\n        if a[i] > 0:\n            heapq.heappush(q, -a[i])\n        while si < sm:\n            ans += 1\n            sm += 2 * heapq.heappop(q)\n    q = []\n    (si, sm) = (0, 0)\n    for i in range(m + 1, n + 1):\n        si += a[i - 1]\n        if a[i - 1] < 0:\n            heapq.heappush(q, a[i - 1])\n        while si < sm:\n            ans += 1\n            si -= 2 * heapq.heappop(q)\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(a, n, m))", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ans = 0\n    post = []\n    s = 0\n    for x in xs[m:]:\n        heapq.heappush(post, x)\n        s += x\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(post)\n            s += -2 * t\n            heapq.heappush(post, -t)\n    pred = []\n    s = 0\n    for x in xs[1:m][::-1]:\n        heapq.heappush(pred, -x)\n        s += -x\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(pred)\n            s += -2 * t\n            heapq.heappush(pred, -t)\n    print(ans)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n, m):\n    if n == 1:\n        return 0\n    ans = 0\n    if m > 1 and a[m - 1] > 0:\n        ans += 1\n        a[m - 1] *= -1\n    sm = a[m - 1]\n    si = 0\n    q = []\n    for i in range(m - 1, 0, -1):\n        si += a[i]\n        if a[i] > 0:\n            heapq.heappush(q, -a[i])\n        while si > 0:\n            ans += 1\n            si += 2 * heapq.heappop(q)\n    q = []\n    (si, sm) = (0, 0)\n    for i in range(m + 1, n + 1):\n        si += a[i - 1]\n        if a[i - 1] < 0:\n            heapq.heappush(q, a[i - 1])\n        while si < sm:\n            ans += 1\n            si -= 2 * heapq.heappop(q)\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(a, n, m))", "from heapq import heapify, heappop, heappush\nfor tcase in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = 0\n    (s, pq) = (0, [])\n    for i in range(m, n):\n        s += a[i]\n        heappush(pq, a[i])\n        while s < 0:\n            s -= 2 * heappop(pq)\n            ans += 1\n    (s, pq) = (0, [])\n    for i in reversed(range(1, m)):\n        s += a[i]\n        heappush(pq, -a[i])\n        while s > 0:\n            s += 2 * heappop(pq)\n            ans += 1\n    print(ans)", "import heapq\n\ndef count1(a):\n    heap = []\n    heapq.heapify(heap)\n    cur_sum = 0\n    count = 0\n    for i in range(len(a)):\n        cur_sum += a[i]\n        heapq.heappush(heap, -a[i])\n        while cur_sum > 0:\n            tmp = -heapq.heappop(heap)\n            cur_sum -= 2 * tmp\n            heapq.heappush(heap, tmp)\n            count += 1\n    return count\n\ndef count2(a):\n    heap = []\n    heapq.heapify(heap)\n    cur_sum = 0\n    count = 0\n    for i in range(len(a)):\n        cur_sum += a[i]\n        heapq.heappush(heap, a[i])\n        while cur_sum < 0:\n            tmp = heapq.heappop(heap)\n            cur_sum -= 2 * tmp\n            heapq.heappush(heap, -tmp)\n            count += 1\n    return count\n\ndef solve(a, m):\n    ans = count1(a[1:m][::-1]) + count2(a[m:])\n    print(ans)\n    return\nt = int(input())\nfor i in range(t):\n    s = input()\n    (n, m) = (int(s.split()[0]), int(s.split()[1]))\n    a = [int(si) for si in input().split()]\n    solve(a, m)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n, m):\n    if n == 1:\n        return 0\n    ans = 0\n    if m > 1 and a[m - 1] > 0:\n        ans += 1\n        a[m - 1] *= -1\n    sm = sum(a[:m])\n    si = sm\n    q = []\n    for i in range(m - 1, 0, -1):\n        si -= a[i]\n        if a[i] > 0:\n            heapq.heappush(q, -a[i])\n        while si < sm:\n            ans += 1\n            sm += 2 * heapq.heappop(q)\n    q = []\n    (si, sm) = (0, 0)\n    for i in range(m + 1, n + 1):\n        si += a[i - 1]\n        if a[i - 1] < 0:\n            heapq.heappush(q, a[i - 1])\n        while si < sm:\n            ans += 1\n            si -= 2 * heapq.heappop(q)\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    res = solve(a, n, m)\n    print(res)", "import heapq\n\ndef main():\n    res = 0\n    pre = 0\n    q = []\n    for i in range(m + 1, n):\n        pre += a[i]\n        if a[i] < 0:\n            heapq.heappush(q, a[i])\n        while pre < 0:\n            res += 1\n            pre -= 2 * heapq.heappop(q)\n    pre = 0\n    q = []\n    for i in range(m, 0, -1):\n        pre += a[i]\n        if a[i] > 0:\n            heapq.heappush(q, -a[i])\n        while pre > 0:\n            res += 1\n            pre += 2 * heapq.heappop(q)\n    return res\nt = int(input())\nfor case in range(t):\n    (n, m) = map(int, input().split())\n    m -= 1\n    a = list(map(int, input().split()))\n    print(main())", "import heapq\n\ndef LPS(n, m, strs):\n    if n == 1:\n        return 0\n    h = []\n    heapq.heapify(h)\n    (cnt, pm) = (0, 0)\n    cur_m = m\n    while cur_m < n - 1:\n        pm = pm + strs[cur_m + 1]\n        heapq.heappush(h, strs[cur_m + 1])\n        if pm < 0:\n            x = heapq.heappop(h)\n            pm = pm - 2 * x\n            cnt = cnt + 1\n        cur_m = cur_m + 1\n    h = []\n    heapq.heapify(h)\n    pm = 0\n    A = strs[:m + 1]\n    A.reverse()\n    for i in range(m):\n        pm = pm + A[i]\n        heapq.heappush(h, -A[i])\n        if pm > 0:\n            x = heapq.heappop(h)\n            pm = pm + 2 * x\n            cnt = cnt + 1\n    new_pm = pm + A[m]\n    if new_pm > 0:\n        if new_pm > A[m]:\n            cnt = cnt + 1\n    return cnt\nx = int(input())\nfor i in range(x):\n    nm = list(map(int, input().split()))\n    (n, m) = (nm[0], nm[1] - 1)\n    s = list(map(int, input().split()))\n    print(LPS(n, m, s))", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ans = 0\n    post = []\n    s = 0\n    for x in xs[m:]:\n        heapq.heappush(post, x)\n        s += x\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(post)\n            s += -2 * t\n            heapq.heappush(post, -t)\n    pred = []\n    s = 0\n    for x in xs[1:m][::-1]:\n        heapq.heappush(pred, -x)\n        s += -x\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(pred)\n            s += -2 * t\n            heapq.heappush(pred, -t)\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    [n, m] = list(map(int, input().split(' ')))\n    arr = list(map(int, input().split(' ')))\n    ans = 0\n    s = 0\n    h = []\n    for i in range(m, n):\n        if arr[i] < 0:\n            heapq.heappush(h, arr[i])\n        s += arr[i]\n        if s < 0:\n            s -= 2 * heapq.heappop(h)\n            ans += 1\n    h = []\n    s = 0\n    for i in range(m - 1, 0, -1):\n        if arr[i] > 0:\n            heapq.heappush(h, -1 * arr[i])\n        s += arr[i]\n        if s > 0:\n            s -= -2 * heapq.heappop(h)\n            ans += 1\n    print(ans)", "import heapq\n\ndef least_prefix_sum(n, m, nums):\n    index: int = m - 1\n    operation_count: int = 0\n    cur_sum = 0\n    heap = []\n    while index >= 1:\n        if nums[index] > 0:\n            heapq.heappush(heap, -1 * nums[index])\n        if cur_sum + nums[index] > 0:\n            cur_sum += 2 * heap[0]\n            heapq.heappop(heap)\n            operation_count += 1\n        cur_sum += nums[index]\n        index -= 1\n    cur_sum = 0\n    heap = []\n    index = m\n    while index < len(nums):\n        if nums[index] < 0:\n            heapq.heappush(heap, nums[index])\n        if cur_sum + nums[index] < 0:\n            cur_sum -= 2 * heap[0]\n            heapq.heappop(heap)\n            operation_count += 1\n        cur_sum += nums[index]\n        index += 1\n    return operation_count\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    nums = input().split(' ')\n    nums = [int(x) for x in nums]\n    print(least_prefix_sum(n, m, nums))", "def inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\nimport heapq\n\ndef min_heap_compare(element1, element2):\n    if element1 > element2:\n        return True\n    return False\n\ndef max_heap_compare(element1, element2):\n    if element1 < element2:\n        return True\n    return False\ntests = inp()\nfor i in range(tests):\n    (n, m) = invr()\n    arr = inlt()\n    ans = 0\n    max_heap = []\n    prefix_sum = 0\n    for j in range(m - 1, 0, -1):\n        prefix_sum += arr[j]\n        heapq.heappush(max_heap, -arr[j])\n        if prefix_sum > 0:\n            val = heapq.heappop(max_heap)\n            prefix_sum += 2 * val\n            ans += 1\n    min_heap = []\n    prefix_sum = 0\n    for j in range(m, n):\n        prefix_sum += arr[j]\n        heapq.heappush(min_heap, arr[j])\n        if prefix_sum < 0:\n            val = heapq.heappop(min_heap)\n            prefix_sum += -2 * val\n            ans += 1\n    print(ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ans = 0\n    post = []\n    s = 0\n    for x in xs[m:]:\n        heapq.heappush(post, x)\n        s += x\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(post)\n            s += -2 * t\n            heapq.heappush(post, -t)\n    pred = []\n    s = 0\n    for x in xs[1:m][::-1]:\n        heapq.heappush(pred, -x)\n        s += -x\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(pred)\n            s += -2 * t\n            heapq.heappush(pred, -t)\n    print(ans)", "import heapq\nT = int(input())\nwhile T > 0:\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    val = 0\n    heap = []\n    ret = 0\n    for i in range(m - 1, 0, -1):\n        val += A[i]\n        if A[i] > 0:\n            heapq.heappush(heap, -A[i])\n            while val > 0:\n                t = heapq.heappop(heap)\n                val += 2 * t\n                ret += 1\n    heap = []\n    val = 0\n    for i in range(m, n):\n        val += A[i]\n        if A[i] < 0:\n            heapq.heappush(heap, A[i])\n            while val < 0:\n                t = heapq.heappop(heap)\n                val -= 2 * t\n                ret += 1\n    print(ret)\n    T -= 1", "import heapq\nT = int(input())\nwhile T > 0:\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    val = 0\n    heap = []\n    ret = 0\n    for i in range(m - 1, 0, -1):\n        val += A[i]\n        if A[i] > 0:\n            heapq.heappush(heap, -A[i])\n            while val > 0:\n                t = heapq.heappop(heap)\n                val += 2 * t\n                ret += 1\n    heap = []\n    val = 0\n    for i in range(m, n):\n        val += A[i]\n        if A[i] < 0:\n            heapq.heappush(heap, A[i])\n            while val < 0:\n                t = heapq.heappop(heap)\n                val -= 2 * t\n                ret += 1\n    print(ret)\n    T -= 1", "import heapq\nfor _ in range(int(input())):\n    [n, m] = list(map(int, input().split(' ')))\n    arr = list(map(int, input().split(' ')))\n    ans = 0\n    s = 0\n    h = []\n    for i in range(m, n):\n        if arr[i] < 0:\n            heapq.heappush(h, arr[i])\n        s += arr[i]\n        if s < 0:\n            s -= 2 * heapq.heappop(h)\n            ans += 1\n    h = []\n    s = 0\n    for i in range(m - 1, 0, -1):\n        if arr[i] > 0:\n            heapq.heappush(h, -1 * arr[i])\n        s += arr[i]\n        if s > 0:\n            s -= -2 * heapq.heappop(h)\n            ans += 1\n    print(ans)", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    hp = []\n    run = 0\n    final = 0\n    for i in range(m, n):\n        run += arr[i]\n        if arr[i] < 0:\n            heappush(hp, arr[i])\n        if run < 0:\n            final += 1\n            run -= 2 * heappop(hp)\n    hp = []\n    run = 0\n    for i in reversed(range(1, m)):\n        arr[i] = -arr[i]\n        run += arr[i]\n        if arr[i] < 0:\n            heappush(hp, arr[i])\n        if run < 0:\n            final += 1\n            run -= 2 * heappop(hp)\n    print(final)", "import heapq\nfrom itertools import accumulate\n\ndef first_func(arr: list, pre: list, m: int) -> int:\n    hp = list()\n    ths = pre[m + 1]\n    cnt = 0\n    for i in range(m + 1, 0, -1):\n        while pre[i] < ths:\n            tmp = heapq.heappop(hp)\n            ths += 2 * tmp\n            cnt += 1\n        heapq.heappush(hp, -1 * arr[i - 1])\n    return cnt\n\ndef second_func(arr: list, pre: list, n: int, m: int) -> int:\n    hp = list()\n    ths = pre[m + 1]\n    cnt = 0\n    for i in range(m + 2, n + 1):\n        heapq.heappush(hp, arr[i - 1])\n        while pre[i] < ths:\n            tmp = heapq.heappop(hp)\n            ths += 2 * tmp\n            cnt += 1\n    return cnt\nn = int(input())\nwhile n > 0:\n    n -= 1\n    (k, m) = list(map(int, input().split()))\n    m -= 1\n    arr = list(map(int, input().split()))\n    pre = [0] + list(accumulate(arr))\n    print(first_func(arr, pre, m) + second_func(arr, pre, k, m))", "import heapq\n\ndef solve(N, m, nums):\n    ans = 0\n    (arr, ps) = ([], 0)\n    for i in range(m, 0, -1):\n        ps += nums[i]\n        heapq.heappush(arr, -nums[i])\n        while ps > 0:\n            a = -heapq.heappop(arr)\n            ps -= a + a\n            ans += 1\n    (arr, ps) = ([], 0)\n    for i in range(m + 1, N):\n        ps += nums[i]\n        heapq.heappush(arr, nums[i])\n        while ps < 0:\n            a = heapq.heappop(arr)\n            ps -= a + a\n            ans += 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    (N, M) = list(map(int, input().split()))\n    nums = list(map(int, input().split()))\n    print(solve(N, M - 1, nums))", "import heapq\nfrom itertools import accumulate\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    m -= 1\n    arr = list(map(int, input().split(' ')))\n    pref = list(accumulate(arr))\n    cur = pref[m]\n    heap = []\n    op = 0\n    for i in range(m, -1, -1):\n        if pref[i] < cur and heap:\n            cur += 2 * heapq.heappop(heap)\n            op += 1\n        heapq.heappush(heap, -arr[i])\n    heap = []\n    cur = pref[m]\n    for i in range(m + 1, n):\n        heapq.heappush(heap, arr[i])\n        if pref[i] < cur and heap:\n            cur += 2 * heapq.heappop(heap)\n            op += 1\n    print(op)", "from heapq import heappop, heappush\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    hp = []\n    run = 0\n    final = 0\n    for i in range(m, n):\n        run += arr[i]\n        if arr[i] < 0:\n            heappush(hp, arr[i])\n        if run < 0:\n            final += 1\n            run -= 2 * heappop(hp)\n    hp.clear()\n    run = 0\n    for i in reversed(range(1, m)):\n        arr[i] = -arr[i]\n        run += arr[i]\n        if arr[i] < 0:\n            heappush(hp, arr[i])\n        if run < 0:\n            final += 1\n            run -= 2 * heappop(hp)\n    print(final)", "import heapq\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ans = 0\n    s = 0\n    post = []\n    for i in xs[m:]:\n        s += i\n        heapq.heappush(post, i)\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(post)\n            s -= 2 * t\n            heapq.heappush(post, -t)\n    s = 0\n    pre = []\n    for i in xs[1:m][::-1]:\n        s -= i\n        heapq.heappush(pre, -i)\n        while s < 0:\n            ans += 1\n            t = heapq.heappop(pre)\n            s -= 2 * t\n            heapq.heappush(pre, -t)\n    print(ans)", "import heapq\nfor _ in range(int(input())):\n    [n, m] = list(map(int, input().split(' ')))\n    arr = list(map(int, input().split(' ')))\n    ans = 0\n    s = 0\n    h = []\n    for i in range(m, n):\n        if arr[i] < 0:\n            heapq.heappush(h, arr[i])\n        s += arr[i]\n        if s < 0:\n            s -= 2 * heapq.heappop(h)\n            ans += 1\n    h = []\n    s = 0\n    for i in range(m - 1, 0, -1):\n        if arr[i] > 0:\n            heapq.heappush(h, -1 * arr[i])\n        s += arr[i]\n        if s > 0:\n            s -= -2 * heapq.heappop(h)\n            ans += 1\n    print(ans)", "import heapq\niter = int(input())\nfor _ in range(iter):\n    (n, m) = list(map(int, input().split(' ')))\n    a = list(map(int, input().split(' ')))\n    op = 0\n    heap = []\n    addheap = []\n    if a[m - 1] > 0 and m != 1:\n        a[m - 1] = -a[m - 1]\n        op += 1\n    pre = sum(a[:m + 1])\n    s = pre\n    heapq.heapify(heap)\n    heapq.heapify(addheap)\n    for i in range(m - 2, -1, -1):\n        s -= a[i + 1]\n        if s < pre:\n            while s < pre:\n                pre += heapq.heappop(heap)\n                op += 1\n        if a[i] > 0:\n            heapq.heappush(heap, -2 * a[i])\n    s = pre\n    for i in range(m, n):\n        s += a[i]\n        if a[i] < 0:\n            heapq.heappush(addheap, a[i])\n        if s < pre:\n            while s < pre:\n                s -= 2 * heapq.heappop(addheap)\n                op += 1\n    print(op)", "t = int(input())\nimport heapq\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sums = sum(a[:m])\n    lin = sums\n    res = 0\n    ans = []\n    for i in range(m - 1, 0, -1):\n        lin -= a[i]\n        if a[i] > 0:\n            heapq.heappush(ans, -a[i])\n        if lin < sums:\n            sums += 2 * heapq.heappop(ans)\n            res += 1\n    lin = 0\n    ans = []\n    for i in range(m, n):\n        lin += a[i]\n        if a[i] < 0:\n            heapq.heappush(ans, a[i])\n        if lin < 0:\n            lin -= 2 * heapq.heappop(ans)\n            res += 1\n    print(res)", "import heapq\n\ndef first_func(arr: list, pre: list, m: int) -> int:\n    hp = list()\n    ths = pre[m + 1]\n    cnt = 0\n    for i in range(m + 1, 0, -1):\n        while pre[i] < ths:\n            tmp = heapq.heappop(hp)\n            assert tmp <= 0\n            ths += 2 * tmp\n            cnt += 1\n        heapq.heappush(hp, -1 * arr[i - 1])\n    return cnt\n\ndef second_func(arr: list, pre: list, n: int, m: int) -> int:\n    hp = list()\n    ths = pre[m + 1]\n    cnt = 0\n    for i in range(m + 2, n + 1):\n        heapq.heappush(hp, arr[i - 1])\n        while pre[i] < ths:\n            tmp = heapq.heappop(hp)\n            assert tmp <= 0\n            ths += 2 * tmp\n            cnt += 1\n    return cnt\nn = int(input())\nwhile n > 0:\n    n -= 1\n    (k, m) = list(map(int, input().split()))\n    m -= 1\n    arr = list(map(int, input().split()))\n    pre = list()\n    pre.append(0)\n    for i in range(0, arr.__len__()):\n        pre.append(arr[i] + pre[i])\n    print(first_func(arr, pre, m) + second_func(arr, pre, k, m))", "import heapq\n\ndef heappush(heap, item):\n    return heapq.heappush(heap, -item)\n\ndef heappop(heap):\n    return -heapq.heappop(heap)\nfor i in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    if n == 1:\n        print('0')\n        continue\n    (opr, summ) = (0, 0)\n    hea1 = []\n    heapq.heapify(hea1)\n    for i in range(m, n):\n        if arr[i] < 0:\n            heappush(hea1, -arr[i])\n        summ += arr[i]\n        while summ < 0:\n            temp = -heappop(hea1)\n            temp = -temp\n            summ += temp * 2\n            opr += 1\n    if arr[m - 1] <= 0:\n        summ = arr[m - 1]\n    elif m != 1:\n        summ = -arr[m - 1]\n        opr += 1\n    temp = 0\n    hea2 = []\n    heapq.heapify(hea2)\n    for i in range(m - 2, 0, -1):\n        if arr[i] > 0:\n            heappush(hea2, arr[i])\n        summ += arr[i]\n        while summ > 0:\n            temp = heappop(hea2)\n            temp = -temp\n            summ += temp * 2\n            opr += 1\n    print(opr)", "import heapq\nt = int(input())\nwhile t > 0:\n    (n, m) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    m_sum = 0\n    lst = []\n    temp = []\n    temp.append(arr[0])\n    for i in range(1, n):\n        temp.append(temp[i - 1] + arr[i])\n    temp_sum = temp[m - 1]\n    count = 0\n    heapq.heapify(lst)\n    for i in range(m - 1, -1, -1):\n        while temp[i] < temp_sum:\n            tp = -1 * heapq.heappop(lst)\n            temp_sum = temp_sum - 2 * tp\n            count = count + 1\n        heapq.heappush(lst, -1 * arr[i])\n    li = []\n    temp_sum = temp[m - 1]\n    heapq.heapify(li)\n    for i in range(m, n):\n        heapq.heappush(li, arr[i])\n        while temp[i] < temp_sum:\n            item = heapq.heappop(li)\n            temp_sum = temp_sum + 2 * item\n            count = count + 1\n    print(count)\n    t = t - 1", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().strip().split()]\n    a = [int(i) for i in input().strip().split()]\n    op = 0\n    curr_sum = 0\n    if a[m - 1] <= 0:\n        curr_sum = a[m - 1]\n    elif m != 1:\n        curr_sum = -1 * a[m - 1]\n        a[m - 1] = -1 * a[m - 1]\n        op += 1\n    pos = []\n    temp = 0\n    for i in range(m - 2, 0, -1):\n        if a[i] > 0:\n            heapq.heappush(pos, (-a[i], i))\n        curr_sum += a[i]\n        while curr_sum > 0:\n            (ele, ind) = heapq.heappop(pos)\n            curr_sum += 2 * ele\n            a[ind] = ele\n            op += 1\n    val = curr_sum\n    pos = []\n    for i in range(m, n):\n        if a[i] < 0:\n            heapq.heappush(pos, (a[i], i))\n        curr_sum += a[i]\n        while curr_sum < val:\n            (ele, ind) = heapq.heappop(pos)\n            curr_sum -= 2 * ele\n            a[ind] = -ele\n            op += 1\n    print(op)", "import heapq\nimport math\neps = 10 ** (-9)\n\ndef solve():\n    (n, m) = input().split(' ')\n    n = int(n)\n    m = int(m)\n    a = input().split(' ')\n    a = [int(x) for x in a]\n    p = [0]\n    ans = 0\n    mini = float('inf')\n    for i in range(len(a)):\n        p.append(a[i] + p[i])\n        mini = min(mini, p[i + 1])\n    if p[m] == mini:\n        print(ans)\n        return\n    z = []\n    accum = 0\n    for i in range(m + 1, len(p)):\n        if a[i - 1] < 0:\n            a[i - 1] = -a[i - 1]\n            heapq.heappush(z, -a[i - 1])\n        p[i] += accum\n        x = p[i]\n        while x < p[m]:\n            y = -heapq.heappop(z)\n            x += 2 * y\n            ans += 1\n            accum += 2 * y\n        p[i] = x\n    if p[m] == min(p):\n        print(ans)\n        return\n    z = []\n    for i in range(m - 1, 0, -1):\n        if a[i] > 0:\n            a[i] = -a[i]\n            heapq.heappush(z, a[i])\n        while p[i] < p[m]:\n            y = heapq.heappop(z)\n            p[m] += 2 * y\n            ans += 1\n    print(ans)\n    return\nt = int(input())\nfor _ in range(t):\n    solve()", "from queue import PriorityQueue as pq\n\ndef intl(l):\n    return list(map(int, l))\n\ndef solve():\n    (n, m) = map(int, input().split())\n    m -= 1\n    a = intl(input().split())\n    psum = [a[0]]\n    for i in range(1, n):\n        psum.append(a[i] + psum[-1])\n    op = 0\n    ch = 0\n    post = pq()\n    for i in range(m + 1, n):\n        if a[i] < 0:\n            post.put(a[i])\n        while psum[i] + ch < psum[m]:\n            x = post.get()\n            ch -= 2 * x\n            op += 1\n    ch = 0\n    pre = pq()\n    for i in range(m, -1, -1):\n        while psum[i] < psum[m] + ch:\n            x = pre.get()\n            ch += 2 * x\n            op += 1\n        if a[i] > 0:\n            pre.put(-a[i])\n    return op\nt = int(input())\nfor _ in range(t):\n    print(solve())", "import itertools\nfrom queue import PriorityQueue\n\ndef solve_left(arr):\n    curr_sum = 0\n    changes_nr = 0\n    positives_pq = PriorityQueue()\n    for elem in arr:\n        curr_sum += elem\n        if elem > 0:\n            positives_pq.put(-elem)\n        while curr_sum > 0 and (not positives_pq.empty()):\n            to_modify = -positives_pq.get()\n            curr_sum -= 2 * to_modify\n            changes_nr += 1\n    return changes_nr\n\ndef solve_right(arr):\n    curr_sum = 0\n    changes_nr = 0\n    negatives_pq = PriorityQueue()\n    for elem in arr:\n        curr_sum += elem\n        if elem < 0:\n            negatives_pq.put(elem)\n        while curr_sum < 0 and (not negatives_pq.empty()):\n            to_modify = negatives_pq.get()\n            curr_sum -= 2 * to_modify\n            changes_nr += 1\n    return changes_nr\n\ndef run():\n    (n, m) = (int(x) for x in input().split())\n    m -= 1\n    arr = [int(x) for x in input().split()]\n    if n == 1:\n        print(0)\n        return\n    ans = solve_left(arr[1:m + 1][::-1]) + solve_right(arr[m + 1:])\n    print(ans)\ntests_nr = int(input())\nfor _ in range(tests_nr):\n    run()", "from queue import PriorityQueue\nfor _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    m -= 1\n    count = 0\n    pre = [0] * (n + 1)\n    for i in range(n):\n        pre[i + 1] = pre[i] + a[i]\n    t = 0\n    pq = PriorityQueue()\n    pq.put(-a[m])\n    for i in range(m - 1, -1, -1):\n        while pre[i + 1] < pre[m + 1] + 2 * t:\n            t += pq.get()\n            count += 1\n        pq.put(-a[i])\n    t = 0\n    q = PriorityQueue()\n    for i in range(m + 1, n):\n        q.put(a[i])\n        while pre[i + 1] + 2 * t < pre[m + 1]:\n            t -= q.get()\n            count += 1\n    print(count)"]