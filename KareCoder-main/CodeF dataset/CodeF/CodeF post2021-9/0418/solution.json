["import sys\ninput = sys.stdin.readline\n\ndef positive_dist(x, n, k, last):\n    cur = n - 1\n    total = 0\n    while cur >= 0 and x[cur] > 0:\n        total += 2 * x[cur]\n        cur -= k\n    if last and x[-1] > 0:\n        total -= x[-1]\n    return total\n\ndef negative_dist(x, n, k, last):\n    cur = 0\n    total = 0\n    while cur < n and x[cur] < 0:\n        total -= 2 * x[cur]\n        cur += k\n    if last and x[0] < 0:\n        total += x[0]\n    return total\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    x = [int(i) for i in input().split()]\n    x.sort()\n    if x[0] >= 0:\n        print(positive_dist(x, n, k, True))\n    elif x[-1] <= 0:\n        print(negative_dist(x, n, k, True))\n    elif abs(x[0]) > abs(x[-1]):\n        print(positive_dist(x, n, k, False) + negative_dist(x, n, k, True))\n    else:\n        print(positive_dist(x, n, k, True) + negative_dist(x, n, k, False))", "from bisect import bisect_left, bisect_right\n\ndef solve(n, k, depots):\n    distance = 0\n    depots.sort()\n    loc1 = bisect_left(depots, 0)\n    loc2 = bisect_right(depots, 0)\n    j = n - 1\n    while j >= loc2:\n        distance += 2 * depots[j]\n        j -= k\n    j = 0\n    while j < loc1:\n        distance -= 2 * depots[j]\n        j += k\n    if loc2 < n and loc1 > 0:\n        distance -= max(-depots[0], depots[-1])\n    elif loc2 < n:\n        distance -= depots[-1]\n    elif loc1 > 0:\n        distance += depots[0]\n    return distance\nans = []\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    ans.append(solve(n, k, list(map(int, input().split()))))\nprint(*ans, sep='\\n')", "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    (b, c) = ([], [])\n    for x in a:\n        if x > 0:\n            b.append(x)\n        elif x < 0:\n            c.append(-x)\n    (nb, nc) = (len(b), len(c))\n    res = 0\n    b.sort()\n    c.sort()\n    if nb == nc == 0:\n        print(0)\n        continue\n    if nc == 0:\n        (nb, nc) = (nc, nb)\n        (b, c) = (c, b)\n    if (nb > 0 and nc > 0) and max(b) > max(c):\n        (nb, nc) = (nc, nb)\n        (b, c) = (c, b)\n    if nb:\n        for x in range(nb - 1, -1, -k):\n            res += b[x] * 2\n    for x in range(nc - 1, -1, -k):\n        res += c[x] * 2\n    print(res - c[-1])", "from sys import stdin, stdout\nimport math\nfor _ in range(int(stdin.readline())):\n    (n, k) = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    a1 = []\n    a2 = []\n    for i in a:\n        if i < 0:\n            a1.append(i * -1)\n        elif i > 0:\n            a2.append(i)\n    a1.sort()\n    a2.sort()\n    ans = 0\n    n1 = len(a1)\n    n2 = len(a2)\n    for i in range(n2 - 1 - k, -1, -k):\n        ans += 2 * a2[i]\n    for i in range(n1 - 1 - k, -1, -k):\n        ans += 2 * a1[i]\n    if n1 > 0 and n2 > 0:\n        if a1[-1] > a2[-1]:\n            ans += a1[-1]\n            ans += 2 * a2[-1]\n        else:\n            ans += a2[-1]\n            ans += 2 * a1[-1]\n    elif n1 > 0:\n        ans += a1[-1]\n    elif n2 > 0:\n        ans += a2[-1]\n    print(ans)", "import heapq\nimport sys\nimport math\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\nI = sys.stdin.readline\nII = lambda : int(I())\nIN = lambda x: map(int, x.split())\nFN = lambda x: map(float, x.split())\nL = lambda x: list(IN(x))\nM = 1000000007\nP = print\nT = True\nF = False\nfor _ in range(II()):\n    (n, k) = IN(I())\n    l = L(I())\n    l.sort()\n    f = 0\n    n2 = n - 1\n    n1 = n\n    for i in range(n):\n        if l[i] >= 0:\n            n2 = min(n2, i - 1)\n        if l[i] > 0:\n            n1 = i\n            break\n    i = n\n    ans = 0\n    while i > n1:\n        ans += 2 * l[max(i - 1, n1)]\n        i = i - k\n    if n1 < n:\n        ans -= l[-1]\n    i = 0\n    while i <= n2:\n        ans -= 2 * l[i]\n        i = i + k\n    if n2 > -1:\n        ans += l[0]\n    if n1 < n and n2 > -1:\n        ans += min(l[-1], abs(l[0]))\n    print(ans)", "from sys import stdin, stdout\n\ndef main():\n    for _ in range(int(stdin.readline().strip())):\n        (n, k) = map(int, stdin.readline().split())\n        x = sorted(list(map(int, stdin.readline().split())))\n        (neg, pos) = ([], [])\n        for i in x:\n            if i < 0:\n                neg.append(i)\n            elif i > 0:\n                pos.append(i)\n        neg.sort()\n        pos.sort(reverse=True)\n        r = []\n        for i in range(0, len(neg), k):\n            r.append(abs(neg[i]))\n        for i in range(0, len(pos), k):\n            r.append(pos[i])\n        if r:\n            print(sum(r) * 2 - max(r))\n        else:\n            print(0)\nmain()", "import sys\nimport bisect\ninp = sys.stdin.readline\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nfor _ in range(int(inp())):\n    (n, k) = map(int, inp().split())\n    a = [int(i) for i in inp().split()]\n    a.append(0)\n    a.sort()\n    i = 0\n    n += 1\n    while a[i] < 0:\n        i += 1\n    ans = 0\n    j = n - 1\n    while j >= i:\n        ans += 2 * a[j]\n        j = j - k\n    j = 0\n    while j < i:\n        ans += 2 * abs(a[j])\n        j = j + k\n    print(ans - max(abs(a[0]), a[-1]))", "def main():\n    for _ in range(int(input())):\n        print(minimize_distance())\n\ndef minimize_distance():\n    (n, k) = map(int, input().split())\n    values = map(int, input().split())\n    positive = []\n    negative = []\n    for val in values:\n        if val > 0:\n            positive.append(val)\n        else:\n            negative.append(-val)\n    positive.sort()\n    negative.sort()\n    if not negative:\n        shorter = negative\n        longer = positive\n    elif not positive:\n        shorter = positive\n        longer = negative\n    elif positive[-1] > negative[-1]:\n        shorter = negative\n        longer = positive\n    else:\n        shorter = positive\n        longer = negative\n    total = longer[-1]\n    si = len(shorter) - 1\n    li = len(longer) - k - 1\n    while si >= 0 or li >= 0:\n        if si < 0:\n            total += longer[li] * 2\n            li -= k\n        elif li < 0:\n            total += shorter[si] * 2\n            si -= k\n        elif longer[li] > shorter[si]:\n            total += longer[li] * 2\n            li -= k\n        else:\n            total += shorter[si] * 2\n            si -= k\n    return total\nmain()", "t = int(input())\nwhile t:\n    t -= 1\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    g = a[0]\n    k = a[1]\n    b.sort()\n    ans = 0\n    i = 0\n    while i < g and b[i] < 0:\n        ans = ans + abs(b[i]) * 2\n        i += k\n    i = g - 1\n    while i >= 0 and b[i] > 0:\n        ans = ans + b[i] * 2\n        i -= k\n    ans = ans - max(abs(b[0]), abs(b[g - 1]))\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    aa = list(map(int, input().split()))\n    c = 0\n    aa.sort()\n    t = True\n    i = n - 1\n    while t == True and i >= 0:\n        if aa[i] > 0:\n            c += aa[i] * 2\n            i -= k\n        else:\n            t = False\n    t = True\n    i = 0\n    while t == True and i < n:\n        if aa[i] < 0:\n            c -= aa[i] * 2\n            i += k\n        else:\n            t = False\n    print(c - max(-aa[0], aa[n - 1]))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.append(0)\n    arr.sort()\n    oi = arr.index(0)\n    ans = 0\n    for i in range(0, oi, k):\n        ans += 2 * abs(arr[i])\n    for i in range(n, oi, -k):\n        ans += 2 * arr[i]\n    t = max(abs(arr[0]), abs(arr[-1]))\n    ans -= t\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    g = a[0]\n    k = a[1]\n    b.sort()\n    ans = 0\n    i = 0\n    while i < g and b[i] < 0:\n        ans = ans + abs(b[i]) * 2\n        i += k\n    i = g - 1\n    while i >= 0 and b[i] > 0:\n        ans = ans + b[i] * 2\n        i -= k\n    ans = ans - max(abs(b[0]), abs(b[g - 1]))\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    c = 0\n    l1.sort()\n    t = True\n    i = n - 1\n    while t and i >= 0:\n        if l1[i] > 0:\n            c += l1[i] * 2\n            i -= k\n        else:\n            t = False\n    t = True\n    i = 0\n    while t == True and i < n:\n        if l1[i] < 0:\n            c -= l1[i] * 2\n            i += k\n        else:\n            t = False\n    print(c - max(-l1[0], l1[n - 1]))", "I = lambda : map(int, input().split())\nfor _ in [0] * int(input()):\n    (n, k) = I()\n    a = sorted(list(I()))\n    i = s = 0\n    while i < n and a[i] < 0:\n        i = i + 1\n    if i == 0:\n        s = a[n - 1]\n        for j in range(n - k - 1, -1, -k):\n            s = s + 2 * a[j]\n    elif i == n:\n        s = a[0]\n        for j in range(k, n, k):\n            s = s + 2 * a[j]\n        s = -s\n    else:\n        b = a[:i]\n        blen = i\n        a = a[i:]\n        alen = n - i\n        if a[-1] < abs(b[0]):\n            s = b[0]\n            for j in range(k, blen, k):\n                s = s + 2 * b[j]\n            s = -s\n            for j in range(alen - 1, -1, -k):\n                s = s + 2 * a[j]\n        else:\n            s = a[alen - 1]\n            for j in range(alen - k - 1, -1, -k):\n                s = s + 2 * a[j]\n            for j in range(0, blen, k):\n                s = s - 2 * b[j]\n    print(s)", "def minimize_distance(n, k, l):\n    l.sort()\n    d = -max(abs(l[0]), abs(l[n - 1]))\n    i = n - 1\n    while i >= 0 and l[i] > 0:\n        d += 2 * l[i]\n        i -= k\n    i = 0\n    while i < n and l[i] < 0:\n        d += 2 * abs(l[i])\n        i += k\n    return d\nt = int(input())\nfor i in range(t):\n    [n, k] = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    print(minimize_distance(n, k, l))", "import math as m\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    res = 0\n    a.sort()\n    pos = (x for x in range(len(a) - 1, -1, -k) if a[x] > 0)\n    nev = (x for x in range(0, len(a), k) if a[x] < 0)\n    for i in pos:\n        res += a[i]\n    for i in nev:\n        res -= a[i]\n    print(2 * res - max(abs(a[0]), a[n - 1]))", "def int_input():\n    a = int(input())\n    return a\n\ndef int_list_input():\n    a = list(map(int, input().split()))\n    return a\n\ndef solve():\n    (n, k) = int_list_input()\n    arr = int_list_input()\n    ans = 0\n    arr.sort()\n    pos = [0]\n    neg = [0]\n    i = n - 1\n    while i >= 0:\n        if arr[i] < 0:\n            break\n        pos.append(arr[i])\n        i = i - k\n    i = 0\n    while i < n:\n        if arr[i] > 0:\n            break\n        neg.append(abs(arr[i]))\n        i = i + k\n    ans = 2 * sum(pos) + 2 * sum(neg)\n    ans -= max(max(pos), max(neg))\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "ne = int(input())\nfor a in range(ne):\n    nk = [int(item) for item in input().split()]\n    n = nk[0]\n    k = nk[1]\n    nnl = [int(item) for item in input().split()]\n    nnl = sorted(nnl, key=lambda item: item)\n    dist = 0\n    neg = 0\n    while neg < n and nnl[neg] < 0:\n        dist -= nnl[neg]\n        neg += k\n    pos = n - 1\n    while pos > -1 and nnl[pos] > 0:\n        dist += nnl[pos]\n        pos -= k\n    bl = 0\n    if nnl[0] < 0:\n        bl -= nnl[0]\n    if nnl[n - 1] > 0:\n        bl = max(bl, nnl[n - 1])\n    dist *= 2\n    dist -= bl\n    print(dist)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    m = list(map(int, input().split()))\n    m.sort()\n    ind = 0\n    s = 0\n    while ind >= 0 and ind < n and (m[ind] <= 0):\n        s += abs(m[ind]) * 2\n        ind += k\n    ind = n - 1\n    while ind >= 0 and ind < n and (m[ind] >= 0):\n        s += abs(m[ind]) * 2\n        ind -= k\n    print(s - max(abs(m[0]), abs(m[-1])))", "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    li = list(map(int, input().split()))\n    ans = 0\n    pos = []\n    neg = []\n    for i in range(n):\n        if li[i] > 0:\n            pos.append(li[i])\n        else:\n            neg.append(-li[i])\n    pos.sort(reverse=True)\n    neg.sort(reverse=True)\n    ans = 0\n    for i in range(k, len(pos)):\n        if i % k == 0:\n            ans = ans + 2 * pos[i]\n    for i in range(k, len(neg)):\n        if i % k == 0:\n            ans = ans + 2 * neg[i]\n    if len(pos) == 0 or len(neg) == 0:\n        if len(pos) != 0:\n            ans = ans + pos[0]\n        elif len(neg) != 0:\n            ans = ans + neg[0]\n    else:\n        ans = ans + min(pos[0], neg[0]) + pos[0] + neg[0]\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    d = []\n    i = 0\n    while i + k - 1 < n:\n        if a[i + k - 1] > 0:\n            break\n        d.append(abs(a[i]))\n        i += k\n    j = n - 1\n    while j - k + 1 >= 0:\n        if a[j - k + 1] < 0:\n            break\n        d.append(a[j])\n        j -= k\n    if i < n and a[i] < 0:\n        d.append(abs(a[i]))\n    if j >= 0 and a[j] > 0:\n        d.append(a[j])\n    print(2 * sum(d) - max(d))", "import math\nimport sys\n\ndef solve(k, negative_part, positive_part):\n    (po, ne) = (len(positive_part), len(negative_part))\n    (answer, a, b) = (0, 0, 0)\n    if po != 0:\n        if po < k:\n            a = positive_part[po - 1]\n            answer += a\n        else:\n            a = positive_part[po - 1]\n            for i in range(po):\n                if i == po - 1:\n                    answer += positive_part[i]\n                elif (po - i - 1) % k == 0:\n                    answer += 2 * positive_part[i]\n    if ne != 0:\n        if ne < k:\n            b = negative_part[ne - 1]\n            answer += b\n        else:\n            b = negative_part[ne - 1]\n            for i in range(ne):\n                if i == ne - 1:\n                    answer += negative_part[i]\n                elif (ne - i - 1) % k == 0:\n                    answer += 2 * negative_part[i]\n    answer += min(a, b)\n    return answer\n\ndef main():\n    test_case = int(sys.stdin.readline())\n    for tc in range(test_case):\n        (n, k) = map(int, sys.stdin.readline().split())\n        arr = [int(a) for a in sys.stdin.readline().split()]\n        positive_part = []\n        negative_part = []\n        for i in range(n):\n            if arr[i] < 0:\n                negative_part.append(-1 * arr[i])\n            else:\n                positive_part.append(arr[i])\n        negative_part.sort()\n        positive_part.sort()\n        print(solve(k, negative_part, positive_part))\nmain()", "T = int(input())\nfor tt in range(T):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    x.sort()\n    res = 0\n    res -= max(abs(x[0]), abs(x[-1]))\n    if x[0] < 0:\n        i = 0\n        while i < len(x) and x[i] < 0:\n            res += 2 * abs(x[i])\n            i += k\n    if x[-1] > 0:\n        i = len(x) - 1\n        while i >= 0 and x[i] > 0:\n            res += 2 * abs(x[i])\n            i -= k\n    print(res)", "def solve(n, k, x):\n    (pos, neg) = ([], [])\n    for num in x:\n        if num < 0:\n            neg.append(-num)\n        elif num > 0:\n            pos.append(num)\n    if pos:\n        pos.sort()\n    if neg:\n        neg.sort()\n    (n1, n2) = (len(pos), len(neg))\n    idx1 = n1 - 1\n    idx2 = n2 - 1\n    v1 = -float('inf') if not pos else pos[-1]\n    v2 = -float('inf') if not neg else neg[-1]\n    v = max(v1, v2)\n    ans = -v\n    if v == -float('inf'):\n        print(0)\n        return\n    while idx1 >= 0 and idx2 >= 0:\n        (p1, p2) = (pos[idx1], neg[idx2])\n        if p1 <= p2:\n            ans += p1 * 2\n            idx1 -= k\n        else:\n            ans += p2 * 2\n            idx2 -= k\n    while idx1 >= 0:\n        p1 = pos[idx1]\n        ans += p1 * 2\n        idx1 -= k\n    while idx2 >= 0:\n        p2 = neg[idx2]\n        ans += p2 * 2\n        idx2 -= k\n    print(ans)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    solve(n, k, x)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    x = [int(i) for i in input().split()]\n    x.sort()\n    d = []\n    i = 0\n    while i < n and x[i] < 0:\n        d.append(-x[i])\n        i += k\n    i = n - 1\n    while i >= 0 and x[i] >= 0:\n        d.append(x[i])\n        i -= k\n    d.sort(reverse=True)\n    ans = 0\n    ans += d[0]\n    for i in range(1, len(d)):\n        ans += d[i] * 2\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    x = sorted(map(int, input().split()))\n    x_filter = []\n    for i in range(0, n, k):\n        if x[i] > 0:\n            break\n        x_filter.append(abs(x[i]))\n    for i in range(n - 1, -1, -k):\n        if x[i] < 0:\n            break\n        x_filter.append(abs(x[i]))\n    print(sum(x_filter) * 2 - max(x_filter))", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = sorted(list(map(int, input().split())))\n    ans = -max(abs(a[0]), abs(a[-1]))\n    i = n - 1\n    while i >= 0 and a[i] >= 0:\n        ans += 2 * a[i]\n        i -= k\n    i = 0\n    while i < n and a[i] < 0:\n        ans += 2 * abs(a[i])\n        i += k\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    a = []\n    b = []\n    for j in map(int, input().split()):\n        if j > 0:\n            a.append(j)\n        elif j < 0:\n            b.append(-j)\n    a.sort()\n    b.sort()\n    l = 0\n    mx = 0\n    if len(a + b) > 0:\n        mx = max(a + b)\n    if len(a) > 0:\n        l += a[(len(a) % k - 1) % k] * 2\n        a = a[(len(a) % k - 1) % k + 1:]\n        if len(a) > 0:\n            for j in range(len(a) // k):\n                l += 2 * a[j * k + k - 1]\n    if len(b) > 0:\n        l += b[(len(b) % k - 1) % k] * 2\n        b = b[(len(b) % k - 1) % k + 1:]\n        if len(b) > 0:\n            for j in range(len(b) // k):\n                l += 2 * b[j * k + k - 1]\n    print(l - mx)", "t = int(input())\nfor r in range(t):\n    (n, k) = map(int, input().split())\n    r = 0\n    A = list(map(int, input().split()))\n    A = sorted(A)\n    if abs(A[0]) > abs(A[n - 1]):\n        r -= abs(A[0])\n    else:\n        r -= abs(A[n - 1])\n    af = 0\n    ak = 0\n    ind = -1\n    for i in range(n):\n        if A[i] < 0:\n            ind = i\n    b = 0\n    while b <= ind:\n        r += 2 * abs(A[b])\n        b += k\n    b = n - 1\n    while b > ind:\n        r += 2 * A[b]\n        b -= k\n    print(r)", "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    li = list(map(int, input().split()))\n    ans = 0\n    pos = []\n    neg = []\n    for i in range(n):\n        if li[i] > 0:\n            pos.append(li[i])\n        else:\n            neg.append(-li[i])\n    pos.sort()\n    neg.sort()\n    ans = 0\n    p = len(pos)\n    p = p - k\n    x = len(neg)\n    x = x - k\n    for i in range(p):\n        if i % k == (p - 1) % k:\n            ans = ans + 2 * pos[i]\n    for i in range(x):\n        if i % k == (x - 1) % k:\n            ans = ans + 2 * neg[i]\n    if len(pos) == 0 or len(neg) == 0:\n        if len(pos) != 0:\n            ans = ans + pos[-1]\n        elif len(neg) != 0:\n            ans = ans + neg[-1]\n    else:\n        ans = ans + min(pos[-1], neg[-1]) + pos[-1] + neg[-1]\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (n, k) = [int(c) for c in input().split(' ')]\n    x = [int(c) for c in input().split(' ')]\n    pos = [y for y in x if y > 0]\n    neg = [abs(y) for y in x if y < 0]\n    pos.sort()\n    neg.sort()\n    dist = 0\n    for l in [pos, neg]:\n        strt = len(l) % k\n        if strt == 0:\n            strt = k\n        strt -= 1\n        kk = strt\n        while kk < len(l) - 1:\n            dist += 2 * l[kk]\n            kk += k\n    if len(pos) == 0:\n        mpos = 0\n    else:\n        mpos = pos[-1]\n    if len(neg) == 0:\n        mneg = 0\n    else:\n        mneg = neg[-1]\n    dist += 2 * min(mpos, mneg)\n    dist += max(mpos, mneg)\n    print(dist)", "t = int(input())\nfor u in range(t):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    x.sort()\n    ans = 0\n    if abs(x[0]) > abs(x[n - 1]):\n        ans -= abs(x[0])\n    else:\n        ans -= abs(x[n - 1])\n    pos = -1\n    for i in range(n):\n        if x[i] < 0:\n            pos += 1\n    j = 0\n    while j <= pos:\n        ans += abs(x[j]) * 2\n        j += k\n    j = n - 1\n    while j > pos:\n        ans += x[j] * 2\n        j -= k\n    print(ans)", "def solve(n, k, x):\n    (pos, neg) = ([], [])\n    for num in x:\n        if num < 0:\n            neg.append(-num)\n        elif num > 0:\n            pos.append(num)\n    if pos:\n        pos.sort()\n    if neg:\n        neg.sort()\n    (n1, n2) = (len(pos), len(neg))\n    idx1 = n1 - 1\n    idx2 = n2 - 1\n    v1 = 0 if not pos else pos[-1]\n    v2 = 0 if not neg else neg[-1]\n    ans = -max(v1, v2)\n    while idx1 >= 0 and idx2 >= 0:\n        (p1, p2) = (pos[idx1], neg[idx2])\n        if p1 <= p2:\n            ans += p1 * 2\n            idx1 -= k\n        else:\n            ans += p2 * 2\n            idx2 -= k\n    while idx1 >= 0:\n        p1 = pos[idx1]\n        ans += p1 * 2\n        idx1 -= k\n    while idx2 >= 0:\n        p2 = neg[idx2]\n        ans += p2 * 2\n        idx2 -= k\n    print(ans)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    solve(n, k, x)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    st_p = []\n    st_m = []\n    for i in input().split():\n        i = int(i)\n        if i > 0:\n            st_p.append(i)\n        else:\n            st_m.append(i)\n    st_p.sort()\n    st_m.sort()\n    awn = -2 * sum(st_m[::k])\n    awn += 2 * sum(st_p[::-k])\n    if st_p and st_m:\n        awn -= max(-st_m[::k][0], st_p[::-k][0])\n    elif st_p:\n        awn -= st_p[::-k][0]\n    elif st_m:\n        awn += st_m[::k][0]\n    else:\n        awn = 0\n    print(awn)", "def minimiseDistance(n, k, array):\n    left = []\n    right = []\n    for x in range(n):\n        if array[x] < 0:\n            left.append(abs(array[x]))\n        elif array[x] > 0:\n            right.append(array[x])\n    if not left and (not right):\n        return 0\n    right.sort()\n    qR = len(right)\n    dist = 0\n    rem = qR % k\n    if rem == 0:\n        i = rem\n    else:\n        dist += right[rem - 1] * 2\n        i = rem\n    while i < qR:\n        i += k\n        dist += right[i - 1] * 2\n    left.sort()\n    qL = len(left)\n    rem = qL % k\n    if rem == 0:\n        i = rem\n    else:\n        dist += left[rem - 1] * 2\n        i = rem\n    while i < qL:\n        i += k\n        dist += left[i - 1] * 2\n    if not left:\n        dist -= right[-1]\n    elif not right:\n        dist -= left[-1]\n    else:\n        dist -= max(left[-1], right[-1])\n    return dist\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    print(minimiseDistance(n, k, l))", "import sys\nfrom os import path\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = map(int, input().split())\n    (neg, pos) = ([], [])\n    for i in a:\n        if i < 0:\n            neg.append(-i)\n        else:\n            pos.append(i)\n    neg.sort()\n    pos.sort()\n    ans = int(0)\n    for i in range(len(pos) - 1, -1, -k):\n        ans += pos[i] * 2\n    for i in range(len(neg) - 1, -1, -k):\n        ans += neg[i] * 2\n    pos.insert(0, 0)\n    neg.insert(0, 0)\n    ans -= max(pos[-1], neg[-1])\n    print(ans)", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in x:\n        if i > 0:\n            a.append(i)\n        elif i < 0:\n            b.append(-i)\n    a.sort(reverse=1)\n    b.sort(reverse=1)\n    dsta = 0\n    for i in range(0, len(a), k):\n        dsta += 2 * a[i]\n    dstb = 0\n    for i in range(0, len(b), k):\n        dstb += 2 * b[i]\n    if len(a):\n        mxa = a[0]\n    else:\n        mxa = 0\n    if len(b):\n        mxb = b[0]\n    else:\n        mxb = 0\n    print(dsta + dstb - max(mxa, mxb))\n    t -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = [x for x in a if x != 0]\n    a.sort()\n    ng = []\n    ps = []\n    for x in a:\n        if x < 0:\n            ng += (abs(x),)\n        else:\n            ps += (x,)\n    ng.sort()\n    ans = 0\n    pls = len(ps)\n    if pls > 0:\n        ans += ps[-1]\n    i = pls - k - 1\n    while i >= 0:\n        ans += 2 * ps[i]\n        i -= k\n    nls = len(ng)\n    if nls > 0:\n        ans += ng[-1]\n    i = nls - k - 1\n    while i >= 0:\n        ans += 2 * ng[i]\n        i -= k\n    if pls > 0 and nls > 0:\n        ans += min(ps[-1], ng[-1])\n    print(ans)", "def func(N, K, arr):\n    (ps, ne) = (sorted([i for i in arr if i > 0]), sorted([i for i in arr if i < 0]))\n    (mn1, mn2) = (0, 0)\n    (it1, it2) = (len(ps) - K - 1, 0)\n    while it1 >= 0:\n        mn1 += ps[it1] * 2\n        it1 -= K\n    while it2 < len(ne):\n        mn1 += abs(ne[it2]) * 2\n        it2 += K\n    (pt1, pt2) = (len(ps) - 1, K)\n    while pt1 >= 0:\n        mn2 += ps[pt1] * 2\n        pt1 -= K\n    while pt2 < len(ne):\n        mn2 += abs(ne[pt2]) * 2\n        pt2 += K\n    if ps:\n        mn1 += ps[-1]\n    if ne:\n        mn2 += abs(ne[0])\n    return min(mn1, mn2)\nfor t in range(int(input())):\n    (N, K) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print(func(N, K, arr))", "def walk(n, k, L):\n    if n == 0:\n        return 0\n    if n <= k:\n        return L[-1]\n    dist = 0\n    q = int(n / k)\n    r = n - q * k\n    if r != 0:\n        for i in range(q):\n            dist += 2 * L[i * k + r - 1]\n        dist += L[-1]\n        return dist\n    if r == 0:\n        for i in range(1, q):\n            dist += 2 * L[i * k - 1]\n        dist += L[-1]\n        return dist\ncases = int(input())\nfor wow in range(cases):\n    line1 = input().split()\n    n = int(line1[0])\n    k = int(line1[1])\n    long = input().split()\n    L1 = []\n    n1 = 0\n    L2 = []\n    n2 = 0\n    for elem in long:\n        elem = int(elem)\n        if elem > 0:\n            L1.append(elem)\n            n1 += 1\n        elif elem < 0:\n            L2.append(-elem)\n            n2 += 1\n    L1.sort()\n    L2.sort()\n    if n1 == 0:\n        print(walk(n2, k, L2))\n    elif n2 == 0:\n        print(walk(n1, k, L1))\n    elif L1[-1] > L2[-1]:\n        print(walk(n1, k, L1) + walk(n2, k, L2) + L2[-1])\n    else:\n        print(walk(n1, k, L1) + walk(n2, k, L2) + L1[-1])", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    bags = sorted(list(map(int, input().split())))\n    negatives = [abs(i) for i in bags if i < 0]\n    positives = [i for i in bags if i > 0][::-1]\n    distance_passed = 0\n    if negatives and positives and (negatives[0] >= positives[0]):\n        index = k\n        while index < len(negatives):\n            distance_passed += 2 * negatives[index]\n            index += k\n        index = 0\n        while index < len(positives):\n            distance_passed += 2 * positives[index]\n            index += k\n        distance_passed += negatives[0]\n    elif negatives and positives and (negatives[0] < positives[0]):\n        index = 0\n        while index < len(negatives):\n            distance_passed += 2 * negatives[index]\n            index += k\n        index = k\n        while index < len(positives):\n            distance_passed += 2 * positives[index]\n            index += k\n        distance_passed += positives[0]\n    elif negatives:\n        index = k\n        while index < len(negatives):\n            distance_passed += 2 * negatives[index]\n            index += k\n        index = 0\n        while index < len(positives):\n            distance_passed += 2 * positives[index]\n            index += k\n        distance_passed += negatives[0]\n    elif positives:\n        index = 0\n        while index < len(negatives):\n            distance_passed += 2 * negatives[index]\n            index += k\n        index = k\n        while index < len(positives):\n            distance_passed += 2 * positives[index]\n            index += k\n        distance_passed += positives[0]\n    print(distance_passed)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    tk = k\n    pa = []\n    na = []\n    for i in l:\n        if i >= 0:\n            pa.append(i)\n        else:\n            na.append(i)\n    pa.sort()\n    na.sort()\n    na.reverse()\n    p = len(pa)\n    q = len(na)\n    arr = []\n    if p > 0:\n        temp = p - 1\n        arr.append(pa[temp])\n        temp -= k\n        while temp >= 0:\n            arr.append(pa[temp])\n            temp -= k\n    if q > 0:\n        temp = q - 1\n        arr.append(-na[temp])\n        temp -= k\n        while temp >= 0:\n            arr.append(-na[temp])\n            temp -= k\n    ans = 0\n    arr.sort()\n    for i in range(len(arr) - 1):\n        ans += arr[i] * 2\n    ans += arr[-1]\n    print(ans)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    a = (b, c) = [[], []]\n    for x in sorted(R()):\n        a[x > 0] += (abs(x),)\n    print(2 * sum(b[::k] + c[::-k]) - max(b[:1] + c[-1:]))", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    a = (b, c) = [[], []]\n    for x in sorted(R()):\n        a[x > 0] += (abs(x),)\n    print(2 * sum(b[::k] + c[::-k]) - max(b[:1] + c[-1:]))", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    a = (b, c) = [[], []]\n    for x in sorted(R()):\n        a[x > 0] += (abs(x),)\n    print(2 * sum(b[::k] + c[::-k]) - max(b[:1] + c[-1:]))", "for t in range(int(input())):\n    (n, k) = tuple(map(int, input().split()))\n    x = sorted(list(map(int, input().split())))\n    negative = list(filter(lambda k: k < 0, x))\n    positive = list(filter(lambda k: k > 0, x))\n    cost = sum([2 * -negative[i] for i in range(0, len(negative), k)]) + sum([2 * positive[i] for i in range(len(positive) - 1, -1, -k)])\n    if len(negative) and len(positive):\n        cost -= max(-negative[0], positive[-1])\n    elif len(negative):\n        cost -= -negative[0]\n    elif len(positive):\n        cost -= positive[-1]\n    print(cost)", "for i in range(int(input())):\n    nk = list(map(int, input().split()))\n    k = nk[1]\n    xi = list(map(int, input().split()))\n    xi_p = [0]\n    xi_n = [0]\n    for i in xi:\n        if i >= 0:\n            xi_p.append(i)\n        else:\n            xi_n.append(i)\n    xi_p.sort()\n    xi_n.sort()\n    min_distance = 0\n    if xi_p[-1] >= -1 * xi_n[0]:\n        min_distance = -1 * xi_p[-1]\n    else:\n        min_distance = xi_n[0]\n    while len(xi_p) >= 1:\n        min_distance += 2 * xi_p[-1]\n        if len(xi_p) >= k:\n            xi_p = xi_p[0:len(xi_p) - k]\n        else:\n            xi_p = []\n    while len(xi_n) >= 1:\n        min_distance += -2 * xi_n[0]\n        if len(xi_n) >= k:\n            xi_n = xi_n[k:]\n        else:\n            xi_n = []\n    print(min_distance)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    a = (b, c) = [[], []]\n    for x in sorted(R()):\n        a[x > 0] += (abs(x),)\n    print(2 * sum(b[::k] + c[::-k]) - max(b[:1] + c[-1:]))", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in x:\n        if i > 0:\n            a.append(i)\n        elif i < 0:\n            b.append(-i)\n    a.sort(reverse=1)\n    b.sort(reverse=1)\n    dsta = 0\n    for i in range(0, len(a), k):\n        dsta += 2 * a[i]\n    dstb = 0\n    for i in range(0, len(b), k):\n        dstb += 2 * b[i]\n    if len(a):\n        mxa = a[0]\n    else:\n        mxa = 0\n    if len(b):\n        mxb = b[0]\n    else:\n        mxb = 0\n    print(dsta + dstb - max(mxa, mxb))\n    t -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().strip().split())\n    l = list(map(int, input().strip().split()))\n    l.sort()\n    a = n\n    for i in range(n):\n        if l[i] >= 0:\n            a = i\n            break\n    ln = l[:a]\n    lp = l[a:]\n    ln = [abs(i) for i in ln]\n    lp.reverse()\n    co = 0\n    for i in range(0, len(ln), k):\n        co += ln[i]\n    for i in range(0, len(lp), k):\n        co += lp[i]\n    co *= 2\n    if len(ln) == 0:\n        co -= lp[0]\n    elif len(lp) == 0:\n        co -= ln[0]\n    else:\n        co -= max(ln[0], lp[0])\n    print(co)", "t = int(input())\nfor e in range(t):\n    l = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    k = l[1]\n    pl = []\n    nl = []\n\n    def cost(l, k):\n        c = 0\n        i = len(l) - 1\n        while i >= 0:\n            if c == 0:\n                c = c + l[i]\n                i = i - k\n            else:\n                c = c + 2 * l[i]\n                i = i - k\n        return c\n    for i in a:\n        if i < 0:\n            nl.append(-i)\n        else:\n            pl.append(i)\n    pl.sort()\n    nl.sort()\n    qp = cost(pl, k)\n    qn = cost(nl, k)\n    if nl == []:\n        nl.append(0)\n    if pl == []:\n        pl.append(0)\n    qm = qp + qn + min(nl[-1], pl[-1])\n    print(qm)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    pos = []\n    neg = []\n    dist = 0\n    for item in arr:\n        if item >= 0:\n            pos.append(item)\n        elif item < 0:\n            neg.append(item * -1)\n    pos.sort()\n    neg.sort()\n    if len(neg) == 0:\n        for i in range(len(pos) - 1, -1, -k):\n            dist += 2 * pos[i]\n        dist -= pos[-1]\n    elif len(pos) == 0:\n        for i in range(len(neg) - 1, -1, -k):\n            dist += 2 * neg[i]\n        dist -= neg[-1]\n    elif pos[-1] > neg[-1]:\n        for i in range(len(neg) - 1, -1, -k):\n            dist += 2 * neg[i]\n        for i in range(len(pos) - 1, -1, -k):\n            dist += 2 * pos[i]\n        dist -= pos[-1]\n    elif neg[-1] >= pos[-1]:\n        for i in range(len(pos) - 1, -1, -k):\n            dist += 2 * pos[i]\n        for i in range(len(neg) - 1, -1, -k):\n            dist += 2 * neg[i]\n        dist -= neg[-1]\n    print(dist)", "def solve(depot, k):\n    ind = -1\n    l = len(depot)\n    sm = 0\n    if l % k:\n        sm += depot[ind + l % k] * 2\n        ind += l % k\n    for i in range(l // k):\n        sm += depot[ind + k] * 2\n        ind += k\n    return sm\n\ndef fndMax(p, n):\n    if bool(p) and bool(n):\n        return max(p[len(p) - 1], n[len(n) - 1])\n    if not bool(p):\n        return n[len(n) - 1]\n    else:\n        return p[len(p) - 1]\nt = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    neg = []\n    pos = []\n    for i in x:\n        if i < 0:\n            neg.append(-i)\n        else:\n            pos.append(i)\n    neg.sort()\n    pos.sort()\n    print(solve(pos, k) + solve(neg, k) - fndMax(pos, neg))\n    t -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    b = []\n    c = []\n    d = 0\n    for i3 in range(n):\n        if a[i3] < 0:\n            b.append(-a[i3])\n        else:\n            c.append(a[i3])\n    c.reverse()\n    p1 = len(b)\n    p2 = len(c)\n    if p1 != 0:\n        t1 = b[0]\n    else:\n        t1 = -1\n    if p2 != 0:\n        t2 = c[0]\n    else:\n        t2 = -1\n    for i11 in range(0, p1, k):\n        d += 2 * b[i11]\n    for i12 in range(0, p2, k):\n        d += 2 * c[i12]\n    d = d - max(t1, t2)\n    print(d)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [0]\n    b = [0]\n    for i in input().split():\n        j = int(i)\n        if j < 0:\n            a.append(abs(j))\n        if j > 0:\n            b.append(j)\n    ans = -max(max(a), max(b))\n    a.sort()\n    b.sort()\n    for i in a[::-k]:\n        ans += 2 * i\n    for i in b[::-k]:\n        ans += 2 * i\n    print(ans)", "t = int(input())\nfor q in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.append(0)\n    a.sort()\n    a_1 = a[:a.index(0)] + [0]\n    a_2 = a[a.index(0) + 1:] + [0]\n    a_o = []\n    for i in range(len(a_1)):\n        if i % k == 0:\n            a_o.append(a_1[i])\n    a_p = []\n    a_2.sort(reverse=True)\n    for i in range(len(a_2)):\n        if i % k == 0:\n            a_p.append(a_2[i])\n    mx = max(max(a_p), abs(min(a_o)))\n    R = 2 * abs(sum(a_o)) + 2 * sum(a_p) - mx\n    print(R)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    a = (b, c) = [[], []]\n    for x in sorted(R()):\n        a[x > 0] += (abs(x),)\n    print(2 * sum(b[::k] + c[::-k]) - max(b[:1] + c[-1:]))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (pos, neg) = ([], [])\n    for i in list(map(int, input().split())):\n        if i > 0:\n            pos.append(i)\n        else:\n            neg.append(i)\n    pos.sort(reverse=True)\n    neg.sort()\n    (posSize, negSize) = (len(pos), len(neg))\n    maxDist = 0\n    for i in range(posSize):\n        if (i + 1) % k == 0:\n            maxDist += 2 * pos[i + 1 - k]\n    for i in range(negSize):\n        if (i + 1) % k == 0:\n            maxDist += 2 * abs(neg[i + 1 - k])\n    if negSize % k:\n        maxDist += 2 * abs(neg[-(negSize % k)])\n    if posSize % k:\n        maxDist += 2 * pos[-(posSize % k)]\n    if negSize > 0 and posSize > 0:\n        maxDist -= max(abs(neg[0]), pos[0])\n    elif posSize > 0:\n        maxDist -= pos[0]\n    else:\n        maxDist -= abs(neg[0])\n    print(maxDist)", "def Solve(depot, k):\n    ind = -1\n    l = len(depot)\n    sm = 0\n    if l % k:\n        sm += depot[ind + l % k] * 2\n        ind += l % k\n    for i in range(l // k):\n        sm += depot[ind + k] * 2\n        ind += k\n    return sm\n\ndef fndMax(p, n):\n    if bool(p) and bool(n):\n        return max(p[len(p) - 1], n[len(n) - 1])\n    if not bool(p):\n        return n[len(n) - 1]\n    else:\n        return p[len(p) - 1]\nt = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    neg = []\n    pos = []\n    for i in x:\n        if i < 0:\n            neg.append(-i)\n        else:\n            pos.append(i)\n    neg.sort()\n    pos.sort()\n    sPos = Solve(pos, k)\n    sNeg = Solve(neg, k)\n    mx = fndMax(pos, neg)\n    print(sPos + sNeg - mx)\n    t -= 1", "import collections\n\ndef readLine():\n    return list(map(int, input().strip().split()))\n\ndef readInt():\n    return int(input())\n\ndef readString():\n    return input()\n\ndef tcase():\n    t = readInt()\n    for _ in range(t):\n        solve()\n\ndef solve():\n    (n, k) = readLine()\n    arr = readLine()\n    pos = []\n    neg = []\n    for a in arr:\n        if a >= 0:\n            pos.append(a)\n        else:\n            neg.append(-a)\n    pos.sort()\n    neg.sort()\n    maximum = 0\n    if pos:\n        maximum = max(maximum, max(pos))\n    if neg:\n        maximum = max(maximum, max(neg))\n\n    def count(arr):\n        na = len(arr)\n        ans = 0\n        for i in range(na - 1, -1, -k):\n            ans += arr[i] * 2\n        return ans\n    print(count(pos) + count(neg) - maximum)\ntcase()", "from collections import Counter\nfrom queue import Queue\nimport math\nT = int(input())\nfor t in range(T):\n    (n, k) = [int(s) for s in input().split(' ')]\n    A = [int(s) for s in input().split(' ')]\n    A.sort()\n    ans = 0\n    for idx in range((n + k - 1) // k):\n        if A[idx * k] < 0:\n            ans += -A[idx * k] * 2\n        else:\n            break\n    A.reverse()\n    for idx in range((n + k - 1) // k):\n        if A[idx * k] >= 0:\n            ans += A[idx * k] * 2\n        else:\n            break\n    ans -= max(abs(A[0]), abs(A[-1]))\n    print(ans)", "for t in range(int(input())):\n    (n, k) = tuple(map(int, input().split()))\n    x = list(map(int, input().split()))\n    x.sort()\n    negative = list(filter(lambda k: k < 0, x))\n    positive = list(filter(lambda k: k > 0, x))\n    cost = 0\n    for i in range(0, len(negative), k):\n        cost += 2 * -negative[i]\n    for i in range(len(positive) - 1, -1, -k):\n        cost += 2 * positive[i]\n    if len(negative) > 0 and len(positive) > 0:\n        cost -= max(-negative[0], positive[-1])\n    elif len(negative) > 0:\n        cost -= -negative[0]\n    elif len(positive) > 0:\n        cost -= positive[-1]\n    print(cost)", "def worst(X, K):\n    if len(X) == 0:\n        return 0\n    L = len(X)\n    total = 0\n    total += X[-1] * 2\n    L -= K\n    while L > 0:\n        total += X[L - 1] * 2\n        L -= K\n    return total\n\ndef best(X, K):\n    if len(X) == 0:\n        return 0\n    L = len(X)\n    total = 0\n    total += X[-1]\n    L -= K\n    while L > 0:\n        total += X[L - 1] * 2\n        L -= K\n    return total\n\ndef solve():\n    [N, K] = [int(x) for x in input().split()]\n    D = [int(x) for x in input().split()]\n    POS = [x for x in D if x > 0]\n    NEG = [-x for x in D if x < 0]\n    POS.sort()\n    NEG.sort()\n    res = best(POS, K) + worst(NEG, K)\n    res2 = best(NEG, K) + worst(POS, K)\n    return min(res, res2)\nT = int(input())\nfor i in range(T):\n    print(solve())", "t = int(input())\nfor h in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    l = 0\n    (b, c) = ([], [])\n    m = max(-1 * a[0], a[-1])\n    if a[0] < 0 and a[-1] > 0:\n        for i in range(1, n):\n            if a[i - 1] < 0 and a[i] >= 0:\n                b = a[:i]\n                c = a[i:]\n                break\n    elif a[0] >= 0:\n        c = a[:]\n    else:\n        b = a[:]\n    i = 0\n    while i < len(b):\n        l += b[i] * -2\n        i += k\n    i = len(c) - 1\n    while i >= 0:\n        l += c[i] * 2\n        i -= k\n    print(l - m)", "t = int(input())\nfor h in range(t):\n    (n, k) = map(int, input().split())\n    v = [int(x) for x in input().split()]\n    v.sort()\n    m = max(-1 * v[0], v[-1])\n    l = 0\n    (a, b) = ([], [])\n    if v[0] < 0 and v[-1] > 0:\n        for i in range(1, n):\n            if v[i] >= 0 and v[i - 1] < 0:\n                b = v[i:]\n                a = v[:i]\n                break\n    elif v[0] >= 0:\n        b = v[:]\n    else:\n        a = v[:]\n    i = len(b) - 1\n    while i >= 0:\n        l += b[i] * 2\n        i -= k\n    i = 0\n    while i < len(a):\n        l += a[i] * -2\n        i += k\n    print(l - m)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    j = -1\n    k1 = -1\n    s = 0\n    m = 0\n    for i in range(n):\n        if a[i] < 0:\n            j = i\n        if a[i] > 0:\n            k1 = i\n            break\n    if j != -1:\n        b = a[:j + 1]\n        r = 0\n        while r <= len(b) - 1:\n            s += 2 * abs(b[r])\n            r += k\n        if abs(b[0]) > m:\n            m = abs(b[0])\n    if k1 != -1:\n        b = a[k1:]\n        r = len(b) - 1\n        while r >= 0:\n            s += b[r] * 2\n            r -= k\n        if b[-1] > m:\n            m = b[-1]\n    s -= m\n    print(s)", "def readArr():\n    return [int(x) for x in input().split()]\n\ndef solve():\n    (n, k) = readArr()\n    arr = readArr()\n    (a, b) = ([], [])\n    for el in arr:\n        if el > 0:\n            a.append(el)\n        elif el < 0:\n            b.append(-el)\n    a.sort()\n    b.sort()\n\n    def get_min_dist(x):\n        dist = 0\n        for i in range(len(x) - 1, -1, -k):\n            if i == len(x) - 1:\n                dist += x[i]\n            else:\n                dist += 2 * x[i]\n        return dist\n\n    def get_max_dist(x):\n        dist = 0\n        for i in range(len(x) - 1, -1, -k):\n            dist += 2 * x[i]\n        return dist\n    ans = min(get_min_dist(a) + get_max_dist(b), get_max_dist(a) + get_min_dist(b))\n    print(ans)\nT = int(input())\nfor _ in range(T):\n    solve()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    a = (b, c) = [[], []]\n    for x in sorted(R()):\n        a[x > 0] += (abs(x),)\n    print(2 * sum(b[::k] + c[::-k]) - max([0] + b[:1] + c[-1:]))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    if k == 1:\n        ans = 0\n        m = 0\n        for i in range(n):\n            ans += abs(x[i])\n            if abs(x[i]) > m:\n                m = abs(x[i])\n        ans *= 2\n        ans -= m\n    else:\n        ans = 0\n        a = []\n        b = []\n        for i in range(n):\n            if x[i] > 0:\n                a += [x[i]]\n            elif x[i] < 0:\n                b += [abs(x[i])]\n        a = sorted(a, reverse=True)\n        b = sorted(b, reverse=True)\n        for i in range(0, len(a), k):\n            ans += a[i]\n        for i in range(0, len(b), k):\n            ans += b[i]\n        ans *= 2\n        if len(a) > 0 and len(b) > 0:\n            ans -= max(a[0], b[0])\n        elif len(a) > 0:\n            ans -= a[0]\n        elif len(b) > 0:\n            ans -= b[0]\n    print(ans)", "cases = int(input())\nfor i in range(cases):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    pos = list(filter(lambda x: x >= 0, arr))\n    pos.sort()\n    neg = list(map(abs, filter(lambda x: x < 0, arr)))\n    neg.sort()\n    if neg and pos:\n        if max(pos) > max(neg):\n            count = 0\n            n = len(neg)\n            p = n - 1\n            while p >= 0:\n                count += 2 * neg[p]\n                p -= k\n            n = len(pos)\n            p = n - 1\n            while p >= 0:\n                if p == n - 1:\n                    count += pos[n - 1]\n                else:\n                    count += 2 * pos[p]\n                p -= k\n        else:\n            count = 0\n            n = len(pos)\n            p = n - 1\n            while p >= 0:\n                count += 2 * pos[p]\n                p -= k\n            n = len(neg)\n            p = n - 1\n            while p >= 0:\n                if p == n - 1:\n                    count += neg[n - 1]\n                else:\n                    count += 2 * neg[p]\n                p -= k\n    elif pos:\n        count = 0\n        p = n - 1\n        while p >= 0:\n            if p == n - 1:\n                count += pos[n - 1]\n            else:\n                count += 2 * pos[p]\n            p -= k\n    else:\n        count = 0\n        p = n - 1\n        while p >= 0:\n            if p == n - 1:\n                count += neg[n - 1]\n            else:\n                count += 2 * neg[p]\n            p -= k\n    print(count)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    pos_arr = []\n    neg_arr = []\n    for i in arr:\n        if i >= 0:\n            pos_arr.append(i)\n        else:\n            neg_arr.append(abs(i))\n    pos_arr.sort(reverse=True)\n    neg_arr.sort(reverse=True)\n    ans = 0\n    for i in range(0, len(pos_arr), k):\n        ans += 2 * pos_arr[i]\n    for i in range(0, len(neg_arr), k):\n        ans += 2 * neg_arr[i]\n    if len(pos_arr) == 0:\n        ans -= abs(neg_arr[0])\n    elif len(neg_arr) == 0:\n        ans -= pos_arr[0]\n    else:\n        ans -= max(pos_arr[0], abs(neg_arr[0]))\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    a = []\n    b = []\n    for el in arr:\n        if el >= 0:\n            a.append(el)\n        elif el < 0:\n            b.append(el)\n    if a:\n        a.sort(reverse=True)\n    if b:\n        b.sort()\n    ans = []\n    i = 0\n    while i < len(a):\n        ans.append(a[i])\n        i += k\n    i = 0\n    while i < len(b):\n        ans.append(-b[i])\n        i += k\n    ans.sort()\n    res = 0\n    for el in ans:\n        res += 2 * el\n    res -= ans[-1]\n    print(res)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    z = max(abs(l[0]), abs(l[-1]))\n    a = []\n    b = []\n    for i in range(n):\n        if l[i] < 0:\n            a.append(l[i])\n        else:\n            b.append(l[i])\n    s = 0\n    for i in range(0, len(a), k):\n        s = s + 2 * abs(a[i])\n    b = b[::-1]\n    for i in range(0, len(b), k):\n        s = s + 2 * abs(b[i])\n    print(s - z)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (otr, pol) = ([], [])\n    s = []\n    for x in input().split():\n        x = int(x)\n        if x < 0:\n            otr.append(-x)\n        elif x > 0:\n            pol.append(x)\n    pol.sort()\n    a = len(pol) % k\n    if a != 0:\n        s.append(pol[a - 1] * 2)\n        pol = pol[a:]\n    pol = [pol[k * (i + 1) - 1] * 2 for i in range(len(pol) // k)]\n    otr.sort()\n    a = len(otr) % k\n    if a != 0:\n        s.append(2 * otr[a - 1])\n        otr = otr[a:]\n    otr = [otr[k * (i + 1) - 1] * 2 for i in range(len(otr) // k)]\n    if len(otr + pol + s) == 0:\n        print(0)\n    else:\n        print(sum(otr) + sum(pol) + sum(s) - max(otr + pol + s) // 2)", "t = int(input())\nfor q in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    pos = []\n    neg = []\n    ind = 0\n    for i in range(n):\n        if arr[i] < 0:\n            neg.append(-arr[i])\n        elif arr[i] > 0:\n            pos.append(arr[i])\n    g = len(neg)\n    p = len(pos)\n    pos.sort()\n    neg.sort()\n    ans = 0\n    pans = 0\n    pi = p - 1\n    while pi >= 0:\n        pans += 2 * pos[pi]\n        pi -= k\n    gans = 0\n    gi = g - 1\n    while gi >= 0:\n        gans += 2 * neg[gi]\n        gi -= k\n    subp = 0\n    if pos:\n        subp = pos[p - 1]\n    subn = 0\n    if neg:\n        subn = neg[g - 1]\n    ans = gans + pans - max(subp, subn)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    (*a,) = map(int, input().split())\n    x = []\n    h = []\n    for i in a:\n        if i >= 0:\n            x.append(i)\n        else:\n            h.append(i)\n    cnt = 0\n    x.sort()\n    p = 0\n    neg = 0\n    for i in range(len(x) - 1, -1, -k):\n        cnt += x[i] * 2\n        p = max(p, x[i])\n    h.sort(reverse=True)\n    for i in range(len(h) - 1, -1, -k):\n        cnt += -h[i] * 2\n        neg = max(neg, -h[i])\n    cnt -= max(p, neg)\n    print(cnt)", "t = int(input())\nfor q in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    pos = []\n    neg = []\n    ind = 0\n    for i in range(n):\n        if arr[i] < 0:\n            neg.append(-arr[i])\n        elif arr[i] > 0:\n            pos.append(arr[i])\n    g = len(neg)\n    p = len(pos)\n    pos.sort()\n    neg.sort()\n    ans = 0\n    pans = 0\n    pi = p - 1\n    while pi >= 0:\n        pans += 2 * pos[pi]\n        pi -= k\n    gans = 0\n    gi = g - 1\n    while gi >= 0:\n        gans += 2 * neg[gi]\n        gi -= k\n    subp = 0\n    if pos:\n        subp = pos[p - 1]\n    subn = 0\n    if neg:\n        subn = neg[g - 1]\n    ans = gans + pans - max(subp, subn)\n    print(ans)", "def solution(depots, k):\n    pos_depots = sorted(list(filter(lambda x: x > 0, depots)))\n    neg_depots = sorted(list(map(lambda x: -x, filter(lambda x: x < 0, depots))))\n    return pos_solution(pos_depots, k) + pos_solution(neg_depots, k) - max(pos_depots[-1] if pos_depots else 0, neg_depots[-1] if neg_depots else 0)\n\ndef pos_solution(arr, k):\n    if arr:\n        traveled = 0\n        for i in range(len(arr) - 1, -1, -k):\n            traveled += 2 * arr[i]\n        _hy_anon_var_1 = traveled\n    else:\n        _hy_anon_var_1 = 0\n    return _hy_anon_var_1\nt = int(input())\nfor _ in range(t):\n    [n, k] = list(map(int, input().split()))\n    depots = list(map(int, input().split()))\n    print(solution(depots, k))", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    lp = []\n    ln = []\n    for i in range(n):\n        if l[i] > 0:\n            lp.append(l[i])\n        else:\n            ln.append(abs(l[i]))\n    lp.sort(reverse=True)\n    ln.sort(reverse=True)\n    ans = 0\n    for i in range(0, len(lp), k):\n        ans += 2 * lp[i]\n    for i in range(0, len(ln), k):\n        ans += 2 * ln[i]\n    if len(lp):\n        m1 = lp[0]\n    else:\n        m1 = 0\n    if len(ln):\n        m2 = ln[0]\n    else:\n        m2 = 0\n    ans = ans - max(m1, m2)\n    print(ans)\n    t -= 1", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    pos_nums = [e for e in nums if e > 0]\n    neg_nums = [abs(e) for e in nums if e < 0]\n    pos_nums.sort()\n    neg_nums.sort()\n    temp_pos = pos_nums[-1] if pos_nums else 0\n    temp_neg = neg_nums[-1] if neg_nums else 0\n    ans = 0\n    while pos_nums:\n        add = pos_nums[-1]\n        for e in range(k):\n            if pos_nums:\n                pos_nums.pop()\n        ans += add * 2\n    while neg_nums:\n        add = neg_nums[-1]\n        for e in range(k):\n            if neg_nums:\n                neg_nums.pop()\n        ans += add * 2\n    print(ans - max(temp_pos, temp_neg))", "t = int(input())\nfor testcase_num in range(t):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    plusx = []\n    minusx = []\n    for i in range(n):\n        if x[i] > 0:\n            plusx.append(x[i])\n        elif x[i] < 0:\n            minusx.append(-1 * x[i])\n    plusx.sort(reverse=True)\n    minusx.sort(reverse=True)\n    distance = 0\n    i = 0\n    while i < len(plusx):\n        distance += plusx[i] * 2\n        i += k\n    i = 0\n    while i < len(minusx):\n        distance += minusx[i] * 2\n        i += k\n    pmax = 0\n    mmax = 0\n    if not len(plusx) == 0:\n        pmax = plusx[0]\n    if not len(minusx) == 0:\n        mmax = minusx[0]\n    dismax = max(pmax, mmax)\n    distance -= dismax\n    print(distance)", "h = int(input())\nfor o in range(h):\n    b = list(map(int, input().split()))\n    n = b[0]\n    k = b[1]\n    a = list(map(int, input().split()))\n    plus = [0]\n    neg = [0]\n    for i in range(n):\n        if a[i] > 0:\n            plus.append(a[i])\n        else:\n            neg.append(a[i])\n    plus.sort()\n    neg.sort(reverse=True)\n    l = len(plus)\n    l1 = len(neg)\n    i = 0\n    sum1 = 0\n    sum2 = 0\n    while l - k * i > 0:\n        sum1 += plus[l - k * i - 1]\n        i += 1\n    i = 0\n    while l1 - k * i > 0:\n        sum2 += abs(neg[l1 - k * i - 1])\n        i += 1\n    print((sum1 + sum2) * 2 - max(max(plus), abs(min(neg))))", "def getvalue(alist, k, length):\n    if length == 0:\n        return 0\n    current = length % k\n    result = 0\n    if current != 0:\n        result += 2 * alist[current - 1]\n    while True:\n        if current == length:\n            break\n        current += k\n        result += 2 * alist[current - 1]\n    return result - alist[length - 1]\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    alist = list(map(int, input().split()))\n    (p, o) = ([], [])\n    (plen, olen) = (0, 0)\n    for i in alist:\n        if i < 0:\n            o.append(-i)\n            olen += 1\n        else:\n            p.append(i)\n            plen += 1\n    p.sort()\n    o.sort()\n    result = getvalue(p, k, plen) + getvalue(o, k, olen)\n    if plen != 0 and olen != 0:\n        result += min(p[plen - 1], o[olen - 1])\n    print(result)", "from collections import *\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = []\n    b = []\n    for i in range(n):\n        if l[i] >= 0:\n            a.append(l[i])\n        else:\n            b.append(l[i])\n    ans = 0\n    a.sort()\n    b.sort(reverse=True)\n    p = len(a)\n    q = len(b)\n    ks = []\n    if p > 0:\n        c = p - 1\n        ks.append(a[c])\n        c -= k\n        while c >= 0:\n            ks.append(a[c])\n            c -= k\n    if q > 0:\n        c = q - 1\n        ks.append(-b[c])\n        c -= k\n        while c >= 0:\n            ks.append(-b[c])\n            c -= k\n    ans = 0\n    ks.sort()\n    x = len(ks)\n    for i in range(x - 1):\n        ans += ks[i] * 2\n    ans += ks[-1]\n    print(ans)", "kl = int(input())\nfor kkl in range(kl):\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = []\n    dl = 1\n    for i in range(n):\n        if a[i] != 0:\n            b.append(a[i])\n            dl += 1\n    b.append(0)\n    b.sort()\n    i0 = b.index(0)\n    kp = dl - i0 - 1\n    kh = kp // k\n    rs = kp % k\n    rz = b[i0 + rs]\n    for i in range(kh):\n        rz += b[i0 + rs + k * (i + 1)]\n    kh = i0 // k\n    rs = i0 % k\n    rz += abs(b[i0 - rs])\n    for i in range(kh):\n        rz += abs(b[i0 - (rs + k * (i + 1))])\n    rz *= 2\n    print(rz - max(-b[0], abs(b[dl - 1])))", "problem_num = int(input())\nfor i in range(problem_num):\n    nk = input()\n    nk = nk.split()\n    n = int(nk[0])\n    k = int(nk[1])\n    x = input()\n    arr = x.split()\n    pos = [int(a) for a in arr if int(a) >= 0]\n    neg = [abs(int(a)) for a in arr if int(a) < 0]\n    pos.sort(reverse=True)\n    pos = pos[::k]\n    neg.sort(reverse=True)\n    neg = neg[::k]\n    max_value = max(pos + neg)\n    print(2 * sum(pos + neg) - max_value)", "a = int(input())\nfor x in range(a):\n    (b, c) = map(int, input().split())\n    d = list(map(int, input().split()))\n    pos = []\n    poslen = 0\n    neg = []\n    neglen = 0\n    for y in range(b):\n        if d[y] >= 0:\n            pos.append(d[y])\n            poslen += 1\n        else:\n            neg.append(d[y] * -1)\n            neglen += 1\n    pos.sort()\n    neg.sort()\n    e = poslen\n    f = neglen\n    j = 0\n    h = 0\n    while poslen > 0:\n        j += 2 * pos[poslen - 1]\n        poslen -= c\n    if neglen > 0:\n        j += neg[neglen - 1]\n        s = neglen - c\n        while s > 0:\n            j += 2 * neg[s - 1]\n            s -= c\n    while f > 0:\n        h += 2 * neg[f - 1]\n        f -= c\n    if e > 0:\n        h += pos[e - 1]\n        k = e - c\n        while k > 0:\n            h += 2 * pos[k - 1]\n            k -= c\n    print(min(j, h))", "t = int(input())\n\ndef solve():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n\n    def sim(locs):\n        pos = []\n        neg = []\n        for i in locs:\n            if i > 0:\n                pos.append(i)\n            else:\n                neg.append(0 - i)\n        pos.sort()\n        neg.sort()\n        ans = 0\n        p = len(pos) - 1\n        while p >= 0:\n            ans += pos[p] * 2\n            p -= k\n        if len(pos) > 0:\n            ans -= pos[-1]\n        p = len(neg) - 1\n        while p >= 0:\n            ans += neg[p] * 2\n            p -= k\n        return ans\n    ans1 = sim(arr)\n    arr = [0 - i for i in arr]\n    ans2 = sim(arr)\n    print(min(ans1, ans2))\nfor i in range(t):\n    solve()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    (ne, po, last, res) = ([], [], -1, 0)\n    for el in a:\n        if el > 0:\n            po += [el]\n        elif el < 0:\n            ne += [abs(el)]\n    if len(po) == len(ne) == 0:\n        print(0)\n        continue\n    po.sort()\n    ne.sort()\n    if len(po):\n        last = po[-1]\n        for i in range(len(po), 0, -k):\n            res += 2 * po[i - 1]\n    if len(ne):\n        last = max(last, ne[-1])\n        for i in range(len(ne), 0, -k):\n            res += 2 * ne[i - 1]\n    print(res - last)", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    a_1 = []\n    a_2 = []\n    m = a[0]\n    for x in a:\n        if x > 0:\n            a_2.append(x)\n        elif x < 0:\n            a_1.append(-x)\n        m = max(m, abs(x))\n    a_1.sort()\n    a_2.sort()\n    way = 0\n    i = len(a_1) - 1\n    while i >= 0:\n        way += 2 * a_1[i]\n        i -= k\n    i = len(a_2) - 1\n    while i >= 0:\n        way += 2 * a_2[i]\n        i -= k\n    way -= m\n    print(way)", "t = int(input())\nimport math\nfor e in range(t):\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    l2.sort()\n    lp = []\n    ln = []\n    for i in l2:\n        if i < 0:\n            ln.append(-i)\n        if i > 0:\n            lp.append(i)\n    lp.sort(reverse=True)\n    cp = 0\n    cn = 0\n    if len(lp) == 0:\n        cp = 0\n    else:\n        q1 = math.ceil(len(lp) / l1[1])\n        p1 = 0\n        for i in range(q1 - 1):\n            cp += 2 * lp[p1]\n            p1 += l1[1]\n        cp += 2 * lp[p1]\n    if len(ln) == 0:\n        cn = 0\n    else:\n        q1 = math.ceil(len(ln) / l1[1])\n        p1 = 0\n        for i in range(q1 - 1):\n            cn += 2 * ln[p1]\n            p1 += l1[1]\n        cn += 2 * ln[p1]\n    if len(lp) > 0 and len(ln) > 0:\n        c = min(cn + cp - lp[0], cn + cp - ln[0])\n        print(c)\n    if len(lp) == 0 and len(ln) > 0:\n        c = cn - ln[0]\n        print(c)\n    if len(lp) > 0 and len(ln) == 0:\n        c = cp - lp[0]\n        print(c)\n    if len(lp) == 0 and len(ln) == 0:\n        print(0)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    array = list(map(int, input().split()))\n    n = list(filter(lambda x: x < 0, array))\n    p = list(filter(lambda x: x > 0, array))\n    n = sorted(n)\n    p = sorted(p, reverse=True)\n    steps = 0\n    c = k\n    for i in range(max(len(n), len(p))):\n        if i < len(n):\n            if c == k:\n                steps += abs(2 * n[i])\n        if i < len(p):\n            if c == k:\n                steps += 2 * p[i]\n        c -= 1\n        if c == 0:\n            c = k\n    a = abs(n[0]) if len(n) > 0 else 0\n    b = p[0] if len(p) > 0 else 0\n    steps -= max(a, b)\n    print(steps)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    pos = list()\n    neg = list()\n    for i in arr:\n        if i < 0:\n            neg.append(i)\n        else:\n            pos.append(i)\n    (p, n) = (0, 0)\n    i = len(pos) - 1\n    ini = k\n    while i >= 0:\n        if p == 0:\n            p += 2 * pos[i]\n        if ini == 0:\n            p += 2 * pos[i]\n            ini = k\n        ini -= 1\n        i -= 1\n    i = 0\n    ini = k\n    while i < len(neg):\n        if n == 0:\n            n += 2 * abs(neg[i])\n        if ini == 0:\n            n += 2 * abs(neg[i])\n            ini = k\n        ini -= 1\n        i += 1\n    if len(neg) == 0:\n        ans = p - max(pos)\n    elif len(pos) == 0:\n        ans = n + min(neg)\n    else:\n        ans = p + n - max(abs(min(neg)), max(pos))\n    print(ans)", "def fun(a):\n    pos = []\n    neg = []\n    for j in range(n):\n        if a[j] > 0:\n            pos.append(a[j])\n        else:\n            neg.append(0 - a[j])\n    cnt = 0\n    pos.sort()\n    neg.sort()\n    b = len(pos) - 1\n    while b >= 0:\n        cnt += pos[b] * 2\n        b -= k\n    if len(pos) > 0:\n        cnt -= pos[-1]\n    b = len(neg) - 1\n    while b >= 0:\n        cnt += neg[b] * 2\n        b -= k\n    return cnt\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = []\n    for j in range(n):\n        b.append(0 - a[j])\n    print(min(fun(a), fun(b)))", "def gt(a, b):\n    ans = a[-1] if len(a) else 0\n    while len(a):\n        for _ in range(k):\n            if len(a):\n                a.pop()\n        if len(a):\n            ans += a[-1] * 2\n    while len(b):\n        if len(b):\n            ans += b[-1] * 2\n        for _ in range(k):\n            if len(b):\n                b.pop()\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (a, b) = ([], [])\n    for i in map(int, input().split()):\n        if i > 0:\n            a.append(i)\n        else:\n            b.append(-i)\n    a.sort()\n    b.sort()\n    print(min(gt(a.copy(), b.copy()), gt(b.copy(), a.copy())))", "cases = int(input())\nfor loop in range(cases):\n    (n, k) = input().split(' ')\n    posdata = input().split(' ')\n    negdata = []\n    for i in range(len(posdata) - 1, -1, -1):\n        posdata[i] = int(posdata[i])\n        if posdata[i] < -0:\n            negdata.append(posdata.pop(i) * -1)\n    posdata = sorted(posdata)\n    negdata = sorted(negdata)\n    tot = 0\n    most = -1\n    for data in [posdata, negdata]:\n        while len(data) > 0:\n            dist = data[-1]\n            for i in range(int(k)):\n                if len(data) > 0:\n                    del data[-1]\n            tot += dist * 2\n            if most == -1 or dist > most:\n                most = dist\n    tot -= most\n    print(tot)"]