["import sys\ninput = sys.stdin.readline\nget_int = lambda : int(input().rstrip())\nget_arr = lambda : [int(w) for w in input().split()]\nget_str = lambda : input().rstrip()\nmod = 10 ** 9 + 7\nt = get_int()\nmx = 10 ** 4 + 1\nfac = [1]\nrfac = [1]\nfor i in range(1, mx):\n    fac.append(fac[-1] * i)\n    rfac.append(rfac[-1] * pow(i, -1, mod))\n    fac[-1] %= mod\n    rfac[-1] %= mod\n\ndef cnk(n, k):\n    return fac[n] * rfac[n - k] * rfac[k] % mod\n\ndef find(n, m, k):\n    arr = [0] * (n - m)\n    for i in range(m + 1):\n        arr.append(2 * i)\n    res = 0\n    for i in range(len(arr)):\n        res += cnk(n, i) * arr[i]\n        res %= mod\n    return res * k * pow(2, -n, mod) % mod\nfor _ in range(t):\n    (n, m, k) = get_arr()\n    print(find(n, m, k))", "import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    (n, m, k) = map(int, inp().split())\n    MOD = 1000000007\n    i2 = pow(2, MOD - 2, MOD)\n    dp = [[-1e+30] * (i + 1) for i in range(n + 1)]\n    dp[1][0] = 0\n    dp[1][1] = k\n    for i in range(2, n + 1):\n        dp[i][0] = dp[i - 1][0]\n        for j in range(1, i):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) * i2 % MOD\n        dp[i][i] = (dp[i - 1][i - 1] + k) % MOD\n    print(dp[n][m])\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "import sys\nimport math\nR = lambda : sys.stdin.readline().rstrip()\nMIS = lambda : map(int, R().split())\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef f(a, b):\n    if dp[a][b] != -1:\n        return dp[a][b]\n    if a == b:\n        dp[a][b] = K * a % mod\n        return dp[a][b]\n    if b == 0:\n        dp[a][b] = 0\n        return dp[a][b]\n    dp[a][b] = (f(a - 1, b) + f(a - 1, b - 1)) % mod\n    if dp[a][b] & 1:\n        dp[a][b] *= mod // 2 + 1\n    else:\n        dp[a][b] //= 2\n    return dp[a][b]\nfor _ in range(int(R())):\n    (N, M, K) = MIS()\n    dp = [[-1] * (M + 1) for _ in range(N + 1)]\n    print(f(N, M) % mod)", "import sys\nimport math\nR = lambda : sys.stdin.readline().rstrip()\nMIS = lambda : map(int, R().split())\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef f(a, b):\n    if dp[a][b] != -1:\n        return dp[a][b]\n    if a == b:\n        dp[a][b] = K * a % mod\n        return dp[a][b]\n    if b == 0:\n        dp[a][b] = 0\n        return dp[a][b]\n    dp[a][b] = (f(a - 1, b) + f(a - 1, b - 1)) % mod\n    if dp[a][b] & 1:\n        dp[a][b] *= mod // 2 + 1\n    else:\n        dp[a][b] //= 2\n    return dp[a][b]\nfor _ in range(int(R())):\n    (N, M, K) = MIS()\n    dp = [[-1] * (M + 1) for _ in range(N + 1)]\n    print(f(N, M) % mod)", "MOD = 10 ** 9 + 7\nsolve_solution = [[-1 for _ in range(2001)] for _ in range(2001)]\n\ndef solve(a, b):\n    if solve_solution[a][b] != -1:\n        return solve_solution[a][b]\n    for i in range(a + 1):\n        for j in range(b + 1):\n            if solve_solution[i][j] == -1:\n                if i == 0:\n                    solve_solution[i][j] = 0\n                    continue\n                if j == 0:\n                    solve_solution[i][j] = i\n                    continue\n                res = solve_solution[i][j - 1] - solve_solution[i - 1][j]\n                if res < 0:\n                    res += MOD\n                res *= (MOD + 1) // 2\n                res += solve_solution[i - 1][j]\n                res %= MOD\n                solve_solution[i][j] = res\n    return solve_solution[a][b]\nT = int(input())\nfor _ in range(T):\n    (n, m, k) = map(int, input().split())\n    a = m\n    b = n - m\n    res = solve(a, b)\n    res = res * k % MOD\n    print(res)", "import sys\nimport math\nR = lambda : sys.stdin.readline().rstrip()\nMIS = lambda : map(int, R().split())\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef f(a, b):\n    if dp[a][b] != -1:\n        return dp[a][b]\n    if a == b:\n        dp[a][b] = K * a % mod\n        return dp[a][b]\n    if b == 0:\n        dp[a][b] = 0\n        return dp[a][b]\n    dp[a][b] = (f(a - 1, b) + f(a - 1, b - 1)) % mod\n    if dp[a][b] & 1:\n        dp[a][b] *= mod // 2 + 1\n    else:\n        dp[a][b] //= 2\n    return dp[a][b]\nfor _ in range(int(R())):\n    (N, M, K) = MIS()\n    dp = [[-1] * (M + 1) for _ in range(N + 1)]\n    print(f(N, M) % mod)", "import sys\nimport math\nR = lambda : sys.stdin.readline().rstrip()\nMIS = lambda : map(int, R().split())\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef f(a, b):\n    if dp[a][b] != -1:\n        return dp[a][b]\n    if a == b:\n        dp[a][b] = K * a % mod\n        return dp[a][b]\n    if b == 0:\n        dp[a][b] = 0\n        return dp[a][b]\n    dp[a][b] = (f(a - 1, b) + f(a - 1, b - 1)) % mod\n    if dp[a][b] & 1:\n        dp[a][b] *= mod // 2 + 1\n    else:\n        dp[a][b] //= 2\n    return dp[a][b]\nfor _ in range(int(R())):\n    (N, M, K) = MIS()\n    dp = [[-1] * (M + 1) for _ in range(N + 1)]\n    print(f(N, M) % mod)", "import sys\nimport math\nR = lambda : sys.stdin.readline().rstrip()\nMIS = lambda : map(int, R().split())\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef f(a, b):\n    if dp[a][b] != -1:\n        return dp[a][b]\n    if a == b:\n        dp[a][b] = K * a % mod\n        return dp[a][b]\n    if b == 0:\n        dp[a][b] = 0\n        return dp[a][b]\n    dp[a][b] = (f(a - 1, b) + f(a - 1, b - 1)) % mod\n    if dp[a][b] & 1:\n        dp[a][b] *= mod // 2 + 1\n    else:\n        dp[a][b] //= 2\n    return dp[a][b]\nfor _ in range(int(R())):\n    (N, M, K) = MIS()\n    dp = [[-1] * (M + 1) for _ in range(N + 1)]\n    print(f(N, M) % mod)", "M = int(1000000000.0 + 7)\ninv2_modM = int(500000000.0 + 4)\nt = int(input())\nfor test in range(t):\n    (n, m, k) = map(lambda x: int(x), input().split())\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(min(n + 1, m + 1)):\n        dp[i][i] = i * k % M\n    for i in range(1, n + 1):\n        for j in range(1, min(i, m + 1)):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) * inv2_modM % M\n    print(dp[n][m])", "t = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    mod = int(1000000000.0 + 7)\n    dp = [[0] * (n + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][i] = i * k % mod\n    for i in range(1, n + 1):\n        for j in range(1, i):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) * (mod + 1) // 2 % mod\n    print(dp[n][m])"]