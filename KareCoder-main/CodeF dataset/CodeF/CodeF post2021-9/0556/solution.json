["from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "import sys, math\nimport threading\nfrom bisect import bisect_right\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(ans, tre, pb, a, h, v):\n    for i in range(len(tre[v][0])):\n        a += tre[tre[v][0][i]][1]\n        pb[h] = pb[h - 1] + tre[tre[v][0][i]][2]\n        h += 1\n        ans[tre[v][0][i]] = bisect_right(pb, a, 0, h) - 1\n        dfs(ans, tre, pb, a, h, tre[v][0][i])\n        a -= tre[tre[v][0][i]][1]\n        h -= 1\n        pb[h] = 0\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = []\n        for i in range(1, n + 1):\n            tre.append([[], 0, 0])\n        for i in range(1, n):\n            (p, a, b) = map(int, input().split())\n            tre[p - 1][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        h = 1\n        pb = [0] * n\n        dfs(ans, tre, pb, a, h, 0)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, bisect, threading\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(ans, a, b, v, tre, pb):\n    for i in range(len(tre[v][0])):\n        vtnxt = tre[v][0][i]\n        x = tre[vtnxt][1]\n        y = tre[vtnxt][2]\n        a += x\n        b += y\n        pb.append(b)\n        c = bisect.bisect_right(pb, a)\n        ans[vtnxt - 1] = c - 1\n        dfs(ans, a, b, vtnxt, tre, pb)\n        a -= x\n        b -= y\n        pb.pop()\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = {}\n        for i in range(1, n + 1):\n            tre[i] = [[], 0, 0]\n        for i in range(2, n + 1):\n            (p, a, b) = map(int, input().split())\n            tre[p][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        b = 0\n        pb = [0]\n        dfs(ans, a, b, 1, tre, pb)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, bisect, threading\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(ans, a, b, v, tre, pb):\n    for i in range(len(tre[v][0])):\n        vtnxt = tre[v][0][i]\n        x = tre[vtnxt][1]\n        y = tre[vtnxt][2]\n        a += x\n        b += y\n        pb.append(b)\n        c = bisect.bisect_right(pb, a)\n        ans[vtnxt - 1] = c - 1\n        dfs(ans, a, b, vtnxt, tre, pb)\n        a -= x\n        b -= y\n        pb.pop()\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = {}\n        for i in range(1, n + 1):\n            tre[i] = [[], 0, 0]\n        for i in range(2, n + 1):\n            (p, a, b) = map(int, input().split())\n            tre[p][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        b = 0\n        pb = [0]\n        dfs(ans, a, b, 1, tre, pb)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, bisect, threading\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(ans, a, b, v, tre, pb):\n    for i in range(len(tre[v][0])):\n        vtnxt = tre[v][0][i]\n        x = tre[vtnxt][1]\n        y = tre[vtnxt][2]\n        a += x\n        b += y\n        pb.append(b)\n        c = bisect.bisect_right(pb, a)\n        ans[vtnxt - 1] = c - 1\n        dfs(ans, a, b, vtnxt, tre, pb)\n        a -= x\n        b -= y\n        pb.pop()\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = {}\n        for i in range(1, n + 1):\n            tre[i] = [[], 0, 0]\n        for i in range(2, n + 1):\n            (p, a, b) = map(int, input().split())\n            tre[p][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        b = 0\n        pb = [0]\n        dfs(ans, a, b, 1, tre, pb)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, bisect, threading\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(ans, a, b, v, tre, pb):\n    for i in range(len(tre[v][0])):\n        vtnxt = tre[v][0][i]\n        x = tre[vtnxt][1]\n        y = tre[vtnxt][2]\n        a += x\n        b += y\n        pb.append(b)\n        c = bisect.bisect_right(pb, a)\n        ans[vtnxt - 1] = c - 1\n        dfs(ans, a, b, vtnxt, tre, pb)\n        a -= x\n        b -= y\n        pb.pop()\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = {}\n        for i in range(1, n + 1):\n            tre[i] = [[], 0, 0]\n        for i in range(2, n + 1):\n            (p, a, b) = map(int, input().split())\n            tre[p][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        b = 0\n        pb = [0]\n        dfs(ans, a, b, 1, tre, pb)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, threading\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfrom bisect import bisect_right as br\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 7)\n\ndef solve():\n    for test in range(int(input())):\n        n = int(input())\n        g = defaultdict(list)\n        for i in range(2, n + 1):\n            (p, a, b) = map(int, input().split())\n            g[p].append((i, a, b))\n        res = [0] * (n + 1)\n\n        def rec(p, x, y):\n            idx = br(y, x)\n            res[p] = idx - 1\n            for (nn, na, nb) in g[p]:\n                y.append(y[-1] + nb)\n                rec(nn, x + na, y)\n                y.pop()\n        rec(1, 0, [0])\n        print(*res[2:])\nthreading.Thread(target=solve).start()", "import sys\nimport threading\nfrom bisect import bisect_right\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(ans, tre, pb, a, h, v):\n    for i in range(len(tre[v][0])):\n        a += tre[tre[v][0][i]][1]\n        pb[h] = pb[h - 1] + tre[tre[v][0][i]][2]\n        h += 1\n        ans[tre[v][0][i]] = bisect_right(pb, a, 0, h) - 1\n        dfs(ans, tre, pb, a, h, tre[v][0][i])\n        a -= tre[tre[v][0][i]][1]\n        h -= 1\n        pb[h] = 0\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = []\n        for i in range(1, n + 1):\n            tre.append([[], 0, 0])\n        for i in range(1, n):\n            (p, a, b) = map(int, input().split())\n            tre[p - 1][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        h = 1\n        pb = [0] * n\n        dfs(ans, tre, pb, a, h, 0)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "import sys, threading\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfrom bisect import bisect_right as br\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 7)\n\ndef solve():\n    for test in range(int(input())):\n        n = int(input())\n        g = defaultdict(list)\n        a = [0, 0]\n        b = [0, 0]\n        for i in range(2, n + 1):\n            (p, aa, bb) = map(int, input().split())\n            g[p].append(i)\n            a.append(aa)\n            b.append(bb)\n        res = [0] * (n + 1)\n\n        def rec(p, x, y):\n            idx = br(y, x)\n            res[p] = idx - 1\n            for nn in g[p]:\n                y.append(y[-1] + b[nn])\n                rec(nn, x + a[nn], y)\n                y.pop()\n        rec(1, 0, [0])\n        print(*res[2:])\nthreading.Thread(target=solve).start()", "from bisect import bisect as br\n(R, G) = (lambda : map(int, input().split()), range)\n(t,) = R()\nfor _ in G(t):\n    (n,) = R()\n    g = [[] for _ in G(n)]\n    for i in G(1, n):\n        (p, a, b) = R()\n        g[p - 1] += [(i, a, b)]\n    r = [0] * n\n    Pb = [0] * n\n    stk = [(0, 0, 0, 0)]\n    while stk:\n        (u, pa, ub, dep) = stk.pop()\n        Pb[dep] = 0 if dep == 0 else Pb[dep - 1] + ub\n        r[u] = dep if Pb[dep] <= pa else br(Pb, pa, hi=dep) - 1\n        for (v, a, b) in g[u]:\n            stk += [(v, pa + a, b, dep + 1)]\n    print(*r[1:])", "import sys\nimport threading\nfrom bisect import bisect_right\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(ans, tre, pb, a, h, v):\n    for i in range(len(tre[v][0])):\n        a += tre[tre[v][0][i]][1]\n        pb[h] = pb[h - 1] + tre[tre[v][0][i]][2]\n        h += 1\n        ans[tre[v][0][i]] = bisect_right(pb, a, 0, h) - 1\n        dfs(ans, tre, pb, a, h, tre[v][0][i])\n        a -= tre[tre[v][0][i]][1]\n        h -= 1\n        pb[h] = 0\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        tre = []\n        for i in range(1, n + 1):\n            tre.append([[], 0, 0])\n        for i in range(1, n):\n            (p, a, b) = map(int, input().split())\n            tre[p - 1][0].append(i)\n            tre[i][1] = a\n            tre[i][2] = b\n        ans = [0] * n\n        a = 0\n        h = 1\n        pb = [0] * n\n        dfs(ans, tre, pb, a, h, 0)\n        print(*ans[1:])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import collections, bisect\nimport sys, threading\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 7)\n\ndef st():\n    for _ in range(int(input())):\n        n = int(input())\n        adj = collections.defaultdict(list)\n        a = [0, 0]\n        b = [0, 0]\n        for i in range(2, n + 1):\n            (node, aa, bb) = map(int, input().split())\n            adj[node].append(i)\n            a.append(aa)\n            b.append(bb)\n        ans = [0] * (n + 1)\n\n        def solve(root, x, y):\n            bb = bisect.bisect_right(y, x)\n            ans[root] = bb - 1\n            for i in adj[root]:\n                y.append(y[-1] + b[i])\n                solve(i, x + a[i], y)\n                y.pop()\n        solve(1, 0, [0])\n        print(*ans[2:])\nthreading.Thread(target=st).start()", "from bisect import bisect_right\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    child = defaultdict(list)\n    A = [0 for _ in range(n)]\n    B = [0 for _ in range(n)]\n    for i in range(1, n):\n        (p, a, b) = map(int, input().split())\n        p -= 1\n        child[p].append(i)\n        A[i] = a\n        B[i] = b\n    ANS = [0 for _ in range(n)]\n    visited = set()\n    Stack = [0]\n    (curr_a, curr_b) = (0, 0)\n    L = []\n    while Stack:\n        curr_p = Stack.pop()\n        if curr_p in visited:\n            curr_a -= A[curr_p]\n            curr_b -= B[curr_p]\n            L.pop()\n        else:\n            curr_a += A[curr_p]\n            curr_b += B[curr_p]\n            L.append(curr_b)\n            ANS[curr_p] = bisect_right(L, curr_a) - 1\n            Stack.append(curr_p)\n            visited.add(curr_p)\n            for next_p in child[curr_p]:\n                Stack.append(next_p)\n    print(*ANS[1:])", "import sys, threading\nimport bisect\nlines = list(map(str.strip, sys.stdin.readlines()))\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(10 ** 8)\n\ndef solve():\n    i = 1\n    while i < len(lines):\n        n = int(lines[i])\n        ncopy = n\n        i += 1\n        children = {}\n        node = 2\n        while n > 1:\n            (parent, a, b) = map(int, lines[i].split(' '))\n            if parent not in children:\n                children[parent] = []\n            children[parent].append([node, a, b])\n            node += 1\n            i += 1\n            n -= 1\n        result = {}\n        taken = []\n\n        def dfs(node, sum):\n            result[node] = bisect.bisect_right(taken, sum)\n            if node not in children:\n                return\n            for (child, left, right) in children[node]:\n                taken.append((taken[-1] if len(taken) != 0 else 0) + right)\n                dfs(child, sum + left)\n                taken.pop()\n        dfs(1, 0)\n        for j in range(2, ncopy + 1):\n            print(result[j], end=' ')\n        print()\nthreading.Thread(target=solve).start()", "import sys, threading\nsys.setrecursionlimit(400000)\nthreading.stack_size(10 ** 8)\nfrom bisect import bisect_right\nfrom collections import defaultdict\n\ndef rec(curr_p, prev_p, curr_a, L, edge):\n    global ANS\n    if curr_p != 0:\n        idx = bisect_right(L, curr_a)\n        ANS[curr_p] = idx - 1\n    for (next_p, a, b) in edge[curr_p]:\n        if next_p == prev_p:\n            continue\n        next_a = curr_a + a\n        L.append(L[-1] + b)\n        rec(next_p, curr_p, next_a, L, edge)\n        L.pop()\n\ndef main():\n    global ANS\n    for _ in range(int(input())):\n        n = int(input())\n        edge = defaultdict(list)\n        for i in range(1, n):\n            (p, a, b) = map(int, input().split())\n            p -= 1\n            edge[p].append((i, a, b))\n            edge[i].append((p, a, b))\n        ANS = [0 for _ in range(n)]\n        rec(0, -1, 0, [0], edge)\n        print(*ANS[1:])\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    child = {i: [] for i in range(1, n + 1)}\n    a = {1: 0}\n    b = {1: 0}\n    cura = 0\n    curb = 0\n    cumb = []\n    for i in range(2, n + 1):\n        (pi, ai, bi) = map(int, input().split())\n        child[pi].append(i)\n        a[i] = ai\n        b[i] = bi\n    ans = {1: 0}\n    q = [1]\n    vis = {}\n    while q:\n        x = q.pop()\n        if x in vis:\n            cura -= a[x]\n            curb -= b[x]\n            cumb.pop()\n        else:\n            cura += a[x]\n            curb += b[x]\n            cumb.append(curb)\n            ans[x] = bisect.bisect_right(cumb, cura) - 1\n            q.append(x)\n            vis[x] = True\n            for i in child[x]:\n                q.append(i)\n    for i in range(2, n + 1):\n        print(ans[i], end=' ')\n    print()", "from collections import defaultdict, deque\nimport bisect\nn = int(input().strip())\nfor i in range(n):\n    m = int(input().strip())\n    res = ['' for _ in range(m - 1)]\n    dic = [[] for _ in range(m + 1)]\n    for i in range(2, m + 1):\n        a = input().strip().split(' ')\n        dic[int(a[0])].append([i, int(a[1]), int(a[2])])\n    stack = [[1, 0, 0]]\n    B = []\n    while stack:\n        (p, A, count) = stack[-1]\n        if p > 1:\n            res[p - 2] = str(bisect.bisect_right(B, A))\n        if count < len(dic[p]):\n            (pp, a, b) = dic[p][count]\n            count += 1\n            stack[-1] = [p, A, count]\n            stack.append([pp, A + a, 0])\n            B.append(B[-1] + b if B else b)\n        else:\n            stack.pop()\n            if B:\n                B.pop()\n    print(' '.join(res))", "from math import inf\nfrom collections import *\nimport math, os, sys, heapq, bisect, random, threading\nfrom functools import lru_cache\nfrom itertools import *\n\ndef inp():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef out(var):\n    sys.stdout.write(str(var))\n\ndef inpu():\n    return int(inp())\n\ndef lis():\n    return list(map(int, inp().split()))\n\ndef stringlis():\n    return list(map(str, inp().split()))\n\ndef sep():\n    return map(int, inp().split())\n\ndef strsep():\n    return map(str, inp().split())\n\ndef fsep():\n    return map(float, inp().split())\n(M, M1) = (1000000007, 998244353)\n\ndef main():\n    how_much_noob_I_am = 1\n    how_much_noob_I_am = inpu()\n    for _ in range(how_much_noob_I_am):\n        n = inpu()\n        d = defaultdict(list)\n        for i in range(2, n + 1):\n            (p, q, r) = sep()\n            d[p].append([i, q, r])\n        arr = [0]\n        ans = [-1] * (n + 1)\n\n        def dfs(curr, res):\n            ans[curr] = bisect.bisect_right(arr, res) - 1\n            for j in d[curr]:\n                arr.append(arr[-1] + j[2])\n                dfs(j[0], res + j[1])\n                arr.pop()\n        dfs(1, 0)\n        print(*ans[2:])\nsys.setrecursionlimit(2 * 10 ** 5 + 50)\nthreading.stack_size(10 ** 8)\nthreading.Thread(target=main).start()", "for _ in range(int(input())):\n    n = int(input())\n    Adjlist = {}\n    for i in range(1, n + 1):\n        Adjlist[i] = []\n    for i in range(2, n + 1):\n        (p, a, b) = map(int, input().split())\n        Adjlist[p].append((i, a, b))\n    stack = [1]\n    Prefixsum = {}\n    Ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        Prefixsum[i] = (0, 0)\n    while stack:\n        a = stack.pop()\n        for p in Adjlist[a]:\n            stack.append(p[0])\n            (temp1, temp2) = Prefixsum[a]\n            Prefixsum[p[0]] = (temp1 + p[1], temp2 + p[2])\n    stack = [(1, 0)]\n    ListB = [0] * n\n    from bisect import bisect\n    while stack:\n        a = stack.pop()\n        for p in Adjlist[a[0]]:\n            stack.append((p[0], a[1] + 1))\n        t = Prefixsum[a[0]]\n        ListB[a[1]] = t[1]\n        if t[0] >= t[1]:\n            Ans[a[0]] = a[1]\n        else:\n            Ans[a[0]] = bisect(ListB, t[0], hi=a[1]) - 1\n    print(*Ans[2:])", "import sys\nimport collections\nimport math\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        tree = [[] for _ in range(n + 1)]\n        for i in range(n - 1):\n            (p, a, b) = ints()\n            tree[p].append((i + 2, a, b))\n        prefix = []\n        res = ['0'] * (n - 1)\n\n        def dfs(i, a):\n            (l, r) = (0, len(prefix) - 1)\n            while l <= r:\n                m = (l + r) // 2\n                if prefix[m] <= a:\n                    l = m + 1\n                else:\n                    r = m - 1\n            res[i - 2] = str(l)\n            for child in tree[i]:\n                total = child[2]\n                if len(prefix) > 0:\n                    total += prefix[-1]\n                prefix.append(total)\n                dfs(child[0], a + child[1])\n                prefix.pop()\n            return\n        dfs(1, 0)\n        print(' '.join(res))\nthreading.Thread(target=solve).start()", "from bisect import bisect_left, bisect_right\nimport sys, threading\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 8)\n\ndef solve():\n    for _ in range(int(input())):\n        n = int(input())\n        graph = [[] for i in range(n + 1)]\n        for i in range(2, n + 1):\n            (u, aj, pj) = map(int, input().split())\n            graph[i].append([u, aj, pj])\n            graph[u].append([i, aj, pj])\n        preaj = [0] * (n + 1)\n        maxpath = [0] * (n + 1)\n        vis = set()\n        vis.add(1)\n\n        def dfs(node, post):\n            for i in graph[node[0]]:\n                if i[0] not in vis:\n                    vis.add(i[0])\n                    preaj[i[0]] = preaj[node[0]] + i[1]\n                    find = 0\n                    if len(post) != 0:\n                        post.append(i[2] + post[-1])\n                    if len(post) == 0:\n                        post.append(i[2])\n                    find = bisect_right(post, preaj[i[0]])\n                    maxpath[i[0]] = find\n                    dfs(i, post)\n                    post.pop()\n        dfs([1, 0, 0], [])\n        print(*maxpath[2:])\nthreading.Thread(target=solve).start()", "from bisect import bisect_left, bisect_right\nimport sys, threading\nsys.setrecursionlimit(10 ** 8)\nthreading.stack_size(10 ** 8)\n\ndef solve():\n    for _ in range(int(input())):\n        n = int(input())\n        graph = [[] for i in range(n + 1)]\n        for i in range(2, n + 1):\n            (u, aj, pj) = map(int, input().split())\n            graph[i].append([u, aj, pj])\n            graph[u].append([i, aj, pj])\n        preaj = [0] * (n + 1)\n        prebj = [0] * (n + 1)\n        maxpath = [0] * (n + 1)\n        vis = set()\n        vis.add(1)\n\n        def dfs(node, post):\n            for i in graph[node[0]]:\n                if i[0] not in vis:\n                    vis.add(i[0])\n                    preaj[i[0]] = preaj[node[0]] + i[1]\n                    find = 0\n                    if len(post) != 0:\n                        post.append(i[2] + post[-1])\n                    if len(post) == 0:\n                        post.append(i[2])\n                    find = bisect_right(post, preaj[i[0]])\n                    maxpath[i[0]] = find\n                    dfs(i, post)\n                    post.pop()\n        dfs([1, 0, 0], [])\n        print(*maxpath[2:])\nthreading.Thread(target=solve).start()", "import bisect\nimport sys\n\nclass Node:\n\n    def __init__(self, id):\n        self.id = id\n        self.root = None\n        self.a = 0\n        self.b = 0\n        self.children = []\n\ndef solve(root, n):\n    b_cumsum = []\n    A = 0\n    result = [-1] * n\n    queue = [root]\n    while queue:\n        next_item = queue.pop()\n        if isinstance(next_item, int):\n            A -= next_item\n            b_cumsum.pop()\n            continue\n        A += next_item.a\n        b_cumsum.append((b_cumsum[-1] if b_cumsum else 0) + next_item.b)\n        result[next_item.id - 1] = bisect.bisect_right(b_cumsum, A) - 1\n        queue.append(next_item.a)\n        for child in next_item.children:\n            queue.append(child)\n    return result[1:]\n\ndef main():\n    sys.setrecursionlimit(1000000)\n    t = int(input())\n    for i in range(t):\n        vertexes = {}\n        n = int(input())\n        for j in range(2, n + 1):\n            (p, a, b) = [int(v) for v in input().split()]\n            if p not in vertexes:\n                vertexes[p] = Node(p)\n            if j not in vertexes:\n                vertexes[j] = Node(j)\n            parent = vertexes[p]\n            child = vertexes[j]\n            child.root = parent\n            child.a = a\n            child.b = b\n            parent.children.append(child)\n        res = solve(vertexes[1], n)\n        print(*res)\nmain()", "import sys\nimport threading\n\ndef dfs(v, p, pans):\n    global put, mb, ans\n    (l, r) = (-1, len(mb))\n    while r > l + 1:\n        m = (r + l) // 2\n        if mb[m] > pans:\n            r = m\n        else:\n            l = m\n    ans[v] = l + 1\n    for i in range(len(put[v])):\n        if put[v][i][0] != p:\n            if len(mb) != 0:\n                mb.append(mb[-1] + put[v][i][1][1])\n            else:\n                mb.append(put[v][i][1][1])\n            dfs(put[v][i][0], v, pans + put[v][i][1][0])\n            if len(mb) > 0:\n                mb.pop()\n\ndef main():\n    global put, mb, ans\n    for _ in range(int(input())):\n        n = int(input())\n        put = [list() for _ in range(n)]\n        for i in range(1, n):\n            (p, a, b) = map(int, input().split())\n            put[p - 1].append([i, [a, b]])\n        (ans, mb) = ([0] * n, list())\n        dfs(0, -1, 0)\n        for i in range(1, len(ans)):\n            print(ans[i], end=' ')\n        print()\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(10 ** 8)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()"]