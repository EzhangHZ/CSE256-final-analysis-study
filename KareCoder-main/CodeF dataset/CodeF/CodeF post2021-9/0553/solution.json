["import sys\nfrom collections import deque\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    empty = sys.stdin.readline()\n    (n, k) = map(int, sys.stdin.readline().split())\n    x = list(map(int, sys.stdin.readline().split()))\n    conn = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (v, u) = map(int, sys.stdin.readline().split())\n        conn[v].append(u)\n        conn[u].append(v)\n    check = [n for i in range(n + 1)]\n    q = deque()\n    for friend in x:\n        q.append(friend)\n        check[friend] = 0\n    while q:\n        pos = q.popleft()\n        for nextPos in conn[pos]:\n            if check[nextPos] < n:\n                continue\n            q.append(nextPos)\n            check[nextPos] = check[pos] + 1\n    q = deque()\n    q.append(1)\n    visit = [n for i in range(n + 1)]\n    visit[1] = 0\n    answer = 'NO'\n    while q:\n        pos = q.popleft()\n        if pos != 1 and len(conn[pos]) == 1:\n            answer = 'YES'\n            break\n        for nextPos in conn[pos]:\n            if visit[nextPos] < n:\n                continue\n            elif visit[pos] + 1 >= check[nextPos]:\n                continue\n            q.append(nextPos)\n            visit[nextPos] = visit[pos] + 1\n    print(answer)", "import threading\nimport sys\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 9)\ninput = sys.stdin.readline\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heappush, heappop, heapify\n\ndef main():\n    for _ in range(int(input())):\n        input()\n        (n, k) = map(int, input().split())\n        k = [int(i) for i in input().split()]\n        ck = Counter(k)\n        c = [float('inf')] * (n + 1)\n        g = [[] for _ in range(n + 1)]\n        for _ in range(n - 1):\n            (u, v) = map(int, input().split())\n            g[u].append(v)\n            g[v].append(u)\n\n        def dfs(cn, p):\n            if ck[cn] == 1:\n                c[cn] = 0\n                return c[cn]\n            for nn in g[cn]:\n                if nn != p:\n                    c[cn] = min(c[cn], 1 + dfs(nn, cn))\n            return c[cn]\n        dfs(1, -1)\n        global pos\n        pos = False\n\n        def pepega(cn, p, cd):\n            global pos\n            if cd >= c[cn]:\n                return\n            if len(g[cn]) == 1 and cn != 1:\n                pos = True\n                return\n            for nn in g[cn]:\n                if nn != p:\n                    pepega(nn, cn, cd + 1)\n        pepega(1, -1, 0)\n        if pos:\n            print('YES')\n        else:\n            print('NO')\nthreading.Thread(target=main).start()", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    visv = set([i - 1 for i in map(int, input().split())])\n    g = [set() for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].add(b - 1)\n        g[b - 1].add(a - 1)\n    qv = set() | visv\n    qh = set([0])\n    vish = set()\n    while 1:\n        if not qh:\n            return 'NO'\n        nqh = set()\n        for i in qh:\n            vish.add(i)\n            if len(g[i]) == 1 and i:\n                return 'YES'\n            for j in g[i]:\n                if j not in vish and j not in visv:\n                    nqh.add(j)\n        nqv = set()\n        for i in qv:\n            for j in g[i]:\n                if j not in visv:\n                    nqv.add(j)\n                    visv.add(j)\n        qh = nqh - nqv\n        qv = nqv\nfor _ in range(int(input())):\n    print(f())", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    visv = set([i - 1 for i in map(int, input().split())])\n    g = [set() for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].add(b - 1)\n        g[b - 1].add(a - 1)\n    qv = set() | visv\n    qh = set([0])\n    vish = set()\n    while 1:\n        if not qh:\n            return 'NO'\n        nqh = set()\n        for i in qh:\n            vish.add(i)\n            if len(g[i]) == 1 and i:\n                return 'YES'\n            for j in g[i]:\n                if j not in vish and j not in visv:\n                    nqh.add(j)\n        nqv = set()\n        for i in qv:\n            for j in g[i]:\n                if j not in visv:\n                    nqv.add(j)\n                    visv.add(j)\n        qh = nqh - nqv\n        qv = nqv\nfor _ in range(int(input())):\n    print(f())", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000000 + 7\nmod2 = 998244353\nfor _ in range(I()):\n    s = S()\n    (n, k) = M()\n    a = L()\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = M()\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(i):\n        q = deque()\n        v = [0] * n\n        v[i] = 1\n        for j in a:\n            q.append([j - 1, j - 1])\n            v[j - 1] = 1\n        q.append([i, i])\n        while q:\n            (r, p) = q.popleft()\n            if r != 0 and p == 0 and (len(adj[r]) == 1):\n                return True\n            for j in adj[r]:\n                if v[j] == 0:\n                    v[j] = 1\n                    q.append([j, p])\n        return False\n    print('YES' if bfs(0) else 'NO')", "def f():\n    input()\n    (n, k) = map(int, input().split())\n    visv = set([i - 1 for i in map(int, input().split())])\n    g = [set() for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].add(b - 1)\n        g[b - 1].add(a - 1)\n    qv = set() | visv\n    qh = set([0])\n    vish = set()\n    while 1:\n        if not qh:\n            return 'NO'\n        nqh = set()\n        for i in qh:\n            vish.add(i)\n            if len(g[i]) == 1 and i:\n                return 'YES'\n            for j in g[i]:\n                if j not in vish and j not in visv:\n                    nqh.add(j)\n        nqv = set()\n        for i in qv:\n            for j in g[i]:\n                if j not in visv:\n                    nqv.add(j)\n                    visv.add(j)\n        qh = nqh - nqv\n        qv = nqv\nfor _ in range(int(input())):\n    print(f())", "from collections import *\n\ndef dfs():\n    while qF and qP:\n        for _ in range(len(qP)):\n            curr = qP.popleft()\n            if curr in visitedF:\n                continue\n            if len(corridors[curr]) == 1 and corridors[curr][0] in visitedP:\n                return 'YES'\n            for child in corridors[curr]:\n                if child not in visitedP:\n                    qP.append(child)\n                    visitedP.add(child)\n        for _ in range(len(qF)):\n            curr = qF.popleft()\n            for child in corridors[curr]:\n                if child not in visitedF:\n                    qF.append(child)\n                    visitedF.add(child)\n    return 'NO'\nt = int(input())\nfor _ in range(t):\n    input()\n    (rooms, friends) = map(int, input().split())\n    fr = list(map(int, input().split()))\n    visitedF = set(fr)\n    visitedP = set([1])\n    qF = deque(fr)\n    qP = deque([1])\n    corridors = defaultdict(list)\n    for _ in range(rooms - 1):\n        (a, b) = map(int, input().split())\n        corridors[a].append(b)\n        corridors[b].append(a)\n    print(dfs())", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    input()\n    (rooms, friends) = [int(x) for x in input().strip().split()]\n    mq = deque()\n    visited: list = [False] * rooms\n    rooms_with_friends: list = [int(x) - 1 for x in input().strip().split()]\n    for room in rooms_with_friends:\n        visited[room] = None\n        mq.appendleft(room)\n    visited[0] = True\n    mq.appendleft(0)\n    adj: list = [[] for _ in range(rooms)]\n    for _ in range(rooms - 1):\n        (a, b) = [int(x) - 1 for x in input().strip().split()]\n        adj[a].append(b)\n        adj[b].append(a)\n    while mq:\n        cur = mq.pop()\n        for nxt in adj[cur]:\n            if visited[nxt] == False:\n                visited[nxt] = visited[cur]\n                mq.appendleft(nxt)\n    found: bool = False\n    for i in range(1, rooms):\n        if visited[i] and len(adj[i]) == 1:\n            found = True\n            break\n    print('YES' if found else 'NO')", "from collections import defaultdict, deque\nt = int(input())\ninput()\nfor z in range(t):\n    (rooms, friends_size) = list(map(int, input().split()))\n    friends = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(rooms - 1):\n        (u, v) = list(map(int, input().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    queue = deque([1])\n    friends_queue = deque(friends)\n    visited = set(friends)\n    visited_me = set([1])\n    can = False\n    while len(queue) and len(friends_queue):\n        size = len(queue)\n        len_f = len(friends_queue)\n        for a in range(len_f):\n            node = friends_queue.popleft()\n            for ngh in graph[node]:\n                if ngh not in visited:\n                    visited.add(ngh)\n                    friends_queue.append(ngh)\n        for p in range(size):\n            node = queue.popleft()\n            for ngh in graph[node]:\n                if ngh not in visited_me and ngh not in visited:\n                    visited_me.add(ngh)\n                    queue.append(ngh)\n            if len(graph[node]) == 1 and node != 1:\n                can = True\n    if can:\n        print('YES')\n    else:\n        print('NO')\n    if z != t - 1:\n        input()", "from collections import defaultdict, deque\nt = int(input())\ninput()\nfor z in range(t):\n    (rooms, friends_size) = list(map(int, input().split()))\n    friends = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(rooms - 1):\n        (u, v) = list(map(int, input().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    queue = deque([1])\n    friends_queue = deque(friends)\n    visited = set(friends)\n    visited_me = set([1])\n    can = False\n    while len(queue) and len(friends_queue):\n        size = len(queue)\n        len_f = len(friends_queue)\n        for a in range(len_f):\n            node = friends_queue.popleft()\n            for ngh in graph[node]:\n                if ngh not in visited:\n                    visited.add(ngh)\n                    friends_queue.append(ngh)\n        for p in range(size):\n            node = queue.popleft()\n            if len(graph[node]) == 1 and node != 1:\n                can = True\n            for ngh in graph[node]:\n                if ngh not in visited_me and ngh not in visited:\n                    visited_me.add(ngh)\n                    queue.append(ngh)\n    if can:\n        print('YES')\n    else:\n        print('NO')\n    if z != t - 1:\n        input()", "from collections import deque\nt = int(input().strip())\nfor _ in range(t):\n    _ = input()\n    (n, k) = map(int, input().strip().split())\n    adj = [[] for _ in range(n)]\n    visited = [False for _ in range(n)]\n    q = deque()\n    for x in input().strip().split():\n        temp = int(x) - 1\n        q.append((temp, 0))\n        visited[temp] = True\n    q.append((0, 1))\n    for _ in range(n - 1):\n        (s, e) = map(lambda x: int(x) - 1, input().strip().split())\n        adj[s].append(e)\n        adj[e].append(s)\n    reaches_leaf = False\n    while len(q) > 0:\n        (node, person) = q.popleft()\n        if person == 1 and len(adj[node]) == 1 and (node != 0):\n            reaches_leaf = True\n            break\n        for adjacent in adj[node]:\n            if not visited[adjacent]:\n                q.append((adjacent, person))\n                visited[adjacent] = True\n    if reaches_leaf:\n        print('YES')\n    else:\n        print('NO')", "from collections import deque\nt = int(input().strip())\nfor _ in range(t):\n    _ = input()\n    (n, k) = map(int, input().strip().split())\n    adj = [[] for _ in range(n)]\n    visited = set()\n    q = deque()\n    for x in input().strip().split():\n        temp = int(x) - 1\n        q.append((temp, 0))\n        visited.add(temp)\n    q.append((0, 1))\n    for _ in range(n - 1):\n        (s, e) = map(lambda x: int(x) - 1, input().strip().split())\n        adj[s].append(e)\n        adj[e].append(s)\n    reaches_leaf = False\n    while len(q) > 0:\n        (node, person) = q.popleft()\n        if person == 1 and len(adj[node]) == 1 and (node != 0):\n            reaches_leaf = True\n            break\n        for adjacent in adj[node]:\n            if adjacent not in visited:\n                q.append((adjacent, person))\n                visited.add(adjacent)\n    if reaches_leaf:\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict, deque\nt = int(input())\nfor _ in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    rooms = list(map(int, input().split()))\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    visited = set(rooms)\n    visited.add(1)\n    que = deque(list(map(lambda x: (x, True), rooms)) + [(1, False)])\n    can_win = False\n    while que:\n        (r, is_friend) = que.popleft()\n        for nei in tree[r]:\n            if nei not in visited:\n                if not is_friend and len(tree[nei]) == 1:\n                    can_win = True\n                    break\n                visited.add(nei)\n                que.append((nei, is_friend))\n    if can_win:\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict\n\ndef solve(n, k, froom, adj):\n    fvisited = set()\n    fvisited.add(1)\n    for r in froom:\n        fvisited.add(r)\n    vroom = [1]\n    leafs = set()\n    for i in range(1, n + 1):\n        if len(adj[i]) == 1:\n            leafs.add(i)\n    leafs.discard(1)\n    while len(fvisited) < n:\n        nfroom = []\n        for r in froom:\n            for val in adj[r]:\n                if val not in fvisited:\n                    fvisited.add(val)\n                    nfroom.append(val)\n        froom = nfroom\n        nvroom = []\n        for r in vroom:\n            for val in adj[r]:\n                if val not in fvisited:\n                    if val in leafs:\n                        return 'YES'\n                    fvisited.add(val)\n                    nvroom.append(val)\n        if not nvroom:\n            return 'NO'\n        vroom = nvroom\n    return 'NO'\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    froom = list(map(int, input().split()))\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    print(solve(n, k, froom, adj))", "def solve():\n    input()\n    (n, k) = map(int, input().split())\n    f = list(enumerate(list(map(lambda x: int(x) - 1, input().split()))))\n    g = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].append(b)\n        g[b].append(a)\n    needed = {}\n    vlad = [0]\n    visited = [False] * n\n    friends = [-1] * n\n    while len(vlad):\n        nf = []\n        for (i, f1) in f:\n            if friends[f1] != -1:\n                continue\n            friends[f1] = i\n            for e in g[f1]:\n                nf.append((i, e))\n        f = nf\n        new_vlad = []\n        for v in vlad:\n            if friends[v] != -1:\n                needed[friends[v]] = True\n                continue\n            if visited[v] == True:\n                continue\n            visited[v] = True\n            if len(g[v]) == 1 and v != 0:\n                return -1\n            for e in g[v]:\n                new_vlad.append(e)\n        vlad = new_vlad\n    return len(needed)\nn = int(input())\nfor i in range(n):\n    print('YES' if solve() == -1 else 'NO')", "for t in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    pos = set(map(int, input().split()))\n    adj = [set() for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].add(v)\n        adj[v].add(u)\n    player = set([1])\n    friends = set() | pos\n    vis = set()\n    forb = set() | pos\n    ok = False\n    while 1:\n        if not player:\n            break\n        player_nxt = set()\n        for i in player:\n            vis.add(i)\n            if len(adj[i]) == 1 and i != 1:\n                ok = True\n                break\n            for j in adj[i]:\n                if j not in vis and j not in forb:\n                    player_nxt.add(j)\n        if ok == True:\n            break\n        friends_nxt = set()\n        for i in friends:\n            for j in adj[i]:\n                if j not in vis:\n                    vis.add(j)\n                    forb.add(j)\n                    friends_nxt.add(j)\n        player = player_nxt - friends_nxt\n        friends = friends_nxt\n        if ok == True:\n            break\n    print('YES' if ok == True else 'NO')", "for t in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    pos = set(map(int, input().split()))\n    adj = [set() for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].add(v)\n        adj[v].add(u)\n    player = set([1])\n    friends = set() | pos\n    vis = set()\n    forb = set() | pos\n    ok = False\n    while 1:\n        if not player:\n            break\n        player_nxt = set()\n        for i in player:\n            vis.add(i)\n            if len(adj[i]) == 1 and i != 1:\n                ok = True\n                break\n            for j in adj[i]:\n                if j not in vis and j not in forb:\n                    player_nxt.add(j)\n        if ok == True:\n            break\n        friends_nxt = set()\n        for i in friends:\n            for j in adj[i]:\n                if j not in vis:\n                    vis.add(j)\n                    forb.add(j)\n                    friends_nxt.add(j)\n        player = player_nxt - friends_nxt\n        friends = friends_nxt\n        if ok == True:\n            break\n    print('YES' if ok == True else 'NO')", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    input()\n    (rooms, friends) = [int(x) for x in input().split()]\n    q = deque([(int(x) - 1, 0) for x in input().split()])\n    q.append((0, 1))\n    adj = [[] for _ in range(rooms)]\n    visited = set()\n    vlad = False\n    for i in range(rooms - 1):\n        (a, b) = [int(x) - 1 for x in input().split()]\n        adj[a].append(b)\n        adj[b].append(a)\n    while q:\n        (curr, ppl) = q.popleft()\n        if curr in visited:\n            continue\n        visited.add(curr)\n        if ppl == 1 and len(adj[curr]) == 1 and (curr != 0):\n            vlad = True\n            break\n        for a in adj[curr]:\n            q.append((a, ppl))\n    if vlad:\n        print('YES')\n    else:\n        print('NO')", "from collections import deque, defaultdict\nfor _ in range(int(input())):\n    adf = input()\n    (n, k) = list(map(int, input().split()))\n    graph = defaultdict(list)\n    visited = set()\n    friends_visited = set()\n    q = deque()\n    for friend in list(map(int, input().split())):\n        q.append((friend, 0))\n        friends_visited.add(friend)\n    q.append((1, 1))\n    visited.add(1)\n    for _ in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        graph[a].append(b)\n        graph[b].append(a)\n    found = 0\n    while q:\n        for _ in range(len(q)):\n            (room, p) = q.popleft()\n            if p == 1 and room in friends_visited:\n                continue\n            elif room != 1 and p == 1 and (len(graph[room]) == 1) and (room not in friends_visited):\n                found = 1\n                break\n            for v in graph[room]:\n                if v not in visited and v not in friends_visited:\n                    if not p:\n                        friends_visited.add(v)\n                    else:\n                        visited.add(v)\n                    q.append((v, 1 if p else 0))\n        if found:\n            break\n    print('NO' if not found else 'YES')", "import sys\n\ndef findpaths(mypos: list, paths):\n    queue = mypos.copy()\n    times = [-1] * n\n    for i in mypos:\n        times[i] = 0\n    q = 0\n    while q < len(queue):\n        pos = queue[q]\n        dirs = paths[pos]\n        for i in dirs:\n            if times[i] == -1:\n                queue.append(i)\n                times[i] = times[pos] + 1\n        q += 1\n    return times\nfor _ in range(int(sys.stdin.readline())):\n    sys.stdin.readline()\n    (n, k) = [int(x) for x in sys.stdin.readline().split()]\n    friendposes = [int(x) - 1 for x in sys.stdin.readline().split()]\n    paths = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        (v, u) = [int(x) - 1 for x in sys.stdin.readline().split()]\n        paths[v].append(u)\n        paths[u].append(v)\n    vlad = findpaths([0], paths)\n    friends = findpaths(friendposes, paths)\n    endposes = []\n    for i in range(1, n):\n        if len(paths[i]) == 1:\n            endposes.append(i)\n    won = any([vlad[endpos] < friends[endpos] for endpos in endposes])\n    print('YNEOS'[1 - won::2])", "from collections import deque\nimport sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    input()\n    (n, k) = map(int, input().split())\n    enemy = list(map(int, input().split()))\n    node = [[-1, -1] for _ in range(n + 1)]\n    edge = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        edge[a].append(b)\n        edge[b].append(a)\n\n    def bfs(li, mask):\n        visited = [False] * (n + 1)\n        q = deque()\n        for t in li:\n            visited[t] = True\n            q.append((t, 1))\n            node[t][mask] = 1\n        while q:\n            (v, cnt) = q.popleft()\n            for w in edge[v]:\n                if visited[w]:\n                    continue\n                visited[w] = True\n                node[w][mask] = cnt + 1\n                q.append((w, cnt + 1))\n    bfs(enemy, 0)\n    bfs([1], 1)\n    flg = False\n    for (idx, t) in enumerate(node):\n        if t[0] > t[1] and idx > 1 and (len(edge[idx]) == 1):\n            flg = True\n    print('YES' if flg else 'NO')", "from collections import deque\nt = int(input().strip())\nfor _ in range(t):\n    _ = input()\n    (n, k) = map(int, input().strip().split())\n    adj = [[] for _ in range(n)]\n    q = deque(map(lambda x: (int(x) - 1, 0), input().strip().split()))\n    q.append((0, 1))\n    for _ in range(n - 1):\n        (s, e) = map(lambda x: int(x) - 1, input().strip().split())\n        adj[s].append(e)\n        adj[e].append(s)\n    visited = set()\n    reaches_leaf = False\n    while len(q) > 0:\n        (node, person) = q.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        if person == 1 and len(adj[node]) == 1 and (node != 0):\n            reaches_leaf = True\n            break\n        for adjacent in adj[node]:\n            q.append((adjacent, person))\n    if reaches_leaf:\n        print('YES')\n    else:\n        print('NO')", "from collections import deque\nimport sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    input()\n    (n, k) = map(int, input().split())\n    enemy = list(map(int, input().split()))\n    node = [[-1, -1] for _ in range(n + 1)]\n    edge = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        edge[a].append(b)\n        edge[b].append(a)\n\n    def bfs(li, mask):\n        visited = [False] * (n + 1)\n        q = deque()\n        for t in li:\n            visited[t] = True\n            q.append((t, 1))\n            node[t][mask] = 1\n        while q:\n            (v, cnt) = q.popleft()\n            for w in edge[v]:\n                if visited[w]:\n                    continue\n                visited[w] = True\n                node[w][mask] = cnt + 1\n                q.append((w, cnt + 1))\n    bfs(enemy, 0)\n    bfs([1], 1)\n    flg = False\n    for (idx, t) in enumerate(node):\n        if t[0] > t[1] and idx > 1 and (len(edge[idx]) == 1):\n            flg = True\n            break\n    print('YES' if flg else 'NO')", "from collections import deque\n\ndef BFSDistance(graph, queue, reach):\n    while len(queue) > 0:\n        currentNode = queue.popleft()\n        children = graph[currentNode]\n        for child in children:\n            if reach[child] == -1:\n                reach[child] = reach[currentNode]\n                queue.append(child)\n\ndef helper(graph, n, queue, reach):\n    queue.append(0)\n    reach[0] = 1\n    BFSDistance(graph, queue, reach)\n    for i in range(1, n):\n        if len(graph[i]) == 1 and reach[i] == 1:\n            return 'YES'\n    return 'NO'\ntests = int(input())\nfor i in range(tests):\n    graph = {}\n    tempStr = input()\n    (n, k) = list(map(int, input().split()))\n    location = list(map(int, input().split()))\n    (queue, reach) = (deque(), [-1 for i in range(n)])\n    for loc in location:\n        queue.append(loc - 1)\n        reach[loc - 1] = 0\n    for i in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        if a - 1 in graph:\n            graph[a - 1].append(b - 1)\n        else:\n            graph[a - 1] = [b - 1]\n        if b - 1 in graph:\n            graph[b - 1].append(a - 1)\n        else:\n            graph[b - 1] = [a - 1]\n    ans = helper(graph, n, queue, reach)\n    print(ans)", "from collections import defaultdict, deque\n\ndef solve():\n    input()\n    (num_rooms, num_players) = list(map(int, input().split()))\n    players_pos = list(map(int, input().split()))\n    graph = defaultdict(set)\n    for _ in range(num_rooms - 1):\n        (u, v) = list(map(int, input().split()))\n        graph[u].add(v)\n        graph[v].add(u)\n    leaves = {node: float('inf') for node in graph if len(graph[node]) == 1 and node != 1}\n    (queue, visited) = (deque([]), set())\n    for node_pos in players_pos:\n        queue.append([node_pos, 0])\n    while queue:\n        for _ in range(len(queue)):\n            (node, dist_from_player) = queue.popleft()\n            if node in visited:\n                continue\n            else:\n                visited.add(node)\n            if node in leaves:\n                leaves[node] = dist_from_player\n            for nei in graph[node]:\n                queue.append([nei, dist_from_player + 1])\n    (vlad_q, visited) = (deque([[1, 0]]), set())\n    while vlad_q:\n        (cur_pos, dist_from_root) = vlad_q.popleft()\n        if cur_pos in visited:\n            continue\n        else:\n            visited.add(cur_pos)\n        if cur_pos in leaves and dist_from_root < leaves[cur_pos]:\n            return True\n        for nei in graph[cur_pos]:\n            vlad_q.append([nei, dist_from_root + 1])\n    return False\nfor _ in range(int(input())):\n    if solve():\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict, deque\n\ndef answer(friends, hashmap):\n    (queue, maxi) = (deque(), defaultdict(lambda : float('inf')))\n    for i in friends:\n        queue.append((i, 0))\n    while queue:\n        (node, travel) = queue.popleft()\n        if travel >= maxi[node]:\n            continue\n        maxi[node] = min(maxi[node], travel)\n        for nei in hashmap[node]:\n            queue.append((nei, travel + 1))\n    visited = set()\n    queue.append((1, 0))\n    while queue:\n        (node, travel) = queue.popleft()\n        if node != 1 and len(hashmap[node]) == 1 and (travel < maxi[node]):\n            return 'YES'\n        visited.add(node)\n        for nei in hashmap[node]:\n            if nei not in visited:\n                queue.append((nei, travel + 1))\n    return 'NO'\ntest = int(input())\nfor i in range(test):\n    hashmap = defaultdict(list)\n    input()\n    first = list(map(int, input().split()))\n    second = list(map(int, input().split()))\n    for j in range(first[0] - 1):\n        third = list(map(int, input().split()))\n        hashmap[third[0]].append(third[1])\n        hashmap[third[1]].append(third[0])\n    print(answer(second, hashmap))", "from collections import defaultdict\nimport heapq\nfrom math import inf\n\ndef cf756e1(n, friends, graph):\n    friendsMinTime = [inf for _ in range(n)]\n    friendsReach = [(0, friend) for friend in friends]\n    heapq.heapify(friendsReach)\n    while friendsReach:\n        (time, root) = heapq.heappop(friendsReach)\n        if friendsMinTime[root - 1] <= time:\n            continue\n        friendsMinTime[root - 1] = time\n        for node in graph[root]:\n            if time + 1 < friendsMinTime[node - 1]:\n                heapq.heappush(friendsReach, (time + 1, node))\n    visited = set([1])\n    locations = [(1, i) for i in graph[1]]\n    heapq.heapify(locations)\n    while locations:\n        (time, root) = heapq.heappop(locations)\n        if friendsMinTime[root - 1] <= time:\n            continue\n        if len(graph[root]) == 1:\n            return True\n        visited.add(root)\n        for node in graph[root]:\n            if node not in visited:\n                heapq.heappush(locations, (time + 1, node))\n    return False\nfor _ in range(int(input())):\n    input()\n    (n, k) = map(int, input().split())\n    friends = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    print('YES' if cf756e1(n, friends, graph) else 'NO')"]