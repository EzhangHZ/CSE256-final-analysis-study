["from typing import List\n\ndef get_primes(size: int) -> List[int]:\n    is_prime = [True for _ in range(size + 1)]\n    primes = []\n    for i in range(2, size + 1):\n        if is_prime[i]:\n            primes.append(i)\n            for j in range(i * i, size + 1, i):\n                is_prime[j] = False\n    return primes\nmax = 10 ** 9\nprimes = get_primes(int(max ** 0.5) + 1)\n\ndef val(n: int) -> int:\n    primes_and_powers = []\n    for p in primes:\n        if p * p > n:\n            break\n        power = 0\n        while n % p == 0:\n            power += 1\n            n //= p\n        if power > 0:\n            primes_and_powers.append([p, power])\n    if n > 1:\n        primes_and_powers.append([n, 1])\n    res = 0\n    mul = 0\n    while mul != 1:\n        mul = 1\n        for i in range(len(primes_and_powers)):\n            if primes_and_powers[i][1] > 0:\n                mul *= primes_and_powers[i][0]\n                primes_and_powers[i][1] -= 1\n        res += mul\n    return res - 1\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    print(val(n))", "def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n + 1) if primes[p]]\n\ndef prime_factors(n, primes):\n    factors = []\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            factors.append(p)\n            n = n // p\n    if n > 1:\n        factors.append(n)\n    return factors\nprimes = sieve_of_eratosthenes(10 ** 6)\nfor _ in range(int(input())):\n    a = int(input())\n    li = prime_factors(a, primes)\n    se = set(li)\n    se = list(se)\n    co = []\n    for i in se:\n        co.append(li.count(i))\n    sm = 0\n    zo = max(co)\n    fino = []\n    while zo > 0:\n        pro = 1\n        for i in range(len(se)):\n            if co[i] > 0:\n                pro = pro * se[i]\n                co[i] = co[i] - 1\n        fino.append(pro)\n        zo = zo - 1\n    print(int(sum(fino)))", "def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n + 1) if primes[p]]\n\ndef prime_factors(n, primes):\n    factors = []\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            factors.append(p)\n            n = n // p\n    if n > 1:\n        factors.append(n)\n    return factors\nprimes = sieve_of_eratosthenes(10 ** 6)\nfor _ in range(int(input())):\n    n = int(input())\n    li = prime_factors(n, primes)\n    st = list(set(li))\n    co = []\n    for i in st:\n        co.append(li.count(i))\n    sm = 0\n    zo = max(co)\n    ans = []\n    while zo > 0:\n        pro = 1\n        for i in range(len(st)):\n            if co[i] > 0:\n                pro = pro * st[i]\n                co[i] = co[i] - 1\n        ans.append(pro)\n        zo = zo - 1\n    print(int(sum(ans)))", "import math\n\ndef main():\n    _i = int(input())\n    for _ in range(_i):\n        n = int(input().strip('\\r\\n'))\n        counts = {}\n        _n = n\n        if _n % 2 == 0:\n            counts[2] = 0\n            while _n % 2 == 0:\n                counts[2] += 1\n                _n /= 2\n        i = 3\n        sqn = int(math.sqrt(_n))\n        while _n > 1:\n            flag = False\n            while _n % i == 0:\n                flag = True\n                if i in counts:\n                    counts[i] += 1\n                else:\n                    counts[i] = 1\n                _n = _n // i\n            if flag:\n                sqn = int(math.sqrt(_n))\n            if i > sqn:\n                counts[int(_n)] = 1\n                break\n            i += 2\n        scnts = sorted(counts.items(), key=lambda x: x[1])\n        res = 1\n        for val in counts:\n            res *= val\n        cur_mul = res\n        res *= scnts[0][1]\n        prev_cnt = scnts[0][1]\n        for (val, cnt) in scnts:\n            if cnt > prev_cnt:\n                res += cur_mul * (cnt - prev_cnt)\n                prev_cnt = cnt\n            cur_mul = cur_mul // val\n        print(res)\nmain()", "from collections import Counter\nimport sys\ninput = sys.stdin.readline\n\ndef prime(n):\n    arr = [True for _ in range(n + 1)]\n    m = int(n ** 0.5)\n    for i in range(2, m + 1):\n        if arr[i] == True:\n            for j in range(2 * i, n + 1, i):\n                arr[j] = False\n    return [i for i in range(2, n + 1) if arr[i] == True]\na = prime(31623)\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    m = int(n ** 0.5)\n    board = []\n    for i in a:\n        if n == 1:\n            break\n        while n % i == 0:\n            n //= i\n            board.append(i)\n    if n != 1:\n        board.append(n)\n    board = Counter(board)\n    sumall = 0\n    while 1:\n        val = list(board.values())\n        if len(val) == 0:\n            break\n        min_count = min(val)\n        g = 1\n        key = list(board.keys())\n        for i in key:\n            board[i] -= min_count\n            if board[i] == 0:\n                del board[i]\n            g *= i\n        sumall += g * min_count\n    print(sumall)", "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    cnt = []\n    c = 0\n    while n % 2 == 0:\n        n //= 2\n        c += 1\n    if c != 0:\n        cnt.append((c, 2))\n    for i in range(3, n, 2):\n        if i * i > n:\n            break\n        c = 0\n        while n % i == 0:\n            n //= i\n            c += 1\n        if c != 0:\n            cnt.append((c, i))\n    if n != 1:\n        cnt.append((1, n))\n    cnt.sort()\n    now = 1\n    for (_, v) in cnt:\n        now *= v\n    z = 0\n    ans = 0\n    for i in range(len(cnt)):\n        c = cnt[i][0]\n        while z < c:\n            z += 1\n            ans += now\n        now //= cnt[i][1]\n    print(ans)\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "import math\nfrom math import prod\nfor _ in range(int(input())):\n    n = int(input())\n    simple_nums = []\n    while n % 2 == 0:\n        simple_nums.append(2)\n        n = n >> 1\n    for i in range(3, math.floor(math.sqrt(n)) + 1, 2):\n        if i * i > n:\n            break\n        while not n % i:\n            simple_nums.append(i)\n            n = n // i\n    if n > 1:\n        simple_nums.append(n)\n    summ = 0\n    while simple_nums:\n        s = set(simple_nums)\n        summ += prod(s)\n        for a in s:\n            simple_nums.remove(a)\n    print(summ)", "for _ in range(int(input())):\n    n = int(input())\n    pf = []\n    while n > 0:\n        m = n\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                pf.append(i)\n                n //= i\n                break\n        if m == n:\n            pf.append(n)\n            n = 0\n    ans = 0\n    i = 0\n    while True:\n        x = pf[i]\n        z = pf[i]\n        pf[i] = 0\n        if x == 0:\n            pass\n        else:\n            for j in range(len(pf)):\n                if pf[j] != z and pf[j] != 0:\n                    x *= pf[j]\n                    z = pf[j]\n                    pf[j] = 0\n            ans += x\n        for v in pf:\n            if v != 0:\n                break\n        else:\n            break\n        i += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = [1 for i in range(0, 30)]\n    i = 2\n    while i * i <= n:\n        j = 0\n        while n % i == 0:\n            a[j] *= i\n            n //= i\n            j += 1\n        if i == 2:\n            i += 1\n        else:\n            i += 2\n    a[0] *= n\n    ans = 0\n    for i in range(0, 30):\n        if a[i] > 1:\n            ans += a[i]\n    print(ans)", "def pfacs(n):\n    res = dict()\n    for i in range(2, n + 1):\n        if i * i > n:\n            if n > 1:\n                res[n] = 1\n            break\n        if n % i == 0:\n            k = 0\n            while n % i == 0:\n                k += 1\n                n //= i\n            res[i] = k\n    return res\n\ndef solve(n):\n    res = 0\n    ap = sorted(pfacs(n).items(), key=lambda x: x[1])\n    while ap:\n        temp = []\n        k = ap[0][1]\n        s = 1\n        for (a, p) in ap:\n            s *= a\n            if p - k > 0:\n                temp.append((a, p - k))\n        res += k * s\n        ap = temp\n    print(res)\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    solve(n)", "def ss(n):\n    i = 2\n    x = {}\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            if i in x:\n                x[i] += 1\n            else:\n                x[i] = 1\n    if n > 1:\n        if n in x:\n            x[n] += 1\n        else:\n            x[n] = 1\n    t = 0\n    for i in x:\n        t = max(t, x[i])\n    ans = [0 for _ in range(t + 1)]\n    for i in x:\n        for j in range(x[i]):\n            if ans[j] == 0:\n                ans[j] = 1\n            ans[j] *= i\n    return sum(ans)\nfor _ in range(int(input())):\n    n = int(input())\n    print(ss(n))", "import math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\nfor _ in range(int(input())):\n    n = int(input())\n    l = []\n    l = prime_factors(n)\n    if len(l) <= 1:\n        print(n)\n        continue\n    count = 1\n    ma = 0\n    for i in range(len(l) - 1):\n        if l[i] == l[i + 1]:\n            count += 1\n        else:\n            ma = max(count, ma)\n            count = 1\n    ma = max(count, ma)\n    l2 = [1] * ma\n    j = 0\n    for i in range(len(l) - 1):\n        l2[j] *= l[i]\n        if l[i] == l[i + 1]:\n            j += 1\n        else:\n            j = 0\n    if l[-1] == l[-2]:\n        l2[j] *= l[-1]\n    else:\n        l2[0] *= l[-1]\n    print(sum(l2))", "import math\nnb_t = int(input())\n\ndef prime_factor(n):\n    i = 2\n    res = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            res.append(i)\n    return res + [n]\nfor _ in range(nb_t):\n    n = int(input())\n    pf = prime_factor(n)\n    pn = set(pf)\n    po = [pf.count(i) for i in pn]\n    c = sorted([[n, p] for (n, p) in zip(pn, po)], key=lambda x: x[1])\n    nb_po = sum(po)\n    res = 0\n    while nb_po > 0:\n        temp = []\n        for i in range(len(po)):\n            if c[i][1] > 0:\n                temp.append(c[i][0])\n                c[i][1] -= 1\n                nb_po -= 1\n        res += math.prod(temp)\n    print(res)", "import math\nfrom collections import deque\ntotal = int(input())\n\ndef all_factors(p):\n    res = []\n    for i in range(2, p // 2):\n        if i * i > p:\n            break\n        if p % i == 0:\n            count = 0\n            while p % i == 0:\n                p //= i\n                count += 1\n            res.append((i, count))\n    if p:\n        res.append((p, 1))\n    return res\n\ndef func(i):\n    factors = deque(all_factors(i))\n    res = 0\n    while factors:\n        size = len(factors)\n        cur = 1\n        for _ in range(size):\n            (f, count) = factors.popleft()\n            cur *= f\n            if count > 1:\n                factors.append((f, count - 1))\n        res += cur\n    return res\nfor i in range(total):\n    print(func(int(input())))", "import math\n\ndef primfacs_dict(n):\n    i = 2\n    prims_collection = {}\n    while i * i <= n:\n        while n % i == 0:\n            prims_collection[i] = prims_collection.get(i, 0) + 1\n            n = n // i\n        i = i + 1\n    if n > 1:\n        prims_collection[n] = prims_collection.get(int(n), 0) + 1\n    return prims_collection\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    prims_collection = primfacs_dict(n)\n    res = 0\n    rem_res = math.prod(prims_collection.keys())\n    rem_l = []\n    while prims_collection:\n        temp_keys = prims_collection.keys()\n        min_temp = min(prims_collection.values())\n        rem_res = rem_res // math.prod(rem_l)\n        res += rem_res * min_temp\n        for k in prims_collection.keys():\n            prims_collection[k] -= min_temp\n        temp = {}\n        rem_l = []\n        for l in prims_collection.keys():\n            if prims_collection[l] != 0:\n                temp[l] = prims_collection[l]\n            else:\n                rem_l += [l]\n        prims_collection = dict(temp)\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    a = [1 for i in range(0, 30)]\n    i = 2\n    while i * i <= n:\n        j = 0\n        while n % i == 0:\n            a[j] *= i\n            n //= i\n            j += 1\n        if i == 2:\n            i += 1\n        else:\n            i += 2\n    a[0] *= n\n    ans = 0\n    for i in range(0, 30):\n        if a[i] > 1:\n            ans += a[i]\n    print(ans)", "def Factor(n):\n    Ans = []\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            Ans.append(d)\n            n //= d\n        else:\n            d += 1\n    if n > 1:\n        Ans.append(n)\n    return Ans\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    m = Factor(n)\n    res = 0\n    while len(m) > 0:\n        i = 0\n        prev = 0\n        tmp = 1\n        while i < len(m):\n            if m[i] != prev:\n                tmp = tmp * m[i]\n                prev = m[i]\n                m.pop(i)\n            else:\n                i = i + 1\n        res = res + tmp\n    print(res)"]