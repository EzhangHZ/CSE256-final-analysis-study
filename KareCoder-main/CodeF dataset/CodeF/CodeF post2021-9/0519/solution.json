["from collections import defaultdict\ncounter = defaultdict(int)\n\ndef solve(a):\n    for ai in a:\n        counter[ai] += 1\n    count = list(counter.values())\n    num_level = len(count)\n    count.sort()\n    for i in range(num_level):\n        count[i] = max(count[i] - i - 2, 0)\n    L = 0\n    R = max(count)\n    if R == 0:\n        return num_level + 1\n\n    def check(k):\n        b = count.copy()\n        for i in range(len(b)):\n            b[i] = max(b[i] - k, 0)\n        if sum(b) <= k:\n            return True\n        return False\n    while R - L > 1:\n        mid = (R + L) // 2\n        if check(mid):\n            R = mid\n        else:\n            L = mid\n    return num_level + 1 + R\nfor a in [*open(0)][2::2]:\n    counter.clear()\n    res = solve(a.split())\n    print(res)", "from collections import Counter\nimport heapq\nnumeroTestes = int(input())\nresults = []\nfor a in range(numeroTestes):\n    vertices = int(input())\n    pais = [int(t) for t in input().split()]\n    counterPais = Counter(pais)\n    l = []\n    total = 0\n    sorted_Values = sorted(counterPais.values(), reverse=True)\n    for value in sorted_Values:\n        tamanho = len(counterPais)\n        va = tamanho + 1 - value - total\n        if va < 0:\n            heapq.heappush(l, va)\n        total += 1\n    cont = 0\n    while l:\n        va = -heapq.heappop(l)\n        if va <= cont:\n            break\n        cont += 1\n        heapq.heappush(l, -va + 1)\n    results.append(cont + total + 1)\nfor r in results:\n    print(r)", "from collections import Counter\nimport heapq\nnumeroTestes = int(input())\nresults = []\nfor a in range(numeroTestes):\n    vertices = int(input())\n    pais = [int(t) for t in input().split()]\n    counterPais = Counter(pais)\n    l = []\n    t = 0\n    sorted_Values = sorted(counterPais.values(), reverse=True)\n    for value in sorted_Values:\n        tamanho = len(counterPais)\n        va = tamanho + 1 - value - t\n        if va < 0:\n            heapq.heappush(l, va)\n        t += 1\n    cont = 0\n    while l:\n        va = -heapq.heappop(l)\n        if va <= cont:\n            break\n        cont += 1\n        heapq.heappush(l, -va + 1)\n    results.append(cont + t + 1)\nfor r in results:\n    print(r)", "from collections import Counter\n\ndef calculate(nodes):\n    common = Counter(nodes).most_common()\n    secs = 0\n    counts = []\n    times = []\n    for (elem, count) in common:\n        times.append(count + secs)\n        counts.append(count)\n        secs += 1\n    secs += 1\n    while max(times) > secs:\n        while times[0] > secs and (len(times) == 1 or times[0] >= times[1]):\n            secs += 1\n            times[0] -= 1\n        for i in range(len(times)):\n            if times[i] > secs and times[i] > times[0]:\n                secs += 1\n                times[i] -= 1\n    print(secs)\ncases = int(input())\nfor i in range(cases):\n    input()\n    calculate(input().split(' '))", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    import heapq\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        parent = [0] * (n + 1)\n        a = list(map(int, input().split()))\n        for i in range(n - 1):\n            parent[a[i]] += 1\n        (heap1, heap2) = ([], [])\n        for i in parent:\n            if i > 0:\n                heapq.heappush(heap1, -i)\n        heapq.heappush(heap1, -1)\n        j = len(heap1)\n        i = 0\n        ans = 0\n        while heap1:\n            ans += 1\n            cand = -heapq.heappop(heap1)\n            if cand - (j - i) > 0:\n                heapq.heappush(heap2, -(cand - (j - i)))\n            i += 1\n        (heap1, heap2) = (heap2, heap1)\n        while heap1:\n            ans += 1\n            cand = -heapq.heappop(heap1)\n            if cand - 2 > 0:\n                heapq.heappush(heap2, -(cand - 2))\n            while heap1:\n                cand = -heapq.heappop(heap1)\n                if cand - 1 > 0:\n                    heapq.heappush(heap2, -cand + 1)\n            while heap2:\n                cand = -heapq.heappop(heap2)\n                heapq.heappush(heap1, -cand)\n        sys.stdout.write(f'{ans}\\n')\nmain()", "from collections import Counter\n\ndef calculate(nodes):\n    common = Counter(nodes).most_common()\n    secs = 0\n    counts = []\n    times = []\n    for (elem, count) in common:\n        times.append(count + secs)\n        counts.append(count)\n        secs += 1\n    secs += 1\n    while max(times) > secs:\n        while times[0] > secs and (len(times) == 1 or times[0] >= times[1]):\n            secs += 1\n            times[0] -= 1\n        for i in range(len(times)):\n            if times[i] > secs and times[i] > times[0]:\n                secs += 1\n                times[i] -= 1\n    print(secs)\ncases = int(input())\nfor i in range(cases):\n    input()\n    calculate(input().split(' '))", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    groups = Counter(p)\n    g = len(groups)\n    time_needed = []\n    infection_timer = 0\n    for (_, group_size) in groups.most_common():\n        time_needed.append(infection_timer + group_size)\n        infection_timer += 1\n    infection_timer += 1\n    while infection_timer < max(time_needed):\n        while (g == 1 or time_needed[0] >= time_needed[1]) and infection_timer < time_needed[0]:\n            time_needed[0] -= 1\n            infection_timer += 1\n        if g > 1:\n            for group_id in range(1, g):\n                if time_needed[group_id] > time_needed[0] and infection_timer < time_needed[group_id]:\n                    time_needed[group_id] -= 1\n                    infection_timer += 1\n    print(infection_timer)", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    groups = Counter(p)\n    g = len(groups)\n    time_needed = []\n    infection_timer = 0\n    for (_, group_size) in groups.most_common():\n        time_needed.append(infection_timer + group_size)\n        infection_timer += 1\n    infection_timer += 1\n    time_needed.sort(reverse=True)\n    while infection_timer < max(time_needed):\n        while (g == 1 or time_needed[0] >= time_needed[1]) and infection_timer < time_needed[0]:\n            time_needed[0] -= 1\n            infection_timer += 1\n        if g > 1:\n            for group_id in range(1, g):\n                if time_needed[group_id] > time_needed[0] and infection_timer < time_needed[group_id]:\n                    time_needed[group_id] -= 1\n                    infection_timer += 1\n    print(infection_timer)", "import time\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * (n + 1)\n    a[0] = 1\n    for i in list(map(int, input().split())):\n        a[i] += 1\n    try:\n        a = [x for x in a if x > 0]\n        a.sort(reverse=True)\n        ans = len(a)\n        for i in range(len(a)):\n            a[i] -= len(a) - i\n        a = [x for x in a if x > 0]\n        while len(a) != 0:\n            a.sort(reverse=True)\n            a = [x - 1 for x in a]\n            a[0] -= 1\n            ans += 1\n            a = [x for x in a if x > 0]\n        print(ans)\n    except Exception as e:\n        print('Was exception: ')\n        print(e)\n        exit(0)", "import time\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * (n + 1)\n    a[0] = 1\n    for i in list(map(int, input().split())):\n        a[i] += 1\n    try:\n        a = [x for x in a if x > 0]\n        a.sort(reverse=True)\n        ans = len(a)\n        for i in range(len(a)):\n            a[i] -= len(a) - i\n        a = [x for x in a if x > 0]\n        while len(a) != 0:\n            a.sort(reverse=True)\n            a = [x - 1 for x in a]\n            a[0] -= 1\n            ans += 1\n            a = [x for x in a if x > 0]\n        print(ans)\n    except Exception as e:\n        print('Was exception: ')\n        print(e)\n        exit(0)", "class Tree:\n\n    def __init__(self, n, p):\n        self.groups = [1]\n        self.time = 0\n        self.n = n\n        p.sort()\n        s = p[0]\n        k = 0\n        for t in p:\n            if t == s:\n                k += 1\n            else:\n                self.groups.append(k)\n                s = t\n                k = 1\n        self.groups.append(k)\n        self.groups.sort(reverse=True)\n        self.k = len(self.groups)\n\n    def afterksec(self):\n        self.time += self.k\n        for i in range(self.k):\n            self.groups[i] -= self.k - i\n        self.groups.sort(reverse=True)\n        self.groups = list(filter(lambda x: x > 0, self.groups))\n\n    def bin_cond(self, t):\n        s = 0\n        for b in self.groups:\n            s += max(b - t, 0)\n        return s <= t\n\n    def bin_search(self):\n        if self.groups == []:\n            return 0\n        l = 0\n        r = self.n\n        while l + 1 != r and l != r:\n            m = (l + r) // 2\n            if self.bin_cond(m):\n                r = m\n            else:\n                l = m\n        self.time += r\n        self.groups = []\n\n    def solve(self):\n        self.afterksec()\n        self.bin_search()\n        return self.time\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    tree = Tree(n, p)\n    print(tree.solve())", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    groups = Counter(p)\n    g = len(groups)\n    time_needed = []\n    infection_timer = 0\n    for (_, group_size) in groups.most_common():\n        time_needed.append(infection_timer + group_size)\n        infection_timer += 1\n    infection_timer += 1\n    while infection_timer < max(time_needed):\n        while (g == 1 or time_needed[0] >= time_needed[1]) and infection_timer < time_needed[0]:\n            time_needed[0] -= 1\n            infection_timer += 1\n        if g > 1:\n            for group_id in range(1, g):\n                if time_needed[group_id] > time_needed[0] and infection_timer < time_needed[group_id]:\n                    time_needed[group_id] -= 1\n                    infection_timer += 1\n    print(infection_timer)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [0 for i in range(n + 1)]\n    arr[0] = 1\n    for i in list(map(int, input().split())):\n        arr[i] += 1\n    arr.sort()\n    arr = [i for i in arr if i != 0]\n    n = len(arr)\n    ans = n\n    arr2 = [arr[i] - i - 1 for i in range(n) if arr[i] - i - 1 > 0]\n    n = len(arr2)\n    if n == 0:\n        print(ans)\n        continue\n    arr3 = [0 for i in range(max(arr2))]\n    n = len(arr3)\n    for i in arr2:\n        arr3[i - 1] += 1\n    for i in range(n - 2, -1, -1):\n        arr3[i] += arr3[i + 1]\n    l = 0\n    r = n - 1\n    while l <= r:\n        if arr3[l] <= 0:\n            break\n        ans += 1\n        arr3[l] = 0\n        if l == r:\n            break\n        arr3[r] -= 1\n        if arr3[r] == 0:\n            r -= 1\n        l += 1\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    d = {}\n    for j in l:\n        d[j] = 0\n    for j in l:\n        d[j] += 1\n    l1 = []\n    for j in d:\n        l1.append(d[j])\n    l1.append(1)\n    l1.sort()\n    x = len(l1)\n    t = 0\n    for j in range(x):\n        t += 1\n        if l1[j] > j + 1:\n            l1[j] -= j + 1\n        else:\n            l1[j] = 0\n    c = sum(l1)\n    l1.sort()\n    ch = False\n    for j in range(x):\n        if l1[j] > 0:\n            l1 = l1[j:]\n            ch = True\n            break\n    if ch:\n        l2 = [l1[0]]\n        x = len(l1)\n        for j in range(1, x):\n            l2.append(l1[j] - l1[j - 1])\n        x1 = 0\n        while c - l2[x1] * (x - x1) >= l1[x1]:\n            if x1 < x:\n                c -= l2[x1] * (x - x1)\n                x1 += 1\n            else:\n                break\n        c -= l2[x1] * (x - x1)\n        x2 = l1[x1] - c\n        t += c\n        r = x2 % (x - x1 + 1)\n        d = x2 // (x - x1 + 1)\n        t += (x - x1) * d + r\n    print(t)", "for _ in [0] * int(input()):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [0] * n + [1]\n    for i in a:\n        c[i - 1] += 1\n    c = sorted(c, reverse=True)\n    ans = sum((i > 0 for i in c))\n    for (i, j) in enumerate(c):\n        if j > 0:\n            c[i] = i + j - ans\n    c = sorted([i for i in c if i > 0], reverse=True)\n    while c:\n        ans += 1\n        for (i, j) in enumerate(c):\n            if j > 0:\n                c[i] = j - 1 - (i == 0)\n        c = sorted([i for i in c if i > 0], reverse=True)\n    print(ans)", "for _ in [0] * int(input()):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [0] * n + [1]\n    for i in a:\n        c[i - 1] += 1\n    c = sorted(c, reverse=True)\n    ans = sum((i > 0 for i in c))\n    for (i, j) in enumerate(c):\n        if j > 0:\n            c[i] = i + j - ans\n    c = sorted([i for i in c if i > 0], reverse=True)\n    while c:\n        ans += 1\n        for (i, j) in enumerate(c):\n            if j > 0:\n                c[i] = j - 1 - (i == 0)\n        c = sorted([i for i in c if i > 0], reverse=True)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = [int(i) for i in input().split()]\n    children = [0] * n + [1]\n    for i in p:\n        children[i - 1] += 1\n    children.sort(reverse=True)\n    total_children = sum((i > 0 for i in children))\n    for (i, j) in enumerate(children):\n        if j > 0:\n            children[i] = i + j - total_children\n    children = sorted([i for i in children if i > 0], reverse=True)\n    while children:\n        total_children += 1\n        for (i, j) in enumerate(children):\n            if j > 0:\n                children[i] = j - 1 - (i == 0)\n        children = sorted([i for i in children if i > 0], reverse=True)\n    print(total_children)", "if True:\n    from collections import Counter\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        cnt = Counter({0: 1})\n        cnt.update(map(int, input().split()))\n        src = cnt.most_common()\n        src.reverse()\n        d = list(map(lambda x: max(x[1][1] - x[0] - 1, 0), enumerate(src)))\n        d.sort(reverse=True)\n        d.append(0)\n        delta = max(d)\n        res = delta\n        i = 0\n        while d and d[0] > 0:\n            d[0] -= 1\n            d = [dd - 1 for dd in d if dd > 0]\n            d.sort(reverse=True)\n            i += 1\n        print(i + len(src))", "from collections import Counter\nfrom multiprocessing.connection import wait\ntestcases = input()\n\ndef can_do(waitlist, mid):\n    extra_op = 0\n    for i in waitlist:\n        if mid < i:\n            extra_op += i - mid\n        mid -= 1\n    return mid >= extra_op\n\ndef solve():\n    n = int(input().strip())\n    c = Counter(map(int, input().strip().split(' ')))\n    c[0] = 1\n    waitlist = sorted(c.values(), reverse=True)\n    l = 0\n    r = n\n    while l < r:\n        mid = (l + r) // 2\n        if can_do(waitlist, mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l\nfor caseNr in range(1, int(testcases) + 1):\n    print('%s' % solve())", "from collections import Counter, defaultdict, deque, namedtuple\nfrom functools import lru_cache\nfrom typing import List, Dict\nimport bisect as b\nimport heapq as h\nimport math as m\n\ndef inti():\n    return int(input())\n\ndef ints():\n    return [int(x) for x in input().split()]\n\ndef main_tc():\n    n = inti()\n    parents = ints()\n    counter = defaultdict(int)\n    counter[0] = 1\n    for parent in parents:\n        counter[parent] += 1\n    numbers = []\n    for (parent, count) in counter.items():\n        numbers.append(count)\n    numbers.sort(reverse=True)\n    remaining = n\n    answer = 0\n    answer += len(numbers)\n    for i in range(len(numbers)):\n        infected = min(len(numbers) - i, numbers[i])\n        numbers[i] -= infected\n        remaining -= infected\n    numbers.sort(reverse=True)\n    while len(numbers) > 0 and numbers[-1] == 0:\n        numbers.pop()\n    second_answer = 0\n    while len(numbers) > 0:\n        second_answer += 1\n        for i in range(len(numbers)):\n            numbers[i] -= 1\n            remaining -= 1\n        if remaining <= second_answer:\n            break\n        while len(numbers) > 0 and numbers[-1] == 0:\n            numbers.pop()\n    print(answer + second_answer)\n\ndef main():\n    tc = inti()\n    for _ in range(tc):\n        main_tc()\nmain()", "from collections import Counter\nfrom multiprocessing.connection import wait\ntestcases = input()\n\ndef can_do(waitlist, mid):\n    extra_op = 0\n    for i in waitlist:\n        if mid < i:\n            extra_op += i - mid\n        mid -= 1\n    return mid >= extra_op\n\ndef solve():\n    n = int(input().strip())\n    c = Counter(map(int, input().strip().split(' ')))\n    c[0] = 1\n    waitlist = sorted(c.values(), reverse=True)\n    l = 0\n    r = n\n    while l < r:\n        mid = (l + r) // 2\n        if can_do(waitlist, mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l\nfor caseNr in range(1, int(testcases) + 1):\n    print('%s' % solve())", "from collections import Counter\nfrom multiprocessing.connection import wait\ntestcases = input()\n\ndef can_do(waitlist, mid):\n    extra_op = 0\n    for i in waitlist:\n        if mid < i:\n            extra_op += i - mid\n        mid -= 1\n    return mid >= extra_op\n\ndef solve():\n    n = int(input().strip())\n    c = Counter(map(int, input().strip().split(' ')))\n    c[0] = 1\n    waitlist = sorted(c.values(), reverse=True)\n    l = 0\n    r = n\n    while l < r:\n        mid = (l + r) // 2\n        if can_do(waitlist, mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l\nfor caseNr in range(1, int(testcases) + 1):\n    print('%s' % solve())", "class Node:\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass doubly_linked_list:\n\n    def __init__(self):\n        self.head = None\n\n    def push(self, NewVal):\n        NewNode = Node(NewVal)\n        NewNode.next = self.head\n        if self.head is not None:\n            self.head.prev = NewNode\n        self.head = NewNode\n\n    def remove(self, node):\n        if node.prev:\n            prev = node.prev\n            next = node.next\n            prev.next = node.next\n            if next:\n                next.prev = node.prev\n        else:\n            self.head = node.next\n            if self.head:\n                self.head.prev = None\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    amount_map = {}\n    for i in a:\n        amount_map[i] = amount_map.get(i, 0) + 1\n    data = sorted(list(amount_map.values()) + [1], reverse=True)\n    result = 0\n    ijected = doubly_linked_list()\n    circle = False\n    result += len(data)\n    n = len(data)\n    for i in range(len(data)):\n        data[i] -= n\n        n -= 1\n    data = [x for x in data if x > 0]\n    while len(data):\n        max_i = 0\n        for i in range(len(data)):\n            if data[i] > data[max_i]:\n                max_i = i\n        data[max_i] -= 1\n        data = [x - 1 for x in data if x - 1 > 0]\n        result += 1\n    print(result)", "t = int(input())\nrr = ''\nfor _t in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = sorted(arr)\n    new_arr = []\n    nlist = []\n    prev = None\n    for a in arr:\n        if a == prev or not nlist:\n            nlist.append(a)\n        else:\n            new_arr.append(nlist)\n            nlist = [a]\n        prev = a\n    if nlist:\n        new_arr.append(nlist)\n    arr = sorted(new_arr, key=lambda x: len(x), reverse=True)\n    arr.append([0])\n\n    def spread(l: list):\n        nl = []\n        for i in range(len(l)):\n            if l[i] != 0:\n                nl.append(l[i] - 1)\n        if not nl:\n            nl = [0]\n        return nl\n    inf_count = []\n    seconds = 0\n    for i in range(len(arr)):\n        seconds += 1\n        inf_count = spread(inf_count)\n        inf_count.append(len(arr[i]) - 1)\n    while True:\n        inf_count = sorted(inf_count, reverse=True)\n        if inf_count[0] == 0:\n            break\n        else:\n            seconds += 1\n            inf_count = spread(inf_count)\n            if inf_count[0] != 0:\n                inf_count[0] -= 1\n    rr += str(seconds) + '\\n'\nprint(rr)", "from collections import defaultdict\nimport math\nfor _ in range(int(input())):\n    n = int(input())\n    l = [0] + list(map(int, input().split()))\n    d = defaultdict(int)\n    for i in range(n):\n        d[l[i]] += 1\n    ans = 0\n    MAX = 0\n    c = []\n    for (i, v) in d.items():\n        ans += 1\n        MAX = max(MAX, v)\n        c.append(v)\n    c.sort(reverse=True)\n    for i in range(len(c)):\n        t = max(0, c[i] - len(c) + i)\n        c[i] = t\n    t = []\n    for i in range(len(c)):\n        if c[i] > 0:\n            t.append(c[i])\n    while t:\n        t.sort(reverse=True)\n        t[0] -= 1\n        for i in range(len(t)):\n            t[i] -= 1\n        while t and t[-1] <= 0:\n            t.pop()\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = [0] + list(map(int, input().split()))\n    branch = {}\n    for i in a:\n        branch[i] = branch.get(i, 0) + 1\n    res = sorted(branch.values())[::-1]\n    cnt = 0\n    j = len(res)\n    for i in range(len(res)):\n        res[i] -= j\n        j -= 1\n        cnt += 1\n    res = sorted(res)[::-1]\n    while res[0] > 0:\n        for i in range(len(res)):\n            if i == 0:\n                res[i] -= 2\n                cnt += 1\n            elif a[i] > 0:\n                res[i] -= 1\n        res = sorted(res)[::-1]\n    print(cnt)", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = Counter(a)\n    floors = [[False, 1]]\n    for (pr, ch) in cnt.items():\n        floors.append([False, ch])\n    floors.sort(key=lambda x: -x[1])\n    secs = len(floors)\n    jumps = secs\n    for i in range(len(floors)):\n        f = floors[i]\n        f[0] = True\n        f[1] -= jumps\n        if f[1] < 0:\n            f[1] = 0\n        jumps -= 1\n    while True:\n        floors.sort(key=lambda x: -x[1])\n        left = floors[0][1]\n        if left == 0:\n            break\n        for i in range(len(floors)):\n            f = floors[i]\n            if f[0] and f[1] > 0:\n                f[1] -= 1\n        infect = False\n        if not infect:\n            for i in range(len(floors)):\n                f = floors[i]\n                if f[1] > 0:\n                    f[1] -= 1\n                    break\n        secs += 1\n    print(secs)", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = Counter(a)\n    floors = [[False, 1]]\n    for (pr, ch) in cnt.items():\n        floors.append([False, ch])\n    floors.sort(key=lambda x: -x[1])\n    secs = len(floors)\n    jumps = secs\n    for i in range(len(floors)):\n        f = floors[i]\n        f[0] = True\n        f[1] -= jumps\n        if f[1] < 0:\n            f[1] = 0\n        jumps -= 1\n    while True:\n        floors.sort(key=lambda x: -x[1])\n        left = floors[0][1]\n        if left == 0:\n            break\n        for i in range(len(floors)):\n            f = floors[i]\n            if f[0] and f[1] > 0:\n                f[1] -= 1\n        infect = False\n        if not infect:\n            for i in range(len(floors)):\n                f = floors[i]\n                if f[1] > 0:\n                    f[1] -= 1\n                    break\n        secs += 1\n    print(secs)", "from heapq import heappop, heappush\nt = int(input())\nconst = 1 << 18\nfor T in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split(' ')]\n    things = {0: const}\n    for x in range(len(arr)):\n        if arr[x] in things:\n            things[arr[x]] += 1\n        else:\n            things[arr[x]] = const\n    laze = []\n    for x in things:\n        heappush(laze, -things[x])\n    time = 0\n    while len(laze) > 0:\n        f = -laze[0]\n        if f <= time:\n            heappop(laze)\n            continue\n        elif f >= const:\n            f -= const\n            f += time + 1\n            heappop(laze)\n            if f > time:\n                heappush(laze, -f)\n        else:\n            f -= 1\n            heappop(laze)\n            if f > time:\n                heappush(laze, -f)\n        time += 1\n    print(time)", "import heapq\nt = int(input())\nwhile t:\n    input()\n    lst = [int(x) for x in input().split(' ')]\n    n = len(lst) + 1\n    g = []\n    for _ in range(n + 1):\n        g.append([])\n    g[0].append(1)\n    for i in range(len(lst)):\n        g[lst[i]].append(i + 2)\n    heap = []\n    for (i, lst) in enumerate(g):\n        if lst:\n            heap.append((-len(lst), i))\n    heapq.heapify(heap)\n    (res, d) = (0, {})\n    while heap or d:\n        mx = float('-inf')\n        nd = {}\n        for p in d:\n            d[p].pop()\n            if len(d[p]) != 0:\n                nd[p] = d[p]\n                if mx < len(d[p]):\n                    (mx, infect) = (len(d[p]), p)\n        d = nd\n        if heap:\n            p = heapq.heappop(heap)[1]\n            g[p].pop()\n            if g[p]:\n                d[p] = g[p]\n        elif d:\n            d[infect].pop()\n            if len(d[infect]) == 0:\n                del d[infect]\n        res += 1\n    print(res)\n    t -= 1", "def calcula_t():\n    n_vertices = int(input())\n    grau = [0] * n_vertices\n    lista_p = list(map(int, input().split()))\n    for p in lista_p:\n        grau[p - 1] += 1\n    a = [1]\n    for i in range(n_vertices):\n        if grau[i] > 0:\n            a.append(grau[i])\n    a.sort(reverse=True)\n    inicio = len(a)\n    fim = n_vertices\n    tempo = 0\n    while inicio < fim:\n        tempo = (inicio + fim) // 2\n        soma = 0\n        for i in range(len(a)):\n            soma += max(0, a[i] - tempo + i)\n        if soma + len(a) <= tempo:\n            fim = tempo\n        else:\n            inicio = tempo + 1\n    print(fim)\n    pass\nn_testes = int(input())\nfor i in range(n_testes):\n    calcula_t()"]