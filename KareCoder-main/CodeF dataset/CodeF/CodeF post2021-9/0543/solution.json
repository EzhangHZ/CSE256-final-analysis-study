["import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "import sys\nI = sys.stdin.readline\nR = lambda : map(int, I().split())\nfor _ in [0] * int(I()):\n    n = int(I()) + 1\n    p = [0, 0] + [*R()]\n    (l, r, mx, z) = ([0] * n, [0] * n, [0] * n, 0)\n    for i in range(1, n):\n        (l[i], r[i]) = R()\n    for i in range(n - 1, 0, -1):\n        if mx[i] < l[i]:\n            mx[i] = r[i]\n            z += 1\n        mx[p[i]] += min(mx[i], r[i])\n    print(z)", "t = int(input())\nfor _ in range(t):\n    n = int(input()) + 1\n    P = [0, 0] + list(map(int, input().split()))\n    L = [0] * (n + 1)\n    R = [0] * (n + 1)\n    Val = [0] * (n + 1)\n    ans = 0\n    for i in range(1, n):\n        (L[i], R[i]) = map(int, input().split())\n    for i in range(n - 1, 0, -1):\n        if Val[i] < L[i]:\n            Val[i] = R[i]\n            ans += 1\n        Val[P[i]] += min(Val[i], R[i])\n    print(ans)", "import sys\n\ndef solve():\n    n = int(input())\n    p = [0] + list(map(int, input().split()))\n    mm = [0] * n\n    lr = []\n    ans = 0\n    for i in range(n):\n        lr.append(list(map(int, input().split())))\n    for i in range(n - 1, -1, -1):\n        if mm[i] < lr[i][0]:\n            mm[i] = lr[i][1]\n            ans += 1\n        if p[i] != 0:\n            mm[p[i] - 1] += min(mm[i], lr[i][1])\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "import sys\n\ndef solve():\n    n = int(input())\n    p = [0] + list(map(int, input().split()))\n    mm = [0] * n\n    lr = []\n    ans = 0\n    for i in range(n):\n        lr.append(list(map(int, input().split())))\n    for i in range(n - 1, -1, -1):\n        if mm[i] < lr[i][0]:\n            mm[i] = lr[i][1]\n            ans += 1\n        if p[i] != 0:\n            mm[p[i] - 1] += min(mm[i], lr[i][1])\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "def solve_testcase(n, parents, vals):\n    num_children = [0] * n\n    for x in parents:\n        num_children[x - 1] += 1\n    leaves = [i for (i, x) in enumerate(num_children) if x == 0]\n    max_sums = [0 for _ in range(n)]\n    ans = 0\n    while leaves:\n        leaf = leaves.pop()\n        high = max_sums[leaf]\n        (want_low, want_high) = vals[leaf]\n        if leaf == 0:\n            if want_low <= high:\n                return ans\n            return ans + 1\n        my_par = parents[leaf - 1] - 1\n        num_children[my_par] -= 1\n        if num_children[my_par] == 0:\n            leaves.append(my_par)\n        if want_low > high:\n            ans += 1\n            high = want_high\n        high = min(high, want_high)\n        max_sums[my_par] += high\n    return ans\nto_print = []\ntest_count = int(input())\nfor _ in range(test_count):\n    length = int(input())\n    my_pars = list(map(int, input().split()))\n    vals = [tuple(map(int, input().split())) for _ in range(length)]\n    to_print.append(solve_testcase(length, my_pars, vals))\nprint(*to_print, sep='\\n')", "import sys\nsys.setrecursionlimit(2 * 10 ** 6)\n\ndef test():\n    pass\n\ndef main():\n    N = int(input())\n    for _ in range(N):\n        n = int(input())\n        par = list(map(int, input().split()))\n        lrs = []\n        for _ in range(n):\n            (l, r) = map(int, input().split())\n            lrs.append((l, r))\n        chs = [[] for _ in range(n)]\n        for (i, p) in enumerate(par):\n            chs[p - 1].append(i + 1)\n\n        def dfs(i):\n            if chs[i]:\n                ans = 0\n                ms = 0\n                for j in chs[i]:\n                    (c, m) = dfs(j)\n                    ms += m\n                    ans += c\n                if ms < lrs[i][0]:\n                    ans += 1\n                    ms = lrs[i][1]\n                ms = min(ms, lrs[i][1])\n                return (ans, ms)\n            else:\n                return (1, lrs[i][1])\n        print(dfs(0)[0])\n\ndef init():\n    import sys\n    import os\n    if 'CP_LOCAL_ENV' in os.environ:\n        test()\n        sys.stdin = open('test.txt')\ninit()\nmain()", "M = 200000\nG = [[] for _ in range(M)]\nL = [0] * M\nR = [0] * M\n\ndef dfs(cur):\n    cnt = 0\n    m_sum = 0\n    l = L[cur]\n    r = R[cur]\n    for nxt in G[cur]:\n        (c, m) = dfs(nxt)\n        cnt += c\n        m_sum += m\n    if m_sum < l:\n        return (cnt + 1, r)\n    else:\n        return (cnt, min(r, m_sum))\n\ndef solve():\n    N = int(input())\n    for (c, p) in enumerate([int(i) for i in input().split()], 1):\n        p -= 1\n        G[p].append(c)\n    for i in range(N):\n        (l, r) = [int(j) for j in input().split()]\n        L[i] = l\n        R[i] = r\n    (res, m) = dfs(0)\n    for i in range(N):\n        G[i] = []\n        L[i] = R[i] = 0\n    return str(res)\nT = int(input())\nans = [solve() for _ in range(T)]\nprint('\\n'.join(ans))", "T = int(input())\nfor i in range(0, T):\n    n = int(input())\n    p = list(map(int, input().split()))\n    e = [[] for i in range(0, n)]\n    l = [0 for i in range(0, n)]\n    r = [0 for i in range(0, n)]\n    for i in range(1, n):\n        e[p[i - 1] - 1].append(i)\n    for i in range(0, n):\n        (l[i], r[i]) = map(int, input().split())\n    ans = 0\n    mx = [0 for i in range(0, n)]\n    for x in range(n - 1, -1, -1):\n        for y in e[x]:\n            mx[x] += mx[y]\n        if mx[x] >= l[x]:\n            mx[x] = min(mx[x], r[x])\n        else:\n            ans += 1\n            mx[x] = r[x]\n    print(ans)", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        parent = list(map(int, input().split()))\n        graph = [[] for _ in range(n)]\n        for (i, el) in enumerate(parent):\n            graph[el - 1].append(i + 1)\n        arr = []\n        for _ in range(n):\n            arr.append(list(map(int, input().split())))\n        ans = [0]\n\n        def solve(node, par):\n            if graph[node] == 0:\n                ans[0] += 1\n                return arr[node][1]\n            p = arr[node][0]\n            f = False\n            temp = 0\n            for nie in graph[node]:\n                if nie != par:\n                    v = solve(nie, node)\n                    temp += v\n            if temp >= p:\n                f = True\n                return min(arr[node][1], temp)\n            if not f:\n                ans[0] += 1\n            return arr[node][1]\n        solve(0, -1)\n        print(ans[0])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "T = int(input())\nfor i in range(0, T):\n    n = int(input())\n    p = list(map(int, input().split()))\n    e = [[] for i in range(0, n)]\n    l = [0 for i in range(0, n)]\n    r = [0 for i in range(0, n)]\n    for i in range(1, n):\n        e[p[i - 1] - 1].append(i)\n    for i in range(0, n):\n        (l[i], r[i]) = map(int, input().split())\n    ans = 0\n    mx = [0 for i in range(0, n)]\n    for x in range(n - 1, -1, -1):\n        for y in e[x]:\n            mx[x] += mx[y]\n        if mx[x] >= l[x]:\n            mx[x] = min(mx[x], r[x])\n        else:\n            ans += 1\n            mx[x] = r[x]\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    l = [0 for i in range(n)]\n    r = [0 for i in range(n)]\n    for i in range(n):\n        (l[i], r[i]) = map(int, input().split())\n    child = [[] for i in range(n)]\n    for i in range(n - 1):\n        child[arr[i] - 1].append(i + 1)\n    ans = 0\n    val = [0 for i in range(n)]\n    for x in range(n - 1, -1, -1):\n        for y in child[x]:\n            val[x] += val[y]\n        if val[x] >= l[x]:\n            val[x] = min(val[x], r[x])\n        else:\n            ans += 1\n            val[x] = r[x]\n    print(ans)", "input = __import__('sys').stdin.readline\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    parent = [0] * n\n    parent = [-1] + list(map(lambda x: int(x) - 1, input().split()))\n    adj = [[] for _ in range(n)]\n    for u in range(1, n):\n        adj[parent[u]].append(u)\n    order = []\n    stack = [0]\n    while len(stack) > 0:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            stack.append(v)\n    (L, R) = ([-1] * n, [-1] * n)\n    for i in range(n):\n        (L[i], R[i]) = map(int, input().split())\n    ans = 0\n    total = [0] * n\n    for u in order[::-1]:\n        if total[u] < L[u]:\n            ans += 1\n            total[u] = R[u]\n        total[parent[u]] += min(total[u], R[u])\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    l = [0 for i in range(n)]\n    r = [0 for i in range(n)]\n    for i in range(n):\n        (l[i], r[i]) = map(int, input().split())\n    child = [[] for i in range(n)]\n    for i in range(n - 1):\n        child[arr[i] - 1].append(i + 1)\n    ans = 0\n    val = [0 for i in range(n)]\n    for x in range(n - 1, -1, -1):\n        for y in child[x]:\n            val[x] += val[y]\n        if val[x] >= l[x]:\n            val[x] = min(val[x], r[x])\n        else:\n            ans += 1\n            val[x] = r[x]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = list(map(int, input().split(' ')))\n    l = []\n    r = []\n    for _ in range(n):\n        temp = input().split(' ')\n        l.append(int(temp[0]))\n        r.append(int(temp[1]))\n    children = [[] for _ in range(n)]\n    for i in range(n - 1):\n        children[p[i] - 1].append(i + 1)\n    needy = [0 for _ in range(n)]\n\n    def parsevert(i: int):\n        total = 0\n        for i2 in children[i]:\n            total += parsevert(i2)\n        if total > r[i]:\n            total = r[i]\n        if total < l[i]:\n            needy[i] = 1\n            total = r[i]\n        return total\n    parsevert(0)\n    print(sum(needy))", "import sys\nimport io\nimport math\nimport collections\nimport decimal\nimport itertools\nimport bisect\nimport heapq\n\ndef input():\n    return sys.stdin.readline()[:-1]\nsys.setrecursionlimit(1000000)\nINF = 10 ** 10\n\ndef dfs(Parent, Children, L, R, p):\n    if Children[p]:\n        l = 0\n        r = 0\n        n = 0\n        for p1 in Children[p]:\n            (r1, n1) = dfs(Parent, Children, L, R, p1)\n            r += r1\n            n += n1\n        r2 = min(r, R[p])\n        if L[p] <= r2:\n            return (min(r2, R[p]), n)\n        else:\n            return (R[p], n + 1)\n    else:\n        return (R[p], 1)\n\ndef solve(N, Parent, Children, L, R):\n    (r, n) = dfs(Parent, Children, L, R, 0)\n    return n\nT0 = int(input())\nfor _ in range(T0):\n    N = int(input())\n    Parent = [-1] * N\n    Children = [list() for _ in range(N)]\n    P = list(map(int, input().split()))\n    for i in range(N - 1):\n        Parent[i + 1] = P[i] - 1\n        Children[P[i] - 1].append(i + 1)\n    (L, R) = ([], [])\n    for _ in range(N):\n        (l, r) = map(int, input().split())\n        L.append(l)\n        R.append(r)\n    print(solve(N, Parent, Children, L, R))", "from collections import deque\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    l = [int(x) - 1 for x in input().split()]\n    rng = []\n    for i in range(n):\n        rng.append([int(x) for x in input().split()])\n    deg = [0] * n\n    for (i, x) in enumerate(l):\n        deg[x] += 1\n    val = [0] * n\n    q = deque()\n    ans = 0\n    for i in range(n):\n        if deg[i] == 0:\n            ans += 1\n            q.append(i)\n            val[i] = rng[i][1]\n    while q:\n        x = q.pop()\n        px = l[x - 1]\n        deg[px] -= 1\n        val[px] += val[x]\n        if deg[px] == 0:\n            q.append(px)\n            if val[px] < rng[px][0]:\n                val[px] = rng[px][1]\n                ans += 1\n            elif val[px] > rng[px][1]:\n                val[px] = rng[px][1]\n    print(ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nif 'pypyjit' in sys.builtin_module_names:\n    import pypyjit\n    pypyjit.set_param('max_unroll_recursion=-1')\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    P = list(map(int, input().split()))\n    LR = [list(map(int, input().split())) for _ in range(N)]\n    child = [[] for _ in range(N)]\n    for (i, p) in enumerate(P):\n        p -= 1\n        child[p].append(i + 1)\n\n    def dfs(pos=0):\n        (l0, r0) = LR[pos]\n        cnt = 0\n        (l, r) = (0, 0)\n        for c in child[pos]:\n            (l1, r1, cnt1) = dfs(c)\n            l += l1\n            r += r1\n            cnt += cnt1\n        if l0 > r:\n            cnt += 1\n            r = r0\n            l = l0\n        else:\n            r = min(r0, r)\n            l = max(l, l0)\n        return (l, r, cnt)\n    (_, _, ans) = dfs()\n    print(ans)", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        dit = {}\n        for i in range(n - 1):\n            if arr[i] in dit:\n                dit[arr[i]].append(i + 2)\n            else:\n                dit[arr[i]] = [i + 2]\n        req = {}\n        for i in range(n):\n            req[i + 1] = list(map(int, input().split()))\n        global ans\n        ans = 0\n\n        def fun(p):\n            global ans\n            if p not in dit:\n                ans += 1\n                return req[p][1]\n            maxx = 0\n            for e in dit[p]:\n                maxx += fun(e)\n            if maxx >= req[p][0]:\n                return min(maxx, req[p][1])\n            else:\n                ans += 1\n                return req[p][1]\n        fun(1)\n        print(ans)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from os import error\nimport sys\ninput = sys.stdin.readline\nDEBUG = False\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef solve():\n    n = inp()\n    tree = []\n    for i in range(n + 1):\n        tree.append({'v': (0, 0), 'child': []})\n    parents = inlt()\n    for (i, p) in enumerate(parents):\n        v = i + 1\n        p = p - 1\n        tree[p]['child'].append(v)\n    for i in range(n):\n        (l, v) = inlt()\n        tree[i]['v'] = (l, v)\n\n    def down(i):\n        (l, v) = tree[i]['v']\n        if len(tree[i]['child']) == 0:\n            if l <= 0 and v >= 0:\n                return (None, None)\n            else:\n                return (1, v)\n        required = 0\n        collected = 0\n        chlds = tree[i]['child']\n        for c in chlds:\n            (rs, cv) = down(c)\n            if cv is not None:\n                collected += cv\n                required += rs\n        if collected < l:\n            required += 1\n            collected = v\n        elif collected > v:\n            collected = v\n        return (required, collected)\n    (rs, _) = down(0)\n    return rs\nn = inp()\nfor t in range(n):\n    ans = solve()\n    print(ans)", "import queue\nfrom sys import stdin\n\nclass Node:\n\n    def __init__(self):\n        self.parent = None\n        self.l = 0\n        self.r = 0\n        self.val = 0\n        self.indeg = 0\n\n    def __repr__(self) -> str:\n        return f'{self.l} {self.r}'\n\ndef merge(curr, res):\n    while curr and curr.indeg == 0:\n        carry = 0\n        if curr.val >= curr.l:\n            carry = min(curr.val, curr.r)\n        else:\n            carry = curr.r\n            res[0] += 1\n        if curr.parent:\n            curr.parent.val += carry\n            curr.parent.indeg -= 1\n        curr = curr.parent\n\ndef solve():\n    n = int(stdin.readline())\n    nodes = [Node() for i in range(n)]\n    leaves = set(range(1, n))\n    parents = list(map(int, stdin.readline().split()))\n    for i in range(1, n):\n        nodes[i].parent = nodes[parents[i - 1] - 1]\n        nodes[parents[i - 1] - 1].indeg += 1\n        leaves.discard(parents[i - 1] - 1)\n    for i in range(n):\n        curr = nodes[i]\n        (l, r) = map(int, stdin.readline().split())\n        curr.l = l\n        curr.r = r\n    res = [0]\n    for leaf in leaves:\n        merge(nodes[leaf], res)\n    print(res[0])\nfor _ in range(int(stdin.readline())):\n    solve()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(200000 + 3)\n\ndef f(n):\n    arr = []\n    s1 = s2 = 0\n    for i in graph[n]:\n        arr.append(i)\n        line = f(i)\n        (a, b) = (line[0], line[1])\n        s1 += a\n        s2 += b\n    if len(arr) == 0:\n        return [1, r[n][1]]\n    elif s2 >= r[n][0]:\n        return [s1, min(r[n][1], s2)]\n    else:\n        return [s1 + 1, r[n][1]]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    graph = [[] for i in range(n + 1)]\n    road = list(map(int, input().split()))\n    for i in range(n - 1):\n        graph[road[i]].append(i + 2)\n    r = [[0, 0] for i in range(n + 1)]\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        (r[i + 1][0], r[i + 1][1]) = (a, b)\n    line = f(1)\n    print(line[0])"]