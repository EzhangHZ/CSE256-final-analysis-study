["def get(good):\n    n = int(input())\n    ans = 10000.0\n    for x in good:\n        if n >= x[0]:\n            rem = n - x[0]\n            ans = min(ans, x[1] + bin(rem).count('1'))\n    print(ans)\ngood = [(0, 0)]\nfact = []\nc = 2\nfor i in range(3, 15):\n    c *= i\n    fact.append(c)\nfor f in fact:\n    good_no = []\n    for num in good:\n        good_no.append((num[0] + f, num[1] + 1))\n    good.extend(good_no)\nfor _ in range(int(input())):\n    get(good)", "from math import factorial\nfrom itertools import combinations\nfacts = []\nfor i in range(3, 15):\n    facts.append(factorial(i))\ncombs = []\nfor i in range(15):\n    for k in combinations(facts, i):\n        combs.append([len(k), sum(k)])\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    res = []\n    for (cnt, num) in combs:\n        left = x - num\n        if left >= 0:\n            b = bin(left)\n            res.append(cnt + b.count('1'))\n    print(min(res))", "from math import factorial\nfrom itertools import combinations\nfacts = []\nfor i in range(3, 15):\n    facts.append(factorial(i))\ncombs = []\nfor i in range(15):\n    for j in combinations(facts, i):\n        combs.append([len(j), sum(j)])\ntc = int(input())\nfor j in range(tc):\n    x = int(input())\n    list3 = []\n    for (i, k) in combs:\n        if x - k >= 0:\n            b = bin(x - k)\n            list3.append(i + b.count('1'))\n    print(min(list3))", "lm = int(1000000000000.0)\nf = [1]\nfor i in range(2, 17):\n    if f[-1] * i < lm:\n        f.append(f[-1] * i)\nd = []\n\ndef t(i, nb, s):\n    if i == 12:\n        if s < lm and bin(s).count('1') - nb > 0:\n            d.append([s, nb])\n    else:\n        t(i + 1, nb, s)\n        t(i + 1, nb + 1, s + f[i])\nf = f[2:]\nt(0, 0, 0)\nd = sorted(d, key=lambda x: x[0])\nfor _ in range(int(input())):\n    n = int(input())\n    ans = bin(n).count('1')\n    for e in d:\n        if e[0] <= n:\n            ans = min(ans, e[1] + bin(n - e[0]).count('1'))\n        else:\n            break\n    print(ans)", "from math import factorial\nfrom itertools import combinations\nfacts = []\nfor i in range(3, 15):\n    facts.append(factorial(i))\ncombs = []\nfor i in range(15):\n    for j in combinations(facts, i):\n        combs.append([len(j), sum(j)])\ntc = int(input())\nfor _ in range(tc):\n    x = int(input())\n    res = []\n    for (i, k) in combs:\n        if x - k >= 0:\n            b = bin(x - k)\n            res.append(i + b.count('1'))\n    print(min(res))", "from itertools import combinations\nfrom math import factorial\nfacs = [factorial(x) for x in range(3, 15)]\nfor _ in range(int(input())):\n    n = int(input())\n    ans = 40\n    for x in range(12):\n        for comb in combinations(facs, x):\n            now = sum(comb)\n            if now <= n:\n                temp = n - now\n                co = x + bin(temp).count('1')\n                if co < ans:\n                    ans = co\n    print(ans)", "from collections import deque\npowerful = [1]\nfor i in range(2, 16):\n    powerful.append(i * powerful[-1])\npowerful.append(4)\nfor i in range(3, 41):\n    powerful.append(2 * powerful[-1])\npowerful.sort(reverse=True)\nfor tcase in range(int(input())):\n    q = deque()\n    (n, k, i) = (int(input()), 0, 0)\n    while n > 0:\n        while i < len(powerful) and powerful[i] > n:\n            i += 1\n        while i < len(powerful) and n - powerful[i] < 2 * powerful[i]:\n            q.append((n - powerful[i], k + 1, i + 1))\n            i += 1\n        (n, k, i) = q.popleft()\n    print(k)", "from collections import deque\npowerful = [1]\nfor i in range(2, 16):\n    powerful.append(i * powerful[-1])\npowerful.append(4)\nfor i in range(3, 41):\n    powerful.append(2 * powerful[-1])\npowerful.sort(reverse=True)\nfor tcase in range(int(input())):\n    q = deque()\n    (n, k, i) = (int(input()), 0, 0)\n    while n > 0:\n        while i < len(powerful) and powerful[i] > n:\n            i += 1\n        while i < len(powerful) and n - powerful[i] < 2 * powerful[i]:\n            q.append((n - powerful[i], k + 1, i + 1))\n            i += 1\n        (n, k, i) = q.popleft()\n    print(k)", "from math import factorial\nfact_sum = {}\n\ndef solve(n):\n    ans = 10 ** 12\n    for (k, v) in fact_sum.items():\n        if n >= v:\n            ans = min(ans, bin(k).count('1') + bin(n - v).count('1'))\n    print(ans)\n\ndef precalcualte():\n    FACT = 14\n    factorials = []\n    f = 1\n    for n in range(1, FACT + 1):\n        f *= n\n        if f >= 2:\n            factorials.append(f)\n    for i in range(1 << len(factorials)):\n        s = 0\n        for j in range(len(factorials)):\n            if i & 1 << j:\n                s += factorials[j]\n        fact_sum[i] = s\nprecalcualte()\nt = input().strip()\nfor i in range(int(t)):\n    n = input().strip()\n    solve(int(n))", "from math import factorial\nfact_sum = {}\n\ndef solve(n):\n    ans = 10 ** 12\n    for (k, v) in fact_sum.items():\n        if n >= v:\n            if n == v:\n                ans = min(ans, bin(k).count('1'))\n            else:\n                ans = min(ans, bin(k).count('1') + bin(n - v).count('1'))\n    print(ans)\n\ndef precalcualte():\n    FACT = 14\n    factorials = []\n    f = 1\n    for n in range(1, FACT + 1):\n        f *= n\n        if f >= 2:\n            factorials.append(f)\n    for i in range(1 << len(factorials)):\n        s = 0\n        for j in range(len(factorials)):\n            if i & 1 << j:\n                s += factorials[j]\n        fact_sum[i] = s\nprecalcualte()\nt = input().strip()\nfor i in range(int(t)):\n    n = input().strip()\n    solve(int(n))", "import math\nimport itertools\nfacts = []\nfor i in range(3, 16):\n    facts.append(math.factorial(i))\ncombs = []\nfor i in range(16):\n    c = list(itertools.combinations(facts, i))\n    for k in c:\n        combs.append(k)\nsums = []\nfor i in range(len(combs)):\n    sums.append([sum(combs[i]), len(combs[i])])\nt = int(input())\nfor i in range(t):\n    itchislo = 0\n    minsum = 1000000000000000\n    sum1 = 0\n    n = int(input())\n    j = 0\n    while j < len(sums):\n        if n - sums[j][0] < 0:\n            j += 1\n            continue\n        else:\n            sum1 = 0\n            itchislo = n - sums[j][0]\n            itchislo = bin(itchislo)\n            itchislo = itchislo[2:]\n            sum1 += itchislo.count('1')\n            sum1 += sums[j][1]\n            if minsum > sum1:\n                minsum = sum1\n        j += 1\n    print(minsum)", "from math import factorial\nfrom itertools import combinations\nfrom sys import stdin\ninput = stdin.readline\n\ndef main():\n    fact = [factorial(i) for i in range(1, 16)]\n    combi = []\n    for i in range(0, 16):\n        for element in combinations(fact, i):\n            combi.append([len(element), sum(element)])\n    for _ in range(int(input())):\n        n = int(input())\n        total_terms = []\n        for (a, b) in combi:\n            remain = n - b\n            if remain >= 0:\n                no_1 = bin(remain).count('1')\n                total_terms.append(a + no_1)\n        print(min(total_terms))\nmain()", "from itertools import combinations\n\ndef bit_count(value: int) -> int:\n    return f'{value:b}'.count('1')\nfactorial = [1]\nfor _ in range(int(input())):\n    n = int(input())\n    while factorial[-1] <= n:\n        factorial.append(factorial[-1] * len(factorial))\n    factorial.pop()\n    result = float('inf')\n    for i in range(len(factorial) - 2):\n        for combination in combinations(factorial[2:], i):\n            if '1' in combination or '2' in combination:\n                continue\n            value = n - sum(combination)\n            if value < 0:\n                continue\n            result = min(result, i + bit_count(value))\n    if result == float('inf'):\n        result = 1\n    print(result)", "def count(n, id):\n    if n == 0:\n        return 0\n    min_ = bin(n).count('1')\n    i = 0\n    while f[i] <= n and i < id:\n        min_ = min(min_, count(n - f[i], i) + 1)\n        i += 1\n    return min_\nf = [1]\ni = 2\nwhile f[-1] < 10 ** 12:\n    f.append(f[-1] * i)\n    i += 1\nfor t in range(int(input())):\n    print(count(int(input()), 20))", "def factorials(n):\n    factorials_list = []\n    prod = 6\n    i = 4\n    while prod <= n:\n        factorials_list.append(prod)\n        prod *= i\n        i += 1\n    return factorials_list\n\ndef count(a):\n    ans = 9223372036854775807\n    for mask in range(1 << len(a)):\n        s = n\n        for i in range(len(a)):\n            s -= [0, a[i]][mask & 1 << i != 0]\n        if s < 0:\n            continue\n        ans = min(bin(mask).count('1') + bin(s).count('1'), ans)\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    a = factorials(n)\n    print(count(a))", "from math import *\nfrom itertools import *\nfact = [factorial(i) for i in range(15)]\ncomb = [(i, sum(s)) for i in range(15) for s in combinations(fact, i)]\nfor i in range(int(input())):\n    num = int(input())\n    print(min((i + bin(num - j).count('1') for (i, j) in comb if j <= num)))", "fact = [1] * 15\nsubs = []\nfor i in range(1, 15):\n    fact[i] = fact[i - 1] * (i + 1)\nfor i in range(1 << 15):\n    (sub, s) = (0, 0)\n    for j in range(15):\n        if i & 1 << j:\n            sub += 1\n            s += fact[j]\n    subs.append((sub, s))\nfor _ in range(int(input())):\n    n = int(input())\n    ans = bin(n).count('1')\n    for i in subs:\n        if i[1] <= n:\n            ans = min(ans, i[0] + bin(n - i[1]).count('1'))\n    print(ans)", "from math import *\nfrom itertools import *\nfact = [factorial(i) for i in range(15)]\ncomb = [(i, sum(s)) for i in range(15) for s in combinations(fact, i)]\nfor i in range(int(input())):\n    num = int(input())\n    if num in fact or int(log2(num)) == log2(num):\n        print(1)\n    else:\n        print(min((i + bin(num - j).count('1') for (i, j) in comb if j <= num)))", "from itertools import *\na = (1,)\nr = range(14)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))\nlst = []", "a = []\np = 1\nfor i in range(1, 15):\n    p *= i\n    if bin(p).count('1') > 1:\n        a.append(p)\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    ans = 10000000000\n    if n & n - 1 == 0 or n in a:\n        print(1)\n        continue\n    for i in range(1 << 12):\n        s = 0\n        for j in range(12):\n            if i & 1 << j:\n                s += a[j]\n        if s > n:\n            break\n        ans = min(ans, bin(i).count('1') + bin(n - s).count('1'))\n    print(ans)", "from itertools import *\na = (1,)\nr = range(14)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "from itertools import *\na = (1,)\nr = range(14)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "from itertools import *\na = (1,)\nb = []\nr = range(14)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "from collections import *\nfact = [1]\npower = [1]\nfor i in range(1, 20):\n    fact.append(fact[-1] * i)\n    power.append(power[-1] * 2)\n\ndef count_bit(num):\n    return str(bin(num)).count('1')\nd = defaultdict(lambda : -1)\n\ndef f(i, target):\n    if target == 0:\n        return 0\n    if target < 0 or i > 15:\n        return float('inf')\n    if d[i, target] != -1:\n        return d[i, target]\n    d[i, target] = min(1 + f(i + 1, target - fact[i]), f(i + 1, target), count_bit(target))\n    return d[i, target]\nfor _ in range(int(input())):\n    n = int(input())\n    print(f(3, n))", "from itertools import *\na = (1,)\nr = range(14)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "from itertools import *\na = (1,)\nr = range(14)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "a = []\np = 1\nfor i in range(1, 15):\n    p *= i\n    if bin(p).count('1') > 1:\n        a.append(p)\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    ans = 10000000000\n    if n & n - 1 == 0 or n in a:\n        print(1)\n        continue\n    for i in range(1 << 12):\n        s = 0\n        for j in range(12):\n            if i & 1 << j:\n                s += a[j]\n        if s > n:\n            break\n        ans = min(ans, bin(i).count('1') + bin(n - s).count('1'))\n    print(ans)", "from math import *\nfrom itertools import combinations\nfact = [factorial(x) for x in range(15)]\ncomb = [(i, sum(x)) for i in range(15) for x in combinations(fact, i)]\nfor t in range(int(input())):\n    n = int(input())\n    print(min((i + bin(n - x).count('1') for (i, x) in comb if x <= n)))", "(k, idx) = (2, 3)\nfact = []\nwhile k <= 1000000000000.0:\n    k *= idx\n    fact.append(k)\n    idx += 1\n\ndef fac(x):\n    for i in range(len(fact)):\n        if fact[i] > x:\n            return i\nfor _ in range(int(input())):\n    n = int(input())\n    i = fac(n)\n    ans = min(1000000000000000.0, bin(n).count('1'))\n    for j in range(1 << i):\n        s = 0\n        a1 = 0\n        for k in range(i):\n            if 1 << k & j:\n                s += fact[k]\n                a1 += 1\n        dif = n - s\n        if dif >= 0:\n            ans = min(ans, a1 + bin(dif).count('1'))\n    print(ans)", "import math\na = [6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200]\nfor t in range(int(input())):\n    n = int(input())\n    res = bin(n).count('1')\n    if math.log(n, 2) == int(math.log(n, 2)) or n in a:\n        print(1)\n        continue\n    for i in range(1, 4096):\n        s = 0\n        for j in range(12):\n            if i & 1 << j:\n                s += a[j]\n        if s > n:\n            break\n        res = min(res, bin(i).count('1') + bin(n - s).count('1'))\n    print(res)", "from itertools import combinations\nfrom sys import stdin\ninput = stdin.readline\nl = []\na = 1\nfor i in range(1, 15):\n    a *= i\n    l.append(a)\nfor _ in range(int(input())):\n    n = int(input())\n    r = 100\n    for i in range(15):\n        for j in combinations(l, i):\n            s = n - sum(j)\n            if s >= 0:\n                r = min(r, i + bin(s).count('1'))\n    print(r)", "from math import factorial\n\ndef bit_count(x):\n    return bin(x).count('1')\n\ndef solve_task(n, ps):\n    min_term_count = bit_count(n)\n    for i in range(len(ps)):\n        if ps[i] > n:\n            continue\n        min_term_count = min(min_term_count, 1 + solve_task(n - ps[i], ps[i + 1:]))\n    return min_term_count\npowers = [factorial(x) for x in range(1, 15)]\npowers.reverse()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(solve_task(n, [p for p in powers if p <= n]))", "from itertools import *\na = (1,)\nb = []\nr = range(15)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "from itertools import *\na = (1,)\nb = []\nr = range(15)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "from itertools import *\na = (1,)\nb = []\nr = range(15)\nfor i in r:\n    a += (a[-1] * (i + 1),)\nb = [(i, sum(c)) for i in r for c in combinations(a, i)]\nfor n in [*map(int, open(0))][1:]:\n    print(min((m + bin(n - s).count('1') for (m, s) in b if s <= n)))", "import itertools, sys\ninput = sys.stdin.readline\nfactorials = [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200]\npowers = [4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888]\nfor i in range(int(input())):\n    num = int(input())\n    minn = bin(num).count('1')\n    if num in powers:\n        print(1)\n    else:\n        list1 = []\n        for i in range(1, 15):\n            list1.append(list(itertools.combinations(factorials, i)))\n        for i in list1:\n            for j in i:\n                imp = num - sum(j)\n                if imp == 0:\n                    output = len(j)\n                    if output < minn:\n                        minn = output\n                elif imp > 0:\n                    s = bin(imp)[2:]\n                    output = len(j) + s.count('1')\n                    if output < minn:\n                        minn = output\n        print(minn)", "import sys\nsys.setrecursionlimit(10000)\ninput = sys.stdin.readline\nfacs = []\n\ndef fac(n):\n    if n <= 1:\n        return 1\n    else:\n        return n * fac(n - 1)\nfor i in range(14):\n    facs.append(fac(i + 1))\n\ndef answer(n, leftfacs):\n    if n == 0:\n        return 0\n    default = bin(n).count('1')\n    aux = [default]\n    for i in range(len(leftfacs)):\n        if leftfacs[i] > n:\n            break\n        newleftfacs = leftfacs[i + 1:]\n        aux.append(answer(n - leftfacs[i], newleftfacs) + 1)\n    return min(aux)\nfor _ in range(int(input())):\n    n = int(input())\n    print(answer(n, facs))", "import itertools, sys\ninput = sys.stdin.readline\nfactorials = [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200]\npowers = [4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888]\nfor i in range(int(input())):\n    num = int(input())\n    minn = bin(num).count('1')\n    if num in powers:\n        print(1)\n    else:\n        list1 = []\n        for i in range(1, 15):\n            list1.append(list(itertools.combinations(factorials, i)))\n        for i in list1:\n            for j in i:\n                imp = num - sum(j)\n                if imp == 0:\n                    output = len(j)\n                    if output < minn:\n                        minn = output\n                elif imp > 0:\n                    s = bin(imp)[2:]\n                    output = len(j) + s.count('1')\n                    if output < minn:\n                        minn = output\n        print(minn)", "from math import *\nfac = [1]\nfor i in range(2, 16):\n    fac.append(fac[-1] * i)\nmask = []\nfor i in range(int(pow(2, len(fac)))):\n    su = 0\n    lne = 0\n    for j in range(len(fac)):\n        if i & 1 << j:\n            su += fac[j]\n            lne += 1\n    mask.append((su, lne))\nfor i in range(int(input())):\n    n = int(input())\n    ans = 12345679\n    for (a, b) in mask:\n        if n - a >= 0:\n            ans = min(ans, bin(n - a)[2:].count('1') + b)\n    print(ans)", "def fact(n):\n    p = 1\n    for j in range(1, n + 1):\n        p = p * j\n    return p\nlst2 = []\nlstfac = []\nfor k in range(1, 16):\n    lstfac.append(fact(k))\n\nclass py_solution:\n\n    def sub_sets(self, sset):\n        return self.subsetsRecur([], sorted(sset))\n\n    def subsetsRecur(self, current, sset):\n        if sset:\n            return self.subsetsRecur(current, sset[1:]) + self.subsetsRecur(current + [sset[0]], sset[1:])\n        return [current]\nlst1 = py_solution().sub_sets(lstfac)\nlst2 = []\nfor h in lst1:\n    lst2.append((sum(h), len(h)))\n\ndef decimalToBinary(n):\n    return bin(n).replace('0b', '')\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    lstf = []\n    for f in lst2:\n        dif = n - f[0]\n        if dif >= 0:\n            s = decimalToBinary(dif)\n            c = s.count('1')\n            lstf.append(c + f[1])\n    print(min(lstf))", "n = [0]\np = 1\nfor x in range(2, 16):\n    n.append(p)\n    p *= x\nj = {}\nfor y in range(1, 2 ** 15):\n    l = format(y, '015b')\n    s = 0\n    ll = 0\n    for z in range(14, -1, -1):\n        if l[z] == '1':\n            s += n[14 - z]\n            ll += 1\n    j[s] = ll\na = int(input())\nfor x in range(a):\n    b = int(input())\n    t = {}\n    ans = 999999999999999999\n    for y in j:\n        if y <= b:\n            t[format(b - y, '050b')] = j[y]\n    for y in t:\n        ans = min(ans, y.count('1') + t[y] - 1)\n    print(ans)", "test = int(input())\nfactorial = []\nsubsets = [[]]\nfact = 1\nfor i in range(1, 15):\n    fact *= i\n    factorial.append(fact)\nfor i in factorial:\n    l = len(subsets)\n    for j in range(l):\n        k = subsets[j].copy()\n        k.append(i)\n        subsets.append(k)\nwhile test:\n    n = int(input())\n    ans = float('inf')\n    for i in subsets:\n        s = sum(i)\n        if s > n:\n            continue\n        ct = len(i)\n        b = bin(n - s)\n        if 1 in i and b[-1] == '1':\n            continue\n        elif 2 in i and b[-2] == '1':\n            continue\n        else:\n            ct += b.count('1')\n        ans = min(ans, ct)\n    print(ans)\n    test -= 1", "import bisect\nt = int(input())\na = [0 for i in range(16)]\na[0] = 1\nfor i in range(1, 16):\n    a[i] = i * a[i - 1]\ns = []\nfor i in range(2 ** 12):\n    s.append(format(i, '#010b')[2:])\nss = []\nfor c in s:\n    sum = 0\n    times = 0\n    c = c[::-1]\n    for i in range(0, len(c)):\n        if c[i] == '1':\n            sum += a[i + 3]\n            times += 1\n    ss.append((sum, times))\n\ndef countSetBits(num):\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    N = n\n    mn = 66\n    for (x, y) in ss:\n        if n >= x:\n            mn = min(mn, countSetBits(n - x) + y)\n    if mn == 66:\n        print(-1)\n    else:\n        print(mn)", "import math\n\ndef fun(x, lst, n):\n    if x - lst[n] < 0:\n        return bin(x).count('1')\n    else:\n        return min(fun(x - lst[n], lst, n + 1) + 1, fun(x, lst, n + 1), bin(x).count('1'))\nnum = []\nk = []\nnum1 = sorted(list({math.factorial(i) for i in range(1, 16)}))\nN = int(input())\nfor i in range(N):\n    num.append(int(input()))\nfor i in num:\n    if bin(i).count('1') == 1 or i in num1 == 1:\n        k.append(1)\n    else:\n        k.append(fun(i, num1, 0))\nfor i in k:\n    print(i)", "import math\n\ndef fun(x, lst, n):\n    if x - lst[n] < 0:\n        return bin(x).count('1')\n    else:\n        return min(fun(x - lst[n], lst, n + 1) + 1, fun(x, lst, n + 1), bin(x).count('1'))\nnum = []\nk = []\nnum1 = sorted(list({math.factorial(i) for i in range(1, 16)}))\nN = int(input())\nfor i in range(N):\n    num.append(int(input()))\nfor i in num:\n    if bin(i).count('1') == 1 or i in num1 == 1:\n        k.append(1)\n    else:\n        k.append(fun(i, num1, 0))\nfor i in k:\n    print(i)", "from math import *\nfrom itertools import combinations\nfact = []\nfor i in range(15):\n    fact.append(factorial(i))\ncomb = []\nfor i in range(15):\n    for x in combinations(fact, i):\n        comb.append([i, sum(x)])\nfor t in range(int(input())):\n    n = int(input())\n    s = []\n    for (x, y) in comb:\n        if y <= n:\n            e = x + bin(n - y).count('1')\n            s.append(e)\n    print(min(s))", "import math\n\ndef comb(A):\n    if len(A) == 1:\n        return [[A[-1]], []]\n    return [c + [A[-1]] for c in comb(A[:-1])] + comb(A[:-1])\n\ndef calc(A):\n    count = 0\n    while A:\n        if A & 1 == 1:\n            count += 1\n        A = A >> 1\n    return count\nfact = [i for i in range(3, 15)]\ncombs = comb(fact)\ncombs = combs[::-1]\nfact_sum = dict()\nfor (i, com) in enumerate(combs):\n    summ = sum([math.factorial(c) for c in com])\n    fact_sum[i] = summ\n\ndef sol(n):\n    ans = 2 ** 31\n    for (i, com) in enumerate(combs):\n        summ = fact_sum[i]\n        if n < summ:\n            break\n        ans = min(ans, len(com) + calc(n - summ))\n    return ans if ans != 2 ** 31 else -1\nx = int(input())\nfor _ in range(x):\n    n = int(input())\n    print(sol(n))", "import math\n\ndef comb(A):\n    if len(A) == 1:\n        return [[A[-1]], []]\n    return [c + [A[-1]] for c in comb(A[:-1])] + comb(A[:-1])\n\ndef calc(A):\n    count = 0\n    while A:\n        if A & 1 == 1:\n            count += 1\n        A = A >> 1\n    return count\nfact = [i for i in range(3, 15)]\ncombs = comb(fact)\ncombs = combs[::-1]\nfact_sum = dict()\nfor (i, com) in enumerate(combs):\n    summ = sum([math.factorial(c) for c in com])\n    fact_sum[i] = summ\n\ndef sol(n):\n    ans = 2 ** 31\n    for (i, com) in enumerate(combs):\n        summ = fact_sum[i]\n        if n < summ:\n            continue\n        ans = min(ans, len(com) + calc(n - summ))\n    return ans if ans != 2 ** 31 else -1\nx = int(input())\nfor _ in range(x):\n    n = int(input())\n    print(sol(n))", "import math\n\ndef comb(A):\n    if len(A) == 1:\n        return [[A[-1]], []]\n    return [c + [A[-1]] for c in comb(A[:-1])] + comb(A[:-1])\n\ndef calc(A):\n    count = 0\n    while A:\n        if A & 1 == 1:\n            count += 1\n        A = A >> 1\n    return count\nfact = [i for i in range(3, 15)]\ncombs = comb(fact)\ncombs = combs[::-1]\nfact_sum = dict()\nfor (i, com) in enumerate(combs):\n    summ = sum([math.factorial(c) for c in com])\n    fact_sum[i] = summ\n\ndef sol(n):\n    ans = 2 ** 31\n    for (i, com) in enumerate(combs):\n        summ = fact_sum[i]\n        if n < summ:\n            break\n        ans = min(ans, len(com) + calc(n - summ))\n    return ans if ans != 2 ** 31 else -1\nx = int(input())\nfor _ in range(x):\n    n = int(input())\n    print(sol(n))", "import math\n\ndef comb(A):\n    if len(A) == 1:\n        return [[A[-1]], []]\n    return [c + [A[-1]] for c in comb(A[:-1])] + comb(A[:-1])\n\ndef calc(A):\n    count = 0\n    while A:\n        if A & 1 == 1:\n            count += 1\n        A = A >> 1\n    return count\nfact = [i for i in range(3, 15)]\ncombs = comb(fact)\ncombs = combs[::-1]\nfact_sum = dict()\nfor (i, com) in enumerate(combs):\n    summ = sum([math.factorial(c) for c in com])\n    fact_sum[i] = summ\n\ndef sol(n):\n    ans = 2 ** 31\n    for (i, com) in enumerate(combs):\n        summ = fact_sum[i]\n        if n < summ:\n            break\n        ans = min(ans, len(com) + calc(n - summ))\n    return ans if ans != 2 ** 31 else -1\nx = int(input())\nfor _ in range(x):\n    n = int(input())\n    print(sol(n))", "def main_tc(good_numbers):\n    n = int(input())\n    answer = 10000\n    for good_number in good_numbers:\n        if n >= good_number[0]:\n            remaining = n - good_number[0]\n            answer = min(answer, good_number[1] + get_bit_count(remaining))\n    print(answer)\n\ndef get_bit_count(n):\n    answer = 0\n    while n > 0:\n        answer += n & 1\n        n >>= 1\n    return answer\n\ndef main():\n    tc = int(input())\n    good_numbers = [(0, 0)]\n    factorials = []\n    cur = 2\n    for i in range(3, 15):\n        cur *= i\n        factorials.append(cur)\n    for f in factorials:\n        extension_good_numbers = []\n        for number in good_numbers:\n            extension_good_numbers.append((number[0] + f, number[1] + 1))\n        good_numbers.extend(extension_good_numbers)\n    for _ in range(tc):\n        main_tc(good_numbers)\nmain()", "import math\n\ndef comb(A):\n    if len(A) == 1:\n        return [[A[-1]], []]\n    return [c + [A[-1]] for c in comb(A[:-1])] + comb(A[:-1])\n\ndef calc(A):\n    count = 0\n    while A:\n        if A & 1 == 1:\n            count += 1\n        A = A >> 1\n    return count\nfact = [i for i in range(3, 15)]\ncombs = comb(fact)\ncombs = combs[::-1]\nfact_sum = dict()\nfor (i, com) in enumerate(combs):\n    summ = sum([math.factorial(c) for c in com])\n    fact_sum[i] = summ\n\ndef sol(n):\n    ans = 2 ** 31\n    for (i, com) in enumerate(combs):\n        summ = fact_sum[i]\n        if n < summ:\n            break\n        ans = min(ans, len(com) + calc(n - summ))\n    return ans if ans != 2 ** 31 else -1\nx = int(input())\nfor _ in range(x):\n    n = int(input())\n    print(sol(n))", "from math import factorial\nfrom itertools import combinations\nfacts = []\nfor i in range(15):\n    facts.append(factorial(i))\ncombs = []\nfor i in range(15):\n    for j in combinations(facts, i):\n        combs.append([len(j), sum(j)])\ntc = int(input())\nfor j in range(tc):\n    x = int(input())\n    list3 = []\n    for (i, k) in combs:\n        if x - k >= 0:\n            b = bin(x - k)\n            list3.append(i + b.count('1'))\n    print(min(list3))", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\ndef solution(n: int) -> int:\n    INF = 53\n\n    def backtrack(pos, cnt, cur_sum):\n        if cur_sum == n:\n            return cnt\n        elif cur_sum > n:\n            return INF\n        elif suffix_sum[pos] < n - cur_sum:\n            return INF\n        if pos == len(num_list):\n            return INF\n        return min(backtrack(pos + 1, cnt + 1, cur_sum + num_list[pos]), backtrack(pos + 1, cnt, cur_sum))\n    power_nums = set()\n    num = 2\n    while num <= n:\n        power_nums.add(num)\n        num *= 2\n    num = 1\n    i = 2\n    while num <= n:\n        power_nums.add(num)\n        num *= i\n        i += 1\n    num_list = sorted(list(power_nums))\n    suffix_sum = [0]\n    for num in num_list:\n        suffix_sum.append(suffix_sum[-1] + num)\n    suffix_sum.reverse()\n    num_list.reverse()\n    min_k = backtrack(0, 0, 0)\n    if min_k == INF:\n        return -1\n    else:\n        return min_k\n\ndef main():\n    t = int(input())\n    for tc in range(t):\n        n = int(input())\n        print(solution(n))\nmain()", "from math import factorial\nfrom sys import stdin\nfrom itertools import combinations\nlist2 = []\nfor i in range(15):\n    list2.append(factorial(i))\nlist1 = []\nfor i in range(15):\n    for j in combinations(list2, i):\n        list1.append([len(j), sum(j)])\ntc = int(input())\nfor j in range(tc):\n    x = int(input())\n    list3 = []\n    for (i, k) in list1:\n        if x - k >= 0:\n            a = bin(x - k)\n            list3.append(i + a.count('1'))\n    print(min(list3))", "import math\n\ndef comb(A):\n    if len(A) == 1:\n        return [[A[-1]], []]\n    return [c + [A[-1]] for c in comb(A[:-1])] + comb(A[:-1])\n\ndef calc(A):\n    count = 0\n    while A:\n        if A & 1 == 1:\n            count += 1\n        A = A >> 1\n    return count\nfact = [i for i in range(3, 15)]\ncombs = comb(fact)\nfact_sum = dict()\nfor com in combs[::-1]:\n    summ = sum([math.factorial(c) for c in com])\n    fact_sum[tuple(com)] = summ\n\ndef sol(n):\n    ans = 2 ** 31\n    for com in combs[::-1]:\n        summ = fact_sum[tuple(com)]\n        if n < summ:\n            continue\n        ans = min(ans, len(com) + calc(n - summ))\n    return ans if ans != 2 ** 31 else -1\nx = int(input())\nfor _ in range(x):\n    n = int(input())\n    print(sol(n))", "from math import factorial\nfrom itertools import combinations\nlist2 = []\nfor i in range(15):\n    list2.append(factorial(i))\nlist1 = []\nfor i in range(15):\n    for j in combinations(list2, i):\n        list1.append([len(j), sum(j)])\ntc = int(input())\nfor j in range(tc):\n    x = int(input())\n    list3 = []\n    for (i, k) in list1:\n        if x - k >= 0:\n            a = bin(x - k)\n            list3.append(i + a.count('1'))\n    print(min(list3))", "from math import factorial\nfrom sys import stdin\nfrom itertools import combinations\nlist2 = []\nfor i in range(15):\n    list2.append(factorial(i))\nlist1 = []\nfor i in range(15):\n    for j in combinations(list2, i):\n        list1.append([len(j), sum(j)])\ntc = int(input())\nfor j in range(tc):\n    x = int(input())\n    list3 = []\n    for (i, k) in list1:\n        if x - k >= 0:\n            a = bin(x - k)\n            list3.append(i + a.count('1'))\n    print(min(list3))"]