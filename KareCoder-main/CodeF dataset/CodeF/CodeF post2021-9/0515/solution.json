["import bisect\n\ndef solve(sights, m, n):\n    L = sorted(range(m * n), key=lambda i: sights[i])\n    ans = 0\n    for r in range(m):\n        row = L[r * n:(r + 1) * n]\n        row.sort(key=lambda i: (sights[i], -i))\n        seen = []\n        for x in row:\n            i = bisect.bisect_left(seen, x)\n            ans += i\n            seen.insert(i, x)\n    return ans\nfor _ in range(int(input())):\n    (m, n) = map(int, input().split())\n    sights = list(map(int, input().split()))\n    print(solve(sights, m, n))", "import sys\nread = lambda : sys.stdin.readline()\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfor _ in range(int(read())):\n    (n, m) = map(int, read().split())\n    a = list(map(int, read().split()))\n    khaali = [[] for i in range(n)]\n    b = sorted(a)\n    idx = defaultdict(lambda : [])\n    for i in range(n * m):\n        idx[b[i]].append(i // m)\n    ans = 0\n    for num in a:\n        row = idx[num].pop(0)\n        op = bisect_left(khaali[row], num)\n        ans += op\n        khaali[row].insert(op, num)\n    print(ans)", "import bisect\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    h = [[] for i in range(n)]\n    q = {i: [] for i in set(l)}\n    p = sorted(l)\n    t = 0\n    s = 0\n    for i in range(n):\n        for j in range(m):\n            q[p[t]].append(i)\n            t += 1\n    for i in q:\n        q[i].reverse()\n    for i in l:\n        t = q[i].pop()\n        j = bisect.bisect_left(h[t], i)\n        s += j\n        h[t].insert(j, i)\n    print(s)", "import bisect\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    h = [[] for i in range(n)]\n    q = {i: [] for i in set(l)}\n    p = sorted(l)\n    t = 0\n    s = 0\n    for i in range(n):\n        for j in range(m):\n            q[p[t]].append(i)\n            t += 1\n    for i in q:\n        q[i].reverse()\n    for i in l:\n        t = q[i].pop()\n        j = bisect.bisect_left(h[t], i)\n        s += j\n        h[t].insert(j, i)\n    print(s)", "import bisect\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    h = [[] for i in range(n)]\n    q = {i: [] for i in set(l)}\n    p = sorted(l)\n    t = 0\n    for i in range(n):\n        for j in range(m):\n            q[p[t]].append(i)\n            t += 1\n    for i in q:\n        q[i].reverse()\n    s = 0\n    for i in l:\n        t = q[i].pop()\n        j = bisect.bisect_left(h[t], i)\n        s += j\n        h[t].insert(j, i)\n    print(s)", "import sys\nread = lambda : sys.stdin.readline()\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfor _ in range(int(read())):\n    (n, m) = map(int, read().split())\n    a = list(map(int, read().split()))\n    khaali = [[] for i in range(n)]\n    b = sorted(a)\n    idx = defaultdict(lambda : [])\n    for i in range(n * m):\n        idx[b[i]].append(i // m)\n    ans = 0\n    for num in a:\n        row = idx[num].pop(0)\n        op = bisect_left(khaali[row], num)\n        ans += op\n        khaali[row].insert(op, num)\n    print(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nfrom bisect import bisect_left\nfrom collections import defaultdict as dd\n\ndef solve():\n    ans = 0\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    Asort = sorted(A)\n    colnum = dd(lambda : dd(lambda : -1))\n    colnumcnt = dd(lambda : dd(lambda : 0))\n    numcol = dd(set)\n    for i in range(N):\n        for j in range(M):\n            a = Asort[M * i + j]\n            colnum[i][a] = j\n            numcol[a].add(i)\n            colnumcnt[i][a] += 1\n    q = [[] for _ in range(N)]\n    for a in A:\n        temp = sorted(numcol[a])\n        for i in temp:\n            if colnumcnt[i][a] <= 0:\n                continue\n            pos = bisect_left(q[i], a)\n            ans += pos\n            colnum[i][a] -= 1\n            colnumcnt[i][a] -= 1\n            if colnumcnt[i][a] == 0:\n                numcol[a].remove(i)\n            q[i].insert(pos, a)\n            break\n    print(ans)\n    return\nT = int(input())\nfor i in range(1, T + 1):\n    solve()", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nfrom bisect import bisect_left\nfrom collections import defaultdict as dd\n\ndef solve():\n    ans = 0\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    Asort = sorted(A)\n    colnum = dd(lambda : dd(lambda : -1))\n    colnumcnt = dd(lambda : dd(lambda : 0))\n    numcol = dd(set)\n    for i in range(N):\n        for j in range(M):\n            a = Asort[M * i + j]\n            colnum[i][a] = j\n            numcol[a].add(i)\n            colnumcnt[i][a] += 1\n    q = [[] for _ in range(N)]\n    for a in A:\n        temp = sorted(numcol[a])\n        for i in temp:\n            if colnumcnt[i][a] <= 0:\n                continue\n            pos = bisect_left(q[i], a)\n            ans += pos\n            colnum[i][a] -= 1\n            colnumcnt[i][a] -= 1\n            if colnumcnt[i][a] == 0:\n                numcol[a].remove(i)\n            q[i].insert(pos, a)\n            break\n    print(ans)\n    return\nT = int(input())\nfor i in range(1, T + 1):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef s(a):\n    n = len(a)\n    r = 0\n    for i in range(n):\n        if a[i] == 0:\n            if i > 0 and a[i - 1] == 1 or (i + 1 < n and a[i + 1] == 1):\n                r += 2\n            else:\n                r += 1\n    return r\n\ndef solve():\n    (n, m) = map(int, input().split())\n    i = 0\n    a = [0] * (n * m)\n    for v in map(int, input().split()):\n        a[i] = (v, i)\n        i += 1\n    a.sort()\n    b = [0] * (n * m)\n    for i in range(n):\n        j = i * m\n        k = j + m\n        while j < k:\n            z = j + 1\n            v = a[j][0]\n            while z < k and a[z][0] == v:\n                z += 1\n            for v in range(z - j):\n                b[a[z - v - 1][1]] = j + v\n            j = z\n    h = [[0] * m for i in range(n)]\n    r = 0\n    for i in range(n * m):\n        j = b[i]\n        (y, x) = divmod(j, m)\n        z = x\n        H = h[y]\n        while z >= 0:\n            r += H[z]\n            z = (z & z + 1) - 1\n        z = x\n        while z < m:\n            H[z] += 1\n            z = z | z + 1\n    print(r)\nfor i in range(int(input())):\n    solve()", "TESTS = int(input())\nfor t in range(TESTS):\n    (n, m) = map(int, input().split())\n    people = list(map(int, input().split()))\n    seats = people.copy()\n    seats.sort()\n    lookup = {}\n    for (i, s) in enumerate(seats):\n        if s not in lookup.keys():\n            lookup[s] = [i]\n        else:\n            lookup[s].append(i)\n    inconvenience = 0\n    grid = [[0] * m for i in range(n)]\n    for key in lookup.keys():\n        lookup[key].sort(key=lambda x: -100000 * (x // m) + x % m)\n    for p in people:\n        index = lookup[p].pop(-1)\n        nn = index // m\n        mm = index % m\n        grid[nn][mm] = 1\n        inconvenience += grid[nn][:mm].count(1)\n    print(inconvenience)", "T = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    a = list(enumerate(map(int, input().split())))\n    a.sort(key=lambda x: (x[1], x[0]))\n    first = 0\n    num = a[0][1]\n    for i in range(1, n * m):\n        if a[i][1] != num:\n            a[first:i] = reversed(a[first:i])\n            first = i\n            num = a[i][1]\n        if i % m == m - 1:\n            a[first:i + 1] = reversed(a[first:i + 1])\n            first = i + 1\n    indxs = [None] * (n * m)\n    for i in range(n * m):\n        indxs[a[i][0]] = i\n    cinema = [[0] * m for _ in range(n)]\n    ans = 0\n    for i in range(n * m):\n        row = indxs[i] // m\n        seat = indxs[i] % m\n        ans += sum(cinema[row][:seat])\n        cinema[row][seat] = 1\n    print(ans)", "T = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    a = list(enumerate(map(int, input().split())))\n    a.sort(key=lambda x: (x[1], x[0]))\n    first = 0\n    num = a[0][1]\n    for i in range(1, n * m):\n        if a[i][1] != num:\n            a[first:i] = reversed(a[first:i])\n            first = i\n            num = a[i][1]\n        if i % m == m - 1:\n            a[first:i + 1] = reversed(a[first:i + 1])\n            first = i + 1\n    indxs = [None] * (n * m)\n    for i in range(n * m):\n        indxs[a[i][0]] = i\n    cinema = [[0] * m for _ in range(n)]\n    ans = 0\n    for i in range(n * m):\n        row = indxs[i] // m\n        seat = indxs[i] % m\n        ans += sum(cinema[row][:seat])\n        cinema[row][seat] = 1\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n * m):\n        d[a[i]] = d.get(a[i], [])\n        d[a[i]].append(i)\n    o = [[] for _ in range(n)]\n    i = k = 0\n    dd = sorted(d)\n    for j in range(n):\n        while len(d[dd[i]][k:]) + len(o[j]) < m:\n            o[j] += d[dd[i]][k:][::-1]\n            k = 0\n            i += 1\n        kk = m - len(o[j])\n        o[j] += d[dd[i]][k:k + kk][::-1]\n        k += kk\n    d = {}\n    for i in range(n):\n        for j in range(m):\n            d[o[i][j]] = (i, j)\n    c = 0\n    s = [[False] * m for _ in range(n)]\n    for k in range(n * m):\n        (i, j) = d[k]\n        s[i][j] = True\n        c += sum(s[i][:j])\n    print(c)", "import bisect\nimport collections\nimport copy\nimport enum\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\n\nclass TreeArray:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.arr = [0] * n\n\n    def lowbit(self, x):\n        return x & -x\n\n    def update(self, x, y):\n        i = x\n        while i < self.n:\n            self.arr[i] += y\n            i += self.lowbit(i)\n\n    def sum(self, x):\n        ans = 0\n        i = x\n        while i > 0:\n            ans += self.arr[i]\n            i -= self.lowbit(i)\n        return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ts = [TreeArray(m + 2) for _ in range(n)]\n    ans = 0\n    cs = list(map(int, input().split()))\n    cs2 = [[i, c] for (i, c) in enumerate(cs)]\n    cs2.sort(key=lambda x: x[1])\n    mp = collections.defaultdict(lambda : collections.defaultdict(int))\n    mpc = collections.defaultdict(list)\n    for r in range(n):\n        for j in range(m):\n            idx = r * m + j\n            mp[cs2[idx][1]].setdefault(r, j + 1)\n            mpc[cs2[idx][1]].append(r)\n    for mc in cs:\n        r = mpc[mc].pop(0)\n        c = mp[mc][r]\n        ans += ts[r].sum(c - 1)\n        ts[r].update(c, 1)\n    print(ans)"]