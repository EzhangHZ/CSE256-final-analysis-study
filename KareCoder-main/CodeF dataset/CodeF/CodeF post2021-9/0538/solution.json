["t = int(input())\nfor _ in range(t):\n    n = int(input())\n    cot = [0] * (n + 1)\n    s = input().split()\n    nums = [int(x) for x in s]\n    for num in nums:\n        cot[num] += 1\n    pre = 0\n    cur = 0\n    v = []\n    ans = []\n    for i in range(n + 1):\n        if pre < i:\n            ans.append(-1)\n            while len(ans) < n + 1:\n                ans.append(-1)\n            break\n        else:\n            ans.append(cur + cot[i])\n            if cot[i] == 0 and len(v) > 0:\n                cur += i - v[-1]\n                v.pop()\n            else:\n                j = 1\n                while j <= cot[i] - 1:\n                    v.append(i)\n                    j += 1\n        pre += cot[i]\n    res = ' '.join([str(a) for a in ans])\n    print(res)", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    _ = input()\n    inp = [int(el) for el in input().split()]\n    nums = defaultdict(int)\n    for el in inp:\n        nums[el] += 1\n    stack = []\n    max_mex = None\n    curr_cost = 0\n    res = []\n    for i in range(len(inp) + 1):\n        if max_mex is not None:\n            res.append('-1')\n        else:\n            stack.extend([i] * nums[i])\n            res.append(str(curr_cost + nums[i]))\n            if len(stack) == 0:\n                max_mex = i\n            else:\n                curr_cost += i - stack[-1]\n                stack.pop()\n    print(' '.join(res))", "t = int(input())\nwhile t:\n    n = int(input())\n    li = list(map(int, input().split()))\n    li.sort()\n    ans = [-1] * (n + 1)\n    d = [0] * (n + 1)\n    stack = []\n    s = 0\n    for i in range(len(li)):\n        d[li[i]] += 1\n    for i in range(n + 1):\n        if i > 0 and d[i - 1] == 0:\n            if not stack:\n                break\n            j = stack.pop()\n            s += i - j - 1\n        ans[i] = s + d[i]\n        while i > 0 and d[i - 1] > 1:\n            d[i - 1] -= 1\n            stack.append(i - 1)\n    print(' '.join(map(str, ans)))\n    t -= 1", "result = []\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    array = [0 for i in range(n + 1)]\n    for number in a:\n        array[number] += 1\n    deque = [0] * max(array[0] - 1, 0)\n    dlen = len(deque)\n    answer = [array[0]]\n    for i in range(1, n + 1):\n        if answer[i - 1] == -1:\n            answer.append(-1)\n        elif array[i - 1] != 0:\n            answer.append(answer[i - 1] - array[i - 1] + array[i])\n        elif dlen > 0:\n            answer.append(answer[i - 1] + (i - 1 - deque.pop()) + array[i])\n            dlen -= 1\n        else:\n            answer.append(-1)\n        deque += [i] * max(array[i] - 1, 0)\n        dlen += max(array[i] - 1, 0)\n    result.append(answer)\nprint('\\n'.join(map(lambda x: ' '.join(map(str, x)), result)))", "from audioop import reverse\nfrom collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    freq = Counter(a)\n    res = [-1] * (n + 1)\n    stack = []\n    v = 0\n    if freq[0] > 0:\n        res[0] = freq[0]\n        stack.extend([0] * (freq[0] - 1))\n        for i in range(1, n + 1):\n            if freq[i - 1] > 0:\n                res[i] = v + freq[i]\n                stack.extend([i] * (freq[i] - 1))\n            elif len(stack) > 0:\n                l = stack.pop()\n                v += i - l - 1\n                res[i] = v + freq[i]\n                stack.extend([i] * (freq[i] - 1))\n            else:\n                break\n    else:\n        res[0] = 0\n    print(' '.join(map(str, res)))", "def solve(arr, n):\n    count = [0 for _ in range(n + 1)]\n    for i in arr:\n        count[i] += 1\n    ans = [-1 for _ in range(n + 1)]\n    ans[0] = count[0]\n    if not ans[0]:\n        return ans\n    steps = 0\n    last = []\n    if ans[0] > 1:\n        last.append(0)\n    for i in range(1, n + 1):\n        if arr[i - 1] >= i:\n            continue\n        ans[i] = count[i] + steps\n        if count[i] > 1:\n            last.append(i)\n        if not count[i]:\n            if not last:\n                return ans\n            steps += i - last[-1]\n            count[last[-1]] -= 1\n            if count[last[-1]] == 1:\n                last.pop()\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    print(*solve(arr, n))", "import math\nt = int(input())\nfor test_case in range(t):\n    n = int(input())\n    array = list(map(int, input().split()))\n    freq_array = [0 for i in range(n + 1)]\n    for i in array:\n        freq_array[i] += 1\n    flag = True\n    steps_for_mex = 0\n    idx = -1\n    for i in range(n + 1):\n        if flag:\n            if freq_array[i] > 0:\n                if freq_array[i] > 1:\n                    idx = i\n                print(freq_array[i] + steps_for_mex, end=' ')\n            else:\n                print(steps_for_mex, end=' ')\n                while idx >= 0:\n                    if freq_array[idx] > 1:\n                        steps_for_mex += i - idx\n                        freq_array[idx] -= 1\n                        break\n                    else:\n                        idx -= 1\n                if idx == -1:\n                    flag = False\n        else:\n            print(-1, end=' ')\n    print()", "from typing import Counter\n\ndef find(arr: list, n):\n    res = [-1] * (n + 1)\n    count = [0] * (n + 1)\n    maxx = 0\n    maxxx = 0\n    d = 0\n    for i in range(n):\n        count[arr[i]] += 1\n    if count[0] < 1:\n        res[0] = 0\n        return res\n    res[0] = count[0]\n    for i in range(1, n + 1):\n        d = 0\n        res[i] = res[i - 1] - count[i - 1] + count[i]\n        if count[i - 1] > 0:\n            if count[maxx] > 0:\n                maxxx = maxx\n            maxx = i - 1\n            count[i - 1] -= 1\n        elif count[maxx] > 0:\n            d = i - 1 - maxx\n            count[maxx] -= 1\n        else:\n            while maxxx > -1 and count[maxxx] < 1:\n                maxxx -= 1\n            if maxxx < 0:\n                res[i] = -1\n                return res\n            else:\n                d = i - 1 - maxxx\n                count[maxxx] -= 1\n        res[i] += d\n    return res\nr = int(input())\nres = []\nfor i in range(r):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    res.append(find(arr, n))\nfor i in res:\n    print(*i)", "def solve(arr, n):\n    count = [0 for _ in range(n + 1)]\n    for i in arr:\n        count[i] += 1\n    ans = [-1 for _ in range(n + 1)]\n    ans[0] = count[0]\n    if not ans[0]:\n        return ans\n    steps = 0\n    last = []\n    if ans[0] > 1:\n        last.append(0)\n    for i in range(1, n + 1):\n        if arr[i - 1] >= i:\n            continue\n        ans[i] = count[i] + steps\n        if count[i] > 1:\n            last.append(i)\n        if not count[i]:\n            if not last:\n                return ans\n            steps += i - last[-1]\n            count[last[-1]] -= 1\n            if count[last[-1]] == 1:\n                last.pop()\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    print(*solve(arr, n))", "import sys\nfrom collections import deque\n\ndef read_line():\n    return sys.stdin.readline().strip()\nt = int(read_line())\nfor _ in range(t):\n    n = int(read_line())\n    a = [int(x) for x in read_line().split()]\n    a = sorted(a)\n    unused = deque()\n    cnt = [0] * (n + 1)\n    for x in a:\n        cnt[x] += 1\n    ans = [-1] * (n + 1)\n    ans[0] = cnt[0]\n    cnt_less = 0\n    for i in range(1, n + 1):\n        cnt_less += cnt[i - 1]\n        if cnt_less < i:\n            break\n        for x in range(cnt[i - 1]):\n            unused.append(i - 1)\n        last_el = unused.pop()\n        ans[i] = ans[i - 1] - cnt[i - 1] + (i - 1 - last_el) + cnt[i]\n    print(' '.join([str(x) for x in ans]))", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    count = {}\n    for element in a:\n        if element in count.keys():\n            count[element] += 1\n        else:\n            count[element] = 1\n    ans = []\n    prev = 0\n    best = []\n\n    def get(i):\n        return 0 if i not in count.keys() else count[i]\n    for i in range(n + 1):\n        ans.append(prev + get(i))\n        if get(i) == 0:\n            if len(best) > 0:\n                have = best[-1]\n                count[have] -= 1\n                if get(have) == 0:\n                    best.pop()\n                prev += i - have\n                count[i] = 1\n            else:\n                while len(ans) != n + 1:\n                    ans.append(-1)\n                break\n        elif get(i) >= 2:\n            best.append(i)\n        count[i] -= 1\n    print(*ans)\nfor _ in range(int(input())):\n    solve()", "from itertools import permutations as per\nfrom math import factorial as fact\nfrom difflib import SequenceMatcher\nimport bisect\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * (n + 1)\n    b = [int(i) for i in input().split()]\n    for i in b:\n        a[i] += 1\n    prev = 0\n    s = []\n    print(a[0], end=' ')\n    while a[0] > 1:\n        s.append(0)\n        a[0] -= 1\n    for i in range(1, n + 1):\n        if prev != -1:\n            if a[i - 1] == 0:\n                if len(s):\n                    prev += i - 1 - s[-1]\n                    s.pop()\n                    print(prev + a[i], end=' ')\n                else:\n                    prev = -1\n                    print(-1, end=' ')\n            else:\n                print(prev + a[i], end=' ')\n                while a[i - 1] != 1:\n                    s.append(i - 1)\n                    a[i - 1] -= 1\n        else:\n            print(-1, end=' ')\n    print()", "t = int(input())\nout = ''\nfor _ in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    count = [0] * (n + 1)\n    for x in arr:\n        count[x] += 1\n    previous = []\n    total = 0\n    this_ = 0\n    for i in range(n + 1):\n        out += str(total + count[i]) + ' '\n        for x in range(count[i]):\n            previous.append(i)\n        if len(previous) == 0:\n            while i < n:\n                out += '-1 '\n                i += 1\n            break\n        total += i - previous.pop(-1)\n    out += '\\n'\nprint(out)", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    a = sorted(map(int, input().split()))\n    m = set()\n    e = []\n    w = {}\n    for i in a:\n        if i not in m:\n            m.add(i)\n        else:\n            e += [i]\n        w[i] = w.get(i, 0) + 1\n    s = 0\n    r = []\n    t = 0\n    for i in range(n + 1):\n        if t:\n            r += [-1]\n        elif i not in m:\n            o = bisect.bisect_right(e, i)\n            if o == 0:\n                t = 1\n                r += [s]\n            else:\n                r += [s]\n                s += i - e[o - 1]\n                e.pop(o - 1)\n        else:\n            r += [w[i] + s]\n    print(*r)", "from collections import Counter\n\ndef solve(n, lst):\n    lst.sort()\n    freq = Counter(lst)\n    freq1 = Counter(lst)\n    mef = [-1] * (n + 1)\n    st = []\n    moves = 0\n    for i in range(n + 1):\n        if i > 0 and freq[i - 1] == 0:\n            if st != []:\n                moves += i - st.pop() - 1\n            else:\n                break\n        mef[i] = freq[i] + moves\n        while i > 0 and freq[i - 1] > 1:\n            freq[i - 1] -= 1\n            st.append(i - 1)\n    print(*mef)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    solve(n, lst)", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    count = {}\n    for i in a:\n        if count.get(i):\n            count[i] += 1\n        else:\n            count[i] = 1\n    make = [count.get(0, 0)]\n    small = make[-1]\n    left = []\n    if small > 1:\n        left.append([0, small - 1])\n    for i in range(1, n + 1):\n        if small < i:\n            make.extend([-1] * (n - i + 1))\n            break\n        elif count.get(i - 1):\n            make.append(make[-1] - count[i - 1] + count.get(i, 0))\n        else:\n            make.append(make[-1] + count.get(i, 0) + i - 1 - left[-1][0])\n            left[-1][1] -= 1\n            if left[-1][1] == 0:\n                left.pop()\n        k = count.get(i, 0)\n        if k > 1:\n            left.append([i, k - 1])\n        small += k\n    print(*make)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n    a.append(10 ** 9)\n    less = 0\n    equal = 0\n    unused = []\n    last = 0\n    for mex in range(n + 1):\n        while a[less + equal] < mex:\n            less += 1\n        while a[less + equal] == mex:\n            equal += 1\n        if less < mex or last < 0:\n            print('-1 ' * (n + 1 - mex), end='')\n            break\n        print(equal + last, end=' ')\n        if not equal:\n            if not unused:\n                last = -1\n            else:\n                last += mex - unused.pop()\n        unused.extend([mex] * (equal - 1))\n        less += equal\n        equal = 0\n    print()", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ctr = Counter(l)\n    an = [-1] * (n + 1)\n    (take, prev) = ([], 0)\n    for i in range(n + 1):\n        cur = ctr[i]\n        an[i] = prev + cur\n        if i > 0 and ctr[i - 1] == 0:\n            if not take:\n                an[i] = -1\n                break\n            x = take.pop()\n            prev += i - 1 - x\n            an[i] += i - 1 - x\n            ctr[i - 1] += 1\n        if cur > 1:\n            take += [i] * (cur - 1)\n    print(*an)", "from collections import Counter\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    s = []\n    a = list(map(int, input().strip().split()))\n    c = Counter(a)\n    ans = [-1] * (n + 1)\n    ans[0] = c[0]\n    (st, cp) = (0, 0)\n    for j in range(n):\n        cp += c[j]\n        if cp <= j:\n            break\n        if c[j] == 0:\n            st += j - s.pop()\n        ans[j + 1] = st + c[j + 1]\n        s += [j] * (c[j] - 1)\n    for j in range(n + 1):\n        print(ans[j], end=' ')\n    print('')", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ctr = Counter(l)\n    an = [-1] * (n + 1)\n    (take, prev) = ([], 0)\n    for i in range(n + 1):\n        cur = ctr[i]\n        an[i] = prev + cur\n        if i > 0 and ctr[i - 1] == 0:\n            if not take:\n                an[i] = -1\n                break\n            x = take.pop()\n            prev += i - 1 - x\n            an[i] += i - 1 - x\n            ctr[i - 1] += 1\n        if cur > 1:\n            take += [i] * (cur - 1)\n    print(*an)", "from collections import Counter\nfrom heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    cnt = Counter(arr)\n    res = []\n    pq = []\n    mn = 0\n    error = False\n    for i in range(n + 1):\n        if error:\n            res.append(-1)\n            continue\n        if cnt[i]:\n            if cnt[i] > 1:\n                heappush(pq, [-i, cnt[i] - 1])\n            res.append(mn + cnt[i])\n        elif pq:\n            res.append(mn)\n            last = heappop(pq)\n            last[1] -= 1\n            if last[1]:\n                heappush(pq, last)\n            mn += i + last[0]\n        else:\n            res.append(mn)\n            error = True\n    print(*res)", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ctr = Counter(l)\n    an = [-1] * (n + 1)\n    (take, prev) = ([], 0)\n    for i in range(n + 1):\n        cur = ctr[i]\n        an[i] = prev + cur\n        if i > 0 and ctr[i - 1] == 0:\n            if not take:\n                an[i] = -1\n                break\n            x = take.pop()\n            prev += i - 1 - x\n            an[i] += i - 1 - x\n            ctr[i - 1] += 1\n        if cur > 1:\n            take += [i] * (cur - 1)\n    print(*an)", "import heapq\nimport sys\nimport math\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\nI = sys.stdin.readline\nII = lambda : int(I())\nIN = lambda x: map(int, x.split())\nFN = lambda x: map(float, x.split())\nL = lambda x: list(IN(x))\nM = 1000000007\nP = print\nT = True\nF = False\nfor _ in range(II()):\n    n = II()\n    a = L(I())\n    d = {}\n    r = 0\n    t = 0\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    ans = [d.get(0, 0)]\n    f = n + 1\n    l = d.get(0, 0)\n    for i in range(1, n + 1):\n        if l < i:\n            f = i\n            break\n        l += d.get(i, 0)\n        z = d.get(i - 1, 0)\n        k = ans[-1] - z\n        m = d.get(i, 0) + k\n        if z == 0:\n            j = i - t - 1\n            while j >= 0 and d.get(j, 0) <= 1:\n                j -= 1\n                t += 1\n            d[i - 1] = d.get(i - 1, 0) + 1\n            d[j] -= 1\n            m += t\n        if z > 1:\n            t = 0\n        ans.append(m)\n        t += 1\n    for i in range(f, n + 1):\n        ans.append(-1)\n    print(*ans, sep=' ')", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    rem = []\n    out = []\n    have = []\n    s = 0\n    ans = 0\n    skip = False\n    f = [0] * (n + 1)\n    for i in a:\n        f[i] += 1\n    for i in range(n + 1):\n        if skip:\n            out.append(-1)\n            continue\n        ans = s + f[i]\n        if len(rem) > 0:\n            ans = -1\n        if ans == -1:\n            skip = True\n        out.append(ans)\n        if f[i] == 0:\n            rem.append(i)\n        else:\n            while f[i] > 1:\n                have.append(i)\n                f[i] -= 1\n        while len(rem) > 0 and len(have) > 0:\n            while len(have) > 0 and have[-1] > rem[-1]:\n                have.pop()\n            if len(have) == 0:\n                break\n            x = rem[-1]\n            rem.pop()\n            y = have[-1]\n            have.pop()\n            s += x - y\n    print(*out)", "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    output = [-1 for _ in range(n + 1)]\n    a.sort()\n    stack = []\n    c = Counter(a)\n    sm = 0\n    for i in range(0, n + 1):\n        if i > 0 and c[i - 1] == 0:\n            if len(stack) == 0:\n                break\n            j = stack.pop()\n            sm += i - j - 1\n        output[i] = sm + c[i]\n        j = i\n        while j > 0 and c[i - 1] > 1:\n            c[i - 1] -= 1\n            stack.append(i - 1)\n    print(*output)", "import heapq\nimport sys\nimport math\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\nI = sys.stdin.readline\nII = lambda : int(I())\nIN = lambda x: map(int, x.split())\nFN = lambda x: map(float, x.split())\nL = lambda x: list(IN(x))\nM = 1000000007\nP = print\nT = True\nF = False\nfor _ in range(II()):\n    n = II()\n    a = L(I())\n    d = {}\n    r = 0\n    t = 0\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    ans = [d.get(0, 0)]\n    f = n + 1\n    l = d.get(0, 0)\n    for i in range(1, n + 1):\n        if l < i:\n            f = i\n            break\n        l += d.get(i, 0)\n        z = d.get(i - 1, 0)\n        k = ans[-1] - z\n        m = d.get(i, 0) + k\n        if z == 0:\n            j = i - t - 1\n            while j >= 0 and d.get(j, 0) <= 1:\n                j -= 1\n                t += 1\n            d[i - 1] = d.get(i - 1, 0) + 1\n            d[j] -= 1\n            m += t\n        if z > 1:\n            t = 0\n        ans.append(m)\n        t += 1\n    for i in range(f, n + 1):\n        ans.append(-1)\n    print(*ans, sep=' ')", "from bisect import bisect_left as bl\nfrom sys import stdin\nfrom collections import Counter\n\ndef f(a):\n    n = len(a)\n    cnt = Counter(a)\n    pp = []\n    for i in cnt:\n        pp += [i] * (cnt[i] - 1)\n    val = [0] * (n + 1)\n    pp = sorted(pp)\n    for i in range(0, n):\n        cst = 0\n        if cnt[i] == 0:\n            ll = bl(pp, i)\n            ll -= 1\n            if ll < 0:\n                cst = float('inf')\n            else:\n                cst = i - pp[ll]\n                pp.pop(ll)\n        val[i + 1] = val[i] + cst\n    for i in range(0, n + 1):\n        val[i] += cnt[i]\n        if val[i] == float('inf'):\n            val[i] = -1\n    return val\nfor i in range(int(input())):\n    s = input()\n    l = list(map(int, input().strip().split()))\n    print(*f(l))", "from queue import LifoQueue\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    stack = LifoQueue(maxsize=n + 3)\n    kcount = [0 for x in range(n + 1)]\n    supporter = [-1 for x in range(n + 1)]\n    for i in a:\n        kcount[i] += 1\n    count = [x for x in kcount]\n    for i in range(n - 1, -1, -1):\n        if count[i] == 0:\n            stack.put(i)\n        else:\n            while stack.empty() == False and count[i] > 1:\n                p = stack.get()\n                supporter[p] = i\n                count[i] -= 1\n    ans = [0 for x in range(n + 1)]\n    if stack.empty() == False:\n        c = stack.get()\n        for i in range(c + 1, n + 1):\n            ans[i] = -1\n    suffix = [0 for x in range(n + 1)]\n    for x in range(n + 1):\n        if supporter[x] != -1:\n            suffix[x] = x - supporter[x]\n    for i in range(1, n + 1):\n        suffix[i] = suffix[i - 1] + suffix[i]\n    for i in range(0, n + 1):\n        if ans[i] == -1:\n            break\n        elif i != 0:\n            ans[i] = suffix[i - 1] + kcount[i]\n        else:\n            ans[i] = kcount[i]\n    for i in ans:\n        print(i, end=' ')\n    print()"]