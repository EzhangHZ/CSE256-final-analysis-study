["import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    (n, m) = map(int, inp().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, c) = inp().split()\n        (u, v) = map(int, (u, v))\n        if c == 'crewmate':\n            g[u].append((v, 0))\n            g[v].append((u, 0))\n        else:\n            g[u].append((v, 1))\n            g[v].append((u, 1))\n    val = [None] * (n + 1)\n    r = 0\n    for i in range(1, n + 1):\n        if val[i] is None:\n            q = [i]\n            val[i] = 0\n            i = 0\n            c = [1, 0]\n            while i < len(q):\n                u = q[i]\n                i += 1\n                for (v, w) in g[u]:\n                    if val[v] is None:\n                        val[v] = val[u] ^ w\n                        c[val[v]] += 1\n                        q.append(v)\n                    elif val[v] != val[u] ^ w:\n                        print(-1)\n                        return\n            r += max(c)\n    print(r)\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        (u, v, c) = input().split()\n        (u, v) = map(int, (u, v))\n        if c == 'crewmate':\n            graph[u].append((v, 0))\n            graph[v].append((u, 0))\n        else:\n            graph[u].append((v, 1))\n            graph[v].append((u, 1))\n    val = [None] * (n + 1)\n    ans = 0\n    for i in range(1, n + 1):\n        if val[i] is None:\n            q = [i]\n            val[i] = 0\n            i = 0\n            c = [1, 0]\n            while i < len(q):\n                u = q[i]\n                i += 1\n                for (v, w) in graph[u]:\n                    if val[v] is None:\n                        val[v] = val[u] ^ w\n                        c[val[v]] += 1\n                        q.append(v)\n                    elif val[v] != val[u] ^ w:\n                        return -1\n            ans += max(c)\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "def solve():\n    (n, m) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, c) = input().split()\n        (u, v) = map(int, (u, v))\n        if c == 'crewmate':\n            g[u].append((v, 0))\n            g[v].append((u, 0))\n        else:\n            g[u].append((v, 1))\n            g[v].append((u, 1))\n    val = [None] * (n + 1)\n    r = 0\n    for i in range(1, n + 1):\n        if val[i] is None:\n            q = [i]\n            val[i] = 0\n            i = 0\n            c = [1, 0]\n            while i < len(q):\n                u = q[i]\n                i += 1\n                for (v, w) in g[u]:\n                    if val[v] is None:\n                        val[v] = val[u] ^ w\n                        c[val[v]] += 1\n                        q.append(v)\n                    elif val[v] != val[u] ^ w:\n                        print(-1)\n                        return\n            r += max(c)\n    print(r)\nfor _ in range(int(input())):\n    solve()", "def solve():\n    (n, m) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, c) = input().split()\n        (u, v) = map(int, (u, v))\n        if c == 'crewmate':\n            g[u].append((v, 0))\n            g[v].append((u, 0))\n        else:\n            g[u].append((v, 1))\n            g[v].append((u, 1))\n    val = [None] * (n + 1)\n    r = 0\n    for i in range(1, n + 1):\n        if val[i] is None:\n            q = [i]\n            val[i] = 0\n            i = 0\n            c = [1, 0]\n            while i < len(q):\n                u = q[i]\n                i += 1\n                for (v, w) in g[u]:\n                    if val[v] is None:\n                        val[v] = val[u] ^ w\n                        c[val[v]] += 1\n                        q.append(v)\n                    elif val[v] != val[u] ^ w:\n                        print(-1)\n                        return\n            r += max(c)\n    print(r)\nfor _ in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\nmap_role = {'imposter': 1, 'crewmate': 0}\nfor _ in range(int(input())):\n    (n, m) = input().split(' ')\n    nocontra = True\n    n = int(n)\n    m = int(m)\n    edges = [[] for i in range(n + 1)]\n    for com in range(m):\n        (i, j, c) = input().split(' ')\n        i = int(i)\n        j = int(j)\n        c = map_role[c.strip()]\n        edges[i].append((j, c))\n        edges[j].append((i, c))\n    role = [-1] * (n + 1)\n    res = 0\n    for player in range(1, n + 1):\n        if role[player] == -1:\n            role[player] = 0\n            count = [1, 0]\n            queue = [player]\n            while len(queue) > 0:\n                u = queue.pop()\n                for edge in edges[u]:\n                    v = edge[0]\n                    status = edge[1]\n                    if role[v] == -1:\n                        role[v] = role[u] if status == 0 else 1 - role[u]\n                        count[role[v]] += 1\n                        queue.append(v)\n                    else:\n                        ans = role[u] if status == 0 else 1 - role[u]\n                        if role[v] != ans:\n                            nocontra = False\n                            break\n                if not nocontra:\n                    break\n            if not nocontra:\n                break\n            res += max(count)\n    if not nocontra:\n        print(-1)\n    else:\n        print(res)", "def solve():\n    (n, m) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v, c) = input().split()\n        (u, v) = map(int, (u, v))\n        if c == 'crewmate':\n            g[u].append((v, 0))\n            g[v].append((u, 0))\n        else:\n            g[u].append((v, 1))\n            g[v].append((u, 1))\n    val = [None] * (n + 1)\n    r = 0\n    for i in range(1, n + 1):\n        if val[i] is None:\n            q = [i]\n            val[i] = 0\n            i = 0\n            c = [1, 0]\n            while i < len(q):\n                u = q[i]\n                i += 1\n                for (v, w) in g[u]:\n                    if val[v] is None:\n                        val[v] = val[u] ^ w\n                        c[val[v]] += 1\n                        q.append(v)\n                    elif val[v] != val[u] ^ w:\n                        print(-1)\n                        return\n            r += max(c)\n    print(r)\nfor _ in range(int(input())):\n    solve()", "inf = float('inf')\nimport sys\nimport pprint\nimport logging\nfrom logging import getLogger\nimport array\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef maps():\n    return [int(i) for i in input().split()]\nlogging.basicConfig(format='%(message)s', level=logging.WARNING)\nlogger = getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\ndef debug(msg, *args):\n    logger.info(f'{msg}={pprint.pformat(args)}')\nfor _ in range(*maps()):\n    (n, m) = maps()\n    (gr, col) = ([[] for _ in range(n)], [-1] * n)\n    for __ in range(m):\n        (i, j, c) = input().split()\n        x = 0 if c[0] == 'c' else 1\n        (i, j) = (int(i) - 1, int(j) - 1)\n        gr[i].append((j, x))\n        gr[j].append((i, x))\n    (ok, ans) = (True, 0)\n    state = [-1] * n\n    for i in range(n):\n        if state[i] == -1:\n            q = [i]\n            (c1, c2) = (0, 0)\n            state[i] = 0\n            while q:\n                v = q.pop()\n                if state[v] == 0:\n                    c1 += 1\n                else:\n                    c2 += 1\n                for (vv, xx) in gr[v]:\n                    if state[vv] == -1:\n                        state[vv] = state[v] ^ xx\n                        q.append(vv)\n                    elif state[vv] != state[v] ^ xx:\n                        ok = False\n                        break\n            if not ok:\n                break\n            ans += max(c1, c2)\n    print(ans if ok else -1)", "inf = float('inf')\nimport sys\nimport pprint\nimport logging\nfrom logging import getLogger\nimport array\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\ndef maps():\n    return [int(i) for i in input().split()]\nlogging.basicConfig(format='%(message)s', level=logging.WARNING)\nlogger = getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\ndef debug(msg, *args):\n    logger.info(f'{msg}={pprint.pformat(args)}')\nfor _ in range(*maps()):\n    (n, m) = maps()\n    (gr, col) = ([[] for _ in range(n)], [-1] * n)\n    for __ in range(m):\n        (i, j, c) = input().split()\n        x = 0 if c[0] == 'c' else 1\n        (i, j) = (int(i) - 1, int(j) - 1)\n        gr[i].append((j, x))\n        gr[j].append((i, x))\n    (ok, ans) = (True, 0)\n    state = [-1] * n\n    for i in range(n):\n        if state[i] == -1:\n            q = [i]\n            (c1, c2) = (0, 0)\n            state[i] = 0\n            for v in q:\n                if state[v] == 0:\n                    c1 += 1\n                else:\n                    c2 += 1\n                for (vv, xx) in gr[v]:\n                    if state[vv] == -1:\n                        state[vv] = state[v] ^ xx\n                        q.append(vv)\n                    elif state[vv] != state[v] ^ xx:\n                        ok = False\n                        break\n            if not ok:\n                break\n            ans += max(c1, c2)\n    print(ans if ok else -1)", "from collections import defaultdict\nfrom sys import stdin, setrecursionlimit\nimport threading\ninput = stdin.readline\n\ndef work():\n\n    def dfs(curr):\n        nonlocal c1, c2, ok\n        if color[curr] == 1:\n            c1 += 1\n        else:\n            c2 += 1\n        for node in graph[curr]:\n            if color[node[0]] == -1:\n                color[node[0]] = color[curr] ^ node[1]\n                dfs(node[0])\n            elif color[node[0]] != color[curr] ^ node[1]:\n                ok = False\n    setrecursionlimit(2 * 10 ** 5 + 5)\n    for _ in range(int(input())):\n        ok = True\n        (n, m) = map(int, input().split())\n        color = [-1 for __ in range(n + 1)]\n        graph = defaultdict(list)\n        for __ in range(m):\n            (u, v, c) = input().split()\n            (u, v) = (int(u), int(v))\n            if c == 'imposter':\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n            else:\n                graph[u].append((v, 0))\n                graph[v].append((u, 0))\n        ans = 0\n        for i in range(1, n + 1):\n            if color[i] == -1:\n                c1 = c2 = 0\n                color[i] = 0\n                dfs(i)\n                ans += max(c1, c2)\n        print(-1 if not ok else ans)\nthreading.stack_size(10 ** 8)\nthreading.Thread(target=work).start()", "from collections import defaultdict\nfrom sys import stdin, setrecursionlimit\nimport threading\ninput = stdin.readline\n\ndef work():\n\n    def dfs(curr):\n        nonlocal c1, c2, ok\n        if color[curr] == 1:\n            c1 += 1\n        else:\n            c2 += 1\n        for node in graph[curr]:\n            if color[node[0]] == -1:\n                color[node[0]] = color[curr] ^ node[1]\n                dfs(node[0])\n            elif color[node[0]] != color[curr] ^ node[1]:\n                ok = False\n    setrecursionlimit(2 * 10 ** 5 + 5)\n    for _ in range(int(input())):\n        ok = True\n        (n, m) = map(int, input().split())\n        color = [-1 for __ in range(n + 1)]\n        graph = defaultdict(list)\n        for __ in range(m):\n            (u, v, c) = input().split()\n            (u, v) = (int(u), int(v))\n            if c == 'imposter':\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n            else:\n                graph[u].append((v, 0))\n                graph[v].append((u, 0))\n        ans = 0\n        for i in range(1, n + 1):\n            if color[i] == -1:\n                c1 = c2 = 0\n                color[i] = 0\n                dfs(i)\n                ans += max(c1, c2)\n        print(-1 if not ok else ans)\nthreading.stack_size(10 ** 8)\nthreading.Thread(target=work).start()", "from sys import stdin, setrecursionlimit\nfrom collections import defaultdict\nfrom threading import Thread, stack_size\ninput = stdin.readline\n\ndef work():\n\n    def dfs(curr):\n        nonlocal c1, c2, ok\n        if color[curr] == 0:\n            c1 += 1\n        else:\n            c2 += 1\n        for node in graph[curr]:\n            if color[node[0]] == -1:\n                color[node[0]] = color[curr] ^ node[1]\n                dfs(node[0])\n            elif color[node[0]] != color[curr] ^ node[1]:\n                ok = False\n    setrecursionlimit(2 * 10 ** 5 + 10)\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        graph = defaultdict(list)\n        for __ in range(m):\n            (a, b, c) = input().split()\n            (a, b) = (int(a), int(b))\n            if c == 'imposter':\n                graph[a].append((b, 1))\n                graph[b].append((a, 1))\n            else:\n                graph[a].append((b, 0))\n                graph[b].append((a, 0))\n        color = [-1 for __ in range(n + 1)]\n        ans = 0\n        ok = True\n        for i in range(1, n + 1):\n            if color[i] == -1:\n                c1 = c2 = 0\n                color[i] = 0\n                dfs(i)\n                ans += max(c1, c2)\n        print(ans if ok else -1)\nstack_size(10 ** 8)\nThread(target=work).start()", "from collections import defaultdict\nfrom sys import stdin, setrecursionlimit\nimport threading\ninput = stdin.readline\n\ndef work():\n\n    def dfs(curr):\n        nonlocal c1, c2, ok\n        if color[curr] == 1:\n            c1 += 1\n        else:\n            c2 += 1\n        for node in graph[curr]:\n            if color[node[0]] == -1:\n                color[node[0]] = color[curr] ^ node[1]\n                dfs(node[0])\n            elif color[node[0]] != -1:\n                if node[1] == 1 and color[node[0]] == color[curr]:\n                    ok = False\n                if node[1] == 0 and color[node[0]] != color[curr]:\n                    ok = False\n    setrecursionlimit(2 * 10 ** 5 + 50)\n    for _ in range(int(input())):\n        ok = True\n        (n, m) = map(int, input().split())\n        color = [-1 for __ in range(n + 1)]\n        graph = defaultdict(list)\n        for __ in range(m):\n            (u, v, c) = input().split()\n            (u, v) = (int(u), int(v))\n            if c == 'imposter':\n                graph[u].append((v, 1))\n                graph[v].append((u, 1))\n            else:\n                graph[u].append((v, 0))\n                graph[v].append((u, 0))\n        ans = 0\n        for i in range(1, n + 1):\n            c1 = c2 = 0\n            if color[i] == -1:\n                color[i] = 0\n                dfs(i)\n                ans += max(c1, c2)\n        print(-1 if not ok else ans)\nthreading.stack_size(10 ** 8)\nthreading.Thread(target=work).start()", "import sys\nfrom collections import defaultdict, deque\nN = int(input())\nfor _ in range(N):\n    adjList = defaultdict(list)\n    (n, m) = map(int, input().split())\n    for _ in range(m):\n        (u, v, s) = input().split()\n        (u, v) = (int(u), int(v))\n        d = 1 if s == 'imposter' else 0\n        adjList[u].append((v, d))\n        adjList[v].append((u, d))\n    role = [None] * (n + 1)\n    ans = 0\n    flag = False\n    for i in range(1, n + 1):\n        if role[i] is not None:\n            continue\n        q = deque([(i, 0)])\n        role[i] = 0\n        maxx = [0, 0]\n        while q:\n            (u, r) = q.popleft()\n            maxx[r] += 1\n            for (v, d) in adjList[u]:\n                if role[v] is None:\n                    role[v] = (r + d) % 2\n                    q.append((v, role[v]))\n                elif role[v] != (r + d) % 2:\n                    print(-1)\n                    flag = True\n                    break\n            if flag:\n                break\n        if flag:\n            break\n        ans += max(maxx)\n    if flag:\n        continue\n    print(ans + sum([1 for i in range(1, n + 1) if role[i] is None]))", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    same = {i: set() for i in range(n)}\n    diff = {i: set() for i in range(n)}\n    for i in range(m):\n        (i, j, c) = input().split()\n        (i, j) = (int(i) - 1, int(j) - 1)\n        if c == 'crewmate':\n            same[i].add(j)\n            same[j].add(i)\n        else:\n            diff[i].add(j)\n            diff[j].add(i)\n    inds = [-1] * n\n    bad = False\n    total = 0\n    for i in range(n):\n        if bad:\n            break\n        if inds[i] == -1:\n            colors = {i: 1}\n            layer = [i]\n            while layer != []:\n                newlayer = []\n                for guy in layer:\n                    for neighbor in same[guy]:\n                        if neighbor not in colors:\n                            colors[neighbor] = colors[guy]\n                            newlayer.append(neighbor)\n                            inds[neighbor] = 1\n                        elif colors[neighbor] == -colors[guy]:\n                            bad = True\n                    for neighbor in diff[guy]:\n                        if neighbor not in colors:\n                            colors[neighbor] = -colors[guy]\n                            newlayer.append(neighbor)\n                            inds[neighbor] = 1\n                        elif colors[neighbor] == colors[guy]:\n                            bad = True\n                layer = newlayer\n            pos = 0\n            neg = 0\n            for guy in colors:\n                if colors[guy] == 1:\n                    pos += 1\n                else:\n                    neg += 1\n            total += max(pos, neg)\n    if bad:\n        print(-1)\n    else:\n        print(total)", "from collections import defaultdict, deque\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    fine = False\n    col = [-1] * (n + 1)\n    ans = 0\n    a = defaultdict(list)\n    for _ in range(q):\n        (u, v, t) = input().split()\n        (u, v) = (int(u), int(v))\n        t = 1 if t == 'imposter' else 2\n        a[u].append((v, t))\n        a[v].append((u, t))\n    for i in range(1, n + 1):\n        if col[i] == -1:\n            c1 = 1\n            c2 = 0\n            col[i] = 1\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for x in a[node]:\n                    n1 = x[0]\n                    type = x[1]\n                    if col[n1] != -1:\n                        if type == 1 and col[node] == col[n1]:\n                            fine = True\n                            break\n                        if type == 2 and col[node] != col[n1]:\n                            fine = True\n                            break\n                    else:\n                        if type == 1:\n                            col[n1] = 3 - col[node]\n                        else:\n                            col[n1] = col[node]\n                        if col[n1] == 1:\n                            c1 += 1\n                        else:\n                            c2 += 1\n                        queue.append(n1)\n            ans += max(c1, c2)\n    if fine:\n        print(-1)\n    else:\n        print(ans)", "def ss(n, m, d):\n    v = [-1 for _ in range(n)]\n    (a, b) = (0, 0)\n\n    def pp(node):\n        nonlocal a, b\n        v[node] = 0\n        q = [node]\n        while q:\n            q1 = []\n            for node in q:\n                if v[node] == 0:\n                    a += 1\n                else:\n                    b += 1\n                for (child, color) in d[node]:\n                    if v[child] == -1:\n                        v[child] = v[node] ^ color\n                        q1.append(child)\n                    elif v[child] != v[node] ^ color:\n                        return False\n            q = q1\n        return True\n    ans = 0\n    for i in range(n):\n        if v[i] == -1:\n            if pp(i):\n                ans += max(a, b)\n                a = 0\n                b = 0\n            else:\n                return -1\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = {i: set() for i in range(n)}\n    for i in range(m):\n        (a, b, c) = map(str, input().split())\n        (a, b) = (int(a), int(b))\n        if c[0] == 'i':\n            c = 1\n        else:\n            c = 0\n        a -= 1\n        b -= 1\n        d[a].add((b, c))\n        d[b].add((a, c))\n    print(ss(n, m, d))", "from collections import defaultdict, deque\nimport sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = defaultdict(list)\n    for i in range(m):\n        (a, b, c) = map(str, input().split())\n        (a, b) = (int(a), int(b))\n        if c[0] == 'i':\n            d[a].append((b, 1))\n            d[b].append((a, 1))\n        else:\n            d[a].append((b, 2))\n            d[b].append((a, 2))\n    color = [-1] * (n + 1)\n    q = deque()\n    ans = 0\n    iscon = False\n    for i in range(1, n + 1):\n        (c1, c2) = (0, 0)\n        if color[i] == -1:\n            q.append(i)\n            color[i] = 1\n            while len(q) > 0:\n                u = q.popleft()\n                if color[u] == 1:\n                    c1 += 1\n                else:\n                    c2 += 1\n                for val in d[u]:\n                    v = val[0]\n                    typ = val[1]\n                    if color[v] != -1:\n                        if typ == 1 and color[v] == color[u]:\n                            iscon = True\n                        if typ == 2 and color[v] != color[u]:\n                            iscon = True\n                        continue\n                    if typ == 1:\n                        color[v] = 3 - color[u]\n                    else:\n                        color[v] = color[u]\n                    q.append(v)\n        ans += max(c1, c2)\n    if iscon:\n        print(-1)\n    else:\n        print(ans)"]