["def count_2(ai):\n    res = 0\n    while not ai % 2:\n        ai = ai // 2\n        res += 1\n    return res\n\ndef output(a, n):\n    n2 = 0\n    res = 0\n    for ai in a:\n        n2 += count_2(ai)\n        if n2 > n:\n            return 0\n    nearest_2 = 1\n    n1 = n\n    while n1 >= 2 ** nearest_2:\n        nearest_2 += 1\n    nearest_2 -= 1\n    n_2 = 1\n    t_selected = 0\n    while n2 < n and nearest_2 > 0:\n        if n_2 > 0:\n            n2 += nearest_2\n            n_2 -= 1\n            res += 1\n            t_selected += 1\n        else:\n            nearest_2 -= 1\n            n_2 = n // 2 ** nearest_2 - t_selected\n    if n2 < n:\n        return -1\n    return res\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    res = output(a, n)\n    print(res)", "def solve(n, arr):\n    dp = [0, 0]\n    twos = 0\n    for val in arr:\n        num = val\n        while not num % 2:\n            num //= 2\n            twos += 1\n            if twos == n:\n                return 0\n    for i in range(2, n + 1):\n        if i % 2:\n            dp.append(0)\n        else:\n            dp.append(dp[i // 2] + 1)\n    dp.sort(reverse=True)\n    ans = 0\n    for val in dp:\n        ans += 1\n        twos += val\n        if twos >= n:\n            return ans\n    return -1\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(solve(n, arr))", "def dvo(x):\n    if x % 2 == 0:\n        return dvo(x // 2) + 1\n    else:\n        return 0\nfor i in range(int(input())):\n    N = n = int(input())\n    a = input().split()\n    otv = 0\n    op = 1\n    for k in a:\n        k = int(k)\n        n -= dvo(k)\n        if n <= 0:\n            break\n    if n > 0:\n        som = []\n        for x in range(2, N + 1, 2):\n            som += [dvo(x)]\n        som.sort()\n        som.reverse()\n        while n > 0 and otv < len(som):\n            n -= som[otv]\n            otv += 1\n    if n > 0:\n        print(-1)\n    else:\n        print(otv)", "from typing import Counter\nimport sys\ninput = sys.stdin.readline\n\ndef print(*args, end='\\n', sep=' ') -> None:\n    sys.stdout.write(sep.join(map(str, args)) + end)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    col = 0\n    for i in range(n):\n        while l[i] % 2 == 0:\n            l[i] >>= 1\n            col += 1\n        if col >= n:\n            break\n    if col >= n:\n        print(0)\n        continue\n    col_2 = 0\n    d = 1\n    while d * 2 <= n:\n        col_2 += 1\n        d *= 2\n    ans = 0\n    while d != 1 and col < n:\n        for _ in range(d, n + 1, 2 * d):\n            col += col_2\n            ans += 1\n            if col >= n:\n                break\n        d //= 2\n        col_2 -= 1\n    if col >= n:\n        print(ans)\n    else:\n        print(-1)", "import math\ntestcases = int(input())\nwhile testcases > 0:\n    testcases -= 1\n    n = int(input())\n    twopower = 0\n    lst = [int(x) for x in input().split()]\n    for element in lst:\n        twopower += int(math.log(element & ~(element - 1), 2))\n    if twopower >= n:\n        print(0)\n        continue\n    balance = n - twopower\n    maxpower = int(math.log(n, 2))\n    temporary = 0\n    floordiv_value = 0\n    answer = 0\n    while maxpower > 0:\n        floordiv_value = n // pow(2, maxpower)\n        current = int(floordiv_value - temporary)\n        if current * maxpower >= balance:\n            answer += float(balance) / maxpower\n            balance = 0\n            answer = math.ceil(answer)\n            break\n        temporary = floordiv_value\n        answer += current\n        balance -= current * maxpower\n        maxpower -= 1\n    if balance > 0:\n        print(-1)\n    else:\n        print(int(answer))", "def gs(x):\n    to = 0\n    while x % 2 == 0:\n        to += 1\n        x /= 2\n    return to\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    nums = [int(temp) for temp in input().split()]\n    odd = 0\n    jl = [0] * (n + 1)\n    flag = 0\n    k = 0\n    for j in range(n - 1, -1, -1):\n        odd += gs(nums[j])\n        if odd >= n:\n            flag = 1\n            break\n    if flag == 0:\n        for i in range(1, n + 1):\n            jl[i] = gs(i)\n        jl.sort()\n        for i in range(n, 0, -1):\n            odd += jl[i]\n            k += 1\n            if odd >= n:\n                flag = 1\n                break\n        if flag == 1:\n            print(k)\n        else:\n            print(-1)\n    else:\n        print(k)", "k = int(input())\nfor l in range(k):\n    n = int(input())\n    a = list(map(int, input().split()))\n    temp = n\n    flag = 0\n    for i in range(n):\n        b = a[i]\n        while True:\n            if b % 2 == 0:\n                temp -= 1\n                b /= 2\n            else:\n                break\n        if temp <= 0:\n            print(0)\n            flag = 1\n            break\n    if flag == 0:\n        arr = []\n        for i in range(1, n + 1):\n            cnt = 0\n            c = i\n            while True:\n                if c % 2 == 0:\n                    cnt += 1\n                    c = c / 2\n                else:\n                    break\n            if cnt > 0:\n                arr.append(cnt)\n        arr = sorted(arr)\n        arr = arr[::-1]\n        ans = 0\n        for i in range(len(arr)):\n            temp -= arr[i]\n            ans += 1\n            if temp <= 0:\n                print(ans)\n                flag = 1\n                break\n        if temp > 0:\n            print(-1)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    mmm = []\n    if 0 in a:\n        print(0)\n        continue\n    k2 = 0\n    op = 0\n    f = 0\n    for j in range(n):\n        while a[j] % 2 == 0:\n            k2 += 1\n            a[j] //= 2\n            if k2 >= n:\n                f = 1\n                break\n        if f:\n            break\n    if k2 < n:\n        for j in range(n - 1, 0, -1):\n            m = 0\n            x = j + 1\n            while x % 2 == 0:\n                m += 1\n                x //= 2\n            mmm.append(m)\n        mmm.sort(reverse=True)\n        for el in mmm:\n            k2 += el\n            op += 1\n            if k2 >= n:\n                break\n    if k2 >= n:\n        print(op)\n    else:\n        print(-1)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def factor(n):\n        count = 0\n        while n // 2 == n / 2:\n            count = count + 1\n            n = n / 2\n        return count\n\n    def answer(n, a):\n        c = 0\n        l = []\n        for i in range(n):\n            c = c + factor(a[i])\n            l.append(factor(i + 1))\n            if c >= n:\n                return 0\n        d = 0\n        l.sort()\n        x = n - 1\n        while x >= 0:\n            c = c + l[x]\n            d = d + 1\n            x = x - 1\n            if c >= n:\n                return d\n        return -1\n    print(answer(n, a))", "def count_2(x):\n    c = 0\n    while x % 2 == 0:\n        c += 1\n        x //= 2\n    return c\nfor _ in range(int(input())):\n    l = []\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    (already, op) = (0, 0)\n    for (i, x) in enumerate(a):\n        if already >= n:\n            break\n        already += count_2(x)\n        op = count_2(i + 1)\n        if op != 0:\n            l.append(op)\n    if already >= n:\n        print(0)\n        continue\n    l.sort(reverse=True)\n    n -= already\n    c = 0\n    for k in l:\n        n -= k\n        c += 1\n        if n <= 0:\n            break\n    if n > 0:\n        print(-1)\n    else:\n        print(c)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    nown = 0\n    for i in range(n):\n        while not a[i] & 1:\n            nown += 1\n            a[i] = a[i] >> 1\n            if nown >= n:\n                break\n    if nown >= n:\n        print(0)\n        continue\n    answer = 0\n    step = 1\n    maxn = 0\n    while step < n:\n        step = step * 2\n        maxn += 1\n    if step > n:\n        step = step >> 1\n        maxn -= 1\n    if maxn <= 0:\n        print(-1)\n        continue\n    while nown < n:\n        unchet = 1\n        while step * unchet <= n:\n            nown += maxn\n            answer += 1\n            unchet += 2\n            if nown >= n:\n                break\n        maxn -= 1\n        step = step >> 1\n        if maxn <= 0:\n            break\n    if nown >= n:\n        print(answer)\n        continue\n    else:\n        print(-1)\n        continue", "n = int(input())\nfor i in range(n):\n    t = int(input())\n    count = 0\n    ans = 0\n    k = 0\n    dvoiki = []\n    s = str(input()).split()\n    s = [int(a) for a in s]\n    for j in range(len(s)):\n        if s[j] % 2 == 0:\n            while s[j] % 2 == 0:\n                if k == t:\n                    break\n                s[j] = s[j] / 2\n                k += 1\n    if k < t:\n        for j in range(len(s)):\n            m = j + 1\n            kolvo = 0\n            if m % 2 == 0:\n                while m % 2 == 0:\n                    m = m / 2\n                    kolvo += 1\n                dvoiki.append(kolvo)\n        dvoiki = sorted(dvoiki, reverse=True)\n        for g in dvoiki:\n            if k >= t:\n                break\n            k += g\n            count += 1\n        if k >= t:\n            ans = count\n        else:\n            ans = -1\n    else:\n        ans = 0\n    print(ans)", "import math\n\ndef foo(n, ls):\n    needs = n\n    pows = []\n    for (i, val) in enumerate(ls):\n        ilog = int(math.log2(i + 1 & -(i + 1)))\n        if ilog > 0:\n            pows.append(ilog)\n        vlog = int(math.log2(val & -val))\n        needs -= vlog\n    if needs <= 0:\n        return 0\n    pows.sort()\n    ans = 0\n    while needs > 0 and pows:\n        needs -= pows.pop()\n        ans += 1\n    if needs > 0:\n        return -1\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ls = [int(i) for i in input().split()]\n    print(foo(n, ls))", "import math\n\ndef highestPowerOf2(n):\n    return n & ~(n - 1)\nfor i in range(int(input())):\n    n = int(input())\n    arrI = list(map(int, input().split()))\n    sumOfPowTwo = 0\n    for i in arrI:\n        sumOfPowTwo += math.log(highestPowerOf2(i), 2)\n    sumOfPowTwo = int(sumOfPowTwo)\n    if sumOfPowTwo >= n:\n        print(0)\n    else:\n        arrPow2 = []\n        for i in range(n):\n            arrPow2.append(int(math.log(highestPowerOf2(i + 1), 2)))\n        if sum(arrPow2) + sumOfPowTwo < n:\n            print(-1)\n        else:\n            arrPow2.sort(reverse=True)\n            for i in range(n):\n                if sumOfPowTwo >= n:\n                    print(i)\n                    break\n                else:\n                    sumOfPowTwo += arrPow2[i]", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    cd = []\n    c = 0\n    for i in range(n):\n        j = a[i]\n        c += max((j & -j).bit_length() - 1, 0)\n        cd.append(max((i + 1 & -(i + 1)).bit_length() - 1, 0))\n    s = sum(cd)\n    cd.sort(reverse=True)\n    if c < n:\n        if s >= n - c:\n            k = n - c\n            coun = 0\n            for p in cd:\n                if k >= p:\n                    k -= p\n                    coun += 1\n                    if k == 0:\n                        break\n            print(coun)\n        if s < n - c:\n            print(-1)\n    else:\n        print(0)", "from math import log2\n\ndef get_power_of_two(n):\n    return int(log2(n & ~(n - 1)))\nfor _ in range(int(input())):\n    n = int(input())\n    array = list(map(int, input().split()))\n    power_sum = 0\n    extra_powers = []\n    for (i, number) in enumerate(array):\n        power_sum += get_power_of_two(number)\n        if (extra_power := get_power_of_two(i + 1)):\n            extra_powers.append(extra_power)\n    extra_powers = sorted(extra_powers)\n    operations = 0\n    while power_sum < n:\n        if len(extra_powers) == 0:\n            operations = -1\n            break\n        power_sum += extra_powers.pop()\n        operations += 1\n    print(operations)", "from math import *\nfor z in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = 0\n    i = 1\n    z = []\n    while i <= n:\n        b2 = bin(a[i - 1])\n        y1 = len(b2) - b2.rfind('1') - 1\n        b1 = bin(i)\n        y2 = len(b1) - b1.rfind('1') - 1\n        z.append(y2)\n        p += y1\n        i += 1\n    p1 = bin(p)\n    p = n - p\n    z.sort()\n    ans = 0\n    try:\n        while p > 0:\n            p -= z.pop()\n            ans += 1\n        print(ans)\n    except:\n        print(-1)", "from math import ceil\nfrom math import sqrt\nfrom collections import Counter\n\ndef hpt(el):\n    p = 0\n    while el % 2 ** p == 0:\n        p += 1\n    return p - 1\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    on = 0\n    m = n\n    for i in range(n):\n        cal = hpt(l[i])\n        m -= cal\n        if m <= 0:\n            on = 1\n            break\n    if on == 1:\n        print(0)\n    else:\n        idx_ = []\n        for i in range(2, n + 1, 2):\n            idx_.append(i)\n        pht = []\n        for i in range(len(idx_)):\n            cal = hpt(idx_[i])\n            pht.append(cal)\n        pht.sort()\n        on2 = 0\n        op = 0\n        for i in range(1, len(pht) + 1):\n            m -= pht[-i]\n            if m <= 0:\n                on2 = 1\n                op += 1\n                break\n            op += 1\n        if m <= 0:\n            print(op)\n        else:\n            print(-1)", "tc = int(input())\noperations_list = [0] * 200000\nfor j in range(0, 2 * 10 ** 5):\n    c_num = 2 * 10 ** 5 - j\n    num_twos = 0\n    while c_num % 2 == 0 and c_num != 0:\n        num_twos += 1\n        c_num = c_num / 2\n    operations_list[2 * 10 ** 5 - j - 1] = num_twos\nfor z in range(0, tc):\n    k = int(input())\n    arr_copy = [0] * k\n    for l in range(0, k):\n        arr_copy[l] = operations_list[l]\n    arr = [int(part) for part in input().split()]\n    count = 0\n    num_oper = -1\n    for i in range(0, k):\n        c_num = arr[i]\n        while c_num % 2 == 0 and c_num != 0:\n            count += 1\n            c_num = c_num / 2\n        if count >= k:\n            num_oper = 0\n            break\n    if count < k:\n        twos_needed = k - count\n        arr_copy.sort(reverse=True)\n        added_operations = 0\n        for p in range(0, len(arr_copy)):\n            twos_needed -= arr_copy[p]\n            added_operations += 1\n            if twos_needed <= 0:\n                break\n        if twos_needed <= 0:\n            print(added_operations)\n        else:\n            print(-1)\n    else:\n        print(0)", "import sys\nsys.setrecursionlimit(200000)\nimport math\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\ninput = sys.stdin.readline\nfrom functools import lru_cache\nimport heapq\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\npower = []\n\n@lru_cache(None)\ndef find(i):\n    return 1 + find(i // 2) if i % 2 == 0 else 0\nfor i in range(1, 2 * 10 ** 5 + 1):\n    power.append(find(i))\nfor _ in range(inp()):\n    n = inp()\n    arr = inlt()\n    number = 0\n    ans = 0\n    for i in range(n):\n        number += find(arr[i])\n    if number >= n:\n        print(ans)\n        continue\n    else:\n        p = power[:n]\n        p.sort(reverse=True)\n        for i in range(n):\n            ans += 1\n            number += p[i]\n            if number >= n:\n                break\n        print(ans) if number >= n else print(-1)", "all_twos = {'1': 0, '2': 1}\n\ndef count_twos(n, memo={}):\n    if n in memo.keys():\n        return memo[n]\n    else:\n        if n % 2 == 0:\n            memo[n] = 1 + count_twos(n / 2, memo)\n            return memo[n]\n        memo[n] = 0\n        return memo[n]\nt = int(input())\nfor a0 in range(t):\n    n = int(input())\n    total_twos = sum([count_twos(int(i), all_twos) for i in str(input()).strip().split()])\n    if total_twos >= n:\n        print(0)\n    else:\n        n_twos = [count_twos(i, all_twos) for i in range(1, n + 1)]\n        n_twos.sort()\n        (it, id) = (0, n - 1)\n        while id >= 0 and total_twos < n:\n            total_twos += n_twos[id]\n            it += 1\n            id -= 1\n        if total_twos >= n:\n            print(it)\n        else:\n            print(-1)", "import functools\ntem = [0] * 200001\nsu = [0] * 200001\n\n@functools.lru_cache(None)\ndef cal(a):\n    if a % 2 == 1:\n        return 0\n    else:\n        return 1 + cal(a // 2)\nfor i in range(2, 200001):\n    tem[i] = cal(i)\n    su[i] = su[i - 1] + tem[i]\nfor jj in range(int(input())):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    c = 0\n    for i in arr:\n        c += cal(i)\n    if c >= n:\n        print(0)\n    elif n - c > su[n]:\n        print(-1)\n    else:\n        tt = sorted(tem[:n + 1], reverse=True)\n        cap = n - c\n        for i in range(n + 1):\n            cap -= tt[i]\n            if cap <= 0:\n                print(i + 1)\n                break", "def numD2(n, mem):\n    if n in mem:\n        return mem[n]\n    if n % 2:\n        mem[n] = 0\n        return 0\n    else:\n        mem[n] = numD2(n // 2, mem) + 1\n        return mem[n]\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    resources = [(-1, i) for i in range(1, n + 1)]\n    for i in range(n):\n        (nb2, vi) = resources[i]\n        if i > n // 2:\n            break\n        if nb2 == -1:\n            if vi % 2 == 0:\n                nb2 = 1\n            else:\n                nb2 = 0\n            resources[i] = (nb2, vi)\n            while vi <= n // 2:\n                vi *= 2\n                nb2 += 1\n                resources[vi - 1] = (nb2, vi)\n    resources = [i for i in resources if i[0] > 0]\n    resources.sort()\n    divided = 0\n    memo = dict()\n    for i in range(n):\n        divided += numD2(a[i], memo)\n    nbOp = 0\n    while divided < n:\n        if len(resources) == 0:\n            print(-1)\n            break\n        (op, _) = resources.pop()\n        nbOp += 1\n        divided += op\n    else:\n        print(nbOp)", "def bipo(a: int) -> int:\n    po = 0\n    while a % 2 == 0:\n        po += 1\n        a //= 2\n    return po\nfor _ in range(int(input())):\n    n = int(input())\n    a = sum(list(map(lambda x: bipo(int(x)), input().split())))\n    if n <= a:\n        print(0)\n        continue\n    indices = [bipo(x) for x in range(1, n + 1)]\n    indices.sort(reverse=True)\n    op = 0\n    while indices[op] and a < n:\n        a += indices[op]\n        op += 1\n    if a < n:\n        print(-1)\n    else:\n        print(op)", "def p(n):\n    (l, r) = (0, 1)\n    while 2 ** r <= n:\n        (l, r) = (r, r * 2)\n    while r - l > 1:\n        m = (l + r) // 2\n        if 2 ** m <= n:\n            l = m\n        else:\n            r = m\n    return l\n\ndef one():\n    n = int(input())\n    a = list(map(int, input().split()))\n    v = sorted((p(k & -k) for k in range(1, n + 1)))\n    z = sum((p(e & -e) for e in a))\n    c = 0\n    while z < n and v:\n        z += v.pop()\n        c += 1\n    print(c if v else -1)\nt = int(input())\nfor i in range(t):\n    one()", "def bipo(a: int) -> int:\n    po = 0\n    while a % 2 == 0:\n        po += 1\n        a //= 2\n    return po\nfor _ in range(int(input())):\n    n = int(input())\n    a = sum(list(map(lambda x: bipo(int(x)), input().split())))\n    if n <= a:\n        print(0)\n        continue\n    indices = [bipo(x) for x in range(2, n + 1, 2)]\n    indices.sort(reverse=True)\n    l = len(indices)\n    op = 0\n    while op < l and a < n:\n        a += indices[op]\n        op += 1\n    if a < n:\n        print(-1)\n    else:\n        print(op)", "import sys\nimport math\nimport heapq\nfrom functools import lru_cache\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef count2s(num):\n    count = 0\n    while num % 2 == 0:\n        count += 1\n        num //= 2\n    return count\n\ndef main():\n    n = inp()\n    array = inlt()\n    twoCount = 0\n    for num in array:\n        twoCount += count2s(num)\n    if n % 2 == 0:\n        num = n\n    else:\n        num = n - 1\n    countsOf2ByIndex = []\n    for i in range(2, num + 1, 2):\n        count = count2s(i)\n        countsOf2ByIndex.append(count)\n    countsOf2ByIndex.sort(reverse=True)\n    needed = 0\n    i = 0\n    while twoCount < n and i < len(countsOf2ByIndex):\n        twoCount += countsOf2ByIndex[i]\n        i += 1\n        needed += 1\n    if twoCount >= n:\n        print(needed)\n    else:\n        print(-1)\nt = inp()\nfor _ in range(t):\n    main()", "from collections import deque\nInputList = lambda Dtype: [Dtype(x) for x in input().split()]\nfrom functools import lru_cache\nfrom math import pi, log2\n\ndef solve():\n    N = int(input())\n    nums = InputList(int)\n\n    def find_max_power_of_2(n):\n        count = 0\n        while n % 2 == 0:\n            n //= 2\n            count += 1\n        return count\n    used = set()\n    have = sum((find_max_power_of_2(x) for x in nums))\n    need = N - have\n    if need <= 0:\n        return 0\n    cur = int(log2(N))\n    ans = 0\n    while need > 0 and cur >= 1:\n        factor = 1\n        candidate = 2 ** cur * factor\n        while candidate <= N:\n            if candidate not in used:\n                used.add(candidate)\n                ans += 1\n                need -= cur\n                if need <= 0:\n                    return ans\n            factor += 1\n            candidate = 2 ** cur * factor\n        cur -= 1\n    return -1\nReturnMode = True\nt = 0\nif not t:\n    t = int(input())\nfor _ in range(t):\n    ans = solve()\n    if ReturnMode:\n        print(ans) if type(ans) != list else print(*ans)", "def solve():\n    n = int(input())\n    lis = list(map(int, input().split()))\n    ans = 0\n    for i in lis:\n        while not i % 2:\n            ans += 1\n            i //= 2\n    if ans >= n:\n        print(0)\n        return\n    cnt = 0\n    ref = list()\n    for i in range(n + 1):\n        cnt = int()\n        while not i % 2 and i > 0:\n            i //= 2\n            cnt += 1\n        ref.append(cnt)\n    ref.sort(reverse=True)\n    i = 0\n    cnt = 0\n    while i < len(ref) and ans < n:\n        ans += ref[i]\n        i += 1\n        cnt += 1\n    print(-1 if ans < n else cnt)\nfor _ in range(int(input())):\n    solve()", "import sys\nfrom collections import *\nsys.setrecursionlimit(10 ** 5)\nitr = (line for line in sys.stdin.read().strip().split('\\n'))\nINP = lambda : next(itr)\n\ndef ni():\n    return int(INP())\n\ndef nl():\n    return [int(_) for _ in INP().split()]\n\ndef solve(n, a):\n    e = 0\n    d = {}\n    for i in range(1, 32):\n        d[2 ** i] = i\n    div = list(d.keys())\n    for i in a:\n        if i % 2 == 0:\n            best = 2\n            for num in div:\n                if i % num == 0:\n                    best = num\n            e += d[best]\n    if e >= n:\n        print(0)\n        return\n    add = 0\n    fa = []\n    for i in range(n, 0, -1):\n        if i % 2 == 0:\n            best = 2\n            for num in div:\n                if i % num == 0:\n                    best = num\n            fa.append(d[best])\n    fa.sort(reverse=True)\n    for i in fa:\n        e += i\n        add += 1\n        if e >= n:\n            print(add)\n            return\n    print(-1)\n    return\nt = ni()\nfor case in range(t):\n    n = ni()\n    a = nl()\n    solve(n, a)", "import math\nimport collections\nimport bisect\nimport heapq\nfrom collections import deque\nfrom math import sqrt, ceil, floor\n\ndef inp_arr():\n    return list(map(int, input().strip().split(' ')))\n\ndef inp_str_arr():\n    return list(input().strip().split(' '))\n\ndef inp_str():\n    return input()\n\ndef cal_2s(n):\n    cnt = 0\n    while n % 2 == 0:\n        cnt += 1\n        n = n // 2\n    return cnt\n\ndef solve():\n    (n,) = inp_arr()\n    a = inp_arr()\n    cnt = 0\n    for x in a:\n        cnt += cal_2s(x)\n    if cnt >= n:\n        print(0)\n        return\n    lis = []\n    for i in range(1, n + 1):\n        lis.append(cal_2s(i))\n    lis.sort(reverse=True)\n    need = n - cnt\n    ans = 0\n    i = 0\n    while need > 0 and i < n:\n        ans += 1\n        need = need - lis[i]\n        i += 1\n    if need > 0:\n        print(-1)\n        return\n    print(ans)\n(tt,) = inp_arr()\nfor t in range(tt):\n    solve()", "def solve():\n    n = int(input())\n    lis = list(map(int, input().split()))\n    ans = 0\n    for i in lis:\n        while not i % 2:\n            ans += 1\n            i //= 2\n    if ans >= n:\n        print(0)\n        return\n    cnt = 0\n    ref = list()\n    for i in range(n + 1):\n        cnt = int()\n        while not i % 2 and i > 0:\n            i //= 2\n            cnt += 1\n        ref.append(cnt)\n    ref.sort(reverse=True)\n    i = 0\n    cnt = 0\n    while i < len(ref) and ans < n:\n        ans += ref[i]\n        i += 1\n        cnt += 1\n    print(-1 if ans < n else cnt)\nfor _ in range(int(input())):\n    solve()", "def factor(a):\n    count = 0\n    while a % 2 == 0:\n        count += 1\n        a = a // 2\n    return count\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().strip().split()))\n    factor_sum = 0\n    for i in range(n):\n        factor_sum += factor(arr[i])\n    diff = n - factor_sum\n    if diff <= 0:\n        print(0)\n    else:\n        factor_list = []\n        for i in range(1, n + 1):\n            factor_list.append(factor(i))\n        factor_list.sort(reverse=True)\n        count = 0\n        start = 0\n        while diff > 0:\n            diff -= factor_list[start]\n            count += 1\n            start += 1\n            if start == n and diff > 0:\n                count = -1\n                break\n        print(count)", "from sys import stdin\n\ndef cant_2(a):\n    cont = 0\n    for n in a:\n        while n % 2 == 0:\n            cont += 1\n            n = n // 2\n    return cont\n\ndef main():\n    cases = int(stdin.readline().strip())\n    for c in range(cases):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        m = cant_2(a)\n        if m >= n:\n            print('0')\n        elif n == 1:\n            print('-1')\n        else:\n            if n % 2 == 0:\n                k = n\n            else:\n                k = n - 1\n            lista = [i for i in range(2, k + 1, 2)]\n            pasos = []\n            for l in lista:\n                cont = 0\n                while l % 2 == 0:\n                    cont += 1\n                    l = l // 2\n                pasos += [cont]\n            p = sorted(pasos)\n            andando = 0\n            flag = True\n            while len(p) > 0 and flag:\n                a = p.pop()\n                m += a\n                andando += 1\n                if m >= n:\n                    print(str(andando))\n                    flag = False\n            if flag:\n                print('-1')\nmain()", "t = int(input())\n\ndef timesDivisible(k):\n    tot = 0\n    while k % 2 == 0:\n        tot += 1\n        k //= 2\n    return tot\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    twos = 0\n    for i in range(n):\n        twos += timesDivisible(a[i])\n    if twos >= n:\n        print(0)\n    else:\n        moves = 0\n        q = []\n        for i in range(n, 0, -1):\n            if i % 2 == 0:\n                q.append(timesDivisible(i))\n        q.sort(reverse=True)\n        for i in range(len(q)):\n            twos += q[i]\n            moves += 1\n            if twos >= n:\n                break\n        if twos >= n:\n            print(moves)\n        else:\n            print(-1)", "def main():\n    n_tests = int(input())\n    for _ in range(n_tests):\n        n = int(input())\n        arr = list(map(int, input().split(' ')))\n        twos = 0\n        for elem in arr:\n            t = 0\n            e_init = elem\n            while elem % 2 == 0:\n                t += 1\n                elem = elem // 2\n            twos += t\n        if twos >= n:\n            print(0)\n            continue\n        idx = []\n        for x in range(1, n + 1):\n            e_init = elem\n            x_init = x\n            t = 0\n            while elem % 2 == 0:\n                t += 1\n                elem = elem // 2\n            while x % 2 == 0:\n                t += 1\n                x = x // 2\n            idx.append((x_init, t))\n        ops = 0\n        for pair in reversed(sorted(idx, key=lambda x: x[1])):\n            ops += 1\n            twos += pair[1]\n            if twos >= n:\n                break\n        if twos >= n:\n            print(ops)\n        else:\n            print(-1)\nmain()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n\n    def twos(p):\n        count = 0\n        while p % 2 == 0:\n            count += 1\n            p = p // 2\n        return count\n    num_of_twos = 0\n    for i in lst:\n        num_of_twos += twos(i)\n    remain = n - num_of_twos\n    if remain <= 0:\n        print(0)\n    else:\n        count = 0\n        array = []\n        for i in range(2, n + 1):\n            array.append(twos(i))\n        array.sort(reverse=True)\n        for i in array:\n            if remain >= i:\n                remain -= i\n                count += 1\n            if remain == 0:\n                break\n        if remain > 0:\n            print(-1)\n        else:\n            print(count)", "import sys\nimport math\nimport heapq\nfrom functools import lru_cache\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef count2s(num):\n    count = 0\n    while num % 2 == 0:\n        count += 1\n        num //= 2\n    return count\n\ndef main():\n    n = inp()\n    array = inlt()\n    twoCount = 0\n    for num in array:\n        twoCount += count2s(num)\n    needed = 0\n    if n % 2 == 0:\n        num = n\n    else:\n        num = n - 1\n    countsOf2ByIndex = []\n    for i in range(num, 0, -2):\n        count = count2s(i)\n        countsOf2ByIndex.append(count)\n    countsOf2ByIndex.sort(reverse=True)\n    i = 0\n    while twoCount < n and i < len(countsOf2ByIndex):\n        twoCount += countsOf2ByIndex[i]\n        i += 1\n        needed += 1\n    if twoCount >= n:\n        print(needed)\n    else:\n        print(-1)\nt = inp()\nfor _ in range(t):\n    main()", "from collections import defaultdict, Counter, deque\nimport sys\nimport threading\nfrom sys import stdin, stdout\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\n\ndef main():\n\n    def count_two(num):\n        count = 0\n        while num and (not num % 2):\n            count += 1\n            num //= 2\n        return count\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        nums = list(map(int, stdin.readline().split()))\n        have = []\n        count = 0\n        total = 0\n        rem = 0\n        for (idx, num) in enumerate(nums):\n            twos = count_two(idx + 1)\n            total += count_two(num)\n            if twos:\n                have.append(twos)\n        if total:\n            if total % n and total < n:\n                rem = n - total\n        else:\n            rem = n\n        have.sort()\n        while rem and have:\n            popped = have.pop()\n            if popped <= rem:\n                rem -= popped\n                count += 1\n        if rem:\n            print(-1)\n        else:\n            print(count)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "def solve():\n    n = int(input())\n    lis = list(map(int, input().split()))\n    cnt = 0\n    for i in lis:\n        while not i % 2:\n            i //= 2\n            cnt += 1\n    if cnt >= n:\n        print(0)\n        return\n    ref = list()\n    tot_sum = cnt\n    for i in range(n + 1):\n        cnt = 0\n        while not i % 2 and i > 0:\n            cnt += 1\n            i //= 2\n        ref.append(cnt)\n    ref.sort(reverse=True)\n    ans = 0\n    i = 0\n    while i < len(ref) and tot_sum < n:\n        tot_sum += ref[i]\n        i += 1\n        ans += 1\n    print(ans if tot_sum >= n else -1)\nfor _ in range(int(input())):\n    solve()", "def solve():\n    n = int(input())\n    lis = list(map(int, input().split()))\n    ans = 0\n    for i in lis:\n        while not i % 2:\n            ans += 1\n            i //= 2\n    if ans >= n:\n        print(0)\n        return\n    cnt = 0\n    ref = list()\n    for i in range(n + 1):\n        cnt = int()\n        while not i % 2 and i > 0:\n            i //= 2\n            cnt += 1\n        ref.append(cnt)\n    ref.sort(reverse=True)\n    i = 0\n    cnt = 0\n    while i < len(ref) and ans < n:\n        ans += ref[i]\n        i += 1\n        cnt += 1\n    print(-1 if ans < n else cnt)\nfor _ in range(int(input())):\n    solve()", "def solve():\n    n = int(input())\n    lis = list(map(int, input().split()))\n    ans = 0\n    for i in lis:\n        while not i % 2:\n            ans += 1\n            i //= 2\n    if ans >= n:\n        print(0)\n        return\n    cnt = 0\n    ref = list()\n    for i in range(n + 1):\n        cnt = int()\n        while not i % 2 and i > 0:\n            i //= 2\n            cnt += 1\n        ref.append(cnt)\n    ref.sort(reverse=True)\n    i = 0\n    cnt = 0\n    while i < len(ref) and ans < n:\n        ans += ref[i]\n        i += 1\n        cnt += 1\n    print(-1 if ans < n else cnt)\nfor _ in range(int(input())):\n    solve()", "def my_log(n):\n    ans = 0\n    while not n % 2:\n        n //= 2\n        ans += 1\n    return ans\nfor _ in range(int(input())):\n    (n, l) = (int(input()), list(map(int, input().split())))\n    prod = 0\n    for i in l:\n        prod += my_log(i)\n    ans = 0\n    ind_logs = sorted(map(my_log, range(1, n + 1)), reverse=True)\n    for i in ind_logs:\n        if prod >= n:\n            break\n        prod += i\n        ans += 1\n    print(-1 if prod < n else ans)", "def bipo(a: int) -> int:\n    po = 0\n    while a % 2 == 0:\n        po += 1\n        a //= 2\n    return po\nfor _ in range(int(input())):\n    n = int(input())\n    a = sum(list(map(lambda x: bipo(int(x)), input().split())))\n    indices = list(range(1, n + 1))\n    indices.sort(key=lambda x: bipo(x), reverse=True)\n    op = 0\n    while indices[op] % 2 == 0 and a < n:\n        a += bipo(indices[op])\n        op += 1\n    if a < n:\n        print(-1)\n    else:\n        print(op)", "def implementation(n, data):\n    initial = 0\n    for i in range(n):\n        initial += find_power(data[i])\n    if initial >= n:\n        print(0)\n        return\n    adder = less(n)\n    if adder == 0:\n        print(-1)\n        return\n    compare = 2 ** adder\n    multiplier = 1\n    steps = 0\n    while adder > 0 and initial < n:\n        while compare * multiplier <= n and initial < n:\n            initial += adder\n            multiplier += 2\n            steps += 1\n        multiplier = 1\n        adder -= 1\n        compare = compare // 2\n    if initial < n:\n        print(-1)\n    else:\n        print(steps)\n\ndef find_power(num):\n    power = 0\n    while num % 2 == 0:\n        power += 1\n        num = num // 2\n    return power\n\ndef less(num):\n    answer = 0\n    compare = 1\n    while compare <= num:\n        compare *= 2\n        answer += 1\n    return answer - 1\nt = int(input())\nfor i in range(t):\n    length = int(input())\n    data = input().split(' ')\n    for i in range(len(data)):\n        data[i] = int(data[i])\n    implementation(length, data)", "from math import ceil\n\ndef count_two(x):\n    ans = 0\n    while x % 2 == 0:\n        ans += 1\n        x //= 2\n    return ans\n\ndef count_bits(n):\n    ans = 0\n    while n > 0:\n        n //= 2\n        ans += 1\n    return ans - 1\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    twos = 0\n    for x in a:\n        twos += count_two(x)\n    if twos >= n:\n        print(0)\n    else:\n        ans = 0\n        b = count_bits(n)\n        xops = 0\n        while b > 0:\n            ops = n // 2 ** b\n            ops -= xops\n            if twos + ops * b >= n:\n                o = ceil((n - twos) / b)\n                ans += o\n                twos = n\n                break\n            else:\n                twos += ops * b\n                ans += ops\n            b -= 1\n            xops += ops\n        if twos < n:\n            print(-1)\n        else:\n            print(ans)", "import math\nt = int(input())\n\ndef power_2(x):\n    count = 0\n    while x % 2 == 0 and x > 0:\n        x //= 2\n        count += 1\n    return count\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    initial_power = 0\n    for num in arr:\n        initial_power += power_2(num)\n    if initial_power >= n:\n        print(0)\n    else:\n        i = 2\n        lst = []\n        while i <= n:\n            lst += [i]\n            i += 2\n        lst.sort(key=power_2, reverse=True)\n        operations = 0\n        for i in range(len(lst)):\n            initial_power += power_2(lst[i])\n            operations += 1\n            if initial_power >= n:\n                break\n        if initial_power < n:\n            print(-1)\n        else:\n            print(operations)\nwhile t:\n    solve()\n    t -= 1", "def counter(num):\n    c = 0\n    while num % 2 == 0:\n        c += 1\n        num //= 2\n    return c\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 0\n    for num in a:\n        c += counter(num)\n    if c >= n:\n        print(0)\n    else:\n        temp = []\n        for i in range(2, n + 1, 2):\n            temp.append(counter(i))\n        temp.sort(reverse=True)\n        j = 0\n        while c < n and j < len(temp):\n            c += temp[j]\n            j += 1\n        if c >= n:\n            print(j)\n        else:\n            print(-1)", "def count_2_factors(n):\n    count = 0\n    while n % 2 == 0:\n        count += 1\n        n //= 2\n    return count\n\ndef solve():\n    n = int(input())\n    indeces = []\n    twos = 0\n    nums = input().split(' ')\n    for i in range(1, n + 1):\n        curr = int(nums[i - 1])\n        twos += count_2_factors(curr)\n        factors = count_2_factors(i)\n        if factors > 0:\n            indeces.append(factors)\n    if twos >= n:\n        return 0\n    count = 0\n    indeces.sort(reverse=True)\n    for f in indeces:\n        if twos >= n:\n            break\n        twos += f\n        count += 1\n    if twos >= n:\n        return count\n    return -1\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        print(solve())\nmain()", "def countTwos(n):\n    two = 0\n    while n % 2 == 0:\n        n = n // 2\n        two += 1\n    return two\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    twos = 0\n    for i in range(n):\n        twos += countTwos(arr[i])\n    if twos >= n:\n        print(0)\n    else:\n        cnt = 0\n        flag = 0\n        dic = {}\n        for i in range(n, 0, -1):\n            if i % 2 == 0:\n                dic[i] = countTwos(i)\n        dic = {k: v for (k, v) in sorted(dic.items(), key=lambda item: item[1], reverse=True)}\n        for k in dic.keys():\n            twos += dic[k]\n            cnt += 1\n            if twos >= n:\n                flag = 1\n                break\n        if flag == 1:\n            print(cnt)\n        else:\n            print(-1)\n    t -= 1", "t = int(input())\n\ndef numtwos(n):\n    twos = 0\n    while n % 2 == 0:\n        twos += 1\n        n = n // 2\n    return twos\n\ndef genarr(n):\n    res = []\n    for i in range(17, 0, -1):\n        l = (n // (1 << i) - 1) // 2\n        if l >= 0:\n            res.extend([i] * (l + 1))\n    return res + [0] * max(n - len(res), 0)\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x = 1 << n\n    twos = 0\n    for el in arr:\n        twos += numtwos(el)\n    if twos >= n:\n        print(0)\n    else:\n        diff = n - twos\n        twos = genarr(n)\n        i = 0\n        while diff > 0 and i < n:\n            diff -= twos[i]\n            i += 1\n        print(i if i < n else -1)", "def d(x):\n    cnt = 0\n    while x % 2 == 0:\n        cnt += 1\n        x = x // 2\n    return cnt\nfor _ in range(int(input())):\n    k = int(input())\n    li = list(map(int, input().split()))\n    if 0 in li:\n        print(-1)\n        continue\n    i = 0\n    for x in li:\n        i += d(x)\n    if i >= k:\n        print(0)\n    elif i == 0:\n        print(-1)\n    else:\n        remaining = k - i\n        if len(li) % 2 == 0:\n            longEven = len(li)\n        else:\n            longEven = len(li) - 1\n        king = []\n        for i in range(1, longEven + 1):\n            if i % 2 == 0:\n                n = i\n                temp = d(n)\n                king.append(temp)\n        king.sort(reverse=True)\n        ops = 0\n        mm = 0\n        while len(king) != mm:\n            xx = king[mm]\n            remaining -= xx\n            ops += 1\n            if remaining <= 0:\n                break\n            mm += 1\n        if remaining > 0:\n            print(-1)\n            continue\n        print(ops)", "t = int(input())\n\ndef d(x):\n    res = 0\n    while x % 2 == 0:\n        res += 1\n        x //= 2\n    return res\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [*map(int, input().split())]\n    s = 0\n    k = []\n    for i in range(n):\n        tmp = a[i]\n        s += d(tmp)\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    i = 0\n    while i < n and s < n:\n        s += k[i]\n        i += 1\n    if s >= n:\n        print(i)\n    else:\n        print(-1)", "def ii():\n    i = input().split()\n    try:\n        if len(i) == 1:\n            return int(i[0])\n        return list(map(int, i))\n    except Exception:\n        if len(i) == 1:\n            return i[0]\n        return i\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef check(n):\n    r = 0\n    while n % 2 == 0:\n        n //= 2\n        r += 1\n    return r\n\ndef ceil(n):\n    if n % 1 == 0:\n        return int(n)\n    else:\n        return int(n) + 1\nfor _ in range(ii()):\n    n = ii()\n    no = n\n    a = ii()\n    if isinstance(a, int):\n        a = [a]\n    r = 0\n    result = 0\n    for i in a:\n        r += check(i)\n    l = []\n    s = 0\n    while n > 1:\n        n //= 2\n        if len(l):\n            l[len(l) - 1] -= n\n        l.append(n)\n        s += n\n    if s + r < no:\n        print('-1')\n        continue\n    if r >= no:\n        print('0')\n        continue\n    for (i, v) in reversed(list(enumerate(l))):\n        t = (no - r) / (i + 1)\n        if t <= v:\n            result += ceil(t)\n            print(result)\n            break\n        else:\n            result += v\n            r += (i + 1) * v", "def opt(x):\n    kol = 0\n    while x % 2 == 0:\n        kol += 1\n        x //= 2\n    return kol\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    num_list = []\n    for i in range(n):\n        ans += opt(a[i])\n        num_list.append(opt(i + 1))\n    num_list.sort(reverse=True)\n    ind = 0\n    while ind < n and ans < n:\n        ans += num_list[ind]\n        ind += 1\n    if ans >= n:\n        print(ind)\n    else:\n        print(-1)", "def opt(x):\n    kol = 0\n    while x % 2 == 0:\n        kol += 1\n        x //= 2\n    return kol\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    num_list = []\n    for i in range(n):\n        ans += opt(a[i])\n        num_list.append(opt(i + 1))\n    num_list.sort(reverse=True)\n    ind = 0\n    while ind < n and ans < n:\n        ans += num_list[ind]\n        ind += 1\n    if ans >= n:\n        print(ind)\n    else:\n        print(-1)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, n):\n    count = 0\n    for x in a:\n        v = x\n        while v % 2 == 0:\n            count += 1\n            v //= 2\n    if count >= n:\n        return 0\n    d = n - count\n    m = int(math.log2(n))\n    ans = 0\n    pre = 0\n    while d > 0 and m > 0:\n        x = 2 ** m\n        y = n // x - pre\n        if m * y < d:\n            d -= m * y\n            ans += y\n            pre += y\n            m -= 1\n        else:\n            ans += int(math.ceil(d / m))\n            d = 0\n    return ans if d <= 0 else -1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    print(solve(a, n))", "t = int(input())\n\ndef d(x):\n    res = 0\n    while x % 2 == 0:\n        res += 1\n        x //= 2\n    return res\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [*map(int, input().split())]\n    s = 0\n    k = []\n    for i in range(n):\n        s += d(a[i])\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    i = 0\n    while i < n and s < n:\n        s += k[i]\n        i += 1\n    if s >= n:\n        print(i)\n    else:\n        print(-1)", "t = int(input())\n\ndef d(x):\n    res = 0\n    while x % 2 == 0:\n        res += 1\n        x //= 2\n    return res\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [*map(int, input().split())]\n    sah = 0\n    k = []\n    for i in range(n):\n        sah += d(a[i])\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    i = 0\n    while i < n and sah < n:\n        sah += k[i]\n        i += 1\n    if sah >= n:\n        print(i)\n    else:\n        print(-1)", "def d(x):\n    ak = 0\n    while x % 2 == 0:\n        ak += 1\n        x //= 2\n    return ak\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    s = 0\n    k = []\n    for i in range(n):\n        s += d(a[i])\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    j = 0\n    while s < n and j < n:\n        s += k[j]\n        j += 1\n    if s >= n:\n        print(j)\n    else:\n        print(-1)", "def st(n):\n    p = 2\n    count = 0\n    while n % p == 0:\n        count += 1\n        n = n // p\n    return count\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    b = []\n    for j in range(n):\n        count += st(a[j])\n        b.append(st(j + 1))\n    if count < n:\n        b.sort(reverse=True)\n        d = 0\n        l = 0\n        while count < n and b[l] != 0:\n            count += b[l]\n            l += 1\n            d += 1\n        if count >= n:\n            print(d)\n        else:\n            print(-1)\n    else:\n        print(0)", "def re(x):\n    di = 0\n    while x % 2 == 0:\n        di += 1\n        x //= 2\n    return di\nfor i in range(int(input())):\n    sum = 0\n    index = []\n    n = int(input())\n    lst = list(map(int, input().split()))\n    for one in range(n):\n        sum += re(lst[one])\n        index.append(re(one + 1))\n    index.sort(reverse=True)\n    i = 0\n    while i < n:\n        if sum >= n:\n            print(i)\n            break\n        else:\n            sum += index[i]\n            i += 1\n    else:\n        print(-1)", "t = int(input())\n\ndef d(x):\n    res = 0\n    while x % 2 == 0:\n        res += 1\n        x //= 2\n    return res\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [*map(int, input().split())]\n    sah = 0\n    k = []\n    for i in range(n):\n        sah += d(a[i])\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    i = 0\n    while i < n and sah < n:\n        sah += k[i]\n        i += 1\n    if sah >= n:\n        print(i)\n    else:\n        print(-1)", "import math\npower = [0] * 200001\nfor i in range(2, 200001):\n    if i % 2 != 0:\n        power[i] = 0\n    else:\n        power[i] = 1 + power[i // 2]\n\ndef func(x):\n    ans = 0\n    while x % 2 == 0:\n        ans += 1\n        x = x // 2\n    return ans\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = []\n    p = 0\n    for x in input().split():\n        arr.append(int(x))\n        p += func(int(x))\n    ans = 0\n    if p >= n:\n        ans = 0\n        diff = 0\n    else:\n        diff = n - p\n        bla = sorted(power[1:n + 1], reverse=True)\n        for f in range(n):\n            diff -= bla[f]\n            ans += 1\n            if diff <= 0:\n                break\n    if diff > 0:\n        ans = -1\n    print(ans)", "t = int(input())\n\ndef pow2(x):\n    ans = 0\n    while x % 2 == 0:\n        ans += 1\n        x //= 2\n    return ans\nwhile t > 0:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    cp = 0\n    for val in arr:\n        cp += pow2(val)\n    powers = []\n    for i in range(1, n + 1):\n        powers.append(pow2(i))\n    need = n - cp\n    moves = 0\n    i = 0\n    powers.sort(reverse=True)\n    while i < len(powers) and need > 0:\n        need -= powers[i]\n        moves += 1\n        i += 1\n    if need <= 0:\n        print(moves)\n    else:\n        print(-1)\n    t -= 1", "def countPow2(k):\n    count = 0\n    while k % 2 == 0:\n        count += 1\n        k //= 2\n    return count\nfor _ in [0] * int(input()):\n    n = int(input())\n    nums = list(map(int, input().rstrip().split()))\n    total = extra = 0\n    extArr = []\n    for num in nums:\n        total += countPow2(num)\n    for i in range(2, n + 1):\n        temp = countPow2(i)\n        extra += temp\n        extArr += [temp]\n    extArr.sort(reverse=True)\n    if total >= n:\n        print(0)\n    elif total + extra < n:\n        print(-1)\n    else:\n        ans = 0\n        for i in range(len(extArr)):\n            ans += 1\n            if total + extArr[i] >= n:\n                break\n            total += extArr[i]\n        print(ans)", "def getTwo(n):\n    count = 0\n    while n % 2 == 0:\n        count += 1\n        n //= 2\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ans = 0\n    counts = []\n    op = 0\n    for i in range(len(nums)):\n        ans += getTwo(nums[i])\n        counts.append(getTwo(i + 1))\n    counts.sort()\n    for i in range(len(counts) - 1, -1, -1):\n        if ans < len(nums):\n            if counts[i] > 0:\n                ans += counts[i]\n                op += 1\n            else:\n                break\n        else:\n            break\n    if ans >= len(nums):\n        print(op)\n    else:\n        print(-1)", "t = int(input())\n\ndef d(x):\n    res = 0\n    while x % 2 == 0:\n        res += 1\n        x //= 2\n    return res\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [*map(int, input().split())]\n    s = 0\n    k = []\n    for i in range(n):\n        s += d(a[i])\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    i = 0\n    while i < n and s < n:\n        s += k[i]\n        i += 1\n    if s >= n:\n        print(i)\n    else:\n        print(-1)", "def get_pwr2(v):\n    res = 0\n    while v % 2 == 0:\n        res += 1\n        v //= 2\n    return res\n\ndef solve(a, n):\n    pwr2 = 0\n    pwr2_add = [0] * n\n    for ni in range(n):\n        pwr2 += get_pwr2(a[ni])\n        pwr2_add[ni] = get_pwr2(ni + 1)\n    pwr2_add.sort(reverse=True)\n    ns = 0\n    while pwr2 < n:\n        if pwr2_add[ns] == 0:\n            break\n        pwr2 += pwr2_add[ns]\n        ns = ns + 1\n    if pwr2 < n:\n        return -1\n    return ns\nt = int(input())\nans = []\nfor ti in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    ans.append(solve(a, n))\nfor a in ans:\n    print(a)", "def count_two(num):\n    count = 0\n    while num % 2 == 0:\n        count += 1\n        num //= 2\n    return count\ntest = int(input())\nfor _ in range(test):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    s = 0\n    arr = []\n    for i in range(n):\n        s += count_two(nums[i])\n        arr.append(count_two(i + 1))\n    arr.sort(reverse=True)\n    count = 0\n    while s < n and count < n:\n        s += arr[count]\n        count += 1\n    if s >= n:\n        print(count)\n    else:\n        print(-1)", "import sys\ninput = sys.stdin.readline\nt = int(input())\n\ndef countTwos(num):\n    count = 0\n    while num % 2 == 0:\n        count += 1\n        num = num / 2\n    return count\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    currentTwos = 0\n    for num in a:\n        currentTwos += countTwos(num)\n    availbleTwos = []\n    sumOfAvailbleTwos = 0\n    for i in range(2, n + 1, 2):\n        twos = countTwos(i)\n        availbleTwos.append(twos)\n    availbleTwos.sort(reverse=True)\n    if currentTwos >= n:\n        print(0)\n    else:\n        operations = 0\n        for num in availbleTwos:\n            if currentTwos >= n:\n                break\n            currentTwos += num\n            operations += 1\n        if currentTwos >= n:\n            print(operations)\n        else:\n            print(-1)", "t = int(input())\n\ndef c(n):\n    co = 0\n    while n % 2 == 0:\n        n //= 2\n        co += 1\n    return co\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = 0\n    ar = [0] * n\n    ct = 0\n    for i in range(n):\n        ar[i] = c(i + 1)\n        count += c(a[i])\n    ar.sort()\n    need_count = n - count\n    if need_count <= 0:\n        print(0)\n    else:\n        cou = 0\n        i = n - 1\n        for i in range(n - 1, -1, -1):\n            if need_count <= 0:\n                break\n            elif ar[i] <= need_count:\n                cou += 1\n                need_count -= ar[i]\n        if need_count > 0:\n            print(-1)\n        else:\n            print(cou)", "from math import *\n\ndef st2(x):\n    k = 0\n    while x % 2 == 0:\n        x //= 2\n        k += 1\n    return k\nt = int(input())\ndi = {x: 2 ** x for x in range(1, 31)}\nfor pupu in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    re = n\n    cur = 0\n    for i in a:\n        if i % 2 == 0:\n            cur += st2(i)\n    sp = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            sp.append(st2(i))\n    sp = sorted(sp)[::-1]\n    if n <= cur:\n        print(0)\n    else:\n        an = 0\n        for i in range(len(sp)):\n            cur += sp[i]\n            if cur >= n:\n                an = i + 1\n                break\n        if an:\n            print(an)\n        else:\n            print(-1)", "def power2(x):\n    pow = 0\n    while x % 2 == 0:\n        pow += 1\n        x /= 2\n    return pow\n\ndef maxmultiple2(n):\n    max = 2\n    while max <= n:\n        max *= 2\n    return max // 2\nimport math\n\ndef sol():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    pow = 0\n    for i in range(n):\n        pow += power2(a[i])\n    if n == 1 and a[0] % 2 != 0:\n        print(-1)\n    elif pow >= n:\n        print(0)\n    else:\n        vis = []\n        n2 = n\n        ans = 0\n        for i in range(n):\n            vis.append(power2(i + 1))\n        vis.sort(reverse=True)\n        for i in range(n):\n            pow += vis[i]\n            if pow >= n:\n                ans += i + 1\n                break\n        if pow >= n:\n            print(ans)\n        else:\n            print(-1)\nt = int(input())\nfor i in range(t):\n    sol()", "def get_count_2(num):\n    count = 0\n    while num % 2 == 0:\n        num /= 2\n        count += 1\n    return count\nfor _ in range(int(input())):\n    length = int(input())\n    array = map(int, input().split())\n    count_2 = sum(map(get_count_2, filter(lambda x: x % 2 == 0, array)))\n    i = length - 1 * (length % 2)\n    step = 0\n    if length <= count_2:\n        print(step)\n        continue\n    for i in sorted(map(get_count_2, [i for i in range(2, length + 1, 2)]), reverse=True):\n        count_2 += i\n        step += 1\n        if length <= count_2:\n            break\n    else:\n        print(-1)\n        continue\n    print(step)", "t = int(input())\n\ndef d(x):\n    res = 0\n    while x % 2 == 0:\n        res += 1\n        x //= 2\n    return res\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [*map(int, input().split())]\n    s = 0\n    k = []\n    for i in range(n):\n        s += d(a[i])\n        k.append(d(i + 1))\n    k.sort(reverse=True)\n    i = 0\n    while i < n and s < n:\n        s += k[i]\n        i += 1\n    if s >= n:\n        print(i)\n    else:\n        print(-1)", "from sys import *\ninput = stdin.readline\nt = int(input())\n\ndef ctz(x):\n    s = 0\n    while x % 2 == 0:\n        s += 1\n        x /= 2\n    return s\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = sum([ctz(int(x)) for x in input().split()])\n    b = [ctz(i + 1) for i in range(n)]\n    b.sort()\n    b.reverse()\n    steps = 0\n    for i in range(n):\n        if a >= n:\n            break\n        a += b[i]\n        steps += 1\n    if a >= n:\n        print(steps)\n    else:\n        print(-1)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef countZeros(num):\n    length = num.bit_length()\n    result = 0\n    for i in range(length):\n        if num & 1 << i:\n            break\n        result += 1\n    return result\n\ndef main():\n    for _ in range(inp()):\n        n = inp()\n        nums = inlt()\n        indexZeros = []\n        currentZeros = 0\n        for (i, num) in enumerate(nums):\n            indexZeros.append(countZeros(i + 1))\n            currentZeros += countZeros(num)\n        if currentZeros >= n:\n            print(0)\n        else:\n            indexZeros.sort(reverse=True)\n            count = 0\n            found = False\n            for i in range(len(indexZeros)):\n                currentZeros += indexZeros[i]\n                if currentZeros >= n:\n                    print(i + 1)\n                    found = True\n                    break\n            if not found:\n                print(-1)\nmain()", "def count(i):\n    if i == 0:\n        return 0\n    c = 0\n    while i % 2 == 0:\n        i //= 2\n        c += 1\n    return c\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    total = 0\n    add = []\n    for i in range(len(a)):\n        total += count(a[i])\n        x = count(i + 1)\n        if x != 0:\n            add.append(x)\n    i = len(add) - 1\n    ops = 0\n    add = sorted(add)\n    while i >= 0 and total < n:\n        total += add[i]\n        i -= 1\n        ops += 1\n    if total >= n:\n        print(ops)\n    else:\n        print(-1)", "def twoFact(n):\n    ans = 0\n    while n != 0:\n        if not n & 1:\n            ans += 1\n            n //= 2\n        else:\n            break\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    tot = 0\n    for i in range(n):\n        tot += twoFact(arr[i])\n    if tot >= n:\n        print(0)\n    else:\n        ops = 0\n        done = False\n        twoList = []\n        for i in range(1, n + 1):\n            twoList.append(twoFact(i))\n        twoList = sorted(twoList, reverse=True)\n        for add in twoList:\n            tot += add\n            ops += 1\n            if tot >= n:\n                done = True\n                break\n        if done:\n            print(ops)\n        else:\n            print(-1)", "def div_2_count(x):\n    cnt = 0\n    while x % 2 == 0:\n        cnt += 1\n        x //= 2\n    return cnt\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    total_div2_cnt = 0\n    for i in range(n):\n        total_div2_cnt += div_2_count(a[i])\n    indx_div_2_count_list = []\n    for i in range(1, n + 1):\n        indx_div_2_count_list.append(div_2_count(i))\n    indx_div_2_count_list.sort(reverse=True)\n    i = 0\n    while i < n and total_div2_cnt < n:\n        total_div2_cnt += indx_div_2_count_list[i]\n        i += 1\n    if total_div2_cnt >= n:\n        print(i)\n    else:\n        print(-1)", "def find_divisibility_by_2_power_n(arr, n):\n    even_count = 0\n    arr2 = []\n    for (x, i) in enumerate(arr):\n        while i % 2 == 0:\n            i = i // 2\n            even_count += 1\n        idx = x + 1\n        count = 0\n        while idx % 2 == 0:\n            idx = idx // 2\n            count += 1\n        arr2.append(count)\n    arr2.sort()\n    arr2.reverse()\n    if even_count >= n:\n        return 0\n    for (x, i) in enumerate(arr2):\n        even_count += i\n        if even_count >= n:\n            return x + 1\n    if even_count < n:\n        return -1\nnum_cases = int(input())\nfor i in range(num_cases):\n    n = int(input())\n    arr = [int(j) for j in input().split()]\n    print(find_divisibility_by_2_power_n(arr, n))", "def number_of_2(x):\n    n = 0\n    while x > 0 and x % 2 == 0:\n        x //= 2\n        n += 1\n    return n\n\ndef solve():\n    n = int(input())\n    a = map(int, input().split())\n    k = 0\n    for e in a:\n        k += number_of_2(e)\n    h = []\n    for i in range(2, n + 1, 2):\n        h.append(number_of_2(i))\n    h = sorted(h, reverse=True)\n    if k >= n:\n        print('0')\n        return\n    ans = 0\n    for i in h:\n        k += i\n        ans += 1\n        if k >= n:\n            break\n    print(-1 if k < n else ans)\nfor _ in range(int(input())):\n    solve()", "inp = []\nfor _ in range(int(input())):\n    input()\n    inp.append([int(x) for x in input().split(' ')])\n\ndef fac(x):\n    c = 0\n    while x % 2 == 0:\n        x /= 2\n        c += 1\n    return c\nfor arr in inp:\n    t = 0\n    res = []\n    for (e, n) in enumerate(arr):\n        t += fac(n)\n        x = fac(e + 1)\n        if x:\n            res.append(x)\n    res.sort(reverse=True)\n    l = len(arr)\n    if t >= l:\n        print(0)\n        continue\n    for (e, f) in enumerate(res):\n        t += f\n        if t >= l:\n            break\n    if t >= l:\n        print(e + 1)\n    else:\n        print(-1)", "def bi(n):\n    c1 = 0\n    while n % 2 != 1:\n        n = n / 2\n        c1 = c1 + 1\n    return c1\ns = int(input())\nfor i in range(0, s):\n    a = int(input())\n    n = list(map(int, input().split()))\n    c2 = 0\n    for k in range(0, len(n)):\n        c2 = c2 + bi(n[k])\n    if c2 >= a:\n        print(0)\n    else:\n        r1 = []\n        for k in range(1, a + 1):\n            r1.append(bi(k))\n        r1.sort(reverse=True)\n        c = 0\n        for j in range(0, len(r1)):\n            if c2 + r1[j] < a:\n                c = c + 1\n                c2 = c2 + r1[j]\n            else:\n                c2 = c2 + r1[j]\n                c = c + 1\n                break\n        if c2 < a:\n            print(-1)\n        else:\n            print(c)", "def f(arr, n):\n    exp = 0\n    values = []\n    for (i, el) in enumerate(arr):\n        k = el\n        while k % 2 == 0:\n            exp += 1\n            k //= 2\n        k = i + 1\n        count = 0\n        while k % 2 == 0:\n            count += 1\n            k //= 2\n        values.append(count)\n    values.sort()\n    operations_count = 0\n    while exp < n and len(values) > 0:\n        v = values.pop()\n        exp += v\n        operations_count += 1\n    if exp >= n:\n        return operations_count\n    return -1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = [int(el) for el in input().split(' ')]\n    print(f(arr, n))", "def inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef solve(n, arr):\n    sum_two_count = 0\n    for (i, j) in enumerate(arr):\n        while j % 2 == 0:\n            j /= 2\n            sum_two_count += 1\n    if sum_two_count >= n:\n        return 0\n    twos_need = n - sum_two_count\n    twos_available = []\n    for j in range(n, 0, -1):\n        t = 0\n        while j % 2 == 0:\n            j /= 2\n            t += 1\n        twos_available.append(t)\n    twos_available.sort(reverse=True)\n    operations = 0\n    for i in twos_available:\n        if twos_need <= 0:\n            return operations\n        twos_need -= i\n        operations += 1\n    return -1\nfor _ in range(inp()):\n    n = inp()\n    print(solve(n, inlt()))", "def solve(n):\n    if n % 2:\n        return 0\n    res = 0\n    while n % 2 == 0:\n        res += 1\n        n = n // 2\n    return res\nt = int(input())\nwhile t:\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    p = 0\n    for i in range(n):\n        p += solve(a[i])\n    k = n - p\n    d = []\n    for i in range(1, n + 1):\n        d.append(solve(i))\n    d.sort(reverse=True)\n    res = 0\n    i = 0\n    while k > 0 and i < n:\n        k -= d[i]\n        res += 1\n        i += 1\n    if k > 0:\n        print('-1')\n    else:\n        print(res)\n    t -= 1", "def solve(A, N, s):\n    v = []\n    c = 0\n    for i in range(N, 0, -1):\n        c = 0\n        if i % 2 == 0:\n            while i % 2 == 0:\n                c += 1\n                i /= 2\n            v.append(c)\n    v.sort()\n    for (i, e) in enumerate(reversed(v)):\n        s += e\n        if s >= N:\n            return i + 1\n    return -1\n\ndef main():\n    for _ in range(int(input())):\n        N = int(input())\n        A = []\n        s = 0\n        for e in list(map(int, input().split())):\n            while e % 2 == 0:\n                e /= 2\n                s += 1\n            A.append(e)\n        if s >= N:\n            print(0)\n        else:\n            print(solve(A, N, s))\nmain()", "def func():\n    n = int(input())\n    w = list(map(int, input().split()))\n    div = 0\n    for i in range(n):\n        x = w[i]\n        while x % 2 == 0:\n            x /= 2\n            div += 1\n    if div >= n:\n        return 0\n    else:\n        v = []\n        for i in range(n):\n            r = 0\n            a = i + 1\n            while a % 2 == 0:\n                r += 1\n                a /= 2\n            v.append(r)\n        v.sort(reverse=True)\n        res = 0\n        i = 0\n        while div < n and i < n:\n            div += v[i]\n            res += 1\n            i += 1\n        if div >= n:\n            return res\n        else:\n            return -1\nt = int(input())\nfor i in range(t):\n    ans = func()\n    print(ans)", "def numd(n):\n    a = 0\n    while n % 2 == 0:\n        a += 1\n        n /= 2\n    return a\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    st = input()\n    arr = [int(i) for i in st.split()]\n    res = 0\n    n = len(arr)\n    n_1 = 0\n    rarr = sorted([numd(i) for i in range(1, len(arr) + 1)], reverse=True)\n    for i in arr:\n        n_1 += numd(i)\n    if n <= n_1:\n        print(0)\n    else:\n        for i in rarr:\n            if i != 0:\n                n_1 += i\n                res += 1\n            if n_1 >= n:\n                break\n        if n_1 < n:\n            print(-1)\n        else:\n            print(res)", "def div_2_count(x):\n    cnt = 0\n    while x % 2 == 0:\n        cnt += 1\n        x //= 2\n    return cnt\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    total_div2_cnt = 0\n    for i in range(n):\n        total_div2_cnt += div_2_count(a[i])\n    indx_div_2_count_list = []\n    for i in range(1, n + 1):\n        indx_div_2_count_list.append(div_2_count(i))\n    indx_div_2_count_list.sort(reverse=True)\n    i = 0\n    while i < n and total_div2_cnt < n:\n        total_div2_cnt += indx_div_2_count_list[i]\n        i += 1\n    if total_div2_cnt >= n:\n        print(i)\n    else:\n        print(-1)", "def l(x):\n    ans = 0\n    while x % 2 == 0:\n        ans += 1\n        x //= 2\n    return ans\nfor i in range(int(input())):\n    d2 = [0] * 20\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    ansd = 0\n    for i in range(n):\n        ans += l(a[i])\n        buff = l(i + 1)\n        d2[buff] += 1\n        ansd += buff\n    d2[0] = 0\n    if ans + ansd >= n:\n        j = 19\n        co = 0\n        while ans < n:\n            if d2[j] * j + ans >= n:\n                co += (n - ans) // j + ((n - ans) % j > 0)\n                break\n            else:\n                co += d2[j]\n                ans += d2[j] * j\n            j -= 1\n        print(co)\n    else:\n        print(-1)", "def solve(A, N, s):\n    v = []\n    c = 0\n    for i in range(1, N + 1):\n        c = 0\n        if i % 2 == 0:\n            while i % 2 == 0:\n                c += 1\n                i /= 2\n            v.append(c)\n    v.sort()\n    c = 0\n    for e in v[::-1]:\n        s += e\n        c += 1\n        if s >= N:\n            return c\n    return -1\n\ndef main():\n    for _ in range(int(input())):\n        N = int(input())\n        A = []\n        s = 0\n        for e in list(map(int, input().split())):\n            while e % 2 == 0:\n                e /= 2\n                s += 1\n            A.append(e)\n        if s >= N:\n            print(0)\n        else:\n            print(solve(A, N, s))\nmain()", "def find_max(num):\n    cur = 0\n    while num > 1:\n        if num % 2 == 0:\n            num //= 2\n            cur += 1\n        else:\n            break\n    return cur\nfor t in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    raw = 0\n    for i in lst:\n        raw += find_max(i)\n    if raw >= n:\n        print('0')\n    else:\n        cnt = 0\n        c = raw\n        done = False\n        l = []\n        for j in list(range(2, n + 1, 2))[::-1]:\n            l.append(find_max(j))\n        for j in sorted(l, reverse=True):\n            c += j\n            cnt += 1\n            if c >= n:\n                done = True\n                break\n        if not done:\n            print('-1')\n        else:\n            print(f'{cnt}')", "def power_of_two(num):\n    count = 0\n    while num % 2 == 0:\n        num /= 2\n        count += 1\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr1 = []\n    for i in range(1, n + 1):\n        arr1.append(power_of_two(i))\n    arr1.sort(reverse=True)\n    two = []\n    for item in arr:\n        two.append(power_of_two(item))\n    s = sum(two)\n    s1 = sum(arr1)\n    if s + s1 < n:\n        print(-1)\n    elif s >= n:\n        print(0)\n    else:\n        dif = n - s\n        count = 0\n        for item in arr1:\n            dif -= item\n            count += 1\n            if dif <= 0:\n                break\n        print(count)", "from math import log2\n\ndef solve():\n    n = int(input())\n    nums = [int(x) for x in input().split()]\n    twos = 0\n    for num in nums:\n        while num % 2 == 0:\n            twos += 1\n            num //= 2\n    l = []\n    for i in range(1, n + 1):\n        x = 0\n        while i % 2 == 0:\n            x += 1\n            i //= 2\n        l.append(x)\n    l.sort()\n    opers = 0\n    while twos < n and l:\n        twos += l.pop()\n        opers += 1\n    if twos >= n:\n        print(opers)\n    else:\n        print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport threading\nfrom functools import lru_cache\nfrom bisect import bisect_left\nfrom collections import defaultdict, deque\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = [int(i) for i in input().split()]\n        possiblilies = [0] * n\n        cnt = 0\n        for index in range(n):\n            num = a[index]\n            while num % 2 == 0:\n                num //= 2\n                cnt += 1\n            cur = index + 1\n            while cur % 2 == 0:\n                cur //= 2\n                possiblilies[index] += 1\n        req = n - cnt\n        if req <= 0:\n            print(0)\n            continue\n        possiblilies.sort(reverse=True)\n        ans = 0\n        for pos in possiblilies:\n            if pos >= req:\n                req = 0\n                ans += 1\n                break\n            else:\n                req -= pos\n                ans += 1\n        if not req:\n            print(ans)\n        else:\n            print(-1)\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()"]