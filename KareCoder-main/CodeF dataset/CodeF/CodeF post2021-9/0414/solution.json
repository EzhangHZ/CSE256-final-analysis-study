["import sys\ninput = lambda : sys.stdin.readline().strip()\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    g = input()\n    c = 0\n    d = {}\n    for i in range(n):\n        if g[i] == 'B':\n            d[i + 1] = -1\n        else:\n            d[i + 1] = 1\n    for i in range(n - 1):\n        d[l[n - (i + 2)]] += d[n - i]\n    print(list(d.values()).count(0))", "import sys\ninput = lambda : sys.stdin.readline().strip('\\r\\n')\ninvr = lambda : map(int, input().split())\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    p = [int(c) - 1 for c in input().split()]\n    p.insert(0, -1)\n    s = input()\n    arr = [0] * n\n    for i in range(n - 1, -1, -1):\n        if s[i] == 'W':\n            arr[i] += 1\n        else:\n            arr[i] -= 1\n        parent = p[i]\n        if parent != -1:\n            arr[parent] += arr[i]\n    print(arr.count(0))", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        s = input()\n        graph = [[] for _ in range(n)]\n        for i in range(n - 1):\n            graph[arr[i] - 1].append(i + 1)\n        ans = [0]\n\n        def solve(node):\n            if s[node] == 'W':\n                temp = -1\n            else:\n                temp = 1\n            for nie in graph[node]:\n                temp += solve(nie)\n            if temp == 0:\n                ans[0] += 1\n            return temp\n        solve(0)\n        print(ans[0])\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "def solve(n, array, string):\n    dp = [0] * n\n    for i in range(n - 1, -1, -1):\n        dp[i] += 1 if string[i] == 'B' else -1\n        if i > 0:\n            dp[array[i - 1] - 1] += dp[i]\n    return dp.count(0)\n\ndef main():\n    tc = int(input())\n    for _ in range(tc):\n        n = int(input())\n        array = [int(a) for a in input().split()]\n        string = input()\n        print(solve(n, array, string))\nmain()", "def solve(n, array, string):\n    dp = [0] * n\n    for i in range(n - 1, -1, -1):\n        dp[i] += 1 if string[i] == 'B' else -1\n        if i > 0:\n            dp[array[i - 1] - 1] += dp[i]\n    return dp.count(0)\n\ndef main():\n    tc = int(input())\n    for _ in range(tc):\n        n = int(input())\n        array = [int(a) for a in input().split()]\n        string = input()\n        print(solve(n, array, string))\nmain()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(4100)\nT = int(input())\nfor itr in range(1, T + 1):\n    n = int(input())\n    parents = [0, 0] + list(map(int, input().split()))\n    sons = [[] for xxx in range(n + 1)]\n    for i in range(2, n + 1):\n        sons[parents[i]].append(i)\n    color = ['W'] + list(input().strip())\n    sm = [0] * (n + 1)\n\n    def dfs(node):\n        if color[node] == 'W':\n            sm[node] += 1\n        else:\n            sm[node] -= 1\n        for subnode in sons[node]:\n            dfs(subnode)\n            sm[node] += sm[subnode]\n    dfs(1)\n    print(sm.count(0) - 1)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nt = int(input())\nfor tests in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    S = input().strip()\n    DPB = [0] * n\n    DPW = [0] * n\n    ANS = 0\n    for i in range(n - 1, -1, -1):\n        if S[i] == 'B':\n            DPB[i] += 1\n        else:\n            DPW[i] += 1\n        if DPB[i] == DPW[i]:\n            ANS += 1\n        p = A[i - 1] - 1\n        DPB[p] += DPB[i]\n        DPW[p] += DPW[i]\n    print(ANS)", "for f in range(int(input())):\n    n = int(input())\n    p = [*map(int, input().split())]\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[p[i - 1] - 1] += d[i]\n    print(d.count(0))", "I = lambda : int(input())\nfor _ in range(I()):\n    n = I()\n    p = [*map(int, input().split())]\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[p[i - 1] - 1] += d[i]\n    print(d.count(0))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    tree = [*map(int, input().split())]\n    s_color = input()\n    t_list = [0] * n\n    for i in range(n - 1, -1, -1):\n        if s_color[i] == 'W':\n            t_list[i] += 1\n        else:\n            t_list[i] -= 1\n        if i > 0:\n            t_list[tree[i - 1] - 1] += t_list[i]\n    print(t_list.count(0))", "for _ in range(int(input())):\n    n = int(input())\n    l = [1] + list(map(int, input().split()))\n    s = list(input())\n    q = [0 for i in range(n)]\n    for i in range(n - 1, -1, -1):\n        if s[i] == 'B':\n            q[i] -= 1\n        else:\n            q[i] += 1\n        q[l[i] - 1] += q[i]\n    print(q.count(0))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(4010)\n\ndef Depth_First_Search(node):\n    dp[node] = 1 if color[node] == 'W' else -1\n    for nextnode in cnt[node]:\n        Depth_First_Search(nextnode)\n        dp[node] += dp[nextnode]\nfor _ in range(int(input())):\n    n = int(input())\n    cnt = [[] for __ in range(n + 1)]\n    arr = list(map(int, input().split()))\n    color = [''] + list(input().strip())\n    for i in range(2, n + 1):\n        cnt[arr[i - 2]].append(i)\n    dp = [0] * (n + 1)\n    Depth_First_Search(1)\n    ans = 0\n    for i in range(1, n + 1):\n        if dp[i] == 0:\n            ans += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = [None] + [int(x) - 1 for x in input().split()]\n    s = input()\n    d = [0] * n\n    for i in reversed(range(n)):\n        d[i] += 1 if s[i] == 'B' else -1\n        if i > 0:\n            d[a[i]] += d[i]\n    print(d.count(0))", "for _ in range(int(input())):\n    n = int(input())\n    T = list(map(int, input().split()))\n    S = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if S[i] == 'W' else -1\n        if i != 0:\n            d[T[i - 1] - 1] += d[i]\n    print(d.count(0))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().split(' ')))\n    str0 = input()\n    arr = [0] * n\n    for i in reversed(range(n)):\n        if str0[i] == 'W':\n            arr[i] += 1\n        else:\n            arr[i] -= 1\n        if i > 0:\n            x = lst[i - 1] - 1\n            arr[x] += arr[i]\n    num = arr.count(0)\n    print(num)", "I = lambda : int(input())\nfor _ in range(I()):\n    n = I()\n    p = [*map(int, input().split())]\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[p[i - 1] - 1] += d[i]\n    print(d.count(0))", "I = lambda : int(input())\nfor _ in range(I()):\n    n = I()\n    p = [*map(int, input().split())]\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[p[i - 1] - 1] += d[i]\n    print(d.count(0))", "l = []\nfor tests in range(int(input())):\n    (n, A, S) = (int(input()), [int(x) for x in input().split()], input().strip())\n    (DPB, DPW, ANS) = ([0] * n, [0] * n, 0)\n    for i in range(n - 1, -1, -1):\n        if S[i] == 'B':\n            DPB[i] += 1\n        else:\n            DPW[i] += 1\n        if DPB[i] == DPW[i]:\n            ANS += 1\n        p = A[i - 1] - 1\n        DPB[p] += DPB[i]\n        DPW[p] += DPW[i]\n    l.append(ANS)\n[print(i) for i in l]", "for f in range(int(input())):\n    n = int(input())\n    p = [*map(int, input().split())]\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[p[i - 1] - 1] += d[i]\n    print(d.count(0))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = str(input())\n    ct = [0] * n\n    for i in reversed(range(n)):\n        if s[i] == 'B':\n            ct[i] = ct[i] + 1\n        else:\n            ct[i] = ct[i] - 1\n        if i > 0:\n            ct[a[i - 1] - 1] += ct[i]\n    print(ct.count(0))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10000000)\n\ndef dfs(node):\n    dp[node] = 1 if color[node] == 'W' else -1\n    for nextnode in cnt[node]:\n        dfs(nextnode)\n        dp[node] += dp[nextnode]\nfor _ in range(int(input())):\n    n = int(input())\n    cnt = [[] for __ in range(n + 1)]\n    arr = list(map(int, input().split()))\n    color = [''] + list(input().strip())\n    for i in range(2, n + 1):\n        cnt[arr[i - 2]].append(i)\n    dp = [0] * (n + 1)\n    dfs(1)\n    ans = 0\n    for i in range(1, n + 1):\n        if dp[i] == 0:\n            ans += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = str(input())\n    ct = [0] * n\n    for i in reversed(range(n)):\n        if s[i] == 'B':\n            ct[i] = ct[i] + 1\n        else:\n            ct[i] = ct[i] - 1\n        if i > 0:\n            ct[a[i - 1] - 1] += ct[i]\n    print(ct.count(0))", "t = int(input())\nfor u in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[arr[i - 1] - 1] += d[i]\n    print(d.count(0))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    g = [0] * n\n    for i in reversed(range(n)):\n        if s[i] == 'B':\n            g[i] = g[i] - 1\n        else:\n            g[i] = g[i] + 1\n        if i > 0:\n            parent = a[i - 1] - 1\n            g[parent] += g[i]\n    res = g.count(0)\n    print(res)", "import sys\ninput = sys.stdin.readline\nfrom math import inf, gcd, log, log2, floor, ceil, sqrt\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heappush, heappop, heapify\nfrom functools import lru_cache\nfrom itertools import permutations, accumulate\nfrom bisect import insort, bisect_left, bisect_right\nimport threading\nsys.setrecursionlimit(10 ** 4)\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef main():\n    t = inp()\n    for k in range(t):\n        n = inp()\n        arr = inlt()\n        colors = insr()\n        for i in range(len(colors)):\n            if colors[i] == 'B':\n                colors[i] = 1\n            else:\n                colors[i] = -1\n\n        def solve(n, arr, colors):\n            graph = defaultdict(list)\n            for (i, x) in enumerate(arr):\n                graph[x - 1].append(i + 1)\n            count = defaultdict(int)\n\n            def dfs(root):\n                nonlocal count\n                total = 0\n                for node in graph[root]:\n                    total += dfs(node)\n                total += colors[root]\n                count[total] += 1\n                return total\n            dfs(0)\n            return count[0]\n        print(solve(n, arr, colors))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "for f in range(int(input())):\n    n = int(input())\n    p = [*map(int, input().split())]\n    s = input()\n    d = [0] * n\n    for i in range(n - 1, -1, -1):\n        d[i] += 1 if s[i] == 'W' else -1\n        if i > 0:\n            d[p[i - 1] - 1] += d[i]\n    print(d.count(0))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(node, tree, ans, s):\n    ans[node] = s[node]\n    for adj in tree[node]:\n        ans[node] += dfs(adj, tree, ans, s)\n    return ans[node]\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    g = [[] for _ in range(n)]\n    for (i, el) in enumerate(a):\n        g[el - 1].append(i + 1)\n    s = list((1 if char == 'B' else -1 for char in input()))\n    ans = [''] * n\n    dfs(0, g, ans, s)\n    print(ans.count(0))", "import sys\ninput = sys.stdin.readline\nimport math\nsys.setrecursionlimit(10000)\nimport threading\nthreading.stack_size(2 ** 27)\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        s = input()\n        g = [[] for i in range(n)]\n        for i in range(n - 1):\n            g[a[i] - 1].append(i + 1)\n        b = [0] * n\n\n        def Dfs(v):\n            if s[v] == 'B':\n                b[v] += 1\n            else:\n                b[v] -= 1\n            for to in g[v]:\n                Dfs(to)\n                b[v] += b[to]\n        Dfs(0)\n        ans = 0\n        for i in b:\n            if i == 0:\n                ans += 1\n        print(ans)\nthreading.Thread(target=main).start()", "import sys\nsys.setrecursionlimit(5000)\n\ndef dfs(n):\n    if bw_list[n] == 'W':\n        (white, black) = (1, 0)\n    else:\n        (white, black) = (0, 1)\n    result = 0\n    for child in childs[n]:\n        (w_child, b_child, r_child) = dfs(child)\n        white += w_child\n        black += b_child\n        result += r_child\n    if white == black:\n        result += 1\n    return (white, black, result)\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    childs = {}\n    for i in range(n + 1):\n        childs[i] = []\n    parants = list(map(int, input().split()))\n    for i in range(len(parants)):\n        childs[parants[i]].append(i + 2)\n    bw_list = ' ' + input()\n    result = 0\n    (_, _, result) = dfs(1)\n    print(result)", "import sys\ninput = sys.stdin.readline\nfrom math import inf, gcd, log, log2, floor, ceil, sqrt\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heappush, heappop, heapify\nfrom functools import lru_cache\nfrom itertools import permutations, accumulate\nfrom bisect import insort, bisect_left, bisect_right\nimport threading\nsys.setrecursionlimit(10 ** 6)\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef main():\n    t = inp()\n    for k in range(t):\n        n = inp()\n        arr = inlt()\n        colors = insr()\n        for i in range(len(colors)):\n            if colors[i] == 'B':\n                colors[i] = 1\n            else:\n                colors[i] = -1\n\n        def solve(n, arr, colors):\n            graph = defaultdict(list)\n            for (i, x) in enumerate(arr):\n                graph[x - 1].append(i + 1)\n            count = defaultdict(int)\n\n            def dfs(root):\n                nonlocal count\n                total = 0\n                for node in graph[root]:\n                    total += dfs(node)\n                total += colors[root]\n                count[total] += 1\n                return total\n            dfs(0)\n            return count[0]\n        print(solve(n, arr, colors))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10000)\n\ndef solve():\n    n = int(input())\n    gr = [[] for _ in range(n + 1)]\n    par = list(map(int, input().split()))\n    for i in range(2, n + 1):\n        gr[par[i - 2]].append(i)\n    s = input().strip()\n    wc = [0] * (n + 1)\n    bc = [0] * (n + 1)\n    ans = [0]\n\n    def dfs(cur, wc, bc, gr, ans):\n        wc[cur] = s[cur - 1] == 'W'\n        bc[cur] = s[cur - 1] == 'B'\n        for v in gr[cur]:\n            dfs(v, wc, bc, gr, ans)\n            wc[cur] += wc[v]\n            bc[cur] += bc[v]\n        ans[0] += wc[cur] == bc[cur]\n    dfs(1, wc, bc, gr, ans)\n    print(ans[0])\ntst = int(input())\nfor tt in range(tst):\n    solve()", "from math import ceil\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef mlt():\n    return map(int, input().split())\nmod = int(1000000000.0 + 7)\n\ndef initmap():\n    return defaultdict(lambda : 0)\n\nclass Solution:\n\n    def __init__(self) -> None:\n        x = int(input())\n        s = [*mlt()]\n        graph = [[] for n in range(x + 1)]\n        self.st = [-1 if n == 'B' else 1 for n in input()]\n        for n in range(len(s)):\n            graph[s[n] - 1].append(n + 1)\n        self.graph = graph\n        self.res = 0\n        self.dfs(0)\n        print(self.res)\n\n    def dfs(self, node):\n        count = 0\n        for n in self.graph[node]:\n            count += self.dfs(n)\n        count += self.st[node]\n        if count == 0:\n            self.res += 1\n        return count\nfor _ in range(int(input())):\n    Solution()", "import sys\nsys.setrecursionlimit(5000)\n\ndef dfs(i):\n    d[i] = 1 if s[i] == 'B' else -1\n    for j in g[i]:\n        dfs(j)\n        d[i] += d[j]\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for (i, p) in enumerate(input().split(), start=1):\n        g[int(p) - 1].append(i)\n    s = input()\n    d = [None] * n\n    dfs(0)\n    print(d.count(0))", "from collections import deque, defaultdict, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\nimport sys\nimport io, os\nsys.setrecursionlimit(300005)\nmod = 1000000007\ninput = sys.stdin.readline\nglobal ans\n\ndef dfs(v, p):\n    global ans\n    (w, b) = (0, 0)\n    if color[v - 1] == 'W':\n        w += 1\n    else:\n        b += 1\n    for nbr in child[v]:\n        (w1, b1) = dfs(nbr, v)\n        w += w1\n        b += b1\n    if w == b:\n        ans += 1\n    return (w, b)\n\ndef ints():\n    return list(map(int, input().split()))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    child = {i: [] for i in range(1, n + 1)}\n    arr = ints()\n    color = input()\n    for i in range(n - 1):\n        child[arr[i]].append(i + 2)\n    ans = 0\n    dfs(1, -1)\n    print(ans)", "import sys\nimport bisect\n\ndef solve():\n    inp = sys.stdin.readline\n    n = int(inp())\n    p = list(map(int, inp().split()))\n    s = inp()\n    G = [[] for i in range(n + 1)]\n    for i in range(2, n + 1):\n        G[p[i - 2]].append(i)\n    q = [1]\n    i = 0\n    while i < len(q):\n        x = q[i]\n        i += 1\n        for v in G[x]:\n            q.append(v)\n    b = [0] * (n + 1)\n    w = [0] * (n + 1)\n    ans = 0\n    for i in range(len(q) - 1, -1, -1):\n        x = q[i]\n        if s[x - 1] == 'B':\n            b[x] = 1\n        else:\n            w[x] = 1\n        for v in G[x]:\n            b[x] += b[v]\n            w[x] += w[v]\n        if b[x] == w[x]:\n            ans += 1\n    print(ans)\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "import sys\n\ndef inp(*, cf=lambda x: x):\n    return cf(input())\n\ndef inpint():\n    return inp(cf=int)\n\ndef inp_line(*, cf=lambda x: x, s=' '):\n    return list(map(cf, input().split(s)))\n\ndef inpints():\n    return inp_line(cf=int)\n\ndef intstostr(l):\n    return ' '.join([str(x) for x in l])\n\ndef listtostr(l):\n    return ' '.join(l)\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(tree, balance, v):\n    for u in tree[v]:\n        dfs(tree, balance, u)\n        balance[v] += balance[u]\n\ndef test_case(case):\n    n = inpint()\n    p = inp_line(cf=lambda x: int(x) - 1)\n    c = inp()\n    tree = [[] for _ in range(n)]\n    for i in range(len(p)):\n        tree[p[i]].append(i + 1)\n    balance = [1 if c[i] == 'W' else -1 for i in range(n)]\n    dfs(tree, balance, 0)\n    ans = 0\n    for i in range(len(balance)):\n        if balance[i] == 0:\n            ans += 1\n    return ans\n\ndef main():\n    T = inpint()\n    for t in range(1, T + 1):\n        print(test_case(t))\nmain()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    t = int(input())\n    while t:\n        n = int(input())\n        g = [[] for _ in range(n)]\n        ls = list(map(int, input().split()))\n        for (i, p) in enumerate(ls):\n            g[i + 1].append(p - 1)\n            g[p - 1].append(i + 1)\n        c = input()\n        size = [0] * n\n        for (i, ch) in enumerate(c):\n            if ch == 'W':\n                size[i] = 1\n            else:\n                size[i] = -1\n\n        def dfs(cur, par):\n            for v in g[cur]:\n                if v == par:\n                    continue\n                dfs(v, cur)\n                size[cur] += size[v]\n        dfs(0, -1)\n        ans = 0\n        for v in size:\n            if not v:\n                ans += 1\n        print(ans)\n        t -= 1\nmain()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(5000)\n\nclass Solution:\n\n    def solve(self):\n        for _ in range(int(input())):\n            self.count = 0\n            n = int(input())\n            a = [int(x) for x in input().split()]\n            self.color = input()\n            self.tree = defaultdict(list)\n            for i in range(n - 1):\n                self.tree[a[i]].append(i + 2)\n            self.dfs(1)\n            print(self.count)\n\n    def dfs(self, node):\n        res = 1 if self.color[node - 1] == 'W' else -1\n        for neighbor in self.tree[node]:\n            res += self.dfs(neighbor)\n        if res == 0:\n            self.count += 1\n        return res\nSolution().solve()", "import sys\nimport threading\n\ndef children_list(n, a):\n    a = [elem - 1 for elem in a]\n    children = []\n    for i in range(n):\n        children.append([])\n    for i in range(n - 1):\n        children[a[i]].append(i + 1)\n    return children\n\ndef func(ch_list, elem, s):\n    elem_children = ch_list[elem]\n    w_count = 0\n    b_count = 0\n    ans = 0\n    if len(elem_children) == 0:\n        if s[elem] == 'W':\n            return (1, 0, 0)\n        else:\n            return (0, 1, 0)\n    for num in elem_children:\n        colors = func(ch_list, num, s)\n        w_count += colors[0]\n        b_count += colors[1]\n        ans += colors[2]\n    if s[elem] == 'W':\n        w_count += 1\n    else:\n        b_count += 1\n    if w_count == b_count:\n        ans += 1\n    return (w_count, b_count, ans)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        s = input()\n        elem = 0\n        ch_list = children_list(n, a)\n        ans = func(ch_list, elem, s)\n        print(ans[2])\nsys.setrecursionlimit(2 * 10 ** 5)\nthreading.stack_size(2 * 10 ** 6)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nsys.setrecursionlimit(4010)\n\ndef Depth_First_Search(node):\n    dp[node] = 1 if color[node] == 'W' else -1\n    for nextnode in cnt[node]:\n        Depth_First_Search(nextnode)\n        dp[node] += dp[nextnode]\nfor _ in range(int(input())):\n    n = int(input())\n    cnt = [[] for __ in range(n + 1)]\n    arr = list(map(int, input().split()))\n    color = [''] + list(input().strip())\n    for i in range(2, n + 1):\n        cnt[arr[i - 2]].append(i)\n    dp = [0] * (n + 1)\n    Depth_First_Search(1)\n    ans = 0\n    for i in range(1, n + 1):\n        if dp[i] == 0:\n            ans += 1\n    print(ans)", "import sys\nimport math\nfrom collections import defaultdict\nfrom collections import Counter\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = int(sys.stdin.readline())\n    ls = list(map(int, sys.stdin.readline().split()))\n    colors = sys.stdin.readline()\n    g = [[] for _ in range(n)]\n    for (i, v) in enumerate(ls):\n        g[v - 1].append(i + 1)\n        g[i + 1].append(v - 1)\n    dp_w = [0] * n\n    dp_b = [0] * n\n\n    def dfs(ver, par):\n        if colors[ver] == 'W':\n            dp_w[ver] = 1\n        else:\n            dp_b[ver] = 1\n        for u in g[ver]:\n            if u != par:\n                dfs(u, ver)\n                dp_w[ver] += dp_w[u]\n                dp_b[ver] += dp_b[u]\n    dfs(0, -1)\n    ans = 0\n    for i in range(n):\n        if dp_w[i] == dp_b[i]:\n            ans += 1\n    print(ans)\nt = int(sys.stdin.readline())\nwhile t:\n    main()\n    t -= 1", "import collections, sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solve(u, d, s, ans):\n    if len(d[u]) == 0:\n        return 1 if s[u - 1] == 'B' else -1\n    c = 0\n    if s[u - 1] == 'B':\n        c += 1\n    else:\n        c -= 1\n    for v in d[u]:\n        c += solve(v, d, s, ans)\n    if c == 0:\n        ans[0] += 1\n    return c\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    d = collections.defaultdict(list)\n    for i in range(n - 1):\n        d[a[i]].append(i + 2)\n    ans = [0]\n    solve(1, d, s, ans)\n    print(ans[0])", "from collections import defaultdict\nimport sys\n\ndef solve():\n    G = defaultdict(list)\n    for (i, par) in enumerate(parents):\n        G[par].append(i + 2)\n\n    def dfs(node):\n        (d, w, b) = (0, 0, 0)\n        if col[node - 1] == 'W':\n            w += 1\n        else:\n            b += 1\n        for child in G[node]:\n            (cd, cw, cb) = dfs(child)\n            d += cd\n            w += cw\n            b += cb\n        if w == b:\n            d += 1\n        return (d, w, b)\n    (ans, _, _) = dfs(1)\n    return ans\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nnumber_of_cases = int(input())\nfor case_num in range(1, number_of_cases + 1):\n    N = int(input())\n    parents = [int(x) for x in input().split()]\n    col = input().strip()\n    sys.stdout.write(f'{solve()}' + '\\n')", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    t = int(input())\n    while t:\n        n = int(input())\n        g = [[] for _ in range(n)]\n        ls = list(map(int, input().split()))\n        for (i, p) in enumerate(ls):\n            g[i + 1].append(p - 1)\n            g[p - 1].append(i + 1)\n        c = input()\n        dp_w = [0] * n\n        dp_b = [0] * n\n\n        def dfs(cur, par):\n            if c[cur] == 'W':\n                dp_w[cur] = 1\n            else:\n                dp_b[cur] = 1\n            for v in g[cur]:\n                if v == par:\n                    continue\n                dfs(v, cur)\n                dp_w[cur] += dp_w[v]\n                dp_b[cur] += dp_b[v]\n        dfs(0, -1)\n        ans = 0\n        for i in range(n):\n            if dp_w[i] == dp_b[i]:\n                ans += 1\n        print(ans)\n        t -= 1\nmain()", "from collections import *\nimport sys\nsys.setrecursionlimit(1 << 30)\nt = int(input())\nfor _ in range(t):\n    n = input()\n    graph = defaultdict(list)\n    parents = [int(i) for i in input().split()]\n    color = input().strip()\n    for i in range(len(parents)):\n        graph[parents[i]].append(i + 2)\n    count = 0\n    r = [0]\n\n    def dfs(node, r):\n        b = w = 0\n        if color[node - 1] == 'W':\n            w += 1\n        else:\n            b += 1\n        for child in graph[node]:\n            (b1, w1) = dfs(child, r)\n            b += b1\n            w += w1\n        if b == w:\n            r[0] += 1\n        return (b, w)\n    dfs(1, r)\n    print(r[0])", "from collections import defaultdict\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    d = defaultdict(list)\n    k = 1\n    for i in a:\n        d[i - 1].append(k)\n        k += 1\n    state_list = [-1] * n\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        state_list[i] = 1 if s[i] == 'W' else -1\n        for j in d[i]:\n            state_list[i] += state_list[j]\n        if state_list[i] == 0:\n            ans += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(5000)\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n + 1)]\n    for (i, p) in enumerate(list(map(int, input().split()))):\n        g[p].append(i + 2)\n    s = input()\n    res = [0]\n\n    def dfs(i=1):\n        (w, b) = (int(s[i - 1] == 'W'), int(s[i - 1] == 'B'))\n        if not g[i]:\n            return (w, b)\n        for nbr in g[i]:\n            (wi, bi) = dfs(nbr)\n            (w, b) = (w + wi, b + bi)\n        if w == b:\n            res[0] += 1\n        return (w, b)\n    dfs()\n    print(res[0])", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    for i in range(n - 1):\n        p[i] -= 1\n    s = input()\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        graph[p[i]].append(i + 1)\n    leaf = []\n    for v in range(n):\n        if len(graph[v]) == 0:\n            leaf.append(v)\n    cnt = 0\n\n    def dfs(v):\n        nonlocal cnt\n        black = 0\n        white = 0\n        if s[v] == 'W':\n            white += 1\n        else:\n            black += 1\n        for nv in graph[v]:\n            (b, w) = dfs(nv)\n            black += b\n            white += w\n        if black == white:\n            cnt += 1\n        return (black, white)\n    dfs(0)\n    print(cnt)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "def solution2(content, color, n):\n    result = [[0, 0, 0] for _ in range(n)]\n    for i in range(len(content) - 1, -1, -1):\n        node = i + 1\n        if color[node] == 'B':\n            result[node][0] += 1\n        else:\n            result[node][1] += 1\n        if result[node][0] == result[node][1]:\n            result[node][2] += 1\n        parent = content[i] - 1\n        result[parent][0] += result[node][0]\n        result[parent][1] += result[node][1]\n        result[parent][2] += result[node][2]\n    node = 0\n    if color[node] == 'B':\n        result[node][0] += 1\n    else:\n        result[node][1] += 1\n    if result[node][0] == result[node][1]:\n        result[node][2] += 1\n    print(result[0][2])\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    content = [int(i) for i in input().split()]\n    color = list(input())\n    solution2(content, color, n)", "from collections import Counter\nfrom functools import lru_cache\nfrom bisect import bisect, bisect_left\nimport sys\nt = int(input())\nresult = []\nsys.setrecursionlimit(10000000)\nfor _ in range(t):\n    n = int(input())\n    parents = list(map(int, input().split()))\n    string = input()\n    hashMap = {i: [] for i in range(1, n + 1)}\n    for i in range(len(parents)):\n        (path, toPath) = (i + 2, parents[i])\n        hashMap[toPath].append(path)\n\n    def dfs(currentNode):\n        neighbourNodes = hashMap[currentNode]\n        (cntWhite, cntBlack) = (0, 0)\n        if string[currentNode - 1] == 'W':\n            cntWhite += 1\n        else:\n            cntBlack += 1\n        ans = 0\n        for neighbour in neighbourNodes:\n            (answer, countWhite, countBlack) = dfs(neighbour)\n            ans += answer\n            cntWhite += countWhite\n            cntBlack += countBlack\n        if cntWhite == cntBlack:\n            return (ans + 1, cntWhite, cntBlack)\n        return (ans, cntWhite, cntBlack)\n    (ans, _, _) = dfs(1)\n    print(ans)", "t = int(input())\nret = []\nfrom sys import setrecursionlimit\nsetrecursionlimit(300000)\nfor I in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    G = [[] for _ in range(n)]\n    for i in range(n - 1):\n        G[a[i] - 1].append(i + 1)\n        G[i + 1].append(a[i] - 1)\n    memo = [-100] * n\n\n    def dfs(before, now):\n        if now != 0 and len(G[now]) == 1:\n            if s[now] == 'W':\n                memo[now] = 1\n                return 1\n            else:\n                memo[now] = -1\n                return -1\n        else:\n            if memo[now] != -100:\n                return memo[now]\n            cnt = 0\n            for next in G[now]:\n                if next == before:\n                    continue\n                if memo[next] != -100:\n                    cnt += memo[next]\n                else:\n                    cnt += dfs(now, next)\n            if s[now] == 'W':\n                cnt += 1\n            else:\n                cnt -= 1\n            memo[now] = cnt\n            return cnt\n    dfs(-1, 0)\n    ret.append(memo.count(0))\nprint(*ret, sep='\\n')", "from math import inf, gcd, log, log2, floor, ceil, sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nfrom functools import lru_cache\nimport sys\nsys.setrecursionlimit(10 ** 5)\nDIRS = [[1, 0], [0, 1], [0, -1], [-1, 0], [-1, -1], [1, 1], [-1, 1], [1, -1]]\nMOD = 10 ** 9 + 7\ninput = sys.stdin.readline\nt = int(input())\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n    s = input().strip('\\n')\n    d = defaultdict(list)\n    for i in range(n - 1):\n        d[a[i]].append(i + 2)\n    ans = 0\n\n    def go(node):\n        (bc, wc) = (0, 0)\n        if s[node - 1] == 'W':\n            wc += 1\n        else:\n            bc += 1\n        for child in d[node]:\n            (cbc, cwc) = go(child)\n            bc += cbc\n            wc += cwc\n        nonlocal ans\n        ans += bc == wc\n        return (bc, wc)\n    go(1)\n    print(ans)\nwhile t:\n    solve()\n    t -= 1", "import sys\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef dfs(x):\n    seen[x] = 1\n    for v in graph[x]:\n        if seen[v] == 1:\n            continue\n        dp[x] += dfs(v)\n    return dp[x]\nfor _ in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    S = input()\n    seen = [0] * n\n    graph = [[] for _ in range(n)]\n    dp = [0] * n\n    for i in range(n):\n        if S[i] == 'W':\n            dp[i] = 1\n        else:\n            dp[i] = -1\n    for i in range(n - 1):\n        frm = i + 1\n        to = A[i] - 1\n        graph[frm].append(to)\n        graph[to].append(frm)\n    dfs(0)\n    print(dp.count(0))", "import sys\nsys.setrecursionlimit(5000)\n\ndef dfs(i):\n    d[i] = 1 if s[i] == 'B' else -1\n    for j in g[i]:\n        if d[j] is None:\n            dfs(j)\n            d[i] += d[j]\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(input().split(), start=1):\n        j = int(j) - 1\n        g[i].append(j)\n        g[j].append(i)\n    s = input()\n    d = [None] * n\n    dfs(0)\n    print(d.count(0))", "from sys import setrecursionlimit\nsetrecursionlimit(5000)\n\ndef dfs(root, tree, coloring):\n    res = 0\n\n    def count_dfs(root):\n        nonlocal res\n        if root not in tree:\n            white = 1 if coloring[root - 1] == 'W' else 0\n            black = 1 if coloring[root - 1] != 'W' else 0\n            return (white, black)\n        (white, black) = (0, 0)\n        for child in tree[root]:\n            (w, b) = count_dfs(child)\n            white += w\n            black += b\n        white = white + 1 if coloring[root - 1] == 'W' else white\n        black = black + 1 if coloring[root - 1] != 'W' else black\n        if white == black:\n            res += 1\n        return (white, black)\n    count_dfs(root)\n    return res\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    parents = list(map(int, input().split()))\n    coloring = input()\n    tree = {}\n    for (idx, node) in enumerate(parents):\n        vertex = idx + 2\n        tree[node] = tree.get(node, [])\n        tree[node].append(vertex)\n    print(dfs(1, tree, coloring))", "import sys\n\nclass TreeNode:\n\n    def __init__(self, x):\n        self.val = x\n        self.children = []\nsys.setrecursionlimit(10000)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    nodes = [TreeNode(x) for x in s]\n    for (i, parent) in enumerate(a):\n        nodes[parent - 1].children.append(nodes[i + 1])\n\n    def dfs(node):\n        if node is None:\n            return (0, 0)\n        balance = cnt = 0\n        for child in node.children:\n            (b, cntc) = dfs(child)\n            balance += b\n            cnt += cntc\n        if node.val == 'B':\n            balance += 1\n        else:\n            balance -= 1\n        cnt += balance == 0\n        return (balance, cnt)\n    (_, cnt) = dfs(nodes[0])\n    print(cnt)", "import sys\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef dfs(x, p):\n    for i in g[x]:\n        if i != p:\n            p = dfs(i, x)\n            dp[x][0] += p[0]\n            dp[x][1] += p[1]\n    if s[x - 1] == 'B':\n        dp[x][0] += 1\n    else:\n        dp[x][1] += 1\n    return dp[x]\nfor test in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    s = input()\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = (i + 2, arr[i])\n        g[a].append(b)\n        g[b].append(a)\n    dp = [[0, 0] for i in range(n + 1)]\n    dfs(1, 0)\n    ans = 0\n    for i in dp:\n        if i[0] == i[1]:\n            ans += 1\n    print(ans - 1)", "from sys import setrecursionlimit\nimport threading\nsetrecursionlimit(10 ** 7)\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        c = input()\n        c = 'p' + c\n        a.insert(0, 0)\n        visit = [0 for i in range(n + 1)]\n        adj = [[] for i in range(n + 1)]\n\n        def add_edge(u, v):\n            adj[u].append(v)\n            adj[v].append(u)\n        stack = []\n        dp = [0 for i in range(n + 1)]\n\n        def dfs(u):\n            visit[u] = 1\n            if c[u] == 'W':\n                dp[u] = 1\n            else:\n                dp[u] = -1\n            for v in adj[u]:\n                if visit[v] == 0:\n                    visit[v] = 1\n                    stack.append(v)\n                    dfs(v)\n                    if c[v] == 'W':\n                        dp[u] += dp[v]\n                    else:\n                        dp[u] += dp[v]\n        for i in range(1, n):\n            add_edge(a[i], i + 1)\n        dfs(1)\n        print(dp[1:].count(0))\nthreading.stack_size(10 ** 7)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from sys import setrecursionlimit\nimport threading\nsetrecursionlimit(10 ** 7)\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        c = input()\n        c = 'p' + c\n        a.insert(0, 0)\n        visit = [0 for i in range(n + 1)]\n        adj = [[] for i in range(n + 1)]\n\n        def add_edge(u, v):\n            adj[u].append(v)\n            adj[v].append(u)\n        stack = []\n        dp = [0 for i in range(n + 1)]\n\n        def dfs(u):\n            visit[u] = 1\n            if c[u] == 'W':\n                dp[u] = 1\n            else:\n                dp[u] = -1\n            for v in adj[u]:\n                if visit[v] == 0:\n                    visit[v] = 1\n                    stack.append(v)\n                    dfs(v)\n                    if c[v] == 'W':\n                        dp[u] += dp[v]\n                    else:\n                        dp[u] += dp[v]\n        for i in range(1, n):\n            add_edge(a[i], i + 1)\n        dfs(1)\n        print(dp[1:].count(0))\nthreading.stack_size(10 ** 7)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(pow(10, 9))\n\ndef dfs(src, par):\n    (count, white) = (0, 0)\n    for ele in graph[src]:\n        if par != ele:\n            (a, b) = dfs(ele, src)\n            count += a\n            white += b\n    count += 1\n    white += string[src] == 'W'\n    if white == count - white:\n        ans[0] += 1\n    return (count, white)\nt = int(input())\nfor _ in range(t):\n    ans = [0]\n    n = int(input())\n    graph = defaultdict(lambda : [])\n    parent = list(map(int, input().split()))\n    string = input()\n    for i in range(2, n + 1):\n        graph[i].append(parent[i - 2])\n        graph[parent[i - 2]].append(i)\n    string = '0' + string\n    dfs(1, -1)\n    print(ans[0])", "from collections import defaultdict\nfrom sys import setrecursionlimit as srl\nsrl(10 ** 5)\nfor _ in range(int(input())):\n    g = defaultdict(list)\n    n = int(input())\n    l = list(map(int, input().split()))\n    for i in range(n - 1):\n        g[i + 2].append(l[i])\n        g[l[i]].append(i + 2)\n    s = input()\n    vis = [0] * (n + 1)\n    val = [0] * (n + 1)\n\n    def dfs(cn):\n        vis[cn] = 1\n        if s[cn - 1] == 'B':\n            val[cn] = -1\n        else:\n            val[cn] = 1\n        for nn in g[cn]:\n            if vis[nn] == 0:\n                dfs(nn)\n                val[cn] += val[nn]\n    dfs(1)\n    res = 0\n    for i in val:\n        if i == 0:\n            res += 1\n    print(res - 1)", "import sys\ninput = sys.stdin.readline\ntc = int(input())\nfor _ in range(tc):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    dict1 = {}\n    dict2 = {}\n    for i in range(len(s)):\n        dict2[i + 1] = s[i]\n    for i in range(len(a)):\n        if a[i] not in dict1:\n            dict1[a[i]] = [i + 2]\n        else:\n            dict1[a[i]] += [i + 2]\n    for i in range(1, n + 1):\n        if i not in dict1:\n            dict1[i] = []\n    dp = {}\n    for i in range(n, 0, -1):\n        if dict1[i] == []:\n            if dict2[i] == 'W':\n                dp[i] = (1, 0)\n            else:\n                dp[i] = (0, 1)\n        else:\n            cntw = 0\n            cntb = 0\n            if dict2[i] == 'W':\n                cntw += 1\n            else:\n                cntb += 1\n            for j in dict1[i]:\n                cntw += dp[j][0]\n                cntb += dp[j][1]\n            dp[i] = (cntw, cntb)\n    cnt = 0\n    for i in dp:\n        if dp[i][0] == dp[i][1]:\n            cnt += 1\n    print(cnt)", "import sys\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef dfs(x, color):\n    seen[x] = 1\n    for v in graph[x]:\n        if seen[v] == 1:\n            continue\n        color = -1\n        if S[v] == 'W':\n            color = 1\n        dp[x] += dfs(v, color)\n    return dp[x]\nfor _ in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    S = input()\n    seen = [0] * n\n    graph = [[] for _ in range(n)]\n    dp = [0] * n\n    for i in range(n):\n        if S[i] == 'W':\n            dp[i] = 1\n        else:\n            dp[i] = -1\n    for i in range(n - 1):\n        frm = i + 1\n        to = A[i] - 1\n        graph[frm].append(to)\n        graph[to].append(frm)\n    color = -1\n    if S[0] == 'W':\n        color = 1\n    dfs(0, color)\n    print(dp.count(0))", "t = int(input())\nans = []\nimport sys\nsys.setrecursionlimit(500000)\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    tek = 0\n    s1 = []\n    for i in s:\n        s1.append(i)\n    dp = [[0, 0] for i in range(n)]\n    use = [0] * n\n\n    def dfs(v):\n        use[v] = 1\n        if s1[v] == 'W':\n            dp[v][0] += 1\n        else:\n            dp[v][1] += 1\n        for i in rb[v]:\n            if use[i] == 0:\n                dfs(i)\n                dp[v][0] += dp[i][0]\n                dp[v][1] += dp[i][1]\n    rb = [[] for i in range(n)]\n    for i in range(len(a)):\n        rb[a[i] - 1].append(i + 1)\n    dfs(0)\n    for i in dp:\n        if i[0] == i[1]:\n            tek += 1\n    ans.append(tek)\nfor i in ans:\n    print(i)", "from sys import stdin, stdout, setrecursionlimit\nimport collections\nimport math\n\ndef solve(graph, n):\n    if n in graph and graph[n] != []:\n        g = [0, 0]\n        color = s[n - 1]\n        for ne in graph[n]:\n            k = solve(graph, ne)\n            g[0] += k[0]\n            g[1] += k[1]\n        if color == 'B':\n            g[0] += 1\n        else:\n            g[1] += 1\n        check[n] = g\n    else:\n        color = s[n - 1]\n        g = [0, 0]\n        if color == 'B':\n            g[0] += 1\n        else:\n            g[1] += 1\n        check[n] = g\n    return check[n]\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\n        global graph\n        graph = {}\n        global s\n        s = input().strip()\n        for i in range(1, n + 1):\n            graph[i] = []\n        for i in range(n - 1):\n            graph[l[i]].append(i + 2)\n        global check\n        check = {}\n        solve(graph, 1)\n        ans = 0\n        for i in check:\n            x = check[i]\n            if x[0] == x[1]:\n                ans += 1\n        print(ans)\n    return\nsetrecursionlimit(10 ** 9)\ninput = stdin.readline\nmain()", "import sys\nsys.setrecursionlimit(2 * 10 ** 5 + 1)\nvc = []\nsum = []\n\ndef dfs(u, v):\n    for z in vc[u]:\n        if z == v:\n            continue\n        else:\n            dfs(z, u)\n            sum[u] += sum[z]\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    vc = []\n    sum = []\n    s = input()\n    for i in range(0, n + 2):\n        sum.append(0)\n        vc.append([])\n    for i in range(0, n):\n        if s[i] == 'B':\n            sum[i + 1] = 1\n        else:\n            sum[i + 1] = -1\n    for i in range(1, n):\n        vc[a[i - 1]].append(i + 1)\n        vc[i + 1].append(a[i - 1])\n    dfs(1, 0)\n    ans = 0\n    for i in range(1, n + 1):\n        if sum[i] == 0:\n            ans += 1\n    print(ans)", "from collections import *\n\ndef get_int():\n    return int(input())\n\ndef get_nums():\n    return list(map(int, input().split()))\n\ndef main():\n    test = get_int()\n    for _ in range(test):\n        n = get_int()\n        nums = get_nums()\n        color = input()\n        graph = defaultdict(list)\n        for (index, value) in enumerate(nums):\n            graph[value].append(index + 2)\n        dp = [[0, 0] for _ in range(n + 1)]\n        ans = [0]\n\n        def dfs(root, parent):\n            dp[root][0] = color[root - 1] == 'W'\n            dp[root][1] = color[root - 1] == 'B'\n            for child in graph[root]:\n                if child != parent:\n                    dfs(child, root)\n                    dp[root][0] += dp[child][0]\n                    dp[root][1] += dp[child][1]\n            ans[0] += dp[root][0] == dp[root][1] > 0\n        dfs(1, -1)\n        print(ans[0])\nimport threading\nimport sys\nsys.setrecursionlimit(1 << 27)\nmain_threading = threading.Thread(target=main)\nmain_threading.start()\nmain_threading.join()", "import sys\nsys.setrecursionlimit(10 ** 5)\nimport bisect\nt = int(input())\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    s = input()\n    cnt = [0] * (n + 1)\n    E = {i: set() for i in range(1, n + 1)}\n    for i in range(n - 1):\n        E[A[i]].add(i + 2)\n\n    def dfs(x):\n        if s[x - 1] == 'W':\n            (w, b) = (1, 0)\n        else:\n            (w, b) = (0, 1)\n        for y in E[x]:\n            (tw, tb) = dfs(y)\n            w += tw\n            b += tb\n        cnt[x] = [w, b]\n        return (w, b)\n    dfs(1)\n    ans = 0\n    for i in range(1, n + 1):\n        if cnt[i][0] == cnt[i][1]:\n            ans += 1\n    print(ans)\nfor _ in range(t):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass TreeNode:\n\n    def __init__(self, val, col):\n        self.val = val\n        self.col = col\n        self.ch = []\n\n    def inord(self):\n        print(self.val)\n        for c in self.ch:\n            c.inord()\n\ndef balcnt(root):\n    if root == None:\n        return [0, 0]\n    allw = 0\n    allb = 0\n    for c in root.ch:\n        (w, b) = balcnt(c)\n        allw += w\n        allb += b\n    if root.col == 0:\n        allw += 1\n    else:\n        allb += 1\n    if allw == allb:\n        cnt[0] += 1\n    return [allw, allb]\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    p = list(map(int, input().split()))\n    s = input()\n    root = TreeNode(1, 0 if s[0] == 'W' else 1)\n    nodes = [root]\n    for i in range(1, n):\n        nodes.append(TreeNode(i + 1, 0 if s[i] == 'W' else 1))\n    for i in range(n - 1):\n        par = nodes[p[i] - 1]\n        cur = nodes[i + 2 - 1]\n        par.ch.append(cur)\n    cnt = [0]\n    balcnt(root)\n    print(cnt[0])", "import sys, threading\nsys.setrecursionlimit(10 ** 4)\n\ndef dfs(x):\n    global v, adj, l, c, ans\n    v[x] = 1\n    if c[x - 1] == 'W':\n        l[x][0] = 1\n    else:\n        l[x][1] = 1\n    for i in adj[x]:\n        if not v[i]:\n            dfs(i)\n            l[x][0] += l[i][0]\n            l[x][1] += l[i][1]\n    if l[x][0] == l[x][1]:\n        ans += 1\n\ndef main():\n    global v, adj, l, c, ans\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        c = list(input())\n        v = [0] * (n + 1)\n        adj = [[] for i in range(n + 1)]\n        l = [[0, 0] for i in range(n + 1)]\n        ans = 0\n        for i in range(n - 1):\n            adj[i + 2].append(a[i])\n            adj[a[i]].append(i + 2)\n        dfs(1)\n        print(ans)\nmain()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    s = input()\n    adj_list = {}\n    for i in range(n):\n        adj_list[i] = []\n    for i in range(n - 1):\n        cur = a[i]\n        adj_list[cur - 1].append(i + 1)\n    cts = [[0, 0] for i in range(n)]\n\n    def fun(root):\n        childs = adj_list[root]\n        (w, b) = (0, 0)\n        if s[root] == 'W':\n            w += 1\n        else:\n            b += 1\n        for chi in childs:\n            if sum(cts[chi]) == 0:\n                (w1, b1) = fun(chi)\n            else:\n                (w1, b1) = (cts[chi][0], cts[chi][1])\n            w += w1\n            b += b1\n        (cts[root][0], cts[root][1]) = (w, b)\n        return (w, b)\n    fun(0)\n    ans = 0\n    for i in range(n):\n        if cts[i][0] == cts[i][1]:\n            ans += 1\n    print(ans)", "import sys\nsys.setrecursionlimit(10000000)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    graph = {x: [] for x in range(1, n + 1)}\n    color = input()\n    for (i, item) in enumerate(a):\n        graph[item].append(i + 2)\n    white_memo = {x: 0 for x in range(1, n + 1)}\n\n    def f_white(x):\n        if white_memo.get(x):\n            return white_memo[x]\n        if color[x - 1] == 'W':\n            ans = 1\n        else:\n            ans = 0\n        for item in graph[x]:\n            ans += f_white(item)\n        white_memo[x] = ans\n        return ans\n    black_memo = {x: 0 for x in range(1, n + 1)}\n\n    def f_black(x):\n        if black_memo.get(x):\n            return black_memo[x]\n        if color[x - 1] == 'B':\n            ans = 1\n        else:\n            ans = 0\n        for item in graph[x]:\n            ans += f_black(item)\n        black_memo[x] = ans\n        return ans\n    f_white(1)\n    f_black(1)\n    same = 0\n    for (key, value) in white_memo.items():\n        if black_memo[key] == value:\n            same += 1\n    print(same)", "def task(n, a, s):\n    leafs = dict()\n    for i in range(1, n + 1):\n        leafs[i] = True\n    leafs[1] = False\n    for i in a:\n        leafs[i] = False\n    parents = dict()\n    parents[1] = None\n    for i in range(2, n + 1):\n        parents[i] = a[i - 2]\n    childs = dict()\n    for i in range(n - 1):\n        if not a[i] in childs:\n            childs[a[i]] = set()\n        childs[a[i]].add(i + 2)\n    cache = dict()\n    queue = []\n    for key in leafs.keys():\n        if leafs[key]:\n            queue.append(key)\n        if s[key - 1] == 'W':\n            cache[key] = 1\n        else:\n            cache[key] = -1\n    total = 0\n    while len(queue):\n        item = queue.pop()\n        if cache[item] == 0:\n            total += 1\n        parent = parents[item]\n        if item != 1:\n            childs[parent].remove(item)\n            cache[parent] += cache[item]\n            if len(childs[parent]) == 0:\n                queue.insert(0, parent)\n    print(total)\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = input()\n    task(n, a, s)", "import sys, threading\nsys.setrecursionlimit(10 ** 5)\nthreading.stack_size(10 ** 8)\n\ndef dfs(x):\n    global v, adj, l, c, ans\n    v[x] = 1\n    if c[x - 1] == 'W':\n        l[x][0] = 1\n    else:\n        l[x][1] = 1\n    for i in adj[x]:\n        if not v[i]:\n            dfs(i)\n            l[x][0] += l[i][0]\n            l[x][1] += l[i][1]\n    if l[x][0] == l[x][1]:\n        ans += 1\n\ndef main():\n    global v, adj, l, c, ans\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        c = list(input())\n        v = [0] * (n + 1)\n        adj = [[] for i in range(n + 1)]\n        l = [[0, 0] for i in range(n + 1)]\n        ans = 0\n        for i in range(n - 1):\n            adj[i + 2].append(a[i])\n            adj[a[i]].append(i + 2)\n        dfs(1)\n        print(ans)\nmain()"]