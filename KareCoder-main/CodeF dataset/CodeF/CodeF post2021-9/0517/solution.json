["def solve():\n    t = input()\n    n = int(input())\n    strings = []\n    for i in range(n):\n        strings.append(input())\n    intervals = []\n    for i in range(n):\n        for j in range(len(t)):\n            if t[j:j + len(strings[i])] == strings[i]:\n                intervals.append((j, j + len(strings[i]), i))\n    intervals.sort()\n    if len(intervals) == 0:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        return used\n    else:\n        return -1\nq = int(input())\nsol = []\nfor _ in range(q):\n    sol.append(solve())\nfor so in sol:\n    if so == -1:\n        print(-1)\n    else:\n        print(len(so))\n        for (s, e, ind) in so:\n            print(ind + 1, s + 1)", "def find(a, b, t, strs, ans):\n    (maxi, id, pos) = (0, -1, -1)\n    for i in range(a, b + 1):\n        for j in range(len(strs)):\n            s = strs[j]\n            c = i + len(s)\n            if c > len(t) or c <= b:\n                continue\n            if t[i:c] == s and c > maxi:\n                maxi = c\n                id = j\n                pos = i\n    if id == -1:\n        return []\n    else:\n        ans.append((id, pos))\n        if maxi == len(t):\n            return ans\n        else:\n            return find(max(pos + 1, b + 1), maxi, t, strs, ans)\nT = int(input())\nfor _ in range(T):\n    t = input()\n    n = int(input())\n    strs = []\n    for _ in range(n):\n        s = input()\n        strs.append(s)\n    ans = find(0, 0, t, strs, [])\n    if len(ans) == 0:\n        print(-1)\n    else:\n        print(len(ans))\n        for (a, b) in ans:\n            print('{} {}'.format(a + 1, b + 1))", "q = int(input())\n\ndef find(index, text, arr, n):\n    id = -1\n    mx_length = 0\n    for i in range(n):\n        if text[index:].find(arr[i]) == 0 and len(arr[i]) > mx_length:\n            mx_length = len(arr[i])\n            id = i + 1\n    return id\n\ndef solve():\n    t = input()\n    n = int(input())\n    arr = []\n    for i in range(n):\n        arr += [input()]\n    start = 0\n    ans = 0\n    result = []\n    idx = find(start, t, arr, n)\n    if idx == -1:\n        print(-1)\n    else:\n        ans += 1\n        result += [[idx, start + 1]]\n        right_most_colored = len(arr[idx - 1]) - 1\n        while right_most_colored < len(t) - 1:\n            idx = -1\n            cnt = -1\n            for i in range(start + 1, right_most_colored + 2):\n                longest_covering_string = find(i, t, arr, n)\n                if longest_covering_string != -1:\n                    if i + len(arr[longest_covering_string - 1]) - 1 > right_most_colored:\n                        right_most_colored = i + len(arr[longest_covering_string - 1]) - 1\n                        idx = longest_covering_string\n                        cnt = i\n            if idx == -1:\n                print(-1)\n                return\n            ans += 1\n            result += [[idx, cnt + 1]]\n            start = cnt\n        print(ans)\n        for i in range(ans):\n            print(*result[i])\nwhile q:\n    solve()\n    q -= 1", "q = int(input())\nfor _ in range(q):\n    t = input()\n    n = int(input())\n    S = [input() for i in range(n)]\n    cur = 0\n    mx = -1\n    ans = []\n    mxid = 0\n    flag_bad = False\n    for i in range(len(t)):\n        for ids in range(len(S)):\n            if i + len(S[ids]) <= len(t) and t[i:i + len(S[ids])] == S[ids]:\n                if i + len(S[ids]) - 1 > mx:\n                    mx = i + len(S[ids]) - 1\n                    mxid = ids\n        if cur == i:\n            if mx < i:\n                print(-1)\n                flag_bad = True\n                break\n            else:\n                ans.append((mxid + 1, mx - len(S[mxid]) + 2))\n                cur = mx + 1\n    if not flag_bad:\n        print(len(ans))\n        for el in ans:\n            print(el[0], el[1])", "ans = 0\nok = True\n\ndef Find(a, b, t, s_list, match):\n    global ans, ok\n    (Max, id, pos) = (0, -1, -1)\n    for i in range(a, b + 1):\n        for j in range(len(s_list)):\n            s = s_list[j]\n            if i + len(s) > len(t) or i + len(s) <= b:\n                continue\n            if t[i:i + len(s)] == s:\n                if i + len(s) > Max:\n                    Max = i + len(s)\n                    id = j\n                    pos = i\n    if id == -1:\n        ok = False\n        return\n    else:\n        match.append((id, pos))\n        ans += 1\n        if Max == len(t):\n            return\n        else:\n            Find(b + 1, Max, t, s_list, match)\n\ndef solve():\n    global ans, ok\n    ans = 0\n    ok = True\n    t = input()\n    n = int(input())\n    s_list = []\n    match = []\n    for _ in range(n):\n        s_list.append(input())\n    Find(0, 0, t, s_list, match)\n    if not ok:\n        print(-1)\n    else:\n        print(ans)\n        for p in match:\n            print(p[0] + 1, p[1] + 1)\nt = int(input())\nfor _ in range(t):\n    solve()", "from itertools import islice\nt = int(input())\nfor i in range(t):\n    text = input()\n    m = int(input())\n    strings = []\n    indexes = {}\n    for i in range(m):\n        strings.append(input())\n    indices = [-1] * (len(text) + 1)\n    for (index, string) in enumerate(strings):\n        i = 0\n        while i + len(string) <= len(text):\n            if text[i:i + len(string)] == string:\n                if indices[i] < i + len(string):\n                    indices[i] = i + len(string)\n                    indexes[i] = index\n            i += 1\n    i = 0\n    ans = []\n    while i < len(text):\n        (max_index, max_value) = max(enumerate(islice(indices, i + 1)), key=lambda k: k[1])\n        if max_value <= i:\n            print(-1)\n            break\n        else:\n            ans.append((indexes[max_index], max_index))\n            i = max_value\n    else:\n        print(len(ans))\n        for (a, b) in ans:\n            print(a + 1, b + 1)", "from heapq import heappush, heappop\n\ndef main():\n    for _ in range(int(input())):\n        problem()\n\ndef problem():\n    word = input().rstrip()\n    num_piece = int(input())\n    pieces = [input().rstrip() for _ in range(num_piece)]\n    matches = [[] for _ in range(len(word))]\n    for (pi, piece) in enumerate(pieces):\n        for i in range(len(word)):\n            if i + len(piece) > len(word):\n                break\n            if word[i:i + len(piece)] == piece:\n                starts_at = i\n                piece_no = pi\n                ends_at = starts_at + len(piece)\n                matches[i].append((ends_at, starts_at, piece_no))\n    last_painted_until = -1\n    painted_until = 0\n    heap = []\n    history = []\n    while painted_until < len(word):\n        for k in range(last_painted_until + 1, painted_until + 1):\n            for match in matches[k]:\n                (ends_at, starts_at, piece_no) = match\n                heappush(heap, (-ends_at, starts_at, piece_no))\n        if len(heap) == 0:\n            print('-1')\n            return\n        (ends_at, starts_at, piece_no) = heappop(heap)\n        ends_at = -ends_at\n        history.append((piece_no, starts_at))\n        last_painted_until = painted_until\n        painted_until = ends_at\n    print(len(history))\n    for (i, j) in history:\n        print(i + 1, j + 1)\nimport sys\ninput = sys.stdin.readline\nsys.exit(main())", "def main():\n    t = input()\n    n = len(t)\n    ans = []\n    ok = True\n    substrings = []\n    for _ in range(int(input())):\n        substrings.append(input())\n    s = sorted(substrings, key=len, reverse=True)\n    i = 0\n    while i < n:\n        max_len = i\n        index = 0\n        pos = 0\n        for w in s:\n            lw = len(w)\n            for j in range(lw):\n                start = i - j\n                end = i - j + lw\n                if start > -1 and end <= n and (t[start:end] == w):\n                    if end > max_len:\n                        max_len = end\n                        index = substrings.index(w)\n                        pos = i - j\n        if max_len == i:\n            ok = False\n            break\n        ans.append([index, pos])\n        i = max_len\n    if ok:\n        print(len(ans))\n        for l in ans:\n            print(f'{l[0] + 1} {l[1] + 1}')\n    else:\n        print(-1)\nn = int(input())\nfor _ in range(n):\n    main()", "for _ in range(int(input())):\n    st = input()\n    case = []\n    length = len(st)\n    for i in range(int(input())):\n        case.append(input())\n    tas = []\n    dp = [0] + [float('inf')] * length\n    dic = {}\n    dic2 = {}\n    bre = False\n    for i in range(0, length):\n        for x in range(len(case)):\n            leng = len(case[x])\n            if i + leng <= length:\n                sub = st[i:i + leng]\n                if st[i:i + leng] == case[x]:\n                    for y in range(i, i + leng):\n                        mini = min(dp[y + 1], dp[i] + 1)\n                        dp[y + 1] = mini\n                    if mini <= dp[i + leng]:\n                        if mini in dic2:\n                            if i + leng > dic2[mini]:\n                                dic[mini] = [str(x + 1), str(i + 1)]\n                                dic2[mini] = i + leng\n                        else:\n                            dic[mini] = [str(x + 1), str(i + 1)]\n                            dic2[mini] = i + leng\n    if dp[-1] != float('inf'):\n        print(dp[-1])\n        for x in dic.values():\n            print(' '.join(x))\n    else:\n        print(-1)"]