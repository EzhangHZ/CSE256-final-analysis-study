["import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    par = [-1 for _ in range(n + 2)]\n    child = [[] for _ in range(n + 2)]\n    degree = [0] * (n + 2)\n    B = list(map(int, input().split()))\n    rg = [0, n]\n    for i in range(n):\n        if B[i] > i + 1:\n            rg[0] = max(rg[0], i + 1)\n        elif B[i] < i + 1:\n            rg[1] = min(rg[1], i)\n        par[i + 1] = B[i]\n        degree[B[i]] += 1\n        child[B[i]].append(i + 1)\n    root = 1\n    while par[root] >= 0:\n        root = par[root]\n    ans = []\n    q = deque([root])\n    while q:\n        node = q.popleft()\n        if 1 <= node <= n:\n            ans.append(node)\n        tmp = []\n        for ch in child[node]:\n            if degree[ch] == 0:\n                q.append(ch)\n            else:\n                tmp.append(ch)\n        while tmp:\n            q.append(tmp.pop())\n    print(rg[0])\n    print(*ans)\n    return\nfor _ in range(int(input())):\n    solve()", "import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    n = int(inp())\n    b = list(map(int, inp().split()))\n    g = [[] for i in range(n + 2)]\n    for i in range(n):\n        g[b[i]].append(i + 1)\n    d = [-1] * (n + 2)\n    q = [0, n + 1]\n    res = []\n    if len(g[0]):\n        f = 1\n    else:\n        f = 0\n    M = n + 5\n    m = 0\n    while q:\n        q.sort(key=lambda x: len(g[x]))\n        res += q\n        qn = []\n        for x in q:\n            for v in g[x]:\n                if d[v] < 0:\n                    d[v] = d[x] + 1\n                    qn.append(v)\n                    if f == 1:\n                        M = min(M, v)\n                    else:\n                        m = max(m, v)\n        f ^= 1\n        q = qn\n    print(m)\n    print(' '.join(map(str, res[2:])))\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    w = [int(k) for k in input().split()]\n    for j in range(n):\n        if w[j] < j + 1:\n            k = j\n            break\n    else:\n        k = n\n    q = {}\n    for j in range(n):\n        if w[j] in q:\n            q[w[j]].append(j + 1)\n        else:\n            q[w[j]] = [j + 1]\n    new = []\n    z = n + 1\n    if z in q:\n        while True:\n            new.append([])\n            new[-1] = q[z]\n            for j in new[-1]:\n                if j in q:\n                    z = j\n                    new[-1][new[-1].index(z)] = new[-1][-1]\n                    new[-1][-1] = z\n                    break\n            else:\n                break\n    z = 0\n    if z in q:\n        while True:\n            new.append([])\n            new[-1] = q[z]\n            for j in new[-1]:\n                if j in q:\n                    z = j\n                    new[-1][new[-1].index(z)] = new[-1][-1]\n                    new[-1][-1] = z\n                    break\n            else:\n                break\n    delta = []\n    for j in new:\n        delta.extend(j)\n    print(k)\n    print(' '.join([str(k) for k in delta]))", "m = int(input())\nfor _ in range(m):\n    n = int(input())\n    b = [0] + [int(x) for x in input().split()]\n    seg = [0, n + 1]\n    for i in range(1, len(b)):\n        left = min(i, b[i])\n        right = max(i, b[i])\n        seg[0] = max(seg[0], left)\n        seg[1] = min(seg[1], right)\n        if seg[1] - seg[0] == 1:\n            break\n    k = seg[0]\n    print(k)\n    dic = {}\n    for i in range(1, len(b)):\n        if b[i] in dic:\n            dic[b[i]].append(i)\n        else:\n            dic[b[i]] = [i]\n    now = 0 if 0 in dic else n + 1\n    while True:\n        tem = -1\n        for j in dic[now]:\n            if j not in dic:\n                print(j, end=' ')\n            else:\n                tem = j\n        if tem == -1:\n            break\n        now = tem\n        print(now, end=' ')\n    print()"]