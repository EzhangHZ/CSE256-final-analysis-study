["import sys\nfrom collections import deque\n\ndef solve(n, edges):\n    vis = [-1] * (n + 1)\n    g = [set() for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].add(v)\n        g[v].add(u)\n    subs = [[], []]\n    for i in range(1, n + 1):\n        if vis[i] < 0:\n            q = deque([i])\n            vis[i] = 0\n            subs[0].append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if vis[v] < 0:\n                        g[v].remove(u)\n                        vis[v] = 1 - vis[u]\n                        q.append(v)\n                        subs[vis[v]].append(v)\n    subs.sort(key=lambda it: len(it))\n    m = len(subs[0])\n    val = []\n    while m:\n        b = m & -m\n        val.extend(list(range(b, b << 1)))\n        m -= b\n    st = set(val)\n    for i in subs[0]:\n        vis[i] = val.pop()\n    k = 1\n    for i in subs[1]:\n        while k in st:\n            k += 1\n        vis[i] = k\n        k += 1\n    return ' '.join(map(str, vis[1:]))\nt = int(sys.stdin.readline())\nans = []\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    ans.append(solve(n, edges))\nprint('\\n'.join(ans))", "from collections import deque\nfor _ in range(int(input())):\n    N = int(input())\n    I = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        I[u].append(v)\n        I[v].append(u)\n    state = [-1] * N\n    s = 0\n    state[s] = 0\n    task = deque([s])\n    while task:\n        p = task.pop()\n        for q in I[p]:\n            if state[q] != -1:\n                continue\n            state[q] = 1 ^ state[p]\n            task.append(q)\n    g0 = []\n    g1 = []\n    for (i, s) in enumerate(state):\n        if s:\n            g1.append(i)\n        else:\n            g0.append(i)\n    if len(g1) > len(g0):\n        (g1, g0) = (g0, g1)\n    p1 = []\n    t1 = len(g1)\n    ans = [-1] * N\n    idx0 = 0\n    idx1 = 0\n    now = 1\n    while t1 > 0:\n        if t1 & 1:\n            for j in range(now, 2 * now):\n                ans[g1[idx1]] = j\n                idx1 += 1\n        else:\n            for j in range(now, 2 * now):\n                ans[g0[idx0]] = j\n                idx0 += 1\n        t1 >>= 1\n        now *= 2\n    for j in range(now, N + 1):\n        ans[g0[idx0]] = j\n        idx0 += 1\n    print(*ans)", "def solution():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(lambda x: int(x) - 1, input().strip().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = [-1] * n\n    stk = [0]\n    colors[0] = 0\n    while stk:\n        u = stk.pop()\n        for v in adj[u]:\n            if colors[v] != -1:\n                continue\n            colors[v] = colors[u] ^ 1\n            stk.append(v)\n    (w, color) = (sum(colors), 1)\n    if w > n - w:\n        (w, color) = (n - w, 0)\n    result = [0] * n\n    idx1 = [i for (i, c) in enumerate(colors) if c == color]\n    idx2 = [j for (j, c) in enumerate(colors) if c != color]\n    bit = 1\n    i = j = 0\n    while bit <= n:\n        if w & bit:\n            for x in range(bit, min(2 * bit - 1, n) + 1):\n                result[idx1[i]] = x\n                i += 1\n        else:\n            for x in range(bit, min(2 * bit - 1, n) + 1):\n                result[idx2[j]] = x\n                j += 1\n        bit <<= 1\n    return ' '.join(map(lambda x: str(x), result))\nfor case in range(int(input())):\n    print('%s' % solution())", "def solution():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(lambda x: int(x) - 1, input().strip().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    colors = [-1] * n\n    stk = [0]\n    colors[0] = 0\n    while stk:\n        u = stk.pop()\n        for v in adj[u]:\n            if colors[v] != -1:\n                continue\n            colors[v] = colors[u] ^ 1\n            stk.append(v)\n    (w, color) = (sum(colors), 1)\n    if w > n - w:\n        (w, color) = (n - w, 0)\n    result = [0] * n\n    idx1 = [i for (i, c) in enumerate(colors) if c == color]\n    idx2 = [j for (j, c) in enumerate(colors) if c != color]\n    bit = 1\n    i = j = 0\n    while bit <= n:\n        if w & bit:\n            for x in range(bit, min(2 * bit - 1, n) + 1):\n                result[idx1[i]] = x\n                i += 1\n        else:\n            for x in range(bit, min(2 * bit - 1, n) + 1):\n                result[idx2[j]] = x\n                j += 1\n        bit <<= 1\n    return ' '.join(map(lambda x: str(x), result))\nfor case in range(int(input())):\n    print('%s' % solution())", "from collections import deque\nfor _ in range(int(input())):\n    N = int(input())\n    I = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        I[u].append(v)\n        I[v].append(u)\n    state = [-1] * N\n    s = 0\n    state[s] = 0\n    task = deque([s])\n    while task:\n        p = task.pop()\n        for q in I[p]:\n            if state[q] != -1:\n                continue\n            state[q] = 1 ^ state[p]\n            task.append(q)\n    g0 = []\n    g1 = []\n    for (i, s) in enumerate(state):\n        if s:\n            g1.append(i)\n        else:\n            g0.append(i)\n    if len(g1) > len(g0):\n        (g1, g0) = (g0, g1)\n    p1 = []\n    t1 = len(g1)\n    ans = [-1] * N\n    idx0 = 0\n    idx1 = 0\n    now = 1\n    while t1 > 0:\n        if t1 & 1:\n            for j in range(now, 2 * now):\n                ans[g1[idx1]] = j\n                idx1 += 1\n        else:\n            for j in range(now, 2 * now):\n                ans[g0[idx0]] = j\n                idx0 += 1\n        t1 >>= 1\n        now *= 2\n    for j in range(now, N + 1):\n        ans[g0[idx0]] = j\n        idx0 += 1\n    print(*ans)", "(p, r) = (input, range)\nfor _ in r(int(p())):\n    n = int(p())\n    h = [set() for i in r(n)]\n    if n == 1:\n        print(1)\n        continue\n    for i in r(n - 1):\n        (u, v) = map(int, p().split())\n        h[u - 1].add(v - 1)\n        h[v - 1].add(u - 1)\n    (c, s, g, i) = ([len(h[i]) for i in r(n)], [0] * n, [0], 1)\n    while 2 ** i - 1 < n:\n        g.append(2 ** i - 1)\n        i += 1\n    g.append(n)\n    l = [i for i in r(n) if c[i] == 1]\n    while l != []:\n        b = []\n        for v in l:\n            (c[v], e) = (0, set())\n            for u in h[v]:\n                if c[u] > 0:\n                    c[u] -= 1\n                    if c[u] == 1:\n                        b.append(u)\n                elif s[u] != 0:\n                    e.add(len(bin(s[u])) - 2)\n            for i in r(len(g) - 1, 0, -1):\n                if i not in e and g[i] >= 2 ** (i - 1):\n                    s[v] = g[i]\n                    g[i] -= 1\n                    break\n        l = b\n    print(' '.join([str(c) for c in s]))"]