["def corruption(n, k):\n    MOD = 10 ** 9 + 7\n    if k >= n:\n        return 2 ** n % MOD\n    res = 1\n    choose = 1\n    for i in range(1, k + 1):\n        choose = choose * (n - i + 1) * pow(i, -1, MOD) % MOD\n        res = (res + choose) % MOD\n    return res\n(n, k) = tuple(map(int, input().split()))\nprint(corruption(n, k))", "def solve():\n    mod = 1000000007\n    (n, k) = map(int, input().strip().split())\n    res = pow(2, n, mod)\n    if k >= n:\n        print(res)\n    elif k + 1 == n:\n        print(res - 1)\n    else:\n        f = [1 for i in range(n + 1)]\n        fi = [1 for i in range(n + 1)]\n        for i in range(1, n + 1):\n            f[i] = f[i - 1] * i % mod\n        fi[n] = pow(f[n], mod - 2, mod)\n        for i in range(n - 1, 0, -1):\n            fi[i] = fi[i + 1] * (i + 1) % mod\n        ans = 0\n        for i in range(0, k + 1):\n            ans += f[n] * fi[n - i] * fi[i] % mod\n            ans %= mod\n        print(ans)\nsolve()", "(n, k) = map(int, input().split())\nans = 1\ns = 1\ny = k - (k - n // 2)\nh = min(n // 2 + (n % 2 == 1) + 1, k + 1)\nif k < n:\n    if k + 1 == h:\n        for i in range(1, h):\n            s = s * (n - i + 1) * pow(i, -1, 10 ** 9 + 7) % (10 ** 9 + 7)\n            ans += s\n            if y > 0 and i > y and (h - 1 != i):\n                ans += s\n        print(ans % (10 ** 9 + 7))\n    else:\n        for i in range(1, n - k):\n            s = s * (n - i + 1) * pow(i, -1, 10 ** 9 + 7) % (10 ** 9 + 7)\n            ans += s\n            if y > 0 and i > y and (h - 1 != i):\n                ans += s\n        print((pow(2, n) - ans) % (10 ** 9 + 7))\nelse:\n    print(pow(2, n, 10 ** 9 + 7))", "import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    (n, k) = map(int, inp().split())\n    MOD = int(1000000000.0 + 7)\n    if k >= n:\n        print(pow(2, n, MOD))\n        return\n    F = [None] * (n + 1)\n    F[0] = 1\n    for i in range(1, n + 1):\n        F[i] = F[i - 1] * i % MOD\n    FI = [None] * (n + 1)\n    FI[n] = pow(F[n], MOD - 2, MOD)\n    FI[0] = 1\n    for i in range(n - 1, 0, -1):\n        FI[i] = FI[i + 1] * (i + 1) % MOD\n    r = 0\n    for i in range(0, k + 1):\n        r = (r + F[n] * FI[n - i] * FI[i]) % MOD\n    print(r)\n\ndef main():\n    solve()\nmain()", "(n, k) = [int(e) for e in input().split()]\nk = min(k, n)\nresult = 1\nc = 1\nmodulo = 10 ** 9 + 7\ninv = [0 for i in range(k + 1)]\ninv[0] = 1\nif k + 1 >= 2:\n    inv[1] = 1\nfor i in range(2, k + 1):\n    inv[i] = modulo - modulo // i * inv[modulo % i] % modulo\nfor m in range(1, k + 1):\n    c = c * (n - m + 1) * inv[m]\n    c %= modulo\n    result = (result + c) % modulo\nprint(result)", "MOD = 10 ** 9 + 7\nMAX_F = 10 ** 5 + 5\nfact = [1 for i in range(MAX_F)]\nifact = [1 for i in range(MAX_F)]\n\ndef mult(a, b):\n    return a * b % MOD\n\ndef power(a, n):\n    if n == 0:\n        return 1\n    tmp = power(a, n // 2)\n    if n % 2 == 0:\n        return mult(tmp, tmp) % MOD\n    return mult(a, mult(tmp, tmp)) % MOD\n\ndef C(n, k):\n    if k < 0 or k > n:\n        return 0\n    return mult(fact[n], mult(ifact[n - k], ifact[k]))\n\ndef init():\n    n = MAX_F - 1\n    for i in range(1, n + 1):\n        fact[i] = mult(fact[i - 1], i)\n    ifact[n] = power(fact[n], MOD - 2)\n    for i in range(n - 1, 0, -1):\n        ifact[i] = mult(ifact[i + 1], i + 1)\ninit()\n(n, k) = map(int, input().split())\nres = 0\nfor m in range(min(n, k) + 1):\n    res += C(n, m)\n    res = res % MOD\nprint(res)", "import sys\ninput = sys.stdin.readline\n\ndef int_num():\n    return int(input())\n\ndef int_list():\n    return list(map(int, input().split()))\n\ndef str_list():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef instr():\n    return input().strip()\n\ndef invr():\n    return map(int, input().split())\n\ndef cal_c1(n, k):\n    MOD = 10 ** 9 + 7\n    k = min(n, k)\n    ans = 1\n    da = 1\n    for i in range(1, k + 1):\n        da *= n + 1 - i\n        da %= MOD\n        t = pow(i, -1, MOD)\n        da *= t\n        da %= MOD\n        ans += da\n        ans %= MOD\n    return ans\n\ndef solve():\n    (n, k) = int_list()\n    ans = cal_c1(n, k)\n    print(ans)\n\ndef main():\n    solve()\nmain()", "(n, k) = map(int, input().split())\nx = 0\ny = 1\nmod = 10 ** 9 + 7\nfor i in range(min(n, k) + 1):\n    x = (x + y) % mod\n    y = y * (n - i) * pow(i + 1, -1, mod) % mod\nprint(x)", "(n, k) = map(int, input().split())\nbinom = 1\ncurNum = n\ncurDeNum = 1\nrem = 0\nc = 0\nwhile k >= 0 and c <= n:\n    c += 1\n    k -= 1\n    rem = (rem + binom) % 1000000007\n    binom = binom * curNum * pow(curDeNum, -1, 1000000007) % 1000000007\n    curNum -= 1\n    curDeNum += 1\nprint(rem)", "(n, k) = map(int, input().split())\nans = 0\ncur = 0\nfor i in range(0, min(n, k) + 1):\n    if i == 0:\n        ans += 1\n        cur = 1\n    else:\n        cur *= n - (i - 1)\n        cur *= pow(i, -1, 1000000007)\n        cur = cur % 1000000007\n        ans += cur\n        ans = ans % 1000000007\nprint(ans)", "(welln, kwell) = map(int, input().split())\nkwell = min(kwell, welln)\nwellMODwell = 10 ** 9 + 7\ncounwellt = 0\nwellc = 1\nfor i in range(kwell + 1):\n    counwellt = (counwellt + wellc) % wellMODwell\n    wellc = wellc * (welln - i) * pow(i + 1, wellMODwell - 2, wellMODwell) % wellMODwell\nprint(counwellt)", "(n, k) = map(int, input().split())\nk = min(k, n)\nMOD = 10 ** 9 + 7\ncount = 0\nc = 1\nfor i in range(k + 1):\n    count = (count + c) % MOD\n    c = c * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD\nprint(count)", "(n, k) = map(int, input().split())\nk = min(k, n)\nMOD = 10 ** 9 + 7\nresult = 0\nc = 1\nfor i in range(k + 1):\n    result = (result + c) % MOD\n    c = c * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD\nprint(result)", "def solve():\n    mod = 1000000007\n    (n, k) = map(int, input().strip().split())\n    res = pow(2, n, mod)\n    if k >= n:\n        print(res)\n    elif k + 1 == n:\n        print(res - 1)\n    else:\n        ans = 1\n        temp1 = 1\n        temp2 = 1\n        for i in range(1, n - k):\n            temp1 *= n - i + 1\n            temp1 %= mod\n            temp2 *= i\n            temp2 %= mod\n            ans += temp1 * pow(temp2, mod - 2, mod) % mod\n        print((res - ans + mod) % mod)\nsolve()", "def solve():\n    mod = 1000000007\n    (n, k) = map(int, input().strip().split())\n    res = pow(2, n, mod)\n    if k >= n:\n        print(res)\n    elif k + 1 == n:\n        print(res - 1)\n    else:\n        ans = 1\n        temp1 = 1\n        temp2 = 1\n        for i in range(1, n - k):\n            temp1 *= n - i + 1\n            temp1 %= mod\n            temp2 *= i\n            temp2 %= mod\n            ans += temp1 * pow(temp2, mod - 2, mod) % mod\n        print((res - ans + mod) % mod)\nsolve()"]