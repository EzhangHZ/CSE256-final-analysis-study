["import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q", "import sys\n\ndef f(u, p, g):\n    nd = []\n    for v in g[u]:\n        if v != p:\n            nd.append(v)\n    if len(nd) == 0:\n        return (1, 0)\n    if len(nd) == 1:\n        (n, _) = f(nd[0], u, g)\n        return (n + 1, n - 1)\n    (n1, s1) = f(nd[0], u, g)\n    (n2, s2) = f(nd[1], u, g)\n    return (n1 + n2 + 1, max(s1 + n2 - 1, s2 + n1 - 1))\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        adj = [[] for i in range(n)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        x = f(0, -1, adj)[1]\n        print(x)\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\n\ndef f(u, p, g):\n    nd = []\n    for v in g[u]:\n        if v != p:\n            nd.append(v)\n    if len(nd) == 0:\n        return (1, 0)\n    if len(nd) == 1:\n        (n, _) = f(nd[0], u, g)\n        return (n + 1, n - 1)\n    (n1, s1) = f(nd[0], u, g)\n    (n2, s2) = f(nd[1], u, g)\n    return (n1 + n2 + 1, max(s1 + n2 - 1, s2 + n1 - 1))\n\ndef solution(adj, n):\n    if n == 1:\n        return 0\n    return f(0, -1, adj)[1]\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        adj = [[] for i in range(n)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        x = solution(adj, n)\n        print(x)\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q", "import sys\n\ndef f(u, p, g):\n    nd = []\n    for v in g[u]:\n        if v != p:\n            nd.append(v)\n    if len(nd) == 0:\n        return (1, 0)\n    if len(nd) == 1:\n        (n, _) = f(nd[0], u, g)\n        return (n + 1, n - 1)\n    (n1, s1) = f(nd[0], u, g)\n    (n2, s2) = f(nd[1], u, g)\n    return (n1 + n2 + 1, max(s1 + n2 - 1, s2 + n1 - 1))\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        adj = [[] for i in range(n)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        x = f(0, -1, adj)[1]\n        print(x)\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from sys import stdin\ninput = stdin.readline\nfrom collections import deque\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    vis = set()\n    q = deque([(1, 0)])\n    res = 0\n    while q:\n        (cn, l) = q.popleft()\n        vis.add(cn)\n        cc = len([x for x in g[cn] if x not in vis])\n        if cc <= 1:\n            res = max(res, n - 2 * l - cc - 1)\n        for nn in g[cn]:\n            if nn not in vis:\n                q.append((nn, l + 1))\n    print(res)", "t = int(input())\nans = 1000000\nwhile t:\n    t -= 1\n    ans = 1000000\n    n = int(input())\n    g = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = [int(x) for x in input().split()]\n        g[a].append(b)\n        g[b].append(a)\n    vis = [0] * (n + 1)\n    q = [(1, 1)]\n    while q:\n        (x, num) = q.pop()\n        vis[x] = 1\n        cnt = 0\n        for y in g[x]:\n            if vis[y] == 0:\n                cnt += 1\n        if cnt == 1:\n            ans = min(ans, num + 1)\n            continue\n        elif cnt == 0:\n            ans = min(ans, num)\n            continue\n        for y in g[x]:\n            if vis[y] == 0:\n                q.append((y, num + 2))\n    print(n - ans)", "import sys, threading\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        graph = [[] for _ in range(n + 1)]\n        children = [0] * (n + 1)\n        for _ in range(n - 1):\n            (a, b) = map(int, input().split())\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def makeTree(node, parent):\n            if parent:\n                graph[node].remove(parent)\n            for v in graph[node]:\n                makeTree(v, node)\n        makeTree(1, 0)\n\n        def dfs(node):\n            if len(graph[node]) == 1:\n                return 1\n            if not graph[node]:\n                return 0\n            delete_left = dfs(graph[node][0])\n            delete_right = dfs(graph[node][1])\n            return 2 + min(delete_left, delete_right)\n        deleted = dfs(1) + 1\n        print(n - deleted)\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "for _ in range(int(input())):\n    n = int(input())\n    d = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        d[a].append(b)\n        d[b].append(a)\n    v = [0 for _ in range(n)]\n    v[0] = 1\n    t = 0\n    ans = 0\n    q = [0]\n    while q:\n        t += 1\n        q1 = []\n        xx = 0\n        yy = 0\n        for node in q:\n            if node != 0:\n                if len(d[node]) == 2:\n                    xx = 1\n                elif len(d[node]) == 1:\n                    yy = 1\n            for child in d[node]:\n                if v[child] == 0:\n                    v[child] = 1\n                    q1.append(child)\n        if yy:\n            break\n        elif xx:\n            ans -= 1\n            break\n        if len(q1) < 2 * len(q):\n            break\n        q = q1\n    if len(d[0]) == 0:\n        print(0)\n    elif len(d[0]) == 1:\n        print(n - 2)\n    else:\n        print(ans + n - 2 * t + 1)", "for _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q", "from collections import deque\nfor _ in range(int(input())):\n    (n, a, vis) = (int(input()), {}, set())\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        if v in a:\n            a[v].append(u)\n        else:\n            a[v] = [u]\n        if u in a:\n            a[u].append(v)\n        else:\n            a[u] = [v]\n    (h, ans) = (deque([(1, 0)]), 0)\n    while h:\n        (x, lev) = h.popleft()\n        vis.add(x)\n        k = 0\n        for y in a[x]:\n            if not y in vis:\n                k += 1\n                h.append((y, lev + 1))\n        if k <= 1:\n            ans = max(ans, n - 2 * lev - k - 1)\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    stack = [0]\n    vis = {0}\n    ordering = []\n    while stack:\n        node = stack.pop()\n        ordering.append(node)\n        for nei in graph[node]:\n            if nei not in vis:\n                vis.add(nei)\n                stack.append(nei)\n    vis = set()\n    dp = [0] * n\n    nc = [0] * n\n    children = [[] for _ in range(n)]\n    while ordering:\n        node = ordering.pop()\n        if len(children[node]) == 1:\n            dp[node] = nc[children[node][0]]\n        elif len(children[node]) == 2:\n            (c1, c2) = children[node]\n            dp[node] = max(nc[c1] + dp[c2], nc[c2] + dp[c1])\n        vis.add(node)\n        for nei in graph[node]:\n            if nei not in vis:\n                nc[nei] += 1 + nc[node]\n                children[nei].append(node)\n    return dp[0]\nfor _ in range(int(input())):\n    print(solve())", "from collections import deque\nfor _ in range(int(input())):\n    (n, a, vis) = (int(input()), {}, set())\n    for _ in range(n - 1):\n        (v, u) = map(int, input().split())\n        if v in a:\n            a[v].append(u)\n        else:\n            a[v] = [u]\n        if u in a:\n            a[u].append(v)\n        else:\n            a[u] = [v]\n    (h, ans) = (deque([(1, 0)]), 0)\n    while h:\n        (x, lev) = h.popleft()\n        vis.add(x)\n        k = 0\n        for y in a[x]:\n            if not y in vis:\n                k += 1\n                h.append((y, lev + 1))\n        if k <= 1:\n            ans = max(ans, n - 2 * lev - k - 1)\n    print(ans)", "import sys\n\ndef dfs(v, p, adj):\n    if len(adj[v]) == 1 and v != 0:\n        return (0, 1)\n    sizes = []\n    fs = []\n    for u in adj[v]:\n        if u == p:\n            continue\n        (f, size) = dfs(u, v, adj)\n        fs.append(f)\n        sizes.append(size)\n    if len(sizes) == 2:\n        return (max(sizes[0] + fs[1], sizes[1] + fs[0]) - 1, 1 + sum(sizes))\n    return (sizes[0] - 1, 1 + sizes[0])\n\ndef solution(adj, n):\n    if n == 1:\n        return 0\n    return dfs(0, -1, adj)[0]\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        adj = [[] for i in range(n)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            adj[u].append(v)\n            adj[v].append(u)\n        x = solution(adj, n)\n        print(x)\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    from collections import defaultdict\n    for _ in range(int(input())):\n        n = int(input())\n        graph = [[] for _ in range(n)]\n        res = [0]\n        d = defaultdict(int)\n        for _ in range(n - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            graph[a].append(b)\n            graph[b].append(a)\n        if n == 1:\n            print(0)\n        elif len(graph[0]) == 1:\n            print(n - 2)\n        else:\n\n            def solve(node, par):\n                r = 0\n                for nie in graph[node]:\n                    if nie != par:\n                        r += solve(nie, node)\n                d[node] = r\n                return r + 1\n\n            def helper(node, par):\n                p = 0\n                if len(graph[node]) == 1:\n                    return 0\n                if len(graph[node]) == 2 and node != 0:\n                    for nie in graph[node]:\n                        if nie != par:\n                            return d[nie]\n                else:\n                    child = []\n                    for nie in graph[node]:\n                        if nie != par:\n                            child.append([d[nie], nie])\n                    p = max(child[0][0] + helper(child[1][1], node), child[1][0] + helper(child[0][1], node))\n                    return p\n            solve(0, -1)\n            print(helper(0, -1))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    from collections import defaultdict\n    for _ in range(int(input())):\n        n = int(input())\n        graph = [[] for _ in range(n)]\n        res = [0]\n        d = defaultdict(int)\n        for _ in range(n - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            graph[a].append(b)\n            graph[b].append(a)\n        if n == 1:\n            print(0)\n        elif len(graph[0]) == 1:\n            print(n - 2)\n        else:\n\n            def solve(node, par):\n                r = 0\n                for nie in graph[node]:\n                    if nie != par:\n                        r += solve(nie, node)\n                d[node] = r\n                return r + 1\n\n            def helper(node, par):\n                p = 0\n                if len(graph[node]) == 1:\n                    return 0\n                if len(graph[node]) == 2 and node != 0:\n                    for nie in graph[node]:\n                        if nie != par:\n                            return d[nie]\n                else:\n                    child = []\n                    for nie in graph[node]:\n                        if nie != par:\n                            child.append([d[nie], nie])\n                    p = max(child[0][0] + helper(child[1][1], node), child[1][0] + helper(child[0][1], node))\n                    return p\n            solve(0, -1)\n            print(helper(0, -1))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(5 * 10 ** 5)\nthreading.stack_size(10 ** 8)\n\ndef treeinput(n):\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef dfs(node, parent):\n    size[node] = 1\n    sm = 0\n    for child in adj[node]:\n        if child != parent:\n            size[node] += dfs(child, node)\n            sm += dp[child]\n    for child in adj[node]:\n        if child != parent:\n            dp[node] = max(dp[node], sm - dp[child] + size[child] - 1)\n    return size[node]\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        global dp, size, adj\n        adj = treeinput(n)\n        dp = defaultdict(int)\n        size = defaultdict(int)\n        dfs(1, -1)\n        print(dp[1])\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nfrom sys import stdin\n\ndef input():\n    return stdin.readline().rstrip('\\r\\n')\nsys.setrecursionlimit(10 ** 8)\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\nt = int(input())\nfor x in range(t):\n    n = int(input())\n    adj = [list() for _ in range(n)]\n    for y in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    @bootstrap\n    def dfs(u, p):\n        arr1 = []\n        for l in adj[u]:\n            if l == p:\n                continue\n            arr1.append(l)\n        if len(arr1) == 2:\n            ans = (yield dfs(arr1[0], u))\n            ans1 = (yield dfs(arr1[1], u))\n            yield (min(ans, ans1) + 2)\n        yield (len(arr1) + 1)\n    print(n - dfs(0, -1))", "import math\nimport sys\nimport threading\ninput = sys.stdin.readline\nfrom collections import defaultdict as dd\nfrom collections import deque\n\ndef helper(nd):\n    vis[nd] = 1\n    here = 1\n    for ng in gr[nd]:\n        if vis[ng] == 0:\n            here += helper(ng)\n    tot[nd] = here\n    return here\n\ndef helper1(nd, par):\n    ch = []\n    for ng in gr[nd]:\n        if ng != par:\n            ch.append(ng)\n    if len(ch) == 0:\n        return 0\n    if len(ch) == 1:\n        return tot[nd] - 2\n    return max(tot[ch[1]] - 1 + helper1(ch[0], nd), tot[ch[0]] - 1 + helper1(ch[1], nd))\n\ndef shouvik():\n    T = int(input())\n    global vis, tot, gr, dp\n    for _ in range(T):\n        n = int(input())\n        gr = dd(set)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            gr[u].add(v)\n            gr[v].add(u)\n        vis = [0] * (n + 1)\n        tot = [0] * (n + 1)\n        helper(1)\n        print(helper1(1, -1))\nsys.setrecursionlimit(3 * 10 ** 5 + 50)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=shouvik)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(5 * 10 ** 5)\nthreading.stack_size(10 ** 8)\n\ndef treeinput(n):\n    adj = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    return adj\n\ndef dfs(node, parent):\n    size[node] = 1\n    sm = 0\n    for child in adj[node]:\n        if child != parent:\n            size[node] += dfs(child, node)\n            sm += dp[child]\n    for child in adj[node]:\n        if child != parent:\n            dp[node] = max(dp[node], sm - dp[child] + size[child] - 1)\n    return size[node]\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        global dp, size, adj\n        adj = treeinput(n)\n        dp = defaultdict(int)\n        size = defaultdict(int)\n        dfs(1, -1)\n        print(dp[1])\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import math\nimport sys\nimport threading\ninput = sys.stdin.readline\nfrom collections import defaultdict as dd\nfrom collections import deque\n\ndef helper(nd):\n    vis[nd] = 1\n    here = 1\n    for ng in gr[nd]:\n        if vis[ng] == 0:\n            here += helper(ng)\n    tot[nd] = here\n    return here\n\ndef helper1(nd, par):\n    if dp[nd] != -1:\n        return dp[nd]\n    ch = []\n    for ng in gr[nd]:\n        if ng != par:\n            ch.append(ng)\n    if len(ch) == 0:\n        dp[nd] = 0\n        return 0\n    if len(ch) == 1:\n        dp[nd] = tot[nd] - 2\n        return dp[nd]\n    dp[nd] = max(dp[nd], tot[ch[0]] - 1 + helper1(ch[1], nd))\n    dp[nd] = max(dp[nd], tot[ch[1]] - 1 + helper1(ch[0], nd))\n    return dp[nd]\n\ndef shouvik():\n    T = int(input())\n    global vis, tot, gr, dp\n    for _ in range(T):\n        n = int(input())\n        gr = dd(set)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            gr[u].add(v)\n            gr[v].add(u)\n        vis = [0] * (n + 1)\n        tot = [0] * (n + 1)\n        dp = [-1] * (n + 1)\n        helper(1)\n        print(helper1(1, -1))\nsys.setrecursionlimit(3 * 10 ** 5 + 50)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=shouvik)\nt.start()\nt.join()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    edges = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        edges[u].append(v)\n        edges[v].append(u)\n    DFS_queue = [1]\n    sizes = [1 for i in range(n + 1)]\n    saved = [0 for i in range(n + 1)]\n    visited = [0 for i in range(n + 1)]\n    while len(DFS_queue) > 0:\n        root = DFS_queue.pop()\n        if visited[root] == 0:\n            visited[root] = 1\n            DFS_queue.append(root)\n            for edge in edges[root]:\n                if visited[edge] == 0:\n                    DFS_queue.append(edge)\n        else:\n            visited[root] = 2\n            children = [edge for edge in edges[root] if visited[edge] == 2]\n            sizes[root] = sum((sizes[child] for child in children)) + 1\n            if len(children) == 1:\n                saved[root] = max(saved[root], sizes[children[0]] - 1)\n            elif len(children) == 2:\n                size_diff = sum((sizes[child] - 1 for child in children))\n                for child in children:\n                    saved[root] = max(saved[root], size_diff + 1 - sizes[child] + saved[child])\n    print(saved[1])", "for _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    q = [(0, -1)]\n    h = 0\n    c = 2\n    while q:\n        new_q = []\n        for (i, j) in q:\n            x = [child for child in g[i] if child != j]\n            c = min(c, len(x))\n            for k in x:\n                new_q.append([k, i])\n        if c < 2:\n            print(n - 1 - c - 2 * h)\n            break\n        h += 1\n        q = new_q"]