["tc = int(input())\nfor _ in range(tc):\n    (n, m, d) = map(int, input().split())\n    pos = list(map(int, input().split()))\n    cst = list(map(int, input().split()))\n    dct = {}\n    for i in range(n):\n        dct[pos[i]] = i\n    mn = 200000000000\n    mx = 200000000000\n    for i in range(1, m):\n        length = dct[cst[i]] - dct[cst[i - 1]]\n        if mn > length:\n            mn = length\n        if mx > d + 1 - length:\n            mx = d + 1 - length\n    if mn < 0 or mx < 0:\n        print(0)\n    elif d + 1 >= n:\n        print(mn)\n    else:\n        print(min(mn, mx))", "t = int(input())\nfor _ in range(0, t):\n    inputs = [int(num) for num in input().split()]\n    n = inputs[0]\n    m = inputs[1]\n    d = inputs[2]\n    list1 = [int(num) for num in input().split()]\n    list2 = [int(num) for num in input().split()]\n    pos = [0 for i in range(0, n + 1)]\n    for i in range(0, n):\n        pos[list1[i]] = i\n    list3 = []\n    flag = 0\n    moves = 0\n    min1 = 1000000\n    max1 = 0\n    maxd = n - 1\n    for i in range(0, m - 1):\n        diff = pos[list2[i + 1]] - pos[list2[i]]\n        if diff < min1:\n            min1 = diff\n        if diff > max1:\n            flag = 1\n            max1 = diff\n    if min1 < 0 or max1 > d:\n        print(0)\n    elif flag == 1 and maxd >= d + 1:\n        moves1 = min1\n        moves2 = d + 1 - max1\n        print(min(moves1, moves2))\n    else:\n        print(min1)", "def ii(num=False):\n    i = input().split()\n    if num:\n        return int(i[0])\n    try:\n        return list(map(int, i))\n    except Exception:\n        return i\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfor _ in range(ii(1)):\n    (n, m, d) = ii()\n    p = ii()\n    a = ii()\n    dic = {v: i for (i, v) in enumerate(p)}\n    pos = [dic[i] for i in a]\n    dist = n\n    for i in range(len(pos)):\n        if i == 0:\n            continue\n        diff = pos[i] - pos[i - 1]\n        if diff > d or diff < 1:\n            dist = 0\n            break\n        dist = min(dist, diff, d - diff + 1 if d < n - 1 else n)\n    print(dist)", "from math import ceil\n\ndef f(a, m):\n    for i in range(m - 1):\n        if a[i] > a[i + 1]:\n            return False\n    return True\nt = int(input())\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = set(a)\n    c = list()\n    f = 0\n    f0 = 0\n    i1 = 0\n    mn = n\n    mx = -1\n    mxi = 0\n    mxi1 = 0\n    for i in range(n):\n        if p[i] in b:\n            c.append(p[i])\n            if f:\n                if i - i1 > d:\n                    f0 = 1\n                    break\n                else:\n                    if i - i1 < mn:\n                        mn = i - i1\n                    if i - i1 > mx:\n                        mx = i - i1\n                        mxi = i\n                        mxi1 = i1\n            f = 1\n            i1 = i\n    if c != a or f0:\n        print(0)\n    elif d >= n - 1:\n        print(mn)\n    else:\n        print(min(mn, d - mx + 1))", "def main():\n    from collections import defaultdict\n    t = int(input())\n    for _ in range(t):\n        (n, m, d) = map(int, input().split())\n        p = list(map(int, input().split()))\n        a = list(map(int, input().split()))\n        dic = defaultdict(int)\n        for i in range(n):\n            dic[p[i]] = i\n        ans = 1000000000\n        for i in range(1, m):\n            a1 = dic[a[i - 1]]\n            a2 = dic[a[i]]\n            if a2 < a1 or a1 + d < a2:\n                ans = 0\n                break\n            else:\n                k = 1000000000\n                if d + 1 < n:\n                    k = d + 1 - (a2 - a1)\n                k = min(k, a2 - a1)\n            ans = min(ans, k)\n        print(ans)\nmain()", "for _ in range(int(input())):\n    [n, m, d] = input().split()\n    n = int(n)\n    m = int(m)\n    d = int(d)\n    p = input().split()\n    a = input().split()\n    p = [int(o) for o in p]\n    a = [int(o) for o in a]\n    ind = {}\n    l = []\n    for u in range(n):\n        ind[p[u]] = u\n    for t in range(m - 1):\n        x = ind[a[t + 1]] - ind[a[t]]\n        l.append(x)\n    if len(l) != 1 or n > d + 1:\n        for y in range(len(l)):\n            if l[y] > d // 2:\n                l[y] = d + 1 - l[y]\n    l.sort()\n    ans = l[0]\n    if ans > 0:\n        print(ans)\n    else:\n        print(0)", "import sys\nimport threading\nfrom math import *\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nfrom functools import *\n\ndef gl():\n    return list(map(int, input().split()))\n\ndef gi():\n    return int(input())\n\ndef gc():\n    return input()\nmod = int(pow(10, 9)) + 7\n\ndef solution():\n    (n, m, d) = gl()\n    arr = gl()\n    a = gl()\n    loc = {}\n    for i in range(n):\n        loc[arr[i]] = i\n    ans = n - 1\n    for i in range(m - 1):\n        if loc[a[i]] < loc[a[i + 1]]:\n            if d < n - 1:\n                ans = min(ans, d - (loc[a[i + 1]] - loc[a[i]]) + 1, loc[a[i + 1]] - loc[a[i]])\n            else:\n                ans = min(ans, loc[a[i + 1]] - loc[a[i]])\n        else:\n            return print(0)\n    return print(max(ans, 0))\n\ndef main():\n    t = gi()\n    for _ in range(t):\n        solution()\nthreading.stack_size(1 << 27)\nsys.setrecursionlimit(1 << 30)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "t = int(input())\nres = []\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    pos = [0 for _ in range(n + 1)]\n    for i in range(n):\n        pos[p[i]] = i\n    op = []\n    for i in range(1, m):\n        if d + 1 < n:\n            max_d = pos[a[i - 1]] + d - pos[a[i]] + 1\n        else:\n            max_d = n\n        min_d = pos[a[i]] - pos[a[i - 1]]\n        op.append(min(min_d, max_d))\n    ans = min(op)\n    if ans < 0:\n        ans = 0\n    res.append(ans)\nfor i in res:\n    print(i)", "t = int(input())\nresult = []\nfor i in range(t):\n    (n, m, d) = list(map(int, input().split(' ')))\n    pi = list(map(int, input().split(' ')))\n    ai = list(map(int, input().split(' ')))\n    s = []\n    dict = {}\n    for j in range(n):\n        dict[pi[j]] = j\n    for j in range(len(ai) - 1):\n        (i0, i1) = (dict[ai[j]], dict[ai[j + 1]])\n        if (i0 > i1) | (i0 + d < i1):\n            s.append(0)\n        elif d + 1 < n:\n            c = d + 1 - (i1 - i0)\n            s.append(min(i1 - i0, c))\n        else:\n            s.append(i1 - i0)\n    result.append(min(s))\nfor i in result:\n    print(i)", "import sys\nfrom os import path\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    pos = {}\n    mina = []\n    flag = False\n    flag2 = True\n    for i in range(n):\n        pos[p[i]] = i\n    for i in range(m - 1):\n        x = pos[a[i]]\n        y = pos[a[i + 1]]\n        if x < y <= x + d:\n            if n - 1 >= d + 1:\n                mina.append(min(y - x, d + 1 - y + x))\n            else:\n                mina.append(y - x)\n            flag = True\n        else:\n            flag2 = False\n            break\n    if flag and flag2:\n        print(min(mina))\n    else:\n        print(0)", "def getint():\n    return int(input())\n\ndef getfloat():\n    return float(input())\n\ndef getints():\n    return list(map(int, input().split()))\n\ndef getfloats():\n    return list(map(float, input().split()))\nfrom collections import Counter\n\ndef answer():\n    (n, m, d) = getints()\n    ps = getints()\n    a = getints()\n    dd = {}\n    aa = []\n    for (i, p) in enumerate(ps):\n        dd[p] = i\n    for _a in a:\n        aa.append(dd[_a])\n    ans = float('inf')\n    for i in range(len(aa) - 1):\n        if aa[i + 1] - aa[i] < 0 or aa[i + 1] - aa[i] > d:\n            return 0\n        ans = min(ans, aa[i + 1] - aa[i])\n        if d < n - 1:\n            ans = min(ans, d + 1 - aa[i + 1] + aa[i])\n    return ans\nT = getint()\nfor _t in range(T):\n    print(answer())", "def solution(n, m, d, p: list, a: list):\n    p_dict = {p[i]: i for i in range(n)}\n    min_r = n + 1\n    flag = True\n    for i in range(m - 1):\n        (prev_i, next_i) = (p_dict[a[i]], p_dict[a[i + 1]])\n        dd = next_i - prev_i\n        if dd <= 0 or dd > d:\n            flag = False\n            break\n        if dd > 0:\n            min_r = min(min_r, dd)\n        if dd <= d:\n            if n - 1 - next_i + prev_i > d - dd:\n                min_r = min(min_r, d - dd + 1)\n    return min_r if flag else 0\nt = int(input())\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(solution(n, m, d, p, a))", "import sys\nt = int(input())\nfor _ in range(t):\n    (n, m, d) = map(int, sys.stdin.readline().split())\n    v = list(map(int, input().strip().split()))\n    w = list(map(int, input().strip().split()))\n    mp = [0] * (n + 1)\n    for i in range(0, n):\n        mp[v[i]] = i\n    ans = sys.maxsize\n    for i in range(0, m - 1):\n        nx = mp[w[i + 1]]\n        ts = mp[w[i]]\n        if ts > nx or nx - ts > d:\n            ans = 0\n        else:\n            ans = min(ans, nx - ts)\n            if d < n - 1:\n                ans = min(ans, d - (nx - ts) + 1)\n    print(ans)", "for _ in range(int(input())):\n    (n, m, d) = (int(x) for x in input().split(' '))\n    p = [int(x) for x in input().split(' ')]\n    a = [int(x) for x in input().split(' ')]\n    pos = [0] * (n + 1)\n    for index in range(n):\n        pos[p[index]] = index\n    ans = -1\n    min_distance = n\n    min_distance_2 = n\n    for index in range(0, m - 1):\n        x = pos[a[index]]\n        y = pos[a[index + 1]]\n        if y < x or y > x + d:\n            ans = 0\n            break\n        else:\n            min_distance = min(min_distance, y - x)\n            if d - y + x < min_distance_2 and d < n - 1:\n                min_distance_2 = d - y + x\n    if ans == 0:\n        print(0)\n    else:\n        tmp = min(min_distance, min_distance_2 + 1)\n        print(tmp)", "for i in range(int(input())):\n    (n, m, d) = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    p = [0 for i in range(n + 1)]\n    for j in range(n):\n        p[l[j]] = j\n    a = list(map(int, input().split()))\n    o = 100001\n    for j in range(m - 1):\n        k = p[a[j + 1]] - p[a[j]]\n        if k < 0 or k > d:\n            o = 0\n            break\n        else:\n            o = min(o, k)\n            if n - k - 1 >= d - k + 1:\n                o = min(o, d - k + 1)\n    print(o)", "for _ in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    l3 = [0] * n\n    for i in range(n):\n        l3[l1[i] - 1] = i + 1\n    f = []\n    for i in range(m - 1):\n        x = l3[l2[i + 1] - 1] - l3[l2[i] - 1]\n        if x > 0:\n            if n - d >= 2:\n                if d - x >= 0:\n                    f.append(min(d - x + 1, x))\n                else:\n                    f.append(min(0, x))\n            else:\n                f.append(x)\n        else:\n            f.append(0)\n    print(min(f))", "t = int(input())\nres = []\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    pos = [0 for _ in range(n + 1)]\n    perm = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    mn = 1000000\n    for i in range(n):\n        pos[perm[i]] = i\n    op = []\n    for i in range(1, m):\n        if d + 1 < n:\n            mx = pos[a[i - 1]] + d - pos[a[i]] + 1\n        else:\n            mx = n\n        min_d = pos[a[i]] - pos[a[i - 1]]\n        mn = min(mn, min(min_d, mx))\n    if mn < 0:\n        mn = 0\n    res.append(mn)\nfor i in res:\n    print(i)", "total = int(input())\n\ndef fun():\n    (size, m, distance) = [int(s) for s in input().split(' ')]\n    l = [int(s) for s in input().split(' ')]\n    choices = [int(s) for s in input().split(' ')]\n    d = dict()\n    for (i, val) in enumerate(l):\n        d[val] = i\n    res = 10 ** 6\n    for i in range(m - 1):\n        (s1, s2) = (d[choices[i]], d[choices[i + 1]])\n        if s1 > s2 or s2 > s1 + distance:\n            res = 0\n            break\n        res = min(res, abs(s2 - s1))\n        if size > distance + 1:\n            res = min(res, abs(s1 + distance - s2 + 1))\n    print(res)\nfor _ in range(total):\n    fun()", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    d = int(input().split()[2])\n    pa = list(map(int, input().split()))\n    p = [0 for i in range(len(pa))]\n    for i in range(len(pa)):\n        p[pa[i] - 1] = i\n    a = list(map(int, input().split()))\n    last = -1\n    result = 1000000000000000\n    for i in a:\n        elem = p[i - 1]\n        if last != -1:\n            if last > elem or elem - last > d:\n                result = 0\n                break\n            else:\n                result = min(result, elem - last)\n                if d < len(p) - 1:\n                    result = min(result, d - elem + last + 1)\n        last = elem\n    print(result)", "import bisect\nfrom collections import defaultdict, Counter\nimport heapq\nimport math\n\ndef primes(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            i = p * p\n            while i <= n:\n                prime[i] = False\n                i += p\n        p += 1\n    return [p for p in range(2, n + 1) if prime[p]]\n\ndef divisors(k, ps):\n    if k == 0:\n        return []\n    result = []\n    (i, p) = (0, ps[0])\n    while i < len(ps) and p * p <= k:\n        while k % p == 0:\n            result.append(p)\n            k = k // p\n        i += 1\n        p = ps[i]\n    if k != 1:\n        result.append(k)\n    return result\nt = int(input())\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    p2i = {pi: i for (i, pi) in enumerate(p)}\n    result = float('inf')\n    for (a, b) in zip(a, a[1:]):\n        (ia, ib) = (p2i[a], p2i[b])\n        if not ia < ib <= ia + d:\n            result = 0\n            break\n        if d < n - 1:\n            result = min(result, d + 1 - (ib - ia))\n        result = min(result, ib - ia)\n    print(result)", "t = int(input())\nres = []\nfor _ in range(t):\n    (n, m, d) = [int(i) for i in input().split()]\n    s = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    minimum = float('inf')\n    ind_list = []\n    prev_num_idx_s = float('inf')\n    curr_num_idx_a = 0\n    i = 0\n    while i < n and curr_num_idx_a < m:\n        if s[i] == a[curr_num_idx_a]:\n            if i - prev_num_idx_s <= d:\n                ind_list.append(i)\n                prev_num_idx_s = i\n                curr_num_idx_a += 1\n        i += 1\n    if curr_num_idx_a != m:\n        res.append(str(0))\n    else:\n        for i in range(len(a) - 1):\n            if n >= d + 2:\n                minimum = min(minimum, d - (ind_list[i + 1] - ind_list[i]) + 1, ind_list[i + 1] - ind_list[i])\n            else:\n                minimum = min(minimum, ind_list[i + 1] - ind_list[i])\n        res.append(str(minimum))\nprint('\\n'.join(res))", "from sys import stdin, stdout\ninput = stdin.readline\nt = int(input())\nfor i in range(t):\n    (n, m, d) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    dic = dict()\n    minn = n\n    for (i, j) in enumerate(p):\n        dic[j] = i\n    prev = dic[a[0]]\n    for i in a[1:]:\n        if dic[i] - prev > 0 and prev + d >= dic[i]:\n            minn = min(minn, dic[i] - prev)\n            if d < n - 1:\n                minn = min(minn, prev + d + 1 - dic[i])\n        else:\n            minn = 0\n        prev = dic[i]\n    if minn < n:\n        print(minn)\n    else:\n        print(0)", "for _ in range(int(input())):\n    (n, m, d) = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    ref = {}\n    for i in range(n):\n        ref[b[i]] = i\n    a = [int(x) for x in input().split()]\n    ans = float('inf')\n    flag = 0\n    for i in range(0, m - 1):\n        x = ref[a[i]]\n        y = ref[a[i + 1]]\n        if x >= y:\n            flag = 1\n            break\n        elif x + d < y:\n            flag = 1\n            break\n        else:\n            tmp = y - x\n            if n - 1 >= d + 1:\n                tmp = min(tmp, d + 1 - tmp)\n            ans = min(ans, tmp)\n    if flag == 1:\n        print(0)\n    else:\n        print(ans)", "import math\n\ndef solve(n, m, d, p, a):\n    pos = [-1] * n\n    for (i, x) in enumerate(p, 1):\n        pos[x - 1] = i\n    best = math.inf\n    for i in range(m - 1):\n        x = a[i]\n        y = a[i + 1]\n        if not pos[x - 1] < pos[y - 1] <= pos[x - 1] + d:\n            best = 0\n            break\n        if d < n - 1:\n            best = min(best, pos[x - 1] + d - pos[y - 1] + 1)\n        best = min(best, pos[y - 1] - pos[x - 1])\n    print(best)\nt = int(input())\nfor test in range(t):\n    (n, m, d) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    solve(n, m, d, p, a)", "def solution():\n    (n, m, d) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    nums2 = list(map(int, input().split()))\n    places = {val: i for (i, val) in enumerate(nums)}\n    smallestIndex = -1\n    smallDistance = float('inf')\n    ans = float('inf')\n    for i in range(m - 1):\n        (f, l) = [places[nums2[i]], places[nums2[i + 1]]]\n        if places[nums2[i]] > places[nums2[i + 1]] or places[nums2[i]] + d < places[nums2[i + 1]]:\n            return 0\n        (a, b) = [places[nums2[i]], places[nums2[i + 1]]]\n        min1 = b - a\n        shiftBToForward = a + d + 1\n        min2 = shiftBToForward - b\n        lengthOfAB = b - a + 1\n        if min2 <= n - lengthOfAB:\n            ans = min(ans, min(min1, min2))\n        else:\n            ans = min(ans, min1)\n    return ans\nfor _ in range(int(input())):\n    print(solution())", "import sys, math, bisect, collections, itertools, heapq\nfrom collections import defaultdict, deque, Counter\nsys.setrecursionlimit(50000)\n\ndef mvalues():\n    return map(int, sys.stdin.readline().split())\n\ndef lvalues():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef svalues():\n    return sys.stdin.readline().strip()\nfor i in range(int(input())):\n    (n, m, d) = mvalues()\n    l1 = lvalues()\n    l2 = lvalues()\n    res = float('inf')\n    dict1 = defaultdict()\n    for (i, value) in enumerate(l1):\n        dict1[value] = i\n    for i in range(1, m):\n        x = dict1.get(l2[i - 1])\n        y = dict1.get(l2[i])\n        z = y - x\n        if z < 0 and y > x + d:\n            res = 0\n            break\n        else:\n            first = d - z\n            res = min(z, res)\n            if x + n - 1 - y > first:\n                res = min(res, first + 1)\n    print(max(res, 0))", "t = int(input())\nfor o in range(t):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    position = [0] * (n + 1)\n    for i in range(n):\n        position[p[i]] = i + 1\n    ans = n\n    flag = True\n    for i in range(m - 1):\n        x = position[a[i]]\n        y = position[a[i + 1]]\n        if not (x < y and y <= x + d):\n            flag = False\n        if d < n - 1:\n            minim = min(d - y + x + 1, y - x)\n        else:\n            minim = y - x\n        ans = min(minim, ans)\n    if flag:\n        print(ans)\n    else:\n        print(0)", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    g = [0 for _ in range(n + 1)]\n    for i in range(n):\n        g[p[i]] = i + 1\n    lst = list(map(int, input().split()))\n    new = []\n    for i in lst:\n        new.append(g[i])\n    check = False\n    mi = 1000000000.0\n    ma = -1\n    for i in range(m - 1):\n        if new[i] < new[i + 1] and new[i + 1] - new[i] <= d:\n            mi = min(mi, new[i + 1] - new[i])\n            ma = max(ma, new[i + 1] - new[i])\n            pass\n        else:\n            check = True\n            break\n    if check:\n        print(0)\n    elif n - 1 <= d:\n        print(mi)\n    else:\n        print(min(mi, d - ma + 1))", "t = int(input())\nfor ole in range(t):\n    (n, m, d) = map(int, input().split())\n    L = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    count = 0\n    P = []\n    D = {}\n    for i in range(n):\n        D[L[i]] = i + 1\n    for i in range(m - 1):\n        count = 0\n        (x, y) = (D[A[i]], D[A[i + 1]])\n        z = x + d\n        if x < y and y <= z:\n            if z + 1 <= n:\n                count += min(y - x, z - y + 1)\n            elif z - y + 1 <= n - y + x - 1:\n                count += min(y - x, z - y + 1)\n            else:\n                count += y - x\n        P.append(count)\n    print(min(P))", "t = int(input())\nfor ole in range(t):\n    (n, m, d) = map(int, input().split())\n    L = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    count = 0\n    P = []\n    D = {}\n    for i in range(n):\n        D[L[i]] = i + 1\n    for i in range(m - 1):\n        count = 0\n        (x, y) = (D[A[i]], D[A[i + 1]])\n        z = x + d\n        if x < y and y <= z:\n            if z + 1 <= n:\n                count += min(y - x, z - y + 1)\n            elif z - y + 1 <= n - y + x - 1:\n                count += min(y - x, z - y + 1)\n            else:\n                count += y - x\n        P.append(count)\n    print(min(P))", "for _ in range(int(input())):\n    (n, m, d) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    di = {}\n    for (index, num) in enumerate(p):\n        di[num] = index\n    res = float('inf')\n    for i in range(m - 1):\n        (u, v) = (di[a[i]], di[a[i + 1]])\n        if u > v or v - u > d:\n            res = 0\n            break\n        out = float('inf')\n        if d < n - 1:\n            out = d + 1 - (v - u)\n        swap = v - u\n        res = min(out, swap, res)\n    print(res)", "def solve1():\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = 0\n    flag = False\n    for i in range(1, n):\n        if a[i] == a[i - 1] == -1:\n            return sum(a) + 4\n        elif a[i] == -1 or a[i - 1] == -1:\n            flag = True\n    if flag:\n        return sum(a)\n    return sum(a) - 4\n\ndef solve():\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    pos = {p[i]: i for i in range(n)}\n    ans = float('inf')\n    for i in range(m - 1):\n        if pos[a[i + 1]] <= pos[a[i]] or pos[a[i + 1]] - pos[a[i]] > d:\n            return 0\n        ans = min(ans, pos[a[i + 1]] - pos[a[i]])\n        dist = pos[a[i + 1]] - pos[a[i]]\n        swapNeed = d - dist + 1\n        swapPossible = pos[a[i]] - 1 + (n - pos[a[i + 1]])\n        if swapPossible >= swapNeed:\n            ans = min(ans, swapNeed)\n    return ans\nfor _ in range(int(input())):\n    ans = solve()\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    locs = {}\n    (n, m, d) = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    locs = {}\n    for i in range(len(p)):\n        locs[p[i]] = i\n    minFix = len(p)\n    for i in range(len(arr) - 1):\n        (p1, p2) = (locs[arr[i]], locs[arr[i + 1]])\n        if 0 > p2 - p1 or p2 - p1 > d:\n            minFix = 0\n            break\n        if p2 + d - (p2 - p1) + 1 < n or p1 - (d - (p2 - p1) + 1) >= 0:\n            minFix = min(minFix, d - (p2 - p1) + 1)\n        elif n - p2 - 1 + p1 > d - (p2 - p1):\n            minFix = min(minFix, d - (p2 - p1) + 1)\n        minFix = min(minFix, p2 - p1)\n    print(minFix)\n    leftleftMost = 0", "import math\nt = int(input())\nfor _ in range(t):\n    (m, n, d) = map(int, input().split())\n    perm = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    idx = {perm[i]: i for i in range(len(perm))}\n    ans = math.inf\n    for i in range(1, len(arr)):\n        (l, r) = (idx[arr[i - 1]], idx[arr[i]])\n        if l < r:\n            ans = min(r - l, ans)\n        if d + l >= r:\n            temp = l + len(perm) - r - 1\n            if l + d - r < temp:\n                ans = min(ans, l + d - r + 1)\n        if r <= l or d + l < r:\n            ans = 0\n    print(ans)", "from math import *\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[p[i]] = i\n    ans = n + 10\n    for i in range(m - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + k >= d[a[i + 1]]:\n            ans = min(ans, d[a[i + 1]] - d[a[i]])\n            if k < n - 1:\n                ans = min(ans, d[a[i]] - d[a[i + 1]] + k + 1)\n        else:\n            ans = 0\n    print(ans)", "for _ in range(int(input())):\n    inp = lambda : map(int, input().split())\n    (n, m, d) = inp()\n    p = [0] + list(inp())\n    a = list(inp())\n    pos = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pos[p[i]] = i\n    mn = n\n    used = m - 1\n    for i in range(m - 1):\n        if pos[a[i]] < pos[a[i + 1]] <= pos[a[i]] + d:\n            to_min = [mn, pos[a[i + 1]] - pos[a[i]]]\n            mn = min(to_min + ([d + 1 - (pos[a[i + 1]] - pos[a[i]])] if d < n - 1 else []))\n            used -= 1\n    print(0 if used else mn)", "for i in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    ans = n + 1\n    v = {}\n    for k in range(n):\n        v[p[k]] = k\n    for j in range(m - 1):\n        if v[a[j]] < v[a[j + 1]] <= v[a[j]] + d:\n            ans = min(ans, v[a[j + 1]] - v[a[j]])\n            if d < n - 1:\n                ans = min(ans, v[a[j]] - v[a[j + 1]] + d + 1)\n        else:\n            ans = 0\n    print(ans)", "from math import *\nfor j in range(int(input())):\n    (har, m1, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(har):\n        d[p[i]] = i\n    ans = har + 10\n    for i in range(m1 - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + k >= d[a[i + 1]]:\n            ans = min(ans, d[a[i + 1]] - d[a[i]])\n            if k < har - 1:\n                ans = min(ans, d[a[i]] - d[a[i + 1]] + k + 1)\n        else:\n            ans = 0\n    print(ans)", "import sys\nfor t in range(int(input())):\n    (n, m, d) = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    pos = {}\n    for i in range(n):\n        pos[p[i]] = i\n    isGood = False\n    for i in range(m - 1):\n        if pos[a[i]] > pos[a[i + 1]] or pos[a[i + 1]] > pos[a[i]] + d:\n            isGood = True\n            break\n    if isGood:\n        print(0)\n    else:\n        ans = sys.maxsize\n        for i in range(m - 1):\n            ans = min(ans, pos[a[i + 1]] - pos[a[i]])\n        if d + 1 < n:\n            for i in range(m - 1):\n                ans = min(ans, d + 1 - (pos[a[i + 1]] - pos[a[i]]))\n        print(ans)", "t = int(input())\nans = []\nfor ti in range(t):\n    (n, m, d) = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    p1 = [0] * (n + 1)\n    for i in range(n):\n        p1[p[i]] = i + 1\n    a1 = [0] * m\n    min_r = n\n    for i in range(m):\n        a1[i] = p1[a[i]]\n        if i > 0:\n            min_r = min(min_r, a1[i] - a1[i - 1])\n            r = a1[i - 1] + d - a1[i] + 1\n            if a1[i] + r - (a1[i - 1] - 1) <= n:\n                min_r = min(min_r, r)\n        if min_r <= 0:\n            break\n    ans.append(max(0, min_r))\nfor a in ans:\n    print(a)", "from math import *\nfor _ in range(int(input())):\n    (n, m, y) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[p[i]] = i\n    ans = n + 10\n    for i in range(m - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + y >= d[a[i + 1]]:\n            ans = min(ans, d[a[i + 1]] - d[a[i]])\n            if y < n - 1:\n                ans = min(ans, d[a[i]] - d[a[i + 1]] + y + 1)\n        else:\n            ans = 0\n    print(ans)", "from math import *\nfor _ in range(int(input())):\n    (n, m, y) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[p[i]] = i\n    ans = n + 10\n    for i in range(m - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + y >= d[a[i + 1]]:\n            ans = min(ans, d[a[i + 1]] - d[a[i]])\n            if y < n - 1:\n                ans = min(ans, d[a[i]] - d[a[i + 1]] + y + 1)\n        else:\n            ans = 0\n    print(ans)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(a, p, m, n, d):\n    dic = {x: i for (i, x) in enumerate(p)}\n    ans = float('inf')\n    for i in range(m - 1):\n        (i1, i2) = (dic[a[i]], dic[a[i + 1]])\n        if not i1 < i2 <= i1 + d:\n            return 0\n        v = i2 - i1\n        d1 = max(0, i1)\n        d2 = max(0, n - 1 - i2)\n        if i2 - 1 - d >= 0:\n            v = min(v, i1 + d - i2 + 1)\n        if i1 + d + 1 < n:\n            v = min(v, i1 + d + 1 - i2)\n        if i2 - i1 + d1 + d2 > d:\n            v = min(v, d + 1 - (i2 - i1))\n        ans = min(ans, v)\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    print(solve(a, p, m, n, d))", "t = int(input())\nfor _ in range(t):\n    things = [int(x) for x in input().split()]\n    d = things[2]\n    perm = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    dperm = {}\n    for i in range(len(perm)):\n        dperm[perm[i]] = i\n    good = False\n    m = len(perm)\n    for i in range(len(arr) - 1):\n        if not dperm[arr[i]] < dperm[arr[i + 1]] or not dperm[arr[i]] + d >= dperm[arr[i + 1]]:\n            good = True\n        a = dperm[arr[i + 1]] - dperm[arr[i]]\n        b = d - dperm[arr[i + 1]] + dperm[arr[i]] + 1\n        if len(perm) > d + 1:\n            m = min(m, a, b)\n        else:\n            m = min(m, a)\n    if good:\n        print(0)\n    else:\n        print(m)", "t = int(input())\nfor _ in range(t):\n    (n, m, d) = map(int, input().split())\n    p = [(index, i - 1) for (index, i) in enumerate(list(map(int, input().split())))]\n    a = [i - 1 for i in list(map(int, input().split()))]\n    p.sort(key=lambda i: i[1])\n    ans = 100005\n    for i in range(m - 1):\n        dist = p[a[i + 1]][0] - p[a[i]][0]\n        if dist < 0 or dist > d:\n            ans = 0\n            break\n        if d >= n - 1:\n            ans = min(ans, dist)\n        else:\n            ans = min(ans, dist, d - dist + 1)\n    print(ans)", "from math import *\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[p[i]] = i\n    ans = n + 10\n    for i in range(m - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + k >= d[a[i + 1]]:\n            ans = min(ans, d[a[i + 1]] - d[a[i]])\n            if k < n - 1:\n                ans = min(ans, d[a[i]] - d[a[i + 1]] + k + 1)\n        else:\n            ans = 0\n    print(ans)", "from math import *\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[p[i]] = i\n    ans = 10 ** 5\n    for i in range(m - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + k >= d[a[i + 1]]:\n            ans = min(ans, abs(d[a[i]] - d[a[i + 1]]))\n            if k < n - 1:\n                ans = min(ans, abs(d[a[i + 1]] - d[a[i]] - k) + 1)\n        else:\n            ans = 0\n    print(ans)", "xyz = int(input())\nfor _ in range(xyz):\n    l = [int(x) for x in input().split()]\n    n = l[0]\n    m = l[1]\n    d = l[2]\n    p = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    l = [-1 for i in range(n + 1)]\n    t = 0\n    mmm = n\n    for i in range(n):\n        l[p[i]] = i + 1\n    for i in range(m - 1):\n        if l[a[i + 1]] - l[a[i]] < 0:\n            print(0)\n            t = 1\n            break\n        elif l[a[i + 1]] - l[a[i]] > d:\n            print(0)\n            t = 1\n            break\n        else:\n            x = l[a[i + 1]] - l[a[i]]\n            y = l[a[i]] - 1 + n - l[a[i + 1]]\n            if x + y > d:\n                mmm = min(mmm, min(x, d - x + 1))\n            else:\n                mmm = min(mmm, x)\n    if t == 1:\n        continue\n    else:\n        print(mmm)", "t = int(input())\nwhile t:\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    info = {}\n    ans = 1000000000\n    for i in range(n):\n        info[p[i]] = i\n    flag = 0\n    for j in range(m - 1):\n        if info[l[j]] > info[l[j + 1]] or info[l[j + 1]] > info[l[j]] + d:\n            flag = 1\n            break\n        else:\n            req = d + 1 - (info[l[j + 1]] - info[l[j]])\n            if info[l[j]] - 0 + n - 1 - info[l[j + 1]] >= req:\n                ans = min(ans, req)\n            ans = min(ans, info[l[j + 1]] - info[l[j]])\n    if flag == 1:\n        print(0)\n    else:\n        print(ans)\n    t -= 1", "for _ in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    pos = [0] * (n + 1)\n    min_move = n\n    for i in range(n):\n        x = p[i]\n        pos[x] = i + 1\n    for i in range(m - 1):\n        if pos[a[i]] > pos[a[i + 1]]:\n            min_move = 0\n            break\n        elif pos[a[i]] + d < pos[a[i + 1]]:\n            min_move = 0\n            break\n        else:\n            min_move = min(min_move, pos[a[i + 1]] - pos[a[i]])\n            moves = d - (pos[a[i + 1]] - pos[a[i]]) + 1\n            if moves <= pos[a[i]] - 1 + n - pos[a[i + 1]]:\n                min_move = min(min_move, moves)\n    print(min_move)", "import math\nfor _ in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    mi = 1000000000.0\n    ans = 0\n    ind = [0] * n\n    for i in range(n):\n        ind[p[i] - 1] = i + 1\n    for i in range(m - 1):\n        if ind[a[i] - 1] < ind[a[i + 1] - 1]:\n            if ind[a[i + 1] - 1] > ind[a[i] - 1] + d:\n                ans = -1\n                break\n            elif 1 + d < n:\n                mi = min(mi, ind[a[i + 1] - 1] - ind[a[i] - 1], ind[a[i] - 1] + d - ind[a[i + 1] - 1] + 1)\n            else:\n                mi = min(mi, ind[a[i + 1] - 1] - ind[a[i] - 1])\n        else:\n            ans = -1\n            break\n    if ans == -1:\n        print(0)\n    else:\n        print(mi)", "for _ in range(int(input())):\n    (n, m, d) = map(int, input().strip().split())\n    p = [0] + list(map(int, input().strip().split()))\n    pos = [0 for i in range(max(p) + 1)]\n    for i in range(1, n + 1):\n        pos[p[i]] = i\n    a = [0] + list(map(int, input().strip().split()))\n    ans = int(1000000000.0)\n    for i in range(1, m):\n        if pos[a[i + 1]] <= pos[a[i]] or pos[a[i + 1]] - pos[a[i]] > d:\n            ans = 0\n            break\n        ans = min(ans, pos[a[i + 1]] - pos[a[i]])\n        dist = pos[a[i + 1]] - pos[a[i]]\n        swap_needed = d - dist + 1\n        swap_possible = pos[a[i]] - 1 + (n - pos[a[i + 1]])\n        if swap_possible >= swap_needed:\n            ans = min(ans, swap_needed)\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    pos = [0] * (n + 1)\n    min_move = n\n    for i in range(n):\n        x = p[i]\n        pos[x] = i + 1\n    for i in range(m - 1):\n        if pos[a[i]] > pos[a[i + 1]]:\n            min_move = 0\n            break\n        elif pos[a[i]] + d < pos[a[i + 1]]:\n            min_move = 0\n            break\n        else:\n            min_move = min(min_move, pos[a[i + 1]] - pos[a[i]])\n            moves = d - (pos[a[i + 1]] - pos[a[i]]) + 1\n            if moves <= pos[a[i]] - 1 + n - pos[a[i + 1]]:\n                min_move = min(min_move, moves)\n    print(min_move)", "from math import *\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[p[i]] = i\n    ans = n + 10\n    for i in range(m - 1):\n        if d[a[i]] < d[a[i + 1]] and d[a[i]] + k >= d[a[i + 1]]:\n            ans = min(ans, abs(d[a[i]] - d[a[i + 1]]))\n            if k < n - 1:\n                ans = min(ans, abs(d[a[i + 1]] - d[a[i]] - k) + 1)\n        else:\n            ans = 0\n    print(ans)", "def nop():\n    t = int(input().strip())\n    for _ in range(t):\n        (n, m, d) = map(int, input().strip().split())\n        p = list(map(int, input().strip().split()))\n        a = list(map(int, input().strip().split()))\n        pos = [0] * (n + 1)\n        pos[0] = float('inf')\n        cnt = 0\n        ans = float('inf')\n        for i in range(n):\n            pos[p[i]] = i + 1\n        for i in range(m - 1):\n            if pos[a[i]] > pos[a[i + 1]]:\n                cnt += 1\n                break\n            elif pos[a[i + 1]] > pos[a[i]] + d:\n                cnt += 1\n                break\n            else:\n                ans = min(ans, pos[a[i + 1]] - pos[a[i]])\n                x = pos[a[i]] + d - pos[a[i + 1]] + 1\n                if x <= pos[a[i]] - 1:\n                    ans = min(ans, x)\n                x1 = pos[a[i]] + d - pos[a[i + 1]] + 1\n                if x1 <= n - pos[a[i + 1]]:\n                    ans = min(ans, x1)\n                if pos[a[i]] - 1 + n - pos[a[i + 1]] >= x:\n                    ans = min(ans, x)\n        if cnt > 0:\n            print(0)\n        else:\n            print(ans)\nnop()", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor i in range(T):\n    (n, m, d) = map(int, input().split())\n    p = list(map(int, input().split()))\n    index = {}\n    a = list(map(int, input().split()))\n    for i in range(n):\n        index[p[i]] = i + 1\n    can = set()\n    for i in range(m - 1):\n        if index[a[i]] >= index[a[i + 1]]:\n            can.add(0)\n            break\n        elif index[a[i + 1]] > index[a[i]] + d:\n            can.add(0)\n            break\n        else:\n            can.add(index[a[i + 1]] - index[a[i]])\n            if index[a[i]] - 1 + (n - index[a[i + 1]]) > index[a[i]] + d - index[a[i + 1]]:\n                can.add(index[a[i]] + d - index[a[i + 1]] + 1)\n    print(min(can))", "import sys\nimport math\nMOD = int(1000000000.0 + 7)\n\ndef power(a, b):\n    ans = 1\n    while b:\n        if b & 1:\n            ans = ans * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return ans\n\ndef power1(a, b):\n    ans = 1\n    while b:\n        if b & 1:\n            ans = ans * a\n        a = a * a\n        b >>= 1\n    return ans\nt = int(input().strip())\nfor _ in range(t):\n    (n, m, d) = map(int, input().strip().split())\n    vec = list(map(int, input().strip().split()))\n    mp = {}\n    for (i, val) in enumerate(vec):\n        mp[val] = i + 1\n    tp = [0] + list(map(int, input().strip().split()))\n    ans = int(100000000000000.0)\n    y = 0\n    for i in range(1, m):\n        if mp[tp[i]] < mp[tp[i + 1]] and mp[tp[i + 1]] <= mp[tp[i]] + d:\n            ans1 = mp[tp[i + 1]] - mp[tp[i]]\n            ans2 = mp[tp[i]] + d + 1 - mp[tp[i + 1]]\n            num = mp[tp[i]] + d + 1 - n\n            div = int(100000000000000.0)\n            ag = mp[tp[i]] + d + 1\n            if ag > n and mp[tp[i]] >= 1 + num:\n                div = n - mp[tp[i + 1]] + num\n            if ag > n:\n                ans2 = int(100000000000000.0)\n            ans = min(ans, min(ans1, min(ans2, div)))\n        else:\n            y = 1\n    if y == 1:\n        ans = 0\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, m, d) = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    pos = [0] * (n + 1)\n    for i in range(n):\n        pos[p[i]] = i + 1\n    res = 10 ** 10\n    for i in range(m - 1):\n        if pos[a[i]] < pos[a[i + 1]] <= pos[a[i]] + d:\n            res = min(res, pos[a[i + 1]] - pos[a[i]])\n            mb = pos[a[i]] + d + 1 - pos[a[i + 1]]\n            if min(pos[a[i]] - 1, n - pos[a[i]]) + min(pos[a[i + 1]] - 1, n - pos[a[i + 1]]) - mb >= 0:\n                res = min(res, mb)\n        else:\n            print(0)\n            break\n    else:\n        print(res)", "inf = int(1e+18)\nfor _ in range(int(input())):\n    (n, m, d) = map(int, input().split())\n    permutation = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    position = {}\n    for i in range(n):\n        position[permutation[i]] = i + 1\n    res = inf\n    no_need = False\n    for i in range(m - 1):\n        (left_a, right_b) = (inf, inf)\n        if position[arr[i]] < position[arr[i + 1]] <= position[arr[i]] + d:\n            b_a = position[arr[i + 1]] - position[arr[i]]\n        else:\n            no_need = True\n            break\n        space = position[arr[i + 1]] - position[arr[i]]\n        needed = d - space + 1\n        if position[arr[i]] - needed > 0:\n            left_a = needed\n        if position[arr[i + 1]] + needed <= n:\n            right_b = needed\n        left_over = position[arr[i]] - 1 + (n - position[arr[i + 1]])\n        req = inf\n        if left_over - needed >= 0:\n            req = needed\n        res = min(res, b_a, right_b, left_a, req)\n    if no_need:\n        print(0)\n    else:\n        print(res)", "t = int(input())\nfor i in range(t):\n    (n, m, d) = list(map(int, input().split(sep=' ')))\n    p = list(map(int, input().split(sep=' ')))\n    a = list(map(int, input().split(sep=' ')))\n    mat = [[0 for j in range(2)] for k in range(n)]\n    cnt1 = 0\n    cnt2 = 0\n    cnt = 99999999999\n    for j in range(n):\n        e = p[j]\n        mat[e - 1] = [e, j + 1]\n    for j in range(m - 1):\n        e1 = a[j]\n        e2 = a[j + 1]\n        x = mat[e1 - 1][1]\n        y = mat[e2 - 1][1]\n        if x > y or y > x + d:\n            cnt = 0\n            break\n        elif 1:\n            cnt1 = y - x\n            if d < n - 1:\n                cnt2 += x + d + 1 - y\n            else:\n                cnt2 = cnt1 + 1\n        cnt = min(cnt, min(cnt1, cnt2))\n        cnt1 = 0\n        cnt2 = 0\n    print(cnt)"]