["import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    rains = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        rains.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (x, y) in zip(centres, centres[1:]):\n        d[y] += d[x]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (x, y) in zip(centres, centres[1:]):\n        p += d[x] * (y - x)\n        if p > m:\n            l = min(l, y - (p - m))\n            r = max(r, y + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "from collections import Counter as ct\nimport math\nR = lambda : map(int, input().split())\nG = range\n(t,) = R()\nfor _ in G(t):\n    (n, m) = R()\n    d = ct()\n    rains = []\n    for _ in G(n):\n        (x, p) = R()\n        rains += [(x, p)]\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (i, j) in zip(centres, centres[1:]):\n        d[j] += d[i]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (i, j) in zip(centres, centres[1:]):\n        p += d[i] * (j - i)\n        if p > m:\n            l = min(l, j - (p - m))\n            r = max(r, j + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "import math\nimport collections\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    d = collections.defaultdict(int)\n    mem = []\n    for _ in range(n):\n        (x, p) = map(int, input().split())\n        mem.append((x, p))\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    a = sorted(d)\n    for (x, y) in zip(a, a[1:]):\n        d[y] += d[x]\n    c = {a[0]: 0}\n    for (x, y) in zip(a, a[1:]):\n        c[y] = c[x] + d[x] * (y - x)\n    (l, r) = (math.inf, -math.inf)\n    for (x, p) in c.items():\n        if p > m:\n            l = min(l, x - (p - m))\n            r = max(r, x + (p - m))\n    if l > r:\n        print('1' * n)\n        continue\n    print(*(int(p >= max(abs(x - l), abs(x - r))) for (x, p) in mem), sep='')", "from collections import Counter as ct\nimport math\nR = lambda : map(int, input().split())\nG = range\n(t,) = R()\nfor _ in G(t):\n    (n, m) = R()\n    d = ct()\n    rains = []\n    for _ in G(n):\n        (x, p) = R()\n        rains += [(x, p)]\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (i, j) in zip(centres, centres[1:]):\n        d[j] += d[i]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (i, j) in zip(centres, centres[1:]):\n        p += d[i] * (j - i)\n        if p > m:\n            l = min(l, j - (p - m))\n            r = max(r, j + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')", "from collections import Counter as ct\nimport math\nR = lambda : map(int, input().split())\nG = range\n(t,) = R()\nfor _ in G(t):\n    (n, m) = R()\n    d = ct()\n    rains = []\n    for _ in G(n):\n        (x, p) = R()\n        rains += [(x, p)]\n        d[x - p] += 1\n        d[x] -= 2\n        d[x + p] += 1\n    centres = sorted(d)\n    for (i, j) in zip(centres, centres[1:]):\n        d[j] += d[i]\n    (l, r) = (math.inf, -math.inf)\n    p = 0\n    for (i, j) in zip(centres, centres[1:]):\n        p += d[i] * (j - i)\n        if p > m:\n            l = min(l, j - (p - m))\n            r = max(r, j + (p - m))\n    print(*(int(x - p <= l and x + p >= r) for (x, p) in rains), sep='')"]