["import heapq\nFIBS = []\nCUMSUMS = []\na = 0\nb = 1\ncumsum = 0\nwhile cumsum < 10 ** 12:\n    FIBS.append(b)\n    cumsum += b\n    CUMSUMS.append(cumsum)\n    (a, b) = (b, a + b)\n\ndef solve(nums):\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True\nn = int(input())\nfor _ in range(n):\n    input()\n    nums = list(map(int, input().strip().split()))\n    if solve(nums):\n        print('YES')\n    else:\n        print('NO')", "import heapq\nFIBNUM = 50\nfibs = [1, 1]\nfor i in range(FIBNUM):\n    fibs.append(fibs[-1] + fibs[-2])\nfibs_sum = [1]\nfor num in fibs[1:]:\n    fibs_sum.append(num + fibs_sum[-1])\nfibs_sum_dict = dict()\nfor (idx, num) in enumerate(fibs_sum):\n    fibs_sum_dict[num] = idx\nt = int(input())\nfor _ in range(t):\n    k = int(input())\n    arr = input().split()\n    arr = [int(i) for i in arr]\n    arr_sum = sum(arr)\n    if arr_sum not in fibs_sum_dict:\n        print('NO')\n    else:\n        arr_heap = [-i for i in arr]\n        heapq.heapify(arr_heap)\n        idx = fibs_sum_dict[arr_sum]\n        last_value = 0\n        success = True\n        while True:\n            if len(arr_heap) == 0:\n                success = False\n                break\n            value = -heapq.heappop(arr_heap)\n            if value < fibs[idx]:\n                success = False\n                break\n            if last_value > 0:\n                heapq.heappush(arr_heap, -last_value)\n            last_value = value - fibs[idx]\n            idx -= 1\n            if idx < 0:\n                break\n        if success:\n            print('YES')\n        else:\n            print('NO')", "def fibSeq(summation):\n    x = []\n    i = 0\n    a = 0\n    b = 0\n    c = 1\n    while i <= summation:\n        if i == summation:\n            return x\n        a = b + c\n        temp = a\n        c = b\n        b = temp\n        i += a\n        x.append(a)\n    return x\nimport heapq\nt = int(input())\nfor case in range(t):\n    k = int(input())\n    c = list(map(int, input().split()))\n    summation = 0\n    x = []\n    x = fibSeq(sum(c))\n    if sum(c) != sum(x):\n        print('NO')\n        continue\n    c.sort()\n    cT = c\n    c = [-i for i in cT]\n    heapq.heapify(c)\n    index = -1\n    lstVal = 0\n    success = True\n    for i in range(len(x) - 1, -1, -1):\n        if not len(c):\n            success = False\n            break\n        val = heapq.heappop(c)\n        if -val < x[i]:\n            success = False\n            break\n        if lstVal < 0:\n            heapq.heappush(c, lstVal)\n        lstVal = val + x[i]\n        if not i:\n            break\n    if success:\n        print('YES')\n    else:\n        print('NO')", "import heapq as h\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    lstsum = sum(lst)\n    lst = [-i for i in lst]\n    h.heapify(lst)\n    fiblst = [1]\n    fibsum = 1\n    cur = 1\n    while fibsum < lstsum:\n        fibsum += cur\n        fiblst.append(cur)\n        cur = cur + fiblst[-2]\n    if fibsum != lstsum:\n        print('NO')\n        continue\n    tmp1 = -1\n    tmp2 = -1\n    flag = 1\n    for i in range(len(fiblst) - 1, -1, -1):\n        if i % 2 == 0 and tmp1 != -1:\n            h.heappush(lst, -tmp1)\n            tmp1 = -1\n        if i % 2 == 1 and tmp2 != -1:\n            h.heappush(lst, -tmp2)\n            tmp2 = -1\n        if len(lst) == 0:\n            flag = 0\n            break\n        maxlst = -h.heappop(lst)\n        res = maxlst - fiblst[i]\n        if res > 0:\n            if i % 2 == 0:\n                tmp1 = res\n            else:\n                tmp2 = res\n        elif res < 0:\n            flag = 0\n            break\n    if flag == 0:\n        print('NO')\n    else:\n        print('YES')", "def tr(a, b, z, m):\n    n = z\n    (x, y) = (a, b)\n    li = m\n    li.append(list(x))\n    if sum(x) == 0:\n        return 'YES'\n    if x[0] >= y[n]:\n        d = x[0] - y[n]\n        x.pop(0)\n        x.sort(reverse=True)\n        x.append(d)\n        n += 1\n        return tr(x, y, n, li)\n    elif n == 0:\n        return 'NO'\n    else:\n        x = m[n - 1]\n        x.append(x.pop(0))\n        n -= 1\n        return tr(x, y, n, li)\no = []\nfor t in range(int(input())):\n    k = int(input())\n    c = list(map(int, input().split()))\n    summ = sum(c)\n    f = [1]\n    while sum(f) < summ:\n        if f == [1]:\n            f.append(1)\n        else:\n            x = len(f)\n            f.append(f[x - 1] + f[x - 2])\n    if sum(f) != summ:\n        o.append('NO')\n    else:\n        f.sort(reverse=True)\n        c.sort(reverse=True)\n        c.append(0)\n        o.append(tr(c, f, 0, []))\nfor u in o:\n    print(u)", "def tr(a, b, z, m):\n    n = z\n    (x, y) = (a, b)\n    li = m\n    li.append(list(x))\n    if sum(x) == 0:\n        return 'YES'\n    if x[0] >= y[n]:\n        d = x[0] - y[n]\n        x.pop(0)\n        x.sort(reverse=True)\n        x.append(d)\n        n += 1\n        return tr(x, y, n, li)\n    elif n == 0:\n        return 'NO'\n    else:\n        x = m[n - 1]\n        x.append(x.pop(0))\n        n -= 1\n        return tr(x, y, n, li)\no = []\ne = [1]\nfor t in range(int(input())):\n    k = int(input())\n    c = list(map(int, input().split()))\n    summ = sum(c)\n    f = list(e)\n    while sum(f) < summ:\n        if f == [1]:\n            f.append(1)\n        else:\n            x = len(f)\n            f.append(f[x - 1] + f[x - 2])\n    if sum(f) > summ:\n        e = list(f)\n        while sum(f) > summ:\n            f.pop()\n    if sum(f) != summ:\n        o.append('NO')\n    else:\n        f.sort(reverse=True)\n        c.sort(reverse=True)\n        c.append(0)\n        o.append(tr(c, f, 0, []))\nfor u in o:\n    print(u)"]