["import sys\nimport threading\nfrom collections import deque\n\ndef main():\n\n    def bfs(node, parent, color):\n        queue = deque([[node, parent, color]])\n        while queue:\n            (node, parent, color) = queue.popleft()\n            visited[node - 1] = color\n            if node in dic:\n                for nbr in dic[node]:\n                    if visited[nbr - 1] == 0:\n                        queue.append([nbr, node, 3 - color])\n                    elif nbr != parent and visited[nbr - 1] == color:\n                        return False\n        return True\n    for _ in range(int(input())):\n        n = int(input())\n        dic = {}\n        flag = True\n        for _ in range(n):\n            (x, y) = list(map(int, sys.stdin.readline().split()))\n            if x == y:\n                flag = False\n            else:\n                if x not in dic:\n                    dic[x] = []\n                if y not in dic:\n                    dic[y] = []\n                dic[x].append(y)\n                dic[y].append(x)\n                if len(dic[x]) > 2 or len(dic[y]) > 2:\n                    flag = False\n        if not flag:\n            print('NO')\n        else:\n            visited = [0] * n\n            flag = True\n            for i in range(1, n + 1):\n                if visited[i - 1] == 0:\n                    if not bfs(i, -1, 1):\n                        flag = False\n                        break\n            if flag:\n                print('YES')\n            else:\n                print('NO')\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    from collections import defaultdict\n    for _ in range(int(input())):\n        n = int(input())\n        f = False\n        d = [[] for _ in range(n + 1)]\n        for _ in range(n):\n            (a, b) = map(int, input().split())\n            d[a].append(b)\n            d[b].append(a)\n            if a == b or len(d[a]) > 2 or len(d[b]) > 2:\n                f = True\n        if f:\n            print('NO')\n        else:\n\n            def get(i):\n                visited[i] = False\n                for el in d[i]:\n                    if visited[el]:\n                        return get(el) + 1\n                return 1\n            visited = [True] * (n + 1)\n            for i in range(1, n + 1):\n                if visited[i]:\n                    if get(i) % 2:\n                        f = True\n            if f:\n                print('NO')\n            else:\n                print('YES')\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "for _ in range(int(input())):\n    n = int(input())\n    ans = 'YES'\n    edges = [[] for i in range(n)]\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n    for i in edges:\n        if len(i) != 2:\n            ans = 'NO'\n            break\n    if ans == 'NO':\n        print(ans)\n    else:\n        vis = [0] * n\n        for i in range(n):\n            if vis[i]:\n                continue\n            queue = [i]\n            cnt = 0\n            while queue:\n                (curr, f) = (queue.pop(), 0)\n                cnt += 1\n                vis[curr] = 1\n                for e in edges[curr]:\n                    if vis[e]:\n                        continue\n                    f = 1\n                    queue.append(e)\n                if not f:\n                    break\n            if cnt % 2:\n                ans = 'NO'\n                break\n        if 0 in vis:\n            ans = 'NO'\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    ans = 'YES'\n    edges = [[] for i in range(n)]\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n    for i in edges:\n        if len(i) != 2:\n            ans = 'NO'\n            break\n    if ans == 'NO':\n        print(ans)\n    else:\n        vis = [0] * n\n        for i in range(n):\n            if vis[i]:\n                continue\n            queue = [i]\n            cnt = 0\n            while queue:\n                (curr, f) = (queue.pop(), 0)\n                cnt += 1\n                vis[curr] = 1\n                for e in edges[curr]:\n                    if vis[e]:\n                        continue\n                    f = 1\n                    queue.append(e)\n                if not f:\n                    break\n            if cnt % 2:\n                ans = 'NO'\n                break\n        if 0 in vis:\n            ans = 'NO'\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    f = False\n    d = [[] for _ in range(n + 1)]\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        d[a].append(b)\n        d[b].append(a)\n        if a == b or len(d[a]) > 2 or len(d[b]) > 2:\n            f = True\n    if f:\n        print('NO')\n    else:\n        seen = [False] * (n + 1)\n        for a in range(1, n + 1):\n            if f:\n                break\n            if not seen[a]:\n                b = a\n                cnt = 0\n                while not seen[b] and len(d[b]) > 0:\n                    seen[b] = True\n                    c = d[b].pop()\n                    d[c].remove(b)\n                    b = c\n                    cnt += 1\n                if seen[b] and cnt % 2 == 1:\n                    f = True\n        if f:\n            print('NO')\n        else:\n            print('YES')", "for _ in range(int(input())):\n    n = int(input())\n    a = [[] for _ in range(n)]\n    flag = True\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        a[x - 1].append(y - 1)\n        a[y - 1].append(x - 1)\n        if x == y:\n            flag = False\n    if flag:\n        for i in range(n):\n            if len(a[i]) > 2:\n                flag = False\n                break\n    if flag:\n        visited = [False] * n\n        for v in range(n):\n            if not visited[v]:\n                visited[v] = True\n                t = v\n                cnt = 0\n                while a[t]:\n                    new_v = a[t].pop()\n                    visited[new_v] = True\n                    a[new_v].remove(t)\n                    t = new_v\n                    cnt += 1\n                if cnt % 2 == 1:\n                    flag = False\n                    break\n    print('YES' if flag else 'NO')", "R = lambda : map(int, input().split())\n(t,) = R()\n\ndef find(i):\n    while fa[i] != i:\n        fa[i] = fa[fa[i]]\n        i = fa[i]\n    return i\nwhile t:\n    t -= 1\n    (n,) = R()\n    n += 1\n    z = 0\n    fa = list(range(n))\n    (c, sons) = ([0] * n, [0] * n)\n    for _ in range(n - 1):\n        (u, v) = R()\n        c[u] += 1\n        c[v] += 1\n        fa[find(u)] = find(v)\n    for i in range(1, n):\n        sons[find(i)] += 1\n    for i in range(1, n):\n        if sons[i] & 1 or c[i] != 2:\n            z = 1\n            break\n    print(['YES', 'NO'][z])", "R = lambda : map(int, input().split())\n(t,) = R()\n\ndef find(i):\n    while fa[i] != i:\n        fa[i] = fa[fa[i]]\n        i = fa[i]\n    return i\nwhile t:\n    t -= 1\n    (n,) = R()\n    n += 1\n    z = 0\n    fa = list(range(n))\n    (c, sons) = ([0] * n, [0] * n)\n    for _ in range(n - 1):\n        (u, v) = R()\n        c[u] += 1\n        c[v] += 1\n        fa[find(u)] = find(v)\n    for i in range(1, n):\n        sons[find(i)] += 1\n    for i in range(1, n):\n        if sons[i] & 1 or c[i] != 2:\n            z = 1\n            break\n    print(['YES', 'NO'][z])", "import math\nimport bisect\n\ndef printf(str):\n    print(str, end=' ')\ntest_case = int(input())\nt = 0\nwhile t < test_case:\n    t += 1\n    n = int(input())\n    ans = 'YES'\n    edges = [[] for i in range(n)]\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n    for i in edges:\n        if len(i) != 2:\n            ans = 'NO'\n            break\n    if ans == 'NO':\n        print(ans)\n    else:\n        vis = [0] * n\n        for i in range(n):\n            if vis[i]:\n                continue\n            queue = [i]\n            cnt = 0\n            while queue:\n                (curr, f) = (queue.pop(), 0)\n                cnt += 1\n                vis[curr] = 1\n                for e in edges[curr]:\n                    if vis[e]:\n                        continue\n                    f = 1\n                    queue.append(e)\n                if not f:\n                    break\n            if cnt % 2:\n                ans = 'NO'\n                break\n        if 0 in vis:\n            ans = 'NO'\n        print(ans)", "R = lambda : map(int, input().split())\n(t,) = R()\n\ndef find(i):\n    while fa[i] != i:\n        fa[i] = fa[fa[i]]\n        i = fa[i]\n    return i\nwhile t:\n    t -= 1\n    (n,) = R()\n    n += 1\n    z = 0\n    fa = list(range(n))\n    (c, sons) = ([0] * n, [0] * n)\n    for _ in range(n - 1):\n        (u, v) = R()\n        c[u] += 1\n        c[v] += 1\n        fa[find(u)] = find(v)\n    for i in range(1, n):\n        sons[find(i)] += 1\n    for i in range(1, n):\n        if sons[i] & 1 or c[i] != 2:\n            z = 1\n            break\n    print(['YES', 'NO'][z])", "R = lambda : map(int, input().split())\n(t,) = R()\n\ndef find(i):\n    while fa[i] != i:\n        fa[i] = fa[fa[i]]\n        i = fa[i]\n    return i\nwhile t:\n    t -= 1\n    (n,) = R()\n    n += 1\n    z = 0\n    fa = list(range(n))\n    (c, sons) = ([0] * n, [0] * n)\n    for _ in range(n - 1):\n        (u, v) = R()\n        c[u] += 1\n        c[v] += 1\n        fa[find(u)] = find(v)\n    for i in range(1, n):\n        sons[find(i)] += 1\n    for i in range(1, n):\n        if sons[i] & 1 or c[i] != 2:\n            z = 1\n            break\n    print(['YES', 'NO'][z])", "R = lambda : map(int, input().split())\n(t,) = R()\n\ndef find(i):\n    while fa[i] != i:\n        fa[i] = fa[fa[i]]\n        i = fa[i]\n    return i\nwhile t:\n    t -= 1\n    (n,) = R()\n    n += 1\n    z = 0\n    fa = list(range(n))\n    (c, sons) = ([0] * n, [0] * n)\n    for _ in range(n - 1):\n        (u, v) = R()\n        c[u] += 1\n        c[v] += 1\n        fa[find(u)] = find(v)\n    for i in range(1, n):\n        sons[find(i)] += 1\n    for i in range(1, n):\n        if sons[i] & 1 or c[i] != 2:\n            z = 1\n            break\n    print(['YES', 'NO'][z])", "for _ in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(tuple(map(int, input().split())))\n    l1 = []\n    ans = 1\n    for i in range(n):\n        l1.append([])\n    for i in l:\n        a = i[0]\n        b = i[1]\n        l1[a - 1].append(b - 1)\n        l1[b - 1].append(a - 1)\n        if len(l1[a - 1]) >= 3 or len(l1[b - 1]) >= 3:\n            ans = 0\n    x = set(range(n))\n    while len(x) != 0 and ans:\n        a = x.pop()\n        b = l1[a][0]\n        c = a\n        count = 0\n        while b != a:\n            count += 1\n            if not b in x:\n                ans = 0\n                break\n            x.remove(b)\n            if l1[b][0] == c:\n                c = b\n                b = l1[b][1]\n            else:\n                c = b\n                b = l1[b][0]\n        if count % 2 == 0 or ans == 0:\n            ans = 0\n            break\n    if ans == 1:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    n = int(input())\n    index = [[] for _ in range(n)]\n    domino = []\n    for i in range(n):\n        (a, b) = (int(x) - 1 for x in input().split())\n        domino.append((a, b))\n        index[a].append(i)\n        index[b].append(i)\n    if any((len(x) != 2 for x in index)):\n        print('NO')\n        continue\n    visited = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        visited[i] = True\n        (u, v) = domino[i]\n        cycle = 1\n        while u != v:\n            i = sum(index[u]) - i\n            visited[i] = True\n            u = sum(domino[i]) - u\n            cycle += 1\n        if cycle % 2 == 1:\n            print('NO')\n            break\n    else:\n        print('YES')", "for _ in range(int(input())):\n    n = int(input())\n    p = [[] for _ in range(n)]\n    d = []\n    for i in range(n):\n        (a, b) = (int(x) - 1 for x in input().split())\n        d.append((a, b))\n        p[a].append(i)\n        p[b].append(i)\n    if any((len(x) != 2 for x in p)):\n        print('NO')\n        continue\n    visited = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        visited[i] = True\n        (u, v) = d[i]\n        cycle = 1\n        while u != v:\n            i = sum(p[u]) - i\n            u = sum(d[i]) - u\n            cycle += 1\n            visited[i] = True\n        if cycle % 2 == 1:\n            print('NO')\n            break\n    else:\n        print('YES')", "def ss(n, l):\n    d = {i + 1: [] for i in range(n)}\n    for (a, b) in l:\n        if a == b:\n            return False\n        d[a].append(b)\n        d[b].append(a)\n    for i in d:\n        if len(d[i]) != 2:\n            return False\n    v = [-1 for _ in range(n + 1)]\n\n    def ppp(node):\n        v[node] = 1\n        q = [node]\n        while q:\n            q1 = []\n            for a in q:\n                for b in d[a]:\n                    if v[b] == v[a]:\n                        return False\n                    elif v[b] == -1:\n                        v[b] = 1 - v[a]\n                        q1.append(b)\n            q = q1\n        return True\n    for i in range(1, n + 1):\n        if v[i] == -1:\n            x = ppp(i)\n            if not x:\n                return False\n    return True\nfor I in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    if ss(n, l):\n        print('YES')\n    else:\n        print('NO')", "def dfs(n, visited, adj):\n    stack = [n]\n    c = 0\n    visited[n] = True\n    while stack:\n        curr = stack.pop()\n        c += 1\n        for i in adj[curr]:\n            if visited[i] == False:\n                stack.append(i)\n                visited[i] = True\n    return (c, visited)\nt = int(input())\nwhile t:\n    p = int(input())\n    d = [[int(x) for x in input().split()] for _ in range(p)]\n    adj = [[] for _ in range(p + 1)]\n    visited = [False] * (p + 1)\n    check = 0\n    for i in range(p):\n        (s, h) = d[i]\n        if s == h:\n            check = 1\n            break\n        adj[s].append(h)\n        adj[h].append(s)\n    for i in range(p + 1):\n        if len(adj[i]) > 2:\n            check = 1\n            break\n        elif visited[i] == False and len(adj[i]) > 1:\n            (cnt, z) = dfs(i, visited, adj)\n            if cnt % 2 != 0:\n                check = 1\n    sj = 'NO' if check else 'YES'\n    print(sj)\n    t -= 1", "from collections import defaultdict\ncnt = [0]\n\ndef bfs(adj, u, par, vis):\n    q = [(u, par)]\n    for (node, parent) in q:\n        for child in adj[node]:\n            if child == parent:\n                continue\n            if vis[child]:\n                continue\n            vis[child] = True\n            cnt[0] += 1\n            q.append((child, node))\nN = int(input())\nfor _ in range(N):\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    flag = True\n    for _ in range(n):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for i in adj:\n        if len(i) > 2:\n            flag = False\n            break\n    if not flag:\n        print('NO')\n        continue\n    mark = [-1] * n\n    for i in range(n):\n        if mark[i] > -1:\n            continue\n        q = [(i, 0)]\n        while len(q):\n            (c, m) = q.pop(0)\n            if mark[c] > -1:\n                if m != mark[c]:\n                    flag = False\n                    break\n                else:\n                    continue\n            mark[c] = m\n            for v in adj[c]:\n                q.append((v, 1 - m))\n            if not flag:\n                break\n    print(['NO', 'YES'][flag])", "for q in range(int(input())):\n    x = int(input())\n    a = []\n    b = [[] for i in range(x)]\n    for i in range(x):\n        (y, z) = map(int, input().split())\n        a.append([y, z])\n        b[y - 1].append(i)\n        b[z - 1].append(i)\n    f = 0\n    for i in b:\n        if len(i) != 2:\n            f = 1\n            break\n    if f == 1:\n        print('NO')\n        continue\n    c = [1] * x\n    for i in range(x):\n        if c[i] == 0:\n            continue\n        c[i] = 0\n        (y, z) = a[i]\n        p = 1\n        while y != z:\n            i = sum(b[y - 1]) - i\n            y = sum(a[i]) - y\n            p += 1\n            c[i] = 0\n        if p % 2 == 1:\n            print('NO')\n            break\n    else:\n        print('YES')", "for _ in range(int(input())):\n    n = int(input())\n    x = [[] for t in range(n)]\n    y = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        y.append([a - 1, b - 1])\n        x[a - 1].append(i)\n        x[b - 1].append(i)\n    if any((len(i) != 2 for i in x)):\n        print('NO')\n        continue\n    vis = [False] * n\n    for i in range(n):\n        if vis[i]:\n            continue\n        vis[i] = True\n        (a, b) = y[i]\n        c = 1\n        while a != b:\n            i = sum(x[a]) - i\n            a = sum(y[i]) - a\n            c += 1\n            vis[i] = True\n        if c % 2 == 1:\n            print('NO')\n            break\n    else:\n        print('YES')", "for i in range(int(input())):\n    n = int(input())\n    p = [[] for i in range(n + 1)]\n    f = [0] * n + [0]\n    k = 1\n    w = [[int(j) for j in input().split()] for t in range(n)]\n    for j in range(n):\n        p[w[j][0]] += [w[j][1]]\n        p[w[j][1]] += [w[j][0]]\n        if len(p[w[j][0]]) > 2 or len(p[w[j][1]]) > 2:\n            k = 0\n    for j in range(1, n + 1):\n        if f[j] < 1:\n            o = [j, 1]\n            f[j] = 1\n            while o:\n                x = o.pop() + 1\n                y = o.pop()\n                for t in p[y]:\n                    if f[t] < 1:\n                        f[t] = x\n                        o += [t, x]\n    for j in range(n):\n        if (f[w[j][0]] + f[w[j][1]]) % 2 < 1:\n            k = 0\n    print(['NO', 'YES'][k])", "for i in range(int(input())):\n    n = int(input())\n    p = [[] for i in range(n + 1)]\n    f = [0] * n + [0]\n    k = 1\n    w = [[int(j) for j in input().split()] for t in range(n)]\n    for j in range(n):\n        p[w[j][0]] += [w[j][1]]\n        p[w[j][1]] += [w[j][0]]\n        if len(p[w[j][0]]) > 2 or len(p[w[j][1]]) > 2:\n            k = 0\n    for j in range(1, n + 1):\n        if f[j] < 1:\n            o = [j, 1]\n            f[j] = 1\n            while o:\n                x = o.pop() + 1\n                y = o.pop()\n                for t in p[y]:\n                    if f[t] < 1:\n                        f[t] = x\n                        o += [t, x]\n    for j in range(n):\n        if (f[w[j][0]] + f[w[j][1]]) % 2 < 1:\n            k = 0\n    print(['NO', 'YES'][k])", "from collections import defaultdict, deque, Counter\n\ndef solve(ps):\n    adj = defaultdict(list)\n    cnt = Counter()\n    for (a, b) in ps:\n        if a == b:\n            return 'NO'\n        adj[a].append((a, b))\n        adj[b].append((a, b))\n        cnt[a] += 1\n        cnt[b] += 1\n    for (k, c) in cnt.items():\n        if c > 2:\n            return 'NO'\n    ts = {}\n    q = deque()\n    for tp in ps:\n        q.append((tp, None))\n    while q:\n        (tp, t) = q.pop()\n        if tp in ts:\n            if t is not None and ts[tp] != t:\n                return 'NO'\n            continue\n        if t is None:\n            t = 0\n        ts[tp] = t\n        for ttp in adj[tp[0]]:\n            if ttp == tp:\n                continue\n            q.append((ttp, 1 - t))\n        for ttp in adj[tp[1]]:\n            if ttp == tp:\n                continue\n            q.append((ttp, 1 - t))\n    return 'YES'\n\ndef main():\n    N = int(input())\n    for _ in range(N):\n        n = int(input())\n        ps = []\n        for _ in range(n):\n            ps.append(tuple(map(int, input().split())))\n        print(solve(ps))\n\ndef init():\n    import os\n    import sys\n    sys.setrecursionlimit(10 ** 8)\n    if 'CP_LOCAL_ENV' in os.environ:\n        sys.stdin = open('cf_test_a.txt')\ninit()\nmain()", "import sys\nimport threading\nfrom collections import defaultdict\n\ndef main():\n    t = int(input())\n\n    def dfs(curr, par, c, graph, color):\n        if color[curr] is not None:\n            if color[curr] != c:\n                return False\n            return True\n        color[curr] = c\n        for ncurr in graph[f'{curr}']:\n            if ncurr == par:\n                continue\n            if not dfs(ncurr, curr, not c, graph, color):\n                return False\n        return True\n    for _ in range(t):\n        n = int(input())\n        graph = defaultdict(list)\n        color = [None] * n\n        ans = True\n        for i in range(n):\n            (a, b) = map(int, input().split())\n            graph[f'{a}'].append(i)\n            graph[f'{b}'].append(i)\n            if a == b:\n                ans = False\n        newgraph = defaultdict(list)\n        for (c, lst) in graph.items():\n            s = lst[0]\n            if len(lst) > 2:\n                ans = False\n                break\n            for i in range(1, len(lst)):\n                newgraph[f'{s}'].append(lst[i])\n                newgraph[f'{lst[i]}'].append(s)\n        graph = None\n        for i in range(n):\n            if not ans:\n                break\n            if color[i] is None and (not dfs(i, -1, True, newgraph, color)):\n                ans = False\n        if ans:\n            print('YES')\n        else:\n            print('NO')\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()"]