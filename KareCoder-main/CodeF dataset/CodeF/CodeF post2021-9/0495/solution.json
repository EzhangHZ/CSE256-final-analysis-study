["from dataclasses import dataclass\nfrom time import time\nimport math\n\n@dataclass\nclass MyInput:\n    t: int\n    test_cases: list\n\ndef get_input():\n    t = int(input())\n    test_cases = []\n    for _ in range(t):\n        x = input()\n        k = input()\n        test_cases.append((x, k))\n    return MyInput(t=t, test_cases=test_cases)\n\ndef get_sample_idx_first(x, k):\n    (_, min_idx) = min(((val, idx) for (idx, val) in enumerate(x[:k + 1]) if val != '0'))\n    return min_idx\n\ndef resolve(x, k):\n    if k == 0:\n        return x\n    ret = []\n    min_value_idx = get_sample_idx_first(x, k)\n    ret.append(x[min_value_idx])\n    k = k - min_value_idx\n    for i in range(min_value_idx + 1, len(x)):\n        while len(ret) > 1 and k and (ret[-1] > x[i]):\n            ret.pop()\n            k -= 1\n        ret.append(x[i])\n    while len(ret) > 1 and k:\n        ret.pop()\n        k -= 1\n    return ''.join(ret)\n\ndef main():\n    myinput = get_input()\n    for i in range(myinput.t):\n        (x, k) = myinput.test_cases[i]\n        k = int(k)\n        print(resolve(x, k))\n    return myinput\nmain()", "import bisect\n\ndef rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor tc in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "import bisect\n\ndef rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor tc in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "def restofs(s, k):\n    lst = []\n    for i in s:\n        while len(lst) > 0 and k != 0 and (lst[-1] > i):\n            lst.pop()\n            k -= 1\n        lst.append(i)\n    while len(lst) > 0 and k != 0:\n        lst.pop()\n        k -= 1\n    return ''.join(lst)\nfor __ in range(int(input())):\n    s = input()\n    k = int(input())\n    (i, x) = (0, s[0])\n    for j in range(1, k + 1):\n        if s[j] > '0' and s[j] < x:\n            x = s[j]\n            i = j\n    print(x + restofs(s[i + 1:], k - i))", "def rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor _ in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "def rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor tc in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "def rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor tc in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "def rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor _ in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "def restofs(s, k):\n    lst = []\n    for i in s:\n        while len(lst) > 0 and k != 0 and (lst[-1] > i):\n            lst.pop()\n            k -= 1\n        lst.append(i)\n    while len(lst) > 0 and k != 0:\n        lst.pop()\n        k -= 1\n    return ''.join(lst)\nfor __ in range(int(input())):\n    s = input()\n    k = int(input())\n    (i, x) = (0, s[0])\n    for j in range(1, k + 1):\n        if s[j] > '0' and s[j] < x:\n            x = s[j]\n            i = j\n    print(x + restofs(s[i + 1:], k - i))", "def rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor tc in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "def allsmall(l, k):\n    n = len(l)\n    res = [l[0]]\n    z = 0\n    i = 1\n    t = 0\n    last = l[0]\n    while i < n and t < k:\n        if z == len(res) - 1 and last > l[i] and (l[i] != '0'):\n            if k - t >= z + 1:\n                res = []\n                t += z + 1\n                z = 0\n                res.append(l[i])\n                last = res[0]\n                i += 1\n                continue\n        if res[-1] > l[i]:\n            if l[i] == '0' and len(res) == 1:\n                res.append(l[i])\n                z += 1\n                i += 1\n            elif k - t >= 1:\n                res.pop()\n                t += 1\n            else:\n                break\n        else:\n            if l[i] == '0':\n                z += 1\n            res.append(l[i])\n            i += 1\n        if len(res) == 0:\n            res.append(l[i])\n            i += 1\n        last = res[0]\n    res.extend(l[i:n])\n    res = res[0:n - k]\n    s = ''\n    for i in res:\n        s += f'{i}'\n    return s\nt = int(input())\nfor i in range(t):\n    l = input()\n    k = int(input())\n    print(allsmall(l, k))", "t = int(input())\nfor i in range(t):\n    x = input()\n    k = int(input())\n    a = len(x)\n    count = '99999999999999999999999999999999999999999999990'\n    b = 0\n    for d in range(k + 1):\n        if x[d] < count and x[d] != '0':\n            count = x[d]\n            b = d\n    k -= b\n    nums = []\n    d = k\n    for e in range(b + 1, a):\n        while nums and nums[-1] > x[e]:\n            if k > 0:\n                nums.pop()\n                k -= 1\n            else:\n                break\n        nums.append(x[e])\n    print(count + ''.join(nums[:len(nums) - k]))", "def allsmall(l, k):\n    n = len(l)\n    res = [l[0]]\n    z = 0\n    i = 1\n    t = 0\n    last = l[0]\n    while i < n and t < k:\n        if z == len(res) - 1 and last > l[i] and (l[i] != '0'):\n            if k - t >= z + 1:\n                res = []\n                t += z + 1\n                z = 0\n                res.append(l[i])\n                last = res[0]\n                i += 1\n                continue\n        if res[-1] > l[i]:\n            if l[i] == '0' and len(res) == 1:\n                res.append(l[i])\n                z += 1\n                i += 1\n            elif k - t >= 1:\n                res.pop()\n                t += 1\n            else:\n                break\n        else:\n            if l[i] == '0':\n                z += 1\n            res.append(l[i])\n            i += 1\n        if len(res) == 0:\n            res.append(l[i])\n            i += 1\n        last = res[0]\n    res.extend(l[i:n])\n    res = res[0:n - k]\n    s = ''\n    for i in res:\n        s += f'{i}'\n    return s\nt = int(input())\nfor i in range(t):\n    l = input()\n    k = int(input())\n    print(allsmall(l, k))", "iterations = int(input())\nfor _ in range(iterations):\n    number_string = input()\n    number_of_operations = int(input())\n    (minimum, index) = (number_string[0], 0)\n    for i in range(number_of_operations + 1):\n        if '0' < number_string[i] < minimum:\n            (minimum, index) = (number_string[i], i)\n    output_string = number_string[index]\n    number_string = number_string[index + 1:]\n    number_of_operations -= index\n    remaining_output = []\n    for number in number_string:\n        while len(remaining_output) > 0 and number_of_operations > 0 and (remaining_output[-1] > number):\n            remaining_output.pop()\n            number_of_operations -= 1\n        remaining_output.append(number)\n    output_string += ''.join(remaining_output[:len(remaining_output) - number_of_operations])\n    print(output_string)", "t = int(input())\nfor i in range(t):\n    x = input()\n    k = int(input())\n    a = len(x)\n    count = '99999999999999999999999999999999999999999999990'\n    b = 0\n    for d in range(k + 1):\n        if x[d] < count and x[d] != '0':\n            count = x[d]\n            b = d\n    k -= b\n    nums = []\n    d = k\n    for e in range(b + 1, a):\n        while nums and nums[-1] > x[e]:\n            if k > 0:\n                nums.pop()\n                k -= 1\n            else:\n                break\n        nums.append(x[e])\n    print(count + ''.join(nums[:len(nums) - k]))", "def rem(ss, kk):\n    ret = []\n    for c in ss:\n        while len(ret) > 0 and kk and (ret[-1] > c):\n            ret.pop()\n            kk -= 1\n        ret.append(c)\n    while len(ret) > 0 and kk:\n        ret.pop()\n        kk -= 1\n    return ''.join(ret)\nt = int(input())\nfor tc in range(t):\n    s = input()\n    n = len(s)\n    k = int(input())\n    i = 0\n    m = s[0]\n    for j in range(1, k + 1):\n        if '0' < s[j] < m:\n            m = s[j]\n            i = j\n    print(m + rem(s[i + 1:], k - i))", "from math import *\nfrom heapq import heappop, heappush\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    pass\n\ndef solution():\n    line = input()\n    k = int(input())\n    m = len(line) - k\n    if k == 0:\n        return print(line)\n    res = []\n    min_index = -1\n    min_val = inf\n    m -= 1\n    for i in range(len(line) - m):\n        val = int(line[i])\n        if val > 0 and val < min_val:\n            min_val = val\n            min_index = i\n    if min_val >= inf:\n        return print(0)\n    res = [min_val]\n    min_heap = []\n    for i in range(min_index + 1, len(line)):\n        val = (int(line[i]), i)\n        heappush(min_heap, val)\n        num_left_vals = len(line) - i - 1\n        if num_left_vals == m - 1:\n            while min_heap and min_heap[0][1] < min_index:\n                heappop(min_heap)\n            (val, min_index) = heappop(min_heap)\n            res.append(val)\n            m -= 1\n    return print(''.join(map(str, res)))\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solution()\nimport sys\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "from math import *\nfrom heapq import heappop, heappush\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    pass\n\ndef solution():\n    line = input()\n    k = int(input())\n    m = len(line) - k\n    if k == 0:\n        return print(line)\n    res = []\n    min_index = -1\n    min_val = inf\n    m -= 1\n    for i in range(len(line) - m):\n        val = int(line[i])\n        if val > 0 and val < min_val:\n            min_val = val\n            min_index = i\n    if min_val >= inf:\n        return print(0)\n    res = [min_val]\n    min_heap = []\n    for i in range(min_index + 1, len(line)):\n        val = (int(line[i]), i)\n        heappush(min_heap, val)\n        num_left_vals = len(line) - i - 1\n        if num_left_vals == m - 1:\n            while min_heap[0][1] < min_index:\n                heappop(min_heap)\n            (val, min_index) = heappop(min_heap)\n            res.append(val)\n            m -= 1\n    return print(''.join(map(str, res)))\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solution()\nimport sys\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "from bisect import bisect_left\nfrom collections import defaultdict\n\ndef case():\n    x = input()\n    k = int(input())\n    pos = defaultdict(list)\n    for i in range(len(x) - 1, -1, -1):\n        pos[x[i]].append(i)\n    ans = []\n    i = 0\n    target = len(x) - k\n    while i < len(x):\n        if len(ans) == target:\n            break\n        for goal in '0123456789':\n            if i == 0 and goal == '0':\n                continue\n            if not pos[goal]:\n                continue\n            while pos[goal] and pos[goal][-1] < i:\n                pos[goal].pop()\n            if pos[goal]:\n                cut_til = pos[goal][-1]\n                if cut_til - i <= k:\n                    k -= cut_til - i\n                    i = cut_til\n                    ans.append(x[i])\n                    break\n        i += 1\n    print(''.join(ans))\n\ndef go():\n    t = int(input())\n    for i in range(t):\n        case()\ngo()"]