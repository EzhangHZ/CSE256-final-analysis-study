["from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef resolve(n, pairs):\n    d = defaultdict(list)\n    for (i, [a, b, m]) in enumerate(pairs):\n        k = a + b - m\n        (al, ar) = (a - min(a, m), a - (m - min(b, m)))\n        d[k].append((al, ar, i))\n    ret = [0] + [None] * n\n    cnt = 0\n    for (k, arr) in d.items():\n        ll = []\n        pq = []\n        for (al, ar, i) in arr:\n            ll.append((al, 1, i))\n            ll.append((ar, -1, i))\n        ll.sort(key=lambda it: (it[0], -it[1]))\n        for (x, y, i) in ll:\n            if y < 0:\n                if ret[i + 1] is not None:\n                    continue\n                cnt += 1\n                while pq and pq[0][0] <= x:\n                    (_, j) = heappop(pq)\n                    ret[j + 1] = f'{pairs[j][0] - x} {pairs[j][1] - k + x}'\n            else:\n                heappush(pq, (x, i))\n    ret[0] = str(cnt)\n    return '\\n'.join(ret)\nfor _ in range(int(input())):\n    input()\n    n = int(input())\n    print(resolve(n, [[int(_) for _ in input().split()] for _ in range(n)]))", "from collections import defaultdict\nimport heapq\n\ndef resolve(n, pairs):\n    d = defaultdict(list)\n    for (i, [a, b, m]) in enumerate(pairs):\n        k = a + b - m\n        (al, ar) = (a - min(a, m), a - (m - min(b, m)))\n        d[k].append((al, ar, i))\n    ret = [0] + [None] * n\n    cnt = 0\n    for (k, arr) in d.items():\n        ll = []\n        for (al, ar, i) in arr:\n            ll.append((al, 1, i))\n            ll.append((ar, -1, i))\n        ll.sort(key=lambda it: (it[0], -it[1]))\n        pq = []\n        for (x, y, i) in ll:\n            if y < 0:\n                if ret[i + 1] is not None:\n                    continue\n                cnt += 1\n                while pq and pq[0][0] <= x:\n                    (_, j) = heapq.heappop(pq)\n                    ret[j + 1] = f'{pairs[j][0] - x} {pairs[j][1] - k + x}'\n            else:\n                heapq.heappush(pq, (x, i))\n    ret[0] = str(cnt)\n    return '\\n'.join(ret)\nt = int(input())\nans = []\nfor _ in range(t):\n    input()\n    n = int(input())\n    ans.append(resolve(n, [[int(_) for _ in input().split()] for _ in range(n)]))\nprint('\\n'.join(ans))", "from collections import defaultdict\nimport heapq\n\ndef resolve(n, pairs):\n    d = defaultdict(list)\n    for (i, [a, b, m]) in enumerate(pairs):\n        k = a + b - m\n        (al, ar) = (a - min(a, m), a - (m - min(b, m)))\n        d[k].append((al, ar, i))\n    ret = [0] + [None] * n\n    cnt = 0\n    for (k, arr) in d.items():\n        ll = []\n        for (al, ar, i) in arr:\n            ll.append((al, 1, i))\n            ll.append((ar, -1, i))\n        ll.sort(key=lambda it: (it[0], -it[1]))\n        pq = []\n        for (x, y, i) in ll:\n            if y < 0:\n                if ret[i + 1] is not None:\n                    continue\n                cnt += 1\n                while pq and pq[0][0] <= x:\n                    (_, j) = heapq.heappop(pq)\n                    ret[j + 1] = f'{pairs[j][0] - x} {pairs[j][1] - k + x}'\n            else:\n                heapq.heappush(pq, (x, i))\n    ret[0] = str(cnt)\n    return '\\n'.join(ret)\nt = int(input())\nans = []\nfor _ in range(t):\n    input()\n    n = int(input())\n    ans.append(resolve(n, [[int(_) for _ in input().split()] for _ in range(n)]))\nprint('\\n'.join(ans))", "for _ in range(int(input())):\n    input()\n    n = int(input())\n    a = []\n    b = []\n    m = []\n    for i in range(n):\n        (ai, bi, mi) = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\n        m.append(mi)\n    ansa = [0] * n\n    ansb = [0] * n\n    events = {}\n    for i in range(n):\n        ma = m[i] - b[i] if m[i] > b[i] else 0\n        mb = m[i] - a[i] if m[i] > a[i] else 0\n        ansa[i] += ma\n        ansb[i] += mb\n        a[i] -= ma\n        b[i] -= mb\n        m[i] -= ma + mb\n        diag = a[i] + b[i] - m[i]\n        if diag not in events:\n            events[diag] = []\n        events[diag].append((a[i] - m[i], 0, i))\n        events[diag].append((a[i], 1, i))\n    used = [0] * n\n    count = 0\n    for diag in events:\n        evts = sorted(events[diag])\n        opened = []\n        for event in evts:\n            if event[1]:\n                if not used[event[2]]:\n                    for i in opened:\n                        ansa[i] += a[i] - event[0]\n                        ansb[i] += m[i] - a[i] + event[0]\n                        used[i] = 1\n                    opened = []\n                    count += 1\n            else:\n                opened.append(event[2])\n    print(count)\n    for i in range(n):\n        print(ansa[i], ansb[i])"]