["from sys import stdin\n\ndef solve():\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    pos = [[] for _ in range(n)]\n    for (i, x) in enumerate(a):\n        pos[x - 1].append(i)\n    p1 = [-1] * n\n    s1 = []\n    p2 = [-1] * n\n    s2 = []\n    for (x_, px) in enumerate(pos[::-1]):\n        x = n - x_\n        if len(px) == 1:\n            p1[px[0]] = p2[px[0]] = x\n        elif len(px) == 2:\n            p1[px[0]] = p2[px[1]] = x\n            s1.append(px[1])\n            s2.append(px[0])\n        elif len(px) == 0 and s1 and s2:\n            p1[s1.pop()] = x\n            p2[s2.pop()] = x\n        else:\n            print('NO')\n            return\n    print('YES')\n    print(' '.join(map(str, p1)))\n    print(' '.join(map(str, p2)))\n\ndef main():\n    t = int(stdin.readline())\n    for _ in range(t):\n        solve()\nmain()", "t = int(input())\nres = []\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    freq = [[] for _ in range(n + 2)]\n    for (ind, e) in enumerate(a):\n        freq[e].append(ind)\n    p = [0] * n\n    q = [0] * n\n    minv = []\n    ans = 'YES'\n    for (i, e) in enumerate(freq):\n        if i == 0:\n            continue\n        val = len(e)\n        if val == 0:\n            minv.append(i)\n        elif val == 1:\n            p[e[0]] = i\n            q[e[0]] = i\n        elif val == 2 and len(minv) != 0:\n            p[e[0]] = i\n            ele = minv.pop()\n            p[e[0]] = i\n            q[e[0]] = ele\n            p[e[1]] = ele\n            q[e[1]] = i\n        else:\n            ans = 'NO'\n            break\n    if ans == 'NO':\n        res.append(ans)\n    else:\n        res.append(ans)\n        res.append(' '.join(map(str, p)))\n        res.append(' '.join(map(str, q)))\nfor i in res:\n    print(i)", "from collections import defaultdict\n\ndef solve():\n    n = int(input())\n    arr = [int(x) for x in input().split(' ')]\n    p = [-1] * n\n    q = [-1] * n\n    p_empty_indexes = []\n    q_empty_indexes = []\n    val_to_indexes = defaultdict(list)\n    for idx in range(n):\n        val_to_indexes[arr[idx]].append(idx)\n    for val in reversed(range(1, n + 1)):\n        occurances = len(val_to_indexes[val]) if val in val_to_indexes else 0\n        if occurances == 2:\n            p[val_to_indexes[val][0]] = val\n            q[val_to_indexes[val][1]] = val\n            p_empty_indexes.append(val_to_indexes[val][1])\n            q_empty_indexes.append(val_to_indexes[val][0])\n        elif occurances == 1:\n            p[val_to_indexes[val][0]] = val\n            q[val_to_indexes[val][0]] = val\n        elif occurances == 0:\n            if len(p_empty_indexes) == 0 or len(q_empty_indexes) == 0:\n                return (None, None)\n            p_idx = p_empty_indexes.pop()\n            q_idx = q_empty_indexes.pop()\n            p[p_idx] = val\n            q[q_idx] = val\n    if len(p_empty_indexes) != 0 or len(q_empty_indexes) != 0:\n        return (None, None)\n    ps = [str(i) for i in p]\n    qs = [str(i) for i in q]\n    return (ps, qs)\ntc = int(input())\nfor idx in range(tc):\n    (p, q) = solve()\n    if p is None:\n        print('NO')\n    else:\n        print('YES')\n        print(' '.join(p))\n        print(' '.join(q))", "from collections import defaultdict\n\ndef main():\n    if max(A) != n:\n        print('NO')\n        return\n    mp = defaultdict(list)\n    for (i, x) in enumerate(A):\n        mp[x].append(i)\n        if len(mp[x]) > 2:\n            print('NO')\n            return\n    p = [-1] * N\n    q = [-1] * N\n    pp = [-1] * N\n    qq = [-1] * N\n    for x in range(n, 0, -1):\n        for i in mp[x]:\n            if pp[x] == -1:\n                pp[x] = i\n                p[i] = x\n            elif qq[x] == -1:\n                qq[x] = i\n                q[i] = x\n    vp = vq = n\n    for x in range(n, 0, -1):\n        for i in mp[x]:\n            while pp[vp] != -1:\n                vp -= 1\n            while qq[vq] != -1:\n                vq -= 1\n            if p[i] == -1 and vp > 0:\n                pp[vp] = i\n                p[i] = vp\n            if q[i] == -1 and vq > 0:\n                qq[vq] = i\n                q[i] = vq\n    for i in range(1, N):\n        if max(p[i], q[i]) != A[i]:\n            print('NO')\n            return\n    print('YES')\n    print(' '.join(map(str, p[1:])))\n    print(' '.join(map(str, q[1:])))\n    return\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    N = n + 1\n    A = [0] + list(map(int, input().split()))\n    main()", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().strip().split()))\n    probe = {v: [] for v in range(1, n + 1)}\n    YES = True\n    for (i, v) in enumerate(lst):\n        probe[v].append(i)\n        if len(probe[v]) > 2:\n            YES = False\n            break\n    if not YES:\n        print('NO')\n        continue\n    p = [None] * n\n    q = [None] * n\n    p_buffer = deque()\n    q_buffer = deque()\n    for v in range(n, 0, -1):\n        if len(probe[v]) == 0 and (len(p_buffer) == 0 or len(q_buffer) == 0):\n            YES = False\n            break\n        elif len(probe[v]) == 0:\n            p[p_buffer.popleft()] = v\n            q[q_buffer.popleft()] = v\n        elif len(probe[v]) == 2:\n            p[probe[v][0]] = v\n            q[probe[v][1]] = v\n            p_buffer.append(probe[v][1])\n            q_buffer.append(probe[v][0])\n        else:\n            p[probe[v][0]] = v\n            q[probe[v][0]] = v\n    if not YES:\n        print('NO')\n        continue\n    for i in range(len(lst)):\n        if lst[i] != max(p[i], q[i]):\n            YES = False\n            break\n    if not YES:\n        print('NO')\n    else:\n        print('YES')\n        print(' '.join(map(str, p)))\n        print(' '.join(map(str, q)))", "def solve():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a1 = a.copy()\n    a1.sort()\n    x = []\n    y = []\n    x_dict = {}\n    y_dict = {}\n    a_count = {}\n    doubleval = []\n    for i in a1:\n        if i not in a_count:\n            a_count[i] = 1\n        elif a_count[i] == 1:\n            a_count[i] += 1\n            doubleval.append(i)\n        else:\n            print('NO')\n            return\n    hat = []\n    for i in range(1, n + 1):\n        if i not in a_count:\n            hat.append(i)\n    if len(hat) != len(doubleval):\n        print('NO')\n        return\n    lookup_dict = {}\n    for i in range(len(hat)):\n        lookup_dict[doubleval[i]] = hat[i]\n    for i in a:\n        if a_count[i] == 1:\n            x.append(i)\n            y.append(i)\n            continue\n        if i not in x_dict:\n            x_dict[i] = 1\n            x.append(i)\n            y.append(lookup_dict[i])\n        elif i not in y_dict:\n            y_dict[i] = 1\n            y.append(i)\n            x.append(lookup_dict[i])\n        if max(i, lookup_dict[i]) != i:\n            print('NO')\n            return\n    print('YES')\n    print(*x)\n    print(*y)\nfor _ in range(int(input())):\n    solve()", "import math\nfor i in range(int(input())):\n    n = int(input())\n    values = list(map(int, input().split()))\n    adj = [[] for i in range(n + 1)]\n    for k in range(n):\n        adj[values[k]].append(k)\n    valid = True\n    P = []\n    Q = []\n    p = [0] * n\n    q = [0] * n\n    for i in range(n, 0, -1):\n        count = len(adj[i])\n        if count == 2:\n            pos1 = adj[i][0]\n            pos2 = adj[i][1]\n            p[pos1] = i\n            P.append(pos2)\n            q[pos2] = i\n            Q.append(pos1)\n            continue\n        if count == 1:\n            pos = adj[i][0]\n            p[pos] = i\n            q[pos] = i\n            continue\n        if len(P) > 0 and len(Q) > 0:\n            p[P.pop()] = i\n            q[Q.pop()] = i\n        else:\n            valid = False\n            break\n    if valid:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "def taskC():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    if n == 1:\n        if a[0] == 1:\n            print('YES')\n            print('1')\n            print('1')\n        else:\n            print('NO')\n        return\n    b = sorted(a)\n    pos = [0 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        if b[i - 1] < i:\n            print('NO')\n            return\n        if pos[b[i - 1]] == 2:\n            print('NO')\n            return\n        else:\n            pos[b[i - 1]] += 1\n    print('YES')\n    pairs = [0 for i in range(n + 1)]\n    zeroes = []\n    for i in range(1, n + 1):\n        if pos[i] == 0:\n            zeroes.append(i)\n        elif pos[i] == 2:\n            zero = zeroes.pop()\n            pairs[i] = zero\n    used = [False for i in range(0, n + 1)]\n    p = [0 for i in range(n)]\n    q = [0 for i in range(n)]\n    for v in range(0, n):\n        val = a[v]\n        if pos[val] == 1:\n            p[v] = val\n            q[v] = val\n        elif pos[val] == 2:\n            pair = [val, pairs[val]]\n            if used[val]:\n                p[v] = pair[0]\n                q[v] = pair[1]\n            else:\n                p[v] = pair[1]\n                q[v] = pair[0]\n                used[val] = True\n    print(*p)\n    print(*q)\nt = int(input())\nfor i in range(t):\n    taskC()", "k = int(input())\nfor _ in range(k):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rp) > 0 and len(rq) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rq) > 0 and len(rp) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rq) > 0 and len(rp) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = [int(v) for v in input().split()]\n    arrset = set(arr)\n    arrsort = sorted(((v, i) for (i, v) in enumerate(arr)))\n    p = [-1] * n\n    q = [-1] * n\n    mp = 1\n    mq = 1\n    fooderp = deque()\n    fooderq = deque()\n    possible = True\n    for (v, i) in arrsort:\n        while mp <= v:\n            fooderp.append(mp)\n            mp += 1\n        while mq <= v:\n            fooderq.append(mq)\n            mq += 1\n        if len(fooderq) != 0 and len(fooderp) != 0 and (fooderp[-1] == v):\n            p[i] = fooderp.pop()\n            q[i] = fooderq.popleft()\n        elif len(fooderp) != 0 and len(fooderq) != 0 and (fooderq[-1] == v):\n            q[i] = fooderq.pop()\n            p[i] = fooderp.popleft()\n        else:\n            possible = False\n            break\n    if not possible:\n        print('NO')\n    else:\n        print('YES')\n        print(' '.join([str(v) for v in p]))\n        print(' '.join([str(v) for v in q]))", "t = int(input())\nfor _ in range(t):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rq) > 0 and len(rp) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "for _ in range(int(input())):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rq) > 0 and len(rp) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "import sys\nfrom heapq import *\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    cnt = [0] * (n + 1)\n    flag = 1\n    ans = [0] + [i for i in range(1, n + 1)]\n    visit = [0] * (n + 1)\n    for a in A:\n        cnt[a] += 1\n        if cnt[a] == 3:\n            flag = 0\n            break\n    if flag == 1:\n        H = []\n        for i in range(1, n + 1):\n            if cnt[i] == 0:\n                heappush(H, i)\n            elif cnt[i] == 1:\n                pass\n            elif cnt[i] == 2 and H:\n                x = H.pop()\n                ans[i] = x\n                ans[x] = i\n            else:\n                flag = 0\n                break\n        if flag == 1:\n            (p, q) = ([], [])\n            for i in range(n):\n                if visit[A[i]] == 0:\n                    p.append(A[i])\n                    q.append(ans[A[i]])\n                else:\n                    q.append(A[i])\n                    p.append(ans[A[i]])\n                visit[A[i]] += 1\n                visit[ans[A[i]]] += 1\n            print('YES')\n            print(*p)\n            print(*q)\n    if flag == 0:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rp) > 0 and len(rq) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "import sys\ninput = sys.stdin.readline\n\ndef readList():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readInts():\n    return map(int, input().split())\n\ndef readStr():\n    return input().strip()\n\ndef solve():\n    n = readInt()\n    arr = readList()\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        pos[arr[i]].append(i)\n    s = 0\n    exc = []\n    for v in range(n, 0, -1):\n        if len(pos[v]) == 2:\n            s += 1\n        elif len(pos[v]) == 1:\n            continue\n        elif len(pos[v]) == 0 and s:\n            s -= 1\n            exc.append(v)\n        else:\n            print('NO')\n            return\n    if s:\n        print('NO')\n        return\n    ans = [[0] * n, [0] * n]\n    for i in range(1, n + 1):\n        if len(pos[i]) == 1:\n            ans[0][pos[i][0]] = i\n            ans[1][pos[i][0]] = i\n        elif len(pos[i]) == 2:\n            v = exc.pop()\n            ans[0][pos[i][0]] = i\n            ans[1][pos[i][0]] = v\n            ans[0][pos[i][1]] = v\n            ans[1][pos[i][1]] = i\n    print('YES')\n    print(*ans[0])\n    print(*ans[1])\nfor _ in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (p, q) = ([0] * n, [0] * n)\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rp.append(pos[i][1])\n            rq.append(pos[i][0])\n        elif len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n        elif len(rp) > 0 and len(rq) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            print('NO')\n            break\n    else:\n        print('YES')\n        print(*p)\n        print(*q)", "def display(a, b, d):\n    (x, y) = ([0] * n, [0] * n)\n    for i in range(n):\n        if b[a[i] - 1] == 1:\n            x[i] = a[i]\n            y[i] = a[i]\n        elif b[a[i] - 1] == 2:\n            x[i] = a[i]\n            y[i] = d[a[i] - 1]\n            b[a[i] - 1] -= 2\n        else:\n            x[i] = d[a[i] - 1]\n            y[i] = a[i]\n    return (x, y)\n\ndef do(b, c):\n    (d, count) = ([0] * n, 0)\n    for i in range(n):\n        if b[i] == 1:\n            d[i] = i + 1\n        elif b[i] == 2:\n            d[i] = c[count] + 1\n            d[c[count]] = i + 1\n            count += 1\n    return (b, d)\nfor t in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    (b, flag) = ([0] * n, True)\n    for i in range(n):\n        b[a[i] - 1] += 1\n        if b[a[i] - 1] == 3:\n            flag = False\n            print('NO')\n            break\n    if flag:\n        sum = 0\n        for i in range(n):\n            sum += b[i]\n            if not sum <= i + 1:\n                flag = False\n                print('NO')\n                break\n        if flag:\n            print('YES')\n            c = []\n            for i in range(n):\n                if b[i] == 0:\n                    c.append(i)\n            (b, d) = do(b, c)\n            (x, y) = display(a, b, d)\n            print(*x)\n            print(*y)", "t = int(input())\nfor _ in range(t):\n    ok = True\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * n\n    q = [0] * n\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rq.append(pos[i][0])\n            rp.append(pos[i][1])\n            continue\n        if len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n            continue\n        if len(rp) > 0 and len(rq) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            ok = False\n    if ok:\n        print('YES')\n        print(*p)\n        print(*q)\n    else:\n        print('NO')", "t = int(input())\nfor __ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    c = [[] for x in range(n)]\n    flag = 0\n    for x in range(n):\n        c[arr[x] - 1].append(x)\n        if len(c[arr[x] - 1]) > 2:\n            flag = 1\n            break\n    a = [-1] * n\n    b = [-1] * n\n    ae = []\n    be = []\n    if flag == 1:\n        print('NO')\n    else:\n        for x in range(n - 1, -1, -1):\n            if len(c[x]) == 2:\n                a[c[x][0]] = x + 1\n                ae.append(c[x][1])\n                be.append(c[x][0])\n                b[c[x][1]] = x + 1\n            elif len(c[x]) == 1:\n                a[c[x][0]] = x + 1\n                b[c[x][0]] = x + 1\n            elif len(ae) == 0 or len(be) == 0:\n                flag = 1\n                break\n            else:\n                a[ae.pop(-1)] = x + 1\n                b[be.pop(-1)] = x + 1\n        if flag == 1:\n            print('NO')\n        else:\n            print('YES')\n            print(*a)\n            print(*b)", "import sys\nimport math\nimport cmath\nimport time\nfor t in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    l = [0] * n\n    sorter = True\n    for i in range(n):\n        l[a[i] - 1] += 1\n        if l[a[i] - 1] == 3:\n            sorter = False\n            print('NO')\n            break\n    if sorter:\n        sum = 0\n        for i in range(n):\n            sum += l[i]\n            if not sum <= i + 1:\n                sorter = False\n                print('NO')\n                break\n        if sorter:\n            print('YES')\n            zeros = []\n            for i in range(n):\n                if l[i] == 0:\n                    zeros.append(i)\n            pq = [0] * n\n            count = 0\n            for i in range(n):\n                if l[i] == 1:\n                    pq[i] = i + 1\n                if l[i] == 2:\n                    pq[i] = zeros[count] + 1\n                    pq[zeros[count]] = i + 1\n                    count += 1\n            p = [0] * n\n            q = [0] * n\n            for i in range(n):\n                if l[a[i] - 1] == 1:\n                    p[i] = a[i]\n                    q[i] = a[i]\n                elif l[a[i] - 1] == 2:\n                    p[i] = a[i]\n                    q[i] = pq[a[i] - 1]\n                    l[a[i] - 1] -= 2\n                else:\n                    p[i] = pq[a[i] - 1]\n                    q[i] = a[i]\n            print(*p)\n            print(*q)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = sorted(a)\n    d = {}\n    (i, f, s, res, pre, c) = (1, [], [], 'YES', b[0], 0)\n    for el in b:\n        if el == pre:\n            c += 1\n            if c == 3:\n                res = 'NO'\n                break\n            continue\n        if c == 1:\n            d[pre] = [pre, 0]\n        else:\n            while i in d or i == pre:\n                i += 1\n            if i > pre:\n                res = 'NO'\n                break\n            d[pre] = [i, 2]\n            i += 1\n        c = 1\n        pre = el\n    if c == 1:\n        d[pre] = [pre, 0]\n    else:\n        while i in d or i == pre:\n            i += 1\n        if i > pre:\n            res = 'NO'\n        d[pre] = [i, 2]\n    print(res)\n    if res == 'NO':\n        continue\n    for el in a:\n        if d[el][-1] == 0:\n            s.append(el)\n            f.append(el)\n        elif d[el][-1] == 2:\n            s.append(el)\n            f.append(d[el][0])\n            d[el][-1] -= 1\n        else:\n            s.append(d[el][0])\n            f.append(el)\n    print(*f, sep=' ')\n    print(*s, sep=' ')", "import itertools\nfrom collections import defaultdict\nfrom queue import PriorityQueue\n\ndef solve(restrictions):\n    n = len(restrictions)\n    p1 = [-1] * n\n    p2 = [-1] * n\n    restriction___positions = defaultdict(list)\n    for (pos, restriction) in enumerate(restrictions):\n        restriction___positions[restriction].append(pos)\n    reserved_positions_p1 = []\n    reserved_positions_p2 = []\n    for restriction in range(n - 1, -1, -1):\n        positions = restriction___positions[restriction]\n        if len(positions) > 2:\n            return False\n        elif len(positions) == 2:\n            p2[positions[0]] = restriction\n            reserved_positions_p1.append(positions[0])\n            p1[positions[1]] = restriction\n            reserved_positions_p2.append(positions[1])\n        elif len(positions) == 1:\n            p1[positions[0]] = restriction\n            p2[positions[0]] = restriction\n        elif len(positions) == 0:\n            if len(reserved_positions_p1) == 0:\n                return False\n            p1_pos = reserved_positions_p1.pop()\n            p2_pos = reserved_positions_p2.pop()\n            p1[p1_pos] = restriction\n            p2[p2_pos] = restriction\n    return (p1, p2)\n\ndef run():\n    n = int(input())\n    arr = [int(x) - 1 for x in input().split()]\n    ans = solve(arr)\n    if ans is False:\n        print('NO')\n    else:\n        (a, b) = ans\n        print('YES')\n        print(*(x + 1 for x in a))\n        print(*(x + 1 for x in b))\ntests_nr = int(input())\nfor _ in range(tests_nr):\n    run()", "import sys\nimport math\nimport cmath\nimport time\nfor t in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    l = [0] * n\n    sorter = True\n    for i in range(n):\n        l[a[i] - 1] += 1\n        if l[a[i] - 1] == 3:\n            sorter = False\n            print('NO')\n            break\n    if sorter:\n        sum = 0\n        for i in range(n):\n            sum += l[i]\n            if not sum <= i + 1:\n                sorter = False\n                print('NO')\n                break\n        if sorter:\n            print('YES')\n            zeros = []\n            for i in range(n):\n                if l[i] == 0:\n                    zeros.append(i)\n            pq = [0] * n\n            count = 0\n            for i in range(n):\n                if l[i] == 1:\n                    pq[i] = i + 1\n                if l[i] == 2:\n                    pq[i] = zeros[count] + 1\n                    pq[zeros[count]] = i + 1\n                    count += 1\n            p = [0] * n\n            q = [0] * n\n            for i in range(n):\n                if l[a[i] - 1] == 1:\n                    p[i] = a[i]\n                    q[i] = a[i]\n                elif l[a[i] - 1] == 2:\n                    p[i] = a[i]\n                    q[i] = pq[a[i] - 1]\n                    l[a[i] - 1] -= 2\n                else:\n                    p[i] = pq[a[i] - 1]\n                    q[i] = a[i]\n            print(*p)\n            print(*q)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (p, q) = ([0] * n, [0] * n)\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    (rp, rq) = ([], [])\n    for i in range(n, 0, -1):\n        if len(pos[i]) == 2:\n            p[pos[i][0]] = i\n            q[pos[i][1]] = i\n            rp.append(pos[i][1])\n            rq.append(pos[i][0])\n        elif len(pos[i]) == 1:\n            p[pos[i][0]] = i\n            q[pos[i][0]] = i\n        elif len(rp) > 0 and len(rq) > 0:\n            p[rp.pop()] = i\n            q[rq.pop()] = i\n        else:\n            print('NO')\n            break\n    else:\n        print('YES')\n        print(*p)\n        print(*q)", "from collections import Counter\nimport math\n\ndef solve(nums):\n    og = nums\n    p_idx = {}\n    q_idx = {}\n    nums = sorted(((v, i) for (i, v) in enumerate(nums)))\n    for (v, i) in nums:\n        if v in p_idx and v in q_idx:\n            return ('NO', [], [])\n        elif v in p_idx:\n            q_idx[v] = i\n        else:\n            p_idx[v] = i\n    fill(p_idx, og)\n    fill(q_idx, og)\n    p = sorted(p_idx, key=lambda v: p_idx[v])\n    q = sorted(q_idx, key=lambda v: q_idx[v])\n    e = [max(a, b) for (a, b) in zip(p, q)]\n    if e != og:\n        return ('NO', [], [])\n    return ('YES', p, q)\n\ndef fill(p_idx, nums):\n    p_idxs = set(p_idx.values())\n    idxs_to_fill = [i for i in range(len(nums)) if i not in p_idxs]\n    idxs_to_fill.sort(key=lambda i: nums[i])\n    num = 1\n    for i in idxs_to_fill:\n        while num in p_idx:\n            num += 1\n        p_idx[num] = i\nt = int(input())\nfor _ in range(t):\n    _ = input()\n    (res, x, y) = solve(list(map(int, input().split())))\n    if res == 'NO':\n        print(res)\n    else:\n        print(res)\n        print(' '.join(map(str, x)))\n        print(' '.join(map(str, y)))", "import sys\ninput = sys.stdin.readline\nfor tc in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [-1] * (2 * n)\n    pos = [[] for i in range(n + 1)]\n    for i in range(n):\n        pos[a[i]].append(i)\n    ext = []\n    ans = True\n    for i in range(n, 0, -1):\n        if len(pos[i]) > 2:\n            ans = False\n            break\n        if len(pos[i]) == 0:\n            if len(ext) < 2:\n                ans = False\n                break\n            b[ext.pop()] = i\n            b[ext.pop()] = i\n        elif len(pos[i]) == 1:\n            b[pos[i][0]] = i\n            b[pos[i][0] + n] = i\n        elif len(pos[i]) == 2:\n            b[pos[i][0]] = i\n            b[pos[i][1] + n] = i\n            ext.append(pos[i][0] + n)\n            ext.append(pos[i][1])\n    if ans:\n        print('YES')\n        for i in range(0, n):\n            print(b[i], end=' ')\n        print()\n        for i in range(n, 2 * n):\n            print(b[i], end=' ')\n        print()\n    else:\n        print('NO')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().strip().split()))\n    count = dict()\n    flag = 0\n    for i in range(n):\n        if a[i] not in count:\n            count[a[i]] = 1\n        else:\n            count[a[i]] += 1\n            if count[a[i]] == 3:\n                flag = 1\n                break\n    if flag == 1 or n not in count or (1 in count and count[1] == 2):\n        print('NO')\n    else:\n        not_found = []\n        for i in range(1, n + 1):\n            if i not in count:\n                not_found.append(i)\n        f = 0\n        b = [(j, i) for (i, j) in enumerate(a)]\n        b.sort()\n        p = [0] * n\n        q = [0] * n\n        start = 0\n        i = 0\n        while i < n:\n            if count[b[i][0]] == 1:\n                p[b[i][1]] = b[i][0]\n                q[b[i][1]] = b[i][0]\n                i += 1\n            else:\n                p[b[i][1]] = b[i][0]\n                q[b[i + 1][1]] = b[i][0]\n                if start == len(not_found) or not_found[start] >= b[i][0]:\n                    f = 1\n                    break\n                p[b[i + 1][1]] = not_found[start]\n                q[b[i][1]] = not_found[start]\n                start += 1\n                i += 2\n        if f == 1:\n            print('NO')\n        else:\n            print('YES')\n            print(*p)\n            print(*q)", "def solve(n, l):\n    a = [0 for _ in range(n)]\n    b = [0 for _ in range(n)]\n    d = [0 for _ in range(n + 1)]\n    for i in range(n):\n        if d[l[i]] > 1:\n            print('NO')\n            return\n        if d[l[i]] == 0:\n            a[i] = l[i]\n            d[l[i]] += 1\n        else:\n            b[i] = l[i]\n            d[l[i]] += 1\n    t = []\n    for i in range(n):\n        if a[i] == 0:\n            t.append([b[i], i])\n    t = sorted(t)[::-1]\n    s = set()\n    for i in a:\n        s.add(i)\n    x = n\n    for (p, q) in t:\n        while x in s:\n            x -= 1\n        if x > p:\n            print('NO')\n            return\n        a[q] = x\n        x -= 1\n    t = []\n    for i in range(n):\n        if b[i] == 0:\n            t.append([a[i], i])\n    t = sorted(t)[::-1]\n    s = set()\n    for i in b:\n        s.add(i)\n    x = n\n    for (p, q) in t:\n        while x in s:\n            x -= 1\n        if x > p:\n            return 'NO'\n            return\n        b[q] = x\n        x -= 1\n    print('YES')\n    print(*a)\n    print(*b)\n    return\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    solve(n, l)", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = defaultdict(list)\n    for (i, ele) in enumerate(arr):\n        d[ele].append(i)\n    np = []\n    for i in range(n):\n        if i + 1 not in d:\n            np.append(i + 1)\n    p = [0] * n\n    q = [0] * n\n    (s1, s2) = (set(), set())\n    poss = True\n    for ele in sorted(d.keys()):\n        val = d[ele]\n        ln = len(val)\n        if ln > 2:\n            poss = False\n            break\n        elif ln == 1:\n            p[val[0]] = ele\n            q[val[0]] = ele\n        else:\n            p[val[0]] = ele\n            q[val[1]] = ele\n            if np[0] > ele:\n                poss = False\n                break\n            ele = np.pop(0)\n            q[val[0]] = ele\n            p[val[1]] = ele\n    if poss:\n        print('YES')\n        for ele in p:\n            print(ele, end=' ')\n        print()\n        for ele in q:\n            print(ele, end=' ')\n        print()\n    else:\n        print('NO')", "for t in range(int(input())):\n    n = int(input())\n    a = [int(s) for s in input().split()]\n    for i in range(n):\n        a[i] = (a[i], i)\n    a.sort()\n    ps = set([i + 1 for i in range(n)])\n    qs = set([i + 1 for i in range(n)])\n    minp = 1\n    minq = 1\n    p = []\n    q = []\n    for i in range(n):\n        elem = a[i][0]\n        if i % 2 == 0:\n            if not elem in ps:\n                print('NO')\n                break\n            p.append(elem)\n            ps.remove(elem)\n            for j in range(minq, n + 1):\n                if j in qs:\n                    minq = j\n                    break\n            if minq > elem:\n                print('NO')\n                break\n            q.append(minq)\n            qs.remove(minq)\n        else:\n            if not elem in qs:\n                print('NO')\n                break\n            q.append(elem)\n            qs.remove(elem)\n            for j in range(minp, n + 1):\n                if j in ps:\n                    minp = j\n                    break\n            if minp > elem:\n                print('NO')\n                break\n            p.append(minp)\n            ps.remove(minp)\n    else:\n        p_ = [0 for i in range(n)]\n        q_ = [0 for i in range(n)]\n        for i in range(n):\n            p_[a[i][1]] = p[i]\n            q_[a[i][1]] = q[i]\n        print('YES')\n        print(' '.join([str(i) for i in p_]))\n        print(' '.join([str(i) for i in q_]))", "def ss(n, l):\n    a = [0 for _ in range(n)]\n    b = [0 for _ in range(n)]\n    d = [0 for _ in range(n + 1)]\n    for i in range(n):\n        if d[l[i]] > 1:\n            print('NO')\n            return\n        if d[l[i]] == 0:\n            a[i] = l[i]\n            d[l[i]] += 1\n        else:\n            b[i] = l[i]\n            d[l[i]] += 1\n    t = []\n    for i in range(n):\n        if a[i] == 0:\n            t.append([b[i], i])\n    t = sorted(t)[::-1]\n    s = set()\n    for i in a:\n        s.add(i)\n    x = n\n    for (p, q) in t:\n        while x in s:\n            x -= 1\n        if x > p:\n            print('NO')\n            return\n        a[q] = x\n        x -= 1\n    t = []\n    for i in range(n):\n        if b[i] == 0:\n            t.append([a[i], i])\n    t = sorted(t)[::-1]\n    s = set()\n    for i in b:\n        s.add(i)\n    x = n\n    for (p, q) in t:\n        while x in s:\n            x -= 1\n        if x > p:\n            return 'NO'\n        b[q] = x\n        x -= 1\n    print('YES')\n    print(*a)\n    print(*b)\n    return\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ss(n, l)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    count = defaultdict(list)\n    for (j, i) in enumerate(arr, start=1):\n        count[i].append(j)\n    if len(max(count.values(), key=len)) > 2 or any((x < i for (i, x) in enumerate(sorted(arr), start=1))):\n        print('NO')\n    else:\n        first = [-1 for _ in range(n + 1)]\n        second = list(first)\n        (ifirst, isecond) = (list(first), list(first))\n        for i in range(n, 0, -1):\n            for j in count[i]:\n                if ifirst[i] == -1:\n                    ifirst[i] = j\n                    first[j] = i\n                elif isecond[i] == -1:\n                    isecond[i] = j\n                    second[j] = i\n        x = int(n)\n        vf = int(n)\n        vs = int(n)\n        while x >= 1:\n            for i in count[x]:\n                while ifirst[vf] != -1:\n                    vf -= 1\n                while isecond[vs] != -1:\n                    vs -= 1\n                if first[i] == -1 and vf > 0:\n                    ifirst[vf] = i\n                    first[i] = vf\n                if second[i] == -1 and vs > 0:\n                    isecond[vs] = i\n                    second[i] = vs\n            x -= 1\n        ans = 'YES'\n        for i in range(1, n + 1):\n            if max(first[i], second[i]) != arr[i - 1]:\n                ans = 'NO'\n        print(ans)\n        if ans == 'YES':\n            print(*first[1:])\n            print(*second[1:])", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [0] * n\n    for i in range(n):\n        a[i] -= 1\n        c[a[i]] += 1\n    if any((c > 2 for c in c)):\n        print('NO')\n        return\n    v = []\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        v += [i] * (2 - c[i])\n        for j in range(c[i]):\n            if not v:\n                print('NO')\n                return\n            g[i] += (v[-1],)\n            g[v[-1]] += (i,)\n            v.pop()\n    pairs = [[] for _ in range(n)]\n    v = [0] * n\n    for i in range(n):\n        if not v[i]:\n            (x, y) = (i, g[i][0])\n            while not v[x]:\n                v[x] = 1\n                pairs[max(x, y)] += ((x + 1, y + 1),)\n                (x, y) = (y, x ^ g[y][0] ^ g[y][1])\n    print('YES')\n    p = [0] * n\n    q = [0] * n\n    for i in range(n):\n        (p[i], q[i]) = pairs[a[i]].pop()\n    print(*p)\n    print(*q)\nfor _ in range(int(input())):\n    solve()", "import heapq\nimport sys\ninput = sys.stdin.readline\n\ndef readInt():\n    return int(input())\n\ndef readArr():\n    return list(map(int, input().split(' ')))\n\ndef makeArr(n):\n    return [0] * n\n\ndef printArr(arr):\n    for x in arr:\n        print(x, end=' ')\n    print()\nT = int(input())\nfor i in range(T):\n    n = readInt()\n    arr = readArr()\n    p = makeArr(n)\n    q = makeArr(n)\n    fail = False\n    vis = {}\n    visP = {}\n    visQ = {}\n    blankP = []\n    blankQ = []\n    for (i, x) in enumerate(arr):\n        if vis.get(x):\n            q[i] = x\n            visQ[x] = 1\n            heapq.heappush(blankP, (-q[i], i))\n        else:\n            p[i] = x\n            visP[x] = 1\n            heapq.heappush(blankQ, (-p[i], i))\n        vis[x] = True\n    for i in range(n, 0, -1):\n        if not visP.get(i):\n            if len(blankP) == 0:\n                fail = True\n                break\n            p[heapq.heappop(blankP)[1]] = i\n    for i in range(n, 0, -1):\n        if not visQ.get(i):\n            if len(blankQ) == 0:\n                fail = True\n                break\n            q[heapq.heappop(blankQ)[1]] = i\n    for (i, x) in enumerate(arr):\n        if max(p[i], q[i]) != x:\n            fail = True\n    if fail:\n        print('NO')\n    else:\n        print('YES')\n        printArr(p)\n        printArr(q)", "import math\nimport collections\n\ndef func(n, a):\n    index = {}\n    d = collections.defaultdict(int)\n    for i in range(n):\n        if index.get(a[i]):\n            index[a[i]].append(i)\n        else:\n            index[a[i]] = [i]\n        d[a[i]] += 1\n    p = [0 for i in range(n)]\n    q = [0 for i in range(n)]\n    eisp = []\n    eisq = []\n    for m in range(n, 0, -1):\n        if d[m] == 2:\n            p[index[m][0]] = m\n            q[index[m][1]] = m\n            eisp.append(index[m][1])\n            eisq.append(index[m][0])\n        if d[m] == 1:\n            p[index[m][0]] = m\n            eisq.append(index[m][0])\n            q[eisq[0]] = m\n            eisq.pop(0)\n        if d[m] == 0:\n            if len(eisp) == 0 or len(eisq) == 0:\n                return -1\n            p[eisp[0]] = m\n            eisp.pop(0)\n            q[eisq[0]] = m\n            eisq.pop(0)\n    if 0 in p or 0 in q:\n        return -1\n    print('YES')\n    print(*p)\n    print(*q)\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if func(n, a) == -1:\n        print('NO')", "out = []\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    f = []\n    for i in range(n + 1):\n        f.append([])\n    ans = 'YES'\n    for i in range(n):\n        f[a[i]].append(i)\n        if len(f[a[i]]) > 2:\n            ans = 'NO'\n    if len(f[-1]) == 0:\n        ans = 'NO'\n    if ans == 'NO':\n        out.append(['NO'])\n        continue\n    free = []\n    p = []\n    for i in range(2):\n        p.append([0] * n)\n    for i in range(n, 0, -1):\n        if len(f[i]) == 2:\n            k = f[i]\n            p[0][k[0]] = i\n            p[1][k[1]] = i\n            free.append([0, k[1]])\n            free.append([1, k[0]])\n        elif len(f[i]) == 1:\n            k = f[i][0]\n            p[0][k] = i\n            p[1][k] = i\n        elif free:\n            for j in range(2):\n                k = free.pop(0)\n                p[k[0]][k[1]] = i\n        else:\n            ans = 'NO'\n    out.append([ans])\n    if ans == 'YES':\n        out.append(p[0])\n        out.append(p[1])\nfor i in out:\n    print(*i)"]