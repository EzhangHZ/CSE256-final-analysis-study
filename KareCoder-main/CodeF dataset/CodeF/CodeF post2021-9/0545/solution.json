["import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    arr = [0] + list(map(int, input().split()))\n    graph = [[] for _ in range(n + 1)]\n    ind = [0] * (n + 1)\n    val = [0] * (n + 1)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        ind[u] += 1\n        ind[v] += 1\n    qu = deque()\n    V = 0\n    for i in range(1, n + 1):\n        V ^= arr[i]\n        if ind[i] == 1:\n            qu.append(i)\n    if V == 0:\n        return 'YES'\n    if k < 3:\n        return 'NO'\n    nums = 0\n    while qu:\n        curr = qu.popleft()\n        val[curr] ^= arr[curr]\n        if val[curr] == V:\n            nums += 1\n        for nei in graph[curr]:\n            ind[nei] -= 1\n            if val[curr] != V:\n                val[nei] ^= val[curr]\n            if ind[nei] == 1:\n                qu.append(nei)\n    return 'YES' if nums >= 2 else 'NO'\nfor _ in range(int(input())):\n    print(solve())", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    (*a,) = map(int, input().split())\n    X = 0\n    for i in a:\n        X ^= i\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    if X == 0:\n        print('YES')\n        return\n    elif k == 2:\n        print('NO')\n        return\n    p = [None] * n\n    q = [0]\n    p[0] = -1\n    i = 0\n    while i < len(q):\n        x = q[i]\n        i += 1\n        for v in g[x]:\n            if p[v] is None:\n                p[v] = x\n                q.append(v)\n    d = [None] * n\n    dx = [None] * n\n    for i in range(len(q) - 1, -1, -1):\n        x = q[i]\n        P = p[x]\n        z = a[x]\n        for v in g[x]:\n            if v != P:\n                z ^= dx[v]\n        c = 0\n        for v in g[x]:\n            if v != P:\n                if d[v]:\n                    c += 1\n                    if z == 0:\n                        print('YES')\n                        return\n        if c > 1:\n            print('YES')\n            return\n        dx[x] = z\n        d[x] = z == X or c > 0\n    print('NO')\nfor i in range(int(input())):\n    solve()", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque, defaultdict\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000000 + 7\nmod2 = 998244353\nsys.setrecursionlimit(300000)\nfor _ in range(I()):\n    (n, k) = M()\n    a = L()\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = M()\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    axor = 0\n    for i in a:\n        axor ^= i\n    if axor == 0:\n        print('YES')\n        continue\n    if k == 2:\n        print('NO')\n        continue\n\n    def bfs():\n        q = deque()\n        q.append(0)\n        visited = [0] * n\n        visited[0] = 1\n        parent = [-1] * n\n        bfstree = []\n        while q:\n            root = q.popleft()\n            bfstree.append(root)\n            for child in adj[root]:\n                if not visited[child]:\n                    q.append(child)\n                    visited[child] = 1\n                    parent[child] = root\n        return (bfstree, parent)\n    cnt = 0\n    (bfstree, parent) = bfs()\n    while bfstree:\n        cur = bfstree.pop()\n        if a[cur] == axor:\n            cnt += 1\n        else:\n            a[parent[cur]] ^= a[cur]\n    if cnt >= 2:\n        print('YES')\n        continue\n    print('NO')", "def solve():\n    (n, k) = map(int, input().split())\n    (*a,) = map(int, input().split())\n    X = 0\n    for i in a:\n        X ^= i\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    if X == 0:\n        print('YES')\n        return\n    elif k == 2:\n        print('NO')\n        return\n    p = [None] * n\n    q = [0]\n    p[0] = -1\n    i = 0\n    while i < len(q):\n        x = q[i]\n        i += 1\n        for v in g[x]:\n            if p[v] is None:\n                p[v] = x\n                q.append(v)\n    d = [None] * n\n    dx = [None] * n\n    for i in range(len(q) - 1, -1, -1):\n        x = q[i]\n        P = p[x]\n        z = a[x]\n        for v in g[x]:\n            if v != P:\n                z ^= dx[v]\n        c = 0\n        for v in g[x]:\n            if v != P:\n                if d[v]:\n                    c += 1\n                    if z == 0:\n                        print('YES')\n                        return\n        if c > 1:\n            print('YES')\n            return\n        dx[x] = z\n        d[x] = z == X or c > 0\n    print('NO')\nfor i in range(int(input())):\n    solve()", "def solve():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    X = 0\n    g = [[] for i in range(n)]\n    for i in a:\n        X ^= i\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    if X == 0:\n        print('YES')\n        return\n    elif k == 2:\n        print('NO')\n        return\n    p = [None] * n\n    q = [0]\n    p[0] = -1\n    i = 0\n    while i < len(q):\n        x = q[i]\n        i += 1\n        for v in g[x]:\n            if p[v] is None:\n                p[v] = x\n                q.append(v)\n    d = [None] * n\n    dx = [None] * n\n    for i in reversed(range(len(q))):\n        x = q[i]\n        P = p[x]\n        z = a[x]\n        c = 0\n        for v in g[x]:\n            if v != P:\n                z ^= dx[v]\n        for v in g[x]:\n            if v != P:\n                if d[v]:\n                    c += 1\n                    if z == 0:\n                        print('YES')\n                        return\n        if c > 1:\n            print('YES')\n            return\n        dx[x] = z\n        d[x] = z == X or c > 0\n    print('NO')\nfor i in range(int(input())):\n    solve()"]