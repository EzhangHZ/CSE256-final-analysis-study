["n = int(input())\np = [-1] + [x - 1 for x in list(map(int, input().split()))]\n(h, dp) = ([1] * n, [0] * n)\nfor i in range(n - 1, -1, -1):\n    dp[i] = max(dp[i], h[i])\n    if i:\n        dp[p[i]] += dp[i]\n        h[p[i]] = max(h[p[i]], h[i] + 1)\nprint(dp[0])", "n = int(input())\na = [-1] + [int(o) - 1 for o in input().split()]\nf = [0] * n\ndp = [0] * n\nfor i in range(n - 1, 0, -1):\n    f[a[i]] = max(f[i] + 1, f[a[i]])\nfor i in range(n - 1, 0, -1):\n    dp[i] = max(dp[i], f[i] + 1)\n    dp[a[i]] += dp[i]\nprint(max(dp[0], f[0] + 1))", "n = int(input())\np = [-1] + [x - 1 for x in list(map(int, input().split()))]\n(h, dp) = ([1] * n, [0] * n)\nfor i in range(n - 1, -1, -1):\n    dp[i] = max(dp[i], h[i])\n    if i:\n        dp[p[i]] += dp[i]\n        h[p[i]] = max(h[p[i]], h[i] + 1)\nprint(dp[0])", "import sys, threading\nfrom collections import defaultdict\n\ndef main():\n\n    def dfs(node):\n        d = 1\n        childs_sum = 0\n        for adj in tree[node]:\n            (child_depth, childs_val) = dfs(adj)\n            d = max(d, 1 + child_depth)\n            childs_sum += childs_val\n        return (d, max(childs_sum, d))\n    n = int(input())\n    pars = list(map(int, input().split()))\n    tree = defaultdict(list)\n    for i in range(n - 1):\n        v = pars[i]\n        tree[v].append(i + 2)\n    res = dfs(1)\n    print(max(*res))\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "from collections import defaultdict\nimport threading\nimport sys\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = ri()\n    p = rl()\n    g = defaultdict(list)\n    i = 2\n    for par in p:\n        g[par].append(i)\n        i += 1\n\n    def rec(cn):\n        l = 1\n        cs = 0\n        for nn in g[cn]:\n            (cl, ccs) = rec(nn)\n            l = max(l, cl + 1)\n            cs += ccs\n        return (l, max(cs, l))\n    res = rec(1)\n    print(max(*res))\n    pass\nthreading.Thread(target=main).start()", "import sys\n\ndef read():\n    return [int(x) for x in sys.stdin.readline().split(' ')]\n[n] = read()\nP = read()\ndeg = n * [0]\nfor i in range(len(P)):\n    P[i] -= 1\n    deg[P[i]] += 1\nP = [0] + P\nQ = []\nfor i in range(n):\n    if deg[i] == 0:\n        Q.append(i)\nM = n * [0]\nS = n * [0]\nwhile len(Q) > 0:\n    i = Q.pop()\n    M[i] += 1\n    if i == 0:\n        continue\n    S[P[i]] += max(M[i], S[i])\n    M[P[i]] = max(M[P[i]], M[i])\n    deg[P[i]] -= 1\n    if deg[P[i]] == 0:\n        Q.append(P[i])\nprint(max(M[0], S[0]))"]