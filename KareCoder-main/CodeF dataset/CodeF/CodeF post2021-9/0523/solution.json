["(n, d) = map(int, input().split())\np = [-1] * (n + 1)\nc = 0\n\ndef find(x):\n    if p[x] < 0:\n        return x\n    return find(p[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        c += 1\n    else:\n        p[find(x)] += p[find(y)]\n        p[find(y)] = find(x)\n    a = sorted(p)\n    ans = 0\n    for j in range(c + 1):\n        ans += a[j]\n    print(-(1 + ans))", "(n, d) = map(int, input().split())\np = [-1] * (n + 1)\nc = 0\n\ndef find(x):\n    if p[x] < 0:\n        return x\n    return find(p[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        c += 1\n    else:\n        p[find(x)] += p[find(y)]\n        p[find(y)] = find(x)\n    a = sorted(p)\n    ans = 0\n    for j in range(c + 1):\n        ans += a[j]\n    print(-(1 + ans))", "(n, d) = map(int, input().split())\np = [-1] * (n + 1)\nc = 0\n\ndef find(x):\n    if p[x] < 0:\n        return x\n    return find(p[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        c += 1\n    else:\n        p[find(x)] += p[find(y)]\n        p[find(y)] = find(x)\n    ans = 0\n    a = sorted(p)\n    for j in range(c + 1):\n        if a[j] < 0:\n            ans += a[j]\n    print(-1 - ans)", "(n, d) = map(int, input().split())\np = [-1] * (n + 1)\nc = 0\n\ndef find(x):\n    if p[x] < 0:\n        return x\n    return find(p[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        c += 1\n    else:\n        p[find(x)] += p[find(y)]\n        p[find(y)] = find(x)\n    ans = 0\n    a = sorted(p)\n    for j in range(c + 1):\n        if a[j] < 0:\n            ans += a[j]\n    print(-1 - ans)", "(n, d) = map(int, input().split())\npessoas = [-1] * (n + 1)\ncount = 0\n\ndef find(x):\n    if pessoas[x] < 0:\n        return x\n    else:\n        return find(pessoas[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        count += 1\n    else:\n        pessoas[find(x)] += pessoas[find(y)]\n        pessoas[find(y)] = find(x)\n    resposta = 0\n    lista = sorted(pessoas)\n    for j in range(count + 1):\n        if lista[j] < 0:\n            resposta += lista[j]\n    print(-1 - resposta)", "(n, d) = map(int, input().split())\npessoas = [-1] * (n + 1)\ncount = 0\n\ndef find(x):\n    if pessoas[x] < 0:\n        return x\n    else:\n        return find(pessoas[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        count += 1\n    else:\n        pessoas[find(x)] += pessoas[find(y)]\n        pessoas[find(y)] = find(x)\n    resposta = 0\n    lista = sorted(pessoas)\n    for j in range(count + 1):\n        if lista[j] < 0:\n            resposta += lista[j]\n    print(-1 - resposta)", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000000 + 7\nmod2 = 998244353\n(n, d) = M()\np = [-1] * (n + 1)\nc = 0\n\ndef find(x):\n    if p[x] < 0:\n        return x\n    return find(p[x])\nfor i in range(d):\n    (x, y) = M()\n    if find(x) == find(y):\n        c += 1\n    else:\n        p[find(x)] += p[find(y)]\n        p[find(y)] = find(x)\n    ans = 0\n    a = sorted(p)\n    for j in range(c + 1):\n        if a[j] < 0:\n            ans += a[j]\n    print(-1 - ans)", "(n, d) = map(int, input().split())\np = [-1] * (n + 1)\nc = 0\n\ndef find(x):\n    if p[x] < 0:\n        return x\n    return find(p[x])\nfor i in range(d):\n    (x, y) = map(int, input().split())\n    if find(x) == find(y):\n        c += 1\n    else:\n        p[find(x)] += p[find(y)]\n        p[find(y)] = find(x)\n    ans = 0\n    a = sorted(p)\n    for j in range(c + 1):\n        if a[j] < 0:\n            ans += a[j]\n    print(-1 - ans)", "def dsu(par, i):\n    if par[i] == i:\n        return i\n    return dsu(par, par[i])\n\ndef solve():\n    (n, d) = map(int, input().split())\n    par = [0] * (n + 1)\n    ans = [1] * (n + 1)\n    ct = 0\n    for i in range(1, n + 1):\n        par[i] = i\n    for i in range(d):\n        (x, y) = map(int, input().split())\n        p1 = dsu(par, x)\n        p2 = dsu(par, y)\n        if p1 != p2:\n            par[p2] = p1\n            ans[p1] += ans[p2]\n        else:\n            ct += 1\n        b = []\n        for j in range(1, n + 1):\n            if par[j] == j:\n                b.append(ans[j])\n        b.sort()\n        b.reverse()\n        s = 0\n        for j in range(min(ct + 1, len(b))):\n            s += b[j]\n        print(s - 1)\n    return 0\nt = 1\nwhile t > 0:\n    t -= 1\n    solve()", "import sys\nimport math\nfrom fractions import Fraction\nfrom decimal import *\ninput = sys.stdin.readline\ninp = input().strip()\narr = [int(x) for x in inp.split(' ')]\nn = arr[0]\nt = arr[1]\npar = [0] + [i + 1 for i in range(n)]\nsizes = [0] + [1 for i in range(n)]\nextra = 0\nwhile t > 0:\n    inp = input().strip()\n    arr = [int(x) for x in inp.split(' ')]\n    x = arr[0]\n    y = arr[1]\n    px = x\n    while par[px] != px:\n        px = par[px]\n    py = y\n    while par[py] != py:\n        py = par[py]\n    if px == py:\n        extra += 1\n    else:\n        par[py] = px\n        sizes[px] += sizes[py]\n        sizes[py] = -1\n    cursizes = []\n    for s in sizes[1:]:\n        if s != -1:\n            cursizes.append(s)\n    cursizes.sort(key=lambda x: -x)\n    i = 0\n    for j in range(extra):\n        cursizes[i + 1] += cursizes[i]\n        i += 1\n        if i == len(cursizes) - 1:\n            break\n    print(cursizes[i] - 1)\n    t -= 1", "import sys\nimport math\nfrom fractions import Fraction\nfrom decimal import *\ninput = sys.stdin.readline\ninp = input().strip()\narr = [int(x) for x in inp.split(' ')]\nn = arr[0]\nt = arr[1]\npar = [0] + [i + 1 for i in range(n)]\nsizes = [0] + [1 for i in range(n)]\nextra = 0\nwhile t > 0:\n    inp = input().strip()\n    arr = [int(x) for x in inp.split(' ')]\n    x = arr[0]\n    y = arr[1]\n    px = x\n    while par[px] != px:\n        px = par[px]\n    py = y\n    while par[py] != py:\n        py = par[py]\n    if px == py:\n        extra += 1\n    else:\n        par[py] = px\n        sizes[px] += sizes[py]\n        sizes[py] = -1\n    cursizes = []\n    for s in sizes[1:]:\n        if s != -1:\n            cursizes.append(s)\n    cursizes.sort(key=lambda x: -x)\n    i = 0\n    for j in range(extra):\n        cursizes[i + 1] += cursizes[i]\n        i += 1\n        if i == len(cursizes) - 1:\n            break\n    print(cursizes[i] - 1)\n    t -= 1", "from collections import defaultdict\nn = 10 ** 3 + 10\nparent = [i for i in range(n)]\nsize = [1 for i in range(n)]\n\ndef find(root):\n    a = root\n    while parent[a] != a:\n        a = parent[a]\n    while root != a:\n        nextnode = parent[root]\n        parent[root] = a\n        root = nextnode\n    return a\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if a != b:\n        if size[a] < size[b]:\n            (a, b) = (b, a)\n        parent[b] = a\n        size[a] += size[b]\n        return False\n    else:\n        return True\nc = 0\n(l, d) = map(int, input().split())\nfor j in range(d):\n    (a, b) = map(int, input().split())\n    cans = union(a, b)\n    if cans:\n        c += 1\n    ans = -1\n    allp = set()\n    grps = []\n    for k in range(1, l + 1):\n        pr = find(k)\n        if pr not in allp:\n            allp.add(pr)\n            grps.append(size[pr])\n    grps.sort(reverse=True)\n    for k in range(min(c + 1, len(grps))):\n        ans += grps[k]\n    print(ans)", "def dfs(people):\n    count = 1\n    people.color = 1\n    for fr in people.friends:\n        if fr.color != 1:\n            count += dfs(fr)\n    return count\n\ndef find(x, y):\n    x.color = 1\n    if x.num == y.num:\n        return True\n    for fr in x.friends:\n        if fr.color != 1 and find(fr, y):\n            return True\n    return False\n\nclass People:\n\n    def __init__(self, num):\n        self.num = num\n        self.friends = set()\n        self.color = 0\n\n    def add(self, friend):\n        self.friends.add(friend)\n        friend.friends.add(self)\n(n, d) = map(int, input().split())\npeoples = list()\nfor i in range(n):\n    peoples.append(People(i))\nmore = 0\nfor i in range(d):\n    (a, b) = map(int, input().split())\n    if find(peoples[a - 1], peoples[b - 1]):\n        more += 1\n    else:\n        peoples[a - 1].add(peoples[b - 1])\n    for pl in peoples:\n        pl.color = 0\n    meets = list()\n    for people in peoples:\n        meets.append(dfs(people))\n    meets.sort()\n    print(sum(meets[len(meets) - more - 1:len(meets)]) - 1)\n    for pl in peoples:\n        pl.color = 0", "import sys\n\ndef solve():\n    inp = sys.stdin.readline\n    (n, d) = map(int, inp().split())\n\n    def getp(x):\n        if P[x] == x:\n            return x\n        P[x] = getp(P[x])\n        return P[x]\n    e = [tuple(map(int, inp().split())) for i in range(d)]\n    for i in range(1, len(e) + 1):\n        P = list(range(n + 1))\n        S = [1] * (n + 1)\n        can = 0\n        for j in range(i):\n            a = getp(e[j][0])\n            b = getp(e[j][1])\n            if a != b:\n                if S[a] < S[b]:\n                    (a, b) = (b, a)\n                P[b] = a\n                S[a] += S[b]\n            else:\n                can += 1\n        W = [True] * (n + 1)\n        q = []\n        for j in range(1, n + 1):\n            j = getp(j)\n            if W[j]:\n                W[j] = False\n                q.append(S[j])\n        ans = 0\n        q.sort(reverse=True)\n        for j in range(can + 1):\n            ans += q[j]\n        print(max(ans - 1, 1))\n\ndef main():\n    solve()\nmain()"]