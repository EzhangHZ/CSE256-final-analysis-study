["import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_left\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nm = int(input())\ns = sum(a)\nans = [None for _ in range(m)]\nfor q in range(m):\n    (x, y) = map(int, input().split())\n\n    def f(v):\n        return max(0, x - a[v]) + max(0, y - (s - a[v])) if 0 <= v and v < n else 1 << 60\n    p = bisect_left(a, x)\n    ans[q] = min(f(p - 1), f(p))\nsys.stdout.write('\\n'.join(map(str, ans)) + '\\n')", "def bin_search(lst, n):\n    lo = 0\n    hi = len(lst) - 1\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if lst[mid] >= n:\n            hi = mid\n        else:\n            lo = mid + 1\n    if lst[lo] >= n:\n        return lo\n    else:\n        return -1\nfrom bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = [*map(int, input().split())]\na.sort()\nsz = len(a)\nsm = sum(a)\nm = int(input())\ndragon = []\nans = [None for _ in range(m)]\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    bs = bisect_left(a, x)\n    if bs != sz:\n        coins = 0\n        b1 = bs\n        b2 = bs - 1\n        rem = sm - a[b1]\n        coins += max(y - rem, 0)\n        coin = 1 << 60\n        if b2 >= 0:\n            coin = x - a[b2]\n            rem = sm - a[b2]\n            coin += max(y - rem, 0)\n        ans[i] = min(coin, coins)\n    else:\n        total_req = x - a[sz - 1]\n        total_req += max(0, y - (sm - a[sz - 1]))\n        ans[i] = total_req\nsys.stdout.write('\\n'.join(map(str, ans)) + '\\n')", "import sys\nimport bisect\ninput = sys.stdin.readline\nn = int(input())\narr = sorted(list(map(int, input().split())))\nq = int(input())\nsumm = sum(arr)\nfor _ in range(q):\n    (i, j) = map(int, input().split())\n    x = bisect.bisect_right(arr, i)\n    if x == n:\n        sys.stdout.write(str(i - arr[-1] + max(0, j - summ + arr[-1])) + '\\n')\n    elif x == 0:\n        sys.stdout.write(str(max(0, j - summ + arr[0])) + '\\n')\n    else:\n        sys.stdout.write(str(min(i - arr[x - 1] + max(0, j - summ + arr[x - 1]), max(0, j - summ + arr[x]))) + '\\n')", "import sys\nimport bisect\ninput = sys.stdin.readline\nn = int(input())\na = sorted(list(map(int, input().split())))\nm = int(input())\ntotal = sum(a)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    var = bisect.bisect_right(a, x)\n    if var == n:\n        sys.stdout.write(str(x - a[-1] + max(0, y - total + a[-1])) + '\\n')\n    elif var == 0:\n        sys.stdout.write(str(max(0, y - total + a[0])) + '\\n')\n    else:\n        sys.stdout.write(str(min(x - a[var - 1] + max(0, y - total + a[var - 1]), max(0, y - total + a[var]))) + '\\n')", "import sys\ninput = sys.stdin.readline\nimport bisect\nt = 1\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = sum(a)\n    a.sort()\n    m = int(input())\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        j = bisect.bisect_right(a, x)\n        if j == n:\n            ans = x - a[-1] + max(0, y + a[-1] - s)\n        elif j == 0:\n            ans = max(0, y + a[0] - s)\n        else:\n            ans = min(max(0, y + a[j] - s), x - a[j - 1] + max(0, y + a[j - 1] - s))\n        sys.stdout.write(str(ans) + '\\n')", "import sys\nimport bisect as bi\n\ndef yes():\n    print('YES')\n\ndef no():\n    print('NO')\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef In():\n    return map(int, sys.stdin.readline().split())\n\ndef Sn():\n    return sys.stdin.readline().strip()\n\ndef dict(a):\n    d = {}\n    for x in a:\n        if d.get(x, -1) != -1:\n            d[x] += 1\n        else:\n            d[x] = 1\n    return d\n\ndef find_gt(a, x):\n    i = bi.bisect_left(a, x)\n    if i != len(a):\n        return i\n    else:\n        return -1\n\ndef main():\n    try:\n        n = I()\n        l = list(In())\n        l.sort()\n        ans = []\n        total = sum(l)\n        for i in range(I()):\n            (a, b) = In()\n            pos = find_gt(l, a)\n            ans1 = max(0, a - l[pos]) + max(0, b - total + l[pos])\n            ans2 = float('inf')\n            if pos - 1 >= 0:\n                ans2 = max(0, a - l[pos - 1]) + max(0, b - total + l[pos - 1])\n            ans.append(str(min(ans1, ans2)))\n        print('\\n'.join(ans))\n    except:\n        pass\nM = 998244353\nP = 1000000007\nfor _ in range(1):\n    main()", "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nsm = sum(a)\nm = int(input())\nb = []\nans = [0] * m\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    idx = bisect.bisect_left(a, x)\n    if idx >= n:\n        idx -= 1\n    res = max(0, x - a[idx])\n    rem = sm - a[idx]\n    res += max(0, y - rem)\n    if idx > 0:\n        idx -= 1\n        cur = max(0, x - a[idx])\n        rem = sm - a[idx]\n        cur += max(0, y - rem)\n        res = min(res, cur)\n    ans[i] = str(res)\nprint('\\n'.join(ans))", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    from bisect import bisect_left\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    s = sum(a)\n    m = int(input())\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        b = bisect_left(a, x)\n        ans1 = 10 ** 20\n        if b < n:\n            ans1 = y - (s - a[b])\n            if ans1 < 0:\n                ans1 = 0\n        ans2 = 10 ** 20\n        if 0 < b:\n            ans2 = y - (s - a[b - 1])\n            if ans2 < 0:\n                ans2 = 0\n            ans2 += x - a[b - 1]\n        print(min(ans1, ans2))\nmain()", "def bin_search(lst, n):\n    lo = 0\n    hi = len(lst) - 1\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if lst[mid] >= n:\n            hi = mid\n        else:\n            lo = mid + 1\n    if lst[lo] >= n:\n        return lo\n    else:\n        return -1\nfrom bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = [*map(int, input().split())]\na.sort()\nsz = len(a)\nsm = sum(a)\nm = int(input())\ndragon = []\nans = [None for _ in range(m)]\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    bs = bisect_left(a, x)\n    if bs != sz:\n        coins = 0\n        b1 = bs\n        b2 = bs - 1\n        rem = sm - a[b1]\n        coins += max(y - rem, 0)\n        coin = 1 << 60\n        if b2 >= 0:\n            coin = x - a[b2]\n            rem = sm - a[b2]\n            coin += max(y - rem, 0)\n        ans[i] = min(coin, coins)\n    else:\n        total_req = x - a[sz - 1]\n        total_req += max(0, y - (sm - a[sz - 1]))\n        ans[i] = total_req\nsys.stdout.write('\\n'.join(map(str, ans)) + '\\n')", "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int(input())\nw = sorted(map(int, input().split()))\nss = sum(w)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    c1 = bisect.bisect_right(w, a)\n    if c1 == 0 or w[c1 - 1] == a:\n        s = ss\n        s -= a if w[c1 - 1] == a else w[0]\n        print(b - s if b > s else 0)\n    elif c1 == n:\n        s = ss\n        s -= w[-1]\n        c = a - w[-1]\n        print(b - s + c if b > s else c)\n    else:\n        s1 = ss - w[c1]\n        s2 = ss - w[c1 - 1]\n        c = a - w[c1 - 1]\n        print(min(b - s1 if b > s1 else 0, b - s2 + c if b > s2 else c))", "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ns = sum(a)\nm = int(input())\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    j = bisect.bisect_right(a, x)\n    if j == n:\n        ans = x - a[j - 1] + max(0, y - (s - a[j - 1]))\n    elif j == 0:\n        ans = max(0, y - (s - a[0]))\n    else:\n        ans = min(x - a[j - 1] + max(0, y - (s - a[j - 1])), max(0, y - (s - a[j])))\n    sys.stdout.write(str(ans) + '\\n')", "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ns = sum(a)\nm = int(input())\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    j = bisect.bisect_right(a, x)\n    if j == n:\n        ans = x - a[j - 1] + max(0, y - (s - a[j - 1]))\n    elif j == 0:\n        ans = max(0, y - (s - a[0]))\n    else:\n        ans = min(x - a[j - 1] + max(0, y - (s - a[j - 1])), max(0, y - (s - a[j])))\n    sys.stdout.write(str(ans) + '\\n')", "import sys\nimport bisect\nimport collections\nimport copy\nimport itertools\nimport math\nimport functools\nimport operator\nfrom heapq import heappop, heappush\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef I():\n    return input().rstrip()\n\ndef IS():\n    return input().split()\n\ndef II():\n    return int(input())\n\ndef IIS():\n    return map(int, input().split())\n\ndef LIIS():\n    return list(map(int, input().split()))\n\ndef main():\n    num_hero = II()\n    pow_hero = LIIS()\n    pow_hero.sort()\n    s = sum(pow_hero)\n    num_dra = II()\n    for _ in [0] * num_dra:\n        (a, b) = IIS()\n        i = bisect.bisect_left(pow_hero, a)\n        (out1, out2) = (None, None)\n        if i > 0:\n            atc = pow_hero[i - 1]\n            out1 = a - atc\n            out1 += max(b - (s - atc), 0)\n        if i < num_hero:\n            atc = pow_hero[i]\n            out2 = max(b - (s - atc), 0)\n        if out1 is None:\n            out = out2\n        elif out2 is None:\n            out = out1\n        else:\n            out = min(out1, out2)\n        print(out)\nmain()", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ns = sum(a)\nt = int(input())\nfor i in range(t):\n    (x, y) = map(int, input().split())\n    b = bisect_left(a, x)\n    if b == 0:\n        c = max(y - (s - a[b]), 0)\n    elif b == len(a):\n        c = max(y - (s - a[b - 1]), 0) + max(x - a[b - 1], 0)\n    else:\n        c = min(max(y - (s - a[b - 1]), 0) + max(x - a[b - 1], 0), max(y - (s - a[b]), 0))\n    sys.stdout.write(str(c) + '\\n')", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nsum_a = sum(a)\nm = int(input())\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    idx = bisect_left(a, x)\n    if idx == 0:\n        res = max(y - (sum_a - a[idx]), 0)\n    elif idx == len(a):\n        res = max(y - (sum_a - a[idx - 1]), 0) + max(x - a[idx - 1], 0)\n    else:\n        res = min(max(y - (sum_a - a[idx - 1]), 0) + max(x - a[idx - 1], 0), max(y - (sum_a - a[idx]), 0))\n    sys.stdout.write(str(res) + '\\n')", "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int(input())\nw = sorted(map(int, input().split()))\nss = sum(w)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    c1 = bisect.bisect_right(w, a)\n    if c1 == 0 or w[c1 - 1] == a:\n        s = ss\n        s -= a if w[c1 - 1] == a else w[0]\n        print(b - s if b > s else 0)\n    elif c1 == n:\n        s = ss\n        s -= w[-1]\n        c = a - w[-1]\n        print(b - s + c if b > s else c)\n    else:\n        s1 = ss - w[c1]\n        s2 = ss - w[c1 - 1]\n        c = a - w[c1 - 1]\n        print(min(b - s1 if b > s1 else 0, b - s2 + c if b > s2 else c))", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect\nn = int(input())\na = sorted([*map(int, input().split())])\nss = sum(a)\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    b = bisect(a, x) - 1\n    ff = a[b]\n    if b == -1:\n        print(max(y - (ss - a[0]), 0))\n    elif ff == x:\n        print(max(y - (ss - x), 0))\n    elif b + 1 < n:\n        fff = a[b + 1]\n        if y - (ss - fff) <= 0:\n            print(0)\n        else:\n            print(min(y - (ss - fff), max(y - (ss - ff), 0) + (x - ff)))\n    else:\n        print(max(y - (ss - ff), 0) + (x - ff))", "import sys\nimport bisect\ninput = sys.stdin.readline\nn = int(input())\na = sorted(map(int, input().split()))\ns = sum(a)\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    p = bisect.bisect_left(a, x) - 1\n    ans1 = 2 * 10 ** 18\n    if p != -1:\n        ans1 = x - a[p] + max(y - s + a[p], 0)\n    ans2 = 2 * 10 ** 18\n    if p != n - 1:\n        ans2 = max(y - s + a[p + 1], 0)\n    print(min(ans1, ans2))", "import bisect\nn = int(input())\nA = [int(x) for x in input().split()]\nA.sort()\ns = sum(A)\nR = []\nfor i in range(int(input())):\n    ans = 10 ** 20\n    (x, y) = map(int, input().split())\n    p = bisect.bisect_left(A, x)\n    if p == 0:\n        ans = min(ans, max(0, y + A[p] - s))\n    elif p == len(A):\n        ans = min(ans, x - A[p - 1] + max(0, y + A[p - 1] - s))\n    else:\n        ans = min(ans, max(0, y + A[p] - s))\n        ans = min(ans, x - A[p - 1] + max(0, y + A[p - 1] - s))\n    R.append(str(ans))\nprint('\\n'.join(R))", "from bisect import bisect_right\nimport sys\n\ndef solve():\n    input = sys.stdin.readline\n    n = int(input())\n    heros = list(map(int, input().strip().split(' ')))\n    m = int(input())\n    power_dragon = []\n    heros.sort()\n    power_heros = 0\n    for i in range(n):\n        power_heros += int(heros[i])\n    for _ in range(m):\n        power_dragon = input().split()\n        power_dragon_defense = int(power_dragon[0])\n        power_dragon_attack = int(power_dragon[1])\n        count = 0\n        pos = bisect_right(heros, power_dragon_defense)\n        if pos == 0:\n            count = max(0, power_dragon_attack - power_heros + heros[pos])\n        elif pos == len(heros):\n            count = power_dragon_defense - heros[pos - 1] + max(0, power_dragon_attack - power_heros + heros[pos - 1])\n        else:\n            temp1 = power_dragon_defense - heros[pos - 1] + max(0, power_dragon_attack - power_heros + heros[pos - 1])\n            temp2 = max(0, power_dragon_attack - power_heros + heros[pos])\n            count = min(temp1, temp2)\n        print(count)\nsolve()", "from sys import stdin\nfrom bisect import bisect_left\ncount_h = stdin.readline()\nheroes = list(map(int, stdin.readline().split(' '))) + [1000000000001]\nheroes.sort()\nheroes_sum = sum(heroes[:-1])\nfor i in range(int(stdin.readline())):\n    (p, a) = map(int, stdin.readline().split(' '))\n    bis = bisect_left(heroes, p)\n    (hero_under, hero_above) = (heroes[bis], heroes[bis - 1 * (bis != 0)])\n    (protect_1, attack_1) = (p - hero_under, a - (heroes_sum - hero_under))\n    (protect_2, attack_2) = (p - hero_above, a - (heroes_sum - hero_above))\n    print(min(protect_1 * (protect_1 > 0) + attack_1 * (attack_1 > 0), protect_2 * (protect_2 > 0) + attack_2 * (attack_2 > 0)))", "from sys import stdin\nfrom bisect import bisect_left\ncount_h = stdin.readline()\nheroes = list(map(int, stdin.readline().split(' '))) + [1000000000001]\nheroes.sort()\nheroes = tuple(heroes)\nheroes_sum = sum(heroes[:-1])\nfor i in range(int(stdin.readline())):\n    (p, a) = map(int, stdin.readline().split(' '))\n    bis = bisect_left(heroes, p)\n    (hero_under, hero_above) = (heroes[bis], heroes[bis - 1 * (bis != 0)])\n    (protect_1, attack_1) = (p - hero_under, a - (heroes_sum - hero_under))\n    (protect_2, attack_2) = (p - hero_above, a - (heroes_sum - hero_above))\n    print(min(protect_1 * (protect_1 > 0) + attack_1 * (attack_1 > 0), protect_2 * (protect_2 > 0) + attack_2 * (attack_2 > 0)))", "import sys\ninput = sys.stdin.readline\nimport bisect\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nA.sort()\nSUM = sum(A)\nMAX = max(A)\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    ANS = 0\n    if x >= MAX:\n        ANS += x - MAX\n        S = SUM - MAX\n        if S >= y:\n            print(ANS)\n        else:\n            print(ANS + (y - S))\n        continue\n    k = bisect.bisect(A, x)\n    u = A[k]\n    S = SUM - u\n    ANS = max(y - S, 0)\n    if k == 0:\n        print(ANS)\n        continue\n    else:\n        u = A[k - 1]\n        ANS2 = x - u\n        S = SUM - u\n        ANS2 += max(y - S, 0)\n        print(min(ANS, ANS2))", "from sys import stdin\nfrom bisect import bisect\nn = int(stdin.readline())\narr = list(map(int, stdin.readline().split()))\narr.sort()\ns = sum(arr)\nfor _ in range(int(stdin.readline())):\n    (x, y) = map(int, stdin.readline().split())\n    a = bisect(arr, x)\n    X = arr[a - 1]\n    if a - 1 <= 0:\n        X = arr[a - 1]\n    Y = s - X\n    v = 0\n    if X < x:\n        v += x - X\n    if Y < y:\n        v += y - Y\n    if a < n:\n        if s - arr[a] < y:\n            v = min(v, y - (s - arr[a]))\n        else:\n            v = 0\n    print(v)", "import sys\nfrom bisect import bisect\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    (*a,) = map(int, input().split())\n    a.sort()\n    d = dict()\n    for i in range(1, len(a)):\n        if a[i] != a[i - 1]:\n            d[a[i]] = a[i - 1]\n    s = sum(a)\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        b = bisect(a, x - 1)\n        if b == n:\n            h = s - a[-1]\n            print(x - a[-1] + max(y - h, 0))\n        else:\n            h = s - a[b]\n            r = max(y - h, 0)\n            if a[b] in d:\n                v = d[a[b]]\n                h = s - v\n                r = min(r, x - v + max(y - h, 0))\n            print(r)\nsolve()", "import sys\ninput = sys.stdin.readline\nimport bisect\nheroes = int(input())\nheroes_strength = list(map(int, input().split()))\nnumber_dragons = int(input())\nheroes_strength.sort()\nall_strength = sum(heroes_strength)\nmax_strength = max(heroes_strength)\nfor i in range(number_dragons):\n    (dragon_defense, dragon_attack) = map(int, input().split())\n    coins = 0\n    if dragon_defense >= max_strength:\n        coins += dragon_defense - max_strength\n        remaining_strength = all_strength - max_strength\n        if remaining_strength >= dragon_attack:\n            print(coins)\n        else:\n            print(coins + (dragon_attack - remaining_strength))\n        continue\n    k = bisect.bisect(heroes_strength, dragon_defense)\n    required_strength = heroes_strength[k]\n    remaining_strength = all_strength - required_strength\n    coins = max(dragon_attack - remaining_strength, 0)\n    if k == 0:\n        print(coins)\n        continue\n    else:\n        required_strength = heroes_strength[k - 1]\n        coins2 = dragon_defense - required_strength\n        remaining_strength = all_strength - required_strength\n        coins2 += max(dragon_attack - remaining_strength, 0)\n        print(min(coins, coins2))", "import bisect\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\narr = list(map(int, input().split()))\narr.sort()\ns = sum(arr)\nm = int(input())\nfor i in range(m):\n    (d, a) = map(int, input().split())\n    index = bisect.bisect_left(arr, d)\n    if index == len(arr):\n        print(d - arr[-1] + max(0, a - (s - arr[-1])))\n    elif index <= 0:\n        print(max(0, a - (s - arr[0])))\n    else:\n        print(min(max(0, a - (s - arr[index])), max(0, d - arr[index - 1] + max(0, a - (s - arr[index - 1])))))", "import sys\nread = lambda : sys.stdin.readline()\nfrom bisect import bisect_left\nn = int(read())\nheroes = list(map(int, read().split()))\nheroes.sort()\ntotalStrength = sum(heroes)\nm = int(read())\nfor _ in range(m):\n    (defense, attack) = map(int, read().split())\n    ans = 10 ** 30\n    idx = bisect_left(heroes, defense)\n    if idx == 0:\n        ans = min(ans, max(attack - (totalStrength - heroes[idx]), 0))\n    elif idx == n:\n        ans = min(ans, defense - heroes[idx - 1] + max(attack - (totalStrength - heroes[idx - 1]), 0))\n    else:\n        ans = min(ans, max(attack - (totalStrength - heroes[idx]), 0), defense - heroes[idx - 1] + max(attack - (totalStrength - heroes[idx - 1]), 0))\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ns = sum(a)\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    i = bisect(a, x)\n    ans = 0\n    t = s\n    if i == n:\n        ans += x - a[-1]\n        t -= a[-1]\n    else:\n        t -= a[i]\n    ans += max(0, y - t)\n    if i != 0:\n        ans = min(ans, x - a[i - 1] + max(0, y - (s - a[i - 1])))\n    sys.stdout.write(str(ans) + '\\n')", "from bisect import bisect\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\n(suma, costs) = (sum(a), [])\na_set = set(a)\na = sorted(a_set)\nn = len(a)\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    if x in a_set:\n        cost = max(0, y - (suma - x))\n    else:\n        if x > a[-1]:\n            pos = n\n        else:\n            pos = bisect(a, x)\n        cost = float('inf')\n        if pos > 0:\n            nou_cost = x - a[pos - 1] + max(0, y - (suma - a[pos - 1]))\n            cost = min(cost, nou_cost)\n        if pos < n:\n            nou_cost = max(0, y - (suma - a[pos]))\n            cost = min(cost, nou_cost)\n    costs.append(str(cost))\nsys.stdout.write('\\n'.join(costs) + '\\n')", "import sys\nread = lambda : sys.stdin.readline()\nfrom heapq import heapify, heappop, heappush\nfrom bisect import bisect_left\nn = int(read())\nheroes = list(map(int, read().split()))\nheroes.sort()\ntotalStrength = sum(heroes)\nm = int(read())\nfor _ in range(m):\n    (defense, attack) = map(int, read().split())\n    ans = 10 ** 30\n    idx = bisect_left(heroes, defense)\n    if idx == 0:\n        ans = min(ans, max(attack - (totalStrength - heroes[idx]), 0))\n    elif idx == n:\n        ans = min(ans, defense - heroes[idx - 1] + max(attack - (totalStrength - heroes[idx - 1]), 0))\n    else:\n        ans = min(ans, max(attack - (totalStrength - heroes[idx]), 0), defense - heroes[idx - 1] + max(attack - (totalStrength - heroes[idx - 1]), 0))\n    print(ans)", "import bisect\nimport sys\ninput = sys.stdin.readline\nn = int(input())\nhero = list(map(int, input().split()))\nm = int(input())\nhero.sort()\nc = sum(hero)\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    r = bisect.bisect_left(hero, x)\n    if r == n:\n        ans = max(0, x - hero[n - 1])\n        ans += max(0, y - (c - hero[n - 1]))\n    elif r == 0:\n        ans = max(0, x - hero[0])\n        ans += max(0, y - (c - hero[0]))\n    else:\n        ans1 = max(0, x - hero[r])\n        ans1 += max(0, y - (c - hero[r]))\n        ans2 = max(0, x - hero[r - 1])\n        ans2 += max(0, y - (c - hero[r - 1]))\n        ans = min(ans1, ans2)\n    print(ans)", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [1000000000001]\na.sort()\nss = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - ss + a[l - 1]), max(0, x - a[l]) + max(0, y - ss + a[l])))", "from sys import stdin\nfrom bisect import bisect_left\ncount_h = stdin.readline()\nheroes = list(map(int, stdin.readline().split(' '))) + [1000000000001]\nheroes.sort()\nheroes = tuple(heroes)\nheroes_sum = sum(heroes[:-1])\nfor i in range(int(stdin.readline())):\n    (p, a) = map(int, stdin.readline().split(' '))\n    bis = bisect_left(heroes, p)\n    (hero_under, hero_above) = (heroes[bis], heroes[bis - 1 * (bis != 0)])\n    (protect_1, attack_1) = (p - hero_under, a - (heroes_sum - hero_under))\n    if hero_under == hero_above:\n        print(protect_1 * (protect_1 > 0) + attack_1 * (attack_1 > 0))\n    else:\n        (protect_2, attack_2) = (p - hero_above, a - (heroes_sum - hero_above))\n        print(min(protect_1 * (protect_1 > 0) + attack_1 * (attack_1 > 0), protect_2 * (protect_2 > 0) + attack_2 * (attack_2 > 0)))", "from sys import stdin\nimport bisect\nn = int(stdin.readline())\na = sorted(map(int, stdin.readline().split()))\ns = sum(a)\nfor _ in range(int(stdin.readline())):\n    (x, y) = list(map(int, stdin.readline().split()))\n    i = bisect.bisect(a, x)\n    if i == n:\n        print(max(0, y - (s - a[i - 1])) + max(0, x - a[i - 1]))\n    elif a[i] == x or i == 0:\n        print(max(0, y - (s - a[i])))\n    elif i > 0:\n        res1 = max(0, y - (s - a[i]))\n        res2 = max(0, y - (s - a[i - 1])) + x - a[i - 1]\n        print(min(res1, res2))", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [1000000000001]\na.sort()\nss = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - ss + a[l - 1]), max(0, x - a[l]) + max(0, y - ss + a[l])))", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [1000000000001]\na.sort()\nss = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - ss + a[l - 1]), max(0, x - a[l]) + max(0, y - ss + a[l])))", "import sys\nimport bisect\nimport collections\nimport copy\nimport itertools\nimport math\nimport functools\nimport operator\nfrom heapq import heappop, heappush\ninput = sys.stdin.readline\n\ndef I():\n    return input().rstrip()\n\ndef IS():\n    return input().split()\n\ndef II():\n    return int(input())\n\ndef IIS():\n    return map(int, input().split())\n\ndef LIIS():\n    return list(map(int, input().split()))\nsys.setrecursionlimit(100000)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef main():\n    N = II()\n    A = LIIS()\n    A.sort()\n    S = sum(A)\n    M = II()\n    for _ in range(M):\n        (defense, attack) = IIS()\n        res = INF\n        pos = bisect.bisect_left(A, defense)\n        if pos < N:\n            res = min(res, max(0, defense - A[pos]) + max(0, attack - (S - A[pos])))\n        if pos:\n            res = min(res, max(0, defense - A[pos - 1]) + max(0, attack - (S - A[pos - 1])))\n        print(res)\nmain()", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [1000000000001]\na.sort()\nss = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - ss + a[l - 1]), max(0, x - a[l]) + max(0, y - ss + a[l])))", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\narr = list(map(int, input().split()))\narr.sort()\nt = sum(arr)\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    idx = bisect_left(arr, x)\n    if idx == n:\n        ans = abs(x - arr[-1]) + max(0, y - (t - arr[-1]))\n    elif idx == 0 or arr[idx] == x:\n        ans = max(0, y - (t - arr[idx]))\n    else:\n        (val1, val2) = (arr[idx - 1], arr[idx])\n        ans1 = max(x - val1, 0) + max(0, y - (t - val1))\n        ans2 = max(x - val2, 0) + max(0, y - (t - val2))\n        ans = min(ans1, ans2)\n    sys.stdout.write(str(ans) + '\\n')", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [1000000000001]\na.sort()\nss = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - ss + a[l - 1]), max(0, x - a[l]) + max(0, y - ss + a[l])))", "import bisect\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\na = list(map(int, input().split(' ')))\na.sort()\ncapacity = sum(a)\nm = int(input())\nfor i in range(m):\n    (k, d) = map(int, input().split(' '))\n    index = bisect.bisect_left(a, k)\n    ans = 0\n    if index == 0:\n        defense = capacity - a[0]\n        if defense < d:\n            ans += d - defense\n    elif index == n:\n        ans += k - a[n - 1]\n        defense = capacity - a[n - 1]\n        if defense < d:\n            ans += d - defense\n    elif a[index - 1] == k:\n        defense = capacity - a[index - 1]\n        if defense < d:\n            ans += d - defense\n    else:\n        defense1 = capacity - a[index - 1]\n        kill1 = k - a[index - 1]\n        sol1 = kill1\n        if defense1 < d:\n            sol1 += d - defense1\n        defense2 = capacity - a[index]\n        sol2 = 0\n        if defense2 < d:\n            sol2 += d - defense2\n        ans = min(sol1, sol2)\n    print(ans)", "from bisect import *\nimport sys\ninput = sys.stdin.readline\nn = int(input())\nli = list(map(int, input().split()))\nli.sort()\nfullStrength = sum(li)\noutput = []\nfor _ in range(int(input())):\n    (xi, yi) = map(int, input().split())\n    left = min(n - 1, bisect_left(li, xi))\n    val = 0\n    if left > 0:\n        leftone = left - 1\n    else:\n        leftone = left\n    val = min(max(0, xi - li[left]) + max(0, yi - (fullStrength - li[left])), max(0, xi - li[leftone]) + max(0, yi - (fullStrength - li[leftone])))\n    print(val)", "import sys\nimport bisect\nt_str = sys.stdin.readline().rstrip()\nif t_str != '':\n    n = int(t_str)\n    h = [int(a) for a in sys.stdin.readline().rstrip().split(' ')]\n    h = sorted(h)\n    d = int(sys.stdin.readline().rstrip())\n    total = sum(h)\n    while d > 0:\n        left = None\n        right = None\n        (x, y) = [int(a) for a in sys.stdin.readline().rstrip().split(' ')]\n        ind = bisect.bisect_left(h, x)\n        if ind != 0:\n            left = h[ind - 1]\n        if ind != n:\n            right = h[ind]\n        result = None\n        if left is not None:\n            result = x - left\n            if total - left < y:\n                result += y - total + left\n        if right is not None:\n            if result is not None:\n                diff = 0\n                if total - right < y:\n                    diff = y - total + right\n                result = min(result, diff)\n            elif total - right < y:\n                result = y - total + right\n            else:\n                result = 0\n        print(result)\n        d -= 1", "import sys\nfrom bisect import bisect_left\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split()))\nm = int(sys.stdin.readline())\ndragon = []\nfor i in range(m):\n    (defense, attack) = map(int, sys.stdin.readline().split())\n    dragon.append((defense, attack))\na.sort()\ntotal = sum(a)\nfor enemy in dragon:\n    defense = enemy[0]\n    attack = enemy[1]\n    loc = bisect_left(a, defense)\n    ans = 0\n    if loc == 0:\n        key = a[0]\n        if total - key < attack:\n            ans += attack - (total - key)\n    elif loc == n:\n        key = a[-1]\n        ans += defense - key\n        if total - key < attack:\n            ans += attack - (total - key)\n    else:\n        case1 = 0\n        key = a[loc]\n        if total - key < attack:\n            case1 += attack - (total - key)\n        case2 = 0\n        key2 = a[loc - 1]\n        case2 += defense - key2\n        if total - key2 < attack:\n            case2 += attack - (total - key2)\n        ans = min(case1, case2)\n    print(ans)", "import bisect\nimport math\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nm = int(input())\ns = sum(a)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    ans = 0\n    index = bisect.bisect_left(a, x)\n    ans = max(0, x - a[index - 1])\n    ans += max(0, y - (s - a[index - 1]))\n    ans2 = math.inf\n    if index != n:\n        ans2 = max(0, x - a[index])\n        ans2 += max(0, y - (s - a[index]))\n    print(min(ans, ans2))", "from bisect import *\nimport sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nt = 1\nwhile t:\n    t -= 1\n    n = inp()\n    a = lis()\n    a.sort()\n    m = inp()\n    su = sum(a)\n    for i in range(m):\n        (x, y) = ma()\n        rr = 0\n        z = bisect_left(a, x)\n        if z >= n:\n            z = n - 1\n        if a[z] < x:\n            rr += x - a[z]\n        su1 = su - a[z]\n        if su1 < y:\n            rr += y - su1\n        if z != 0:\n            rr1 = 0\n            if a[z - 1] < x:\n                rr1 += x - a[z - 1]\n            su1 = su - a[z - 1]\n            if su1 < y:\n                rr1 += y - su1\n            rr = min(rr, rr1)\n        print(rr)", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\nn = int(input())\nhero = list(map(int, input().split()))\nhero.sort()\ntotal = sum(hero)\ndragon = int(input())\nfor i in range(dragon):\n    (x, y) = map(int, input().split())\n    idx = bisect_left(hero, x)\n    v = 0\n    if idx == n:\n        v = x - hero[-1] + max(0, y - (total - hero[-1]))\n    elif idx == 0 or hero[idx] == x:\n        v = max(0, y - (total - hero[idx]))\n    else:\n        (v1, v2) = (hero[idx - 1], hero[idx])\n        v = min(max(x - v1, 0) + max(0, y - (total - v1)), max(x - v2, 0) + max(0, y - (total - v2)))\n    print(v)", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\ncount_h = int(input())\nheroes = [int(x) for x in input().split()] + [1000000000001]\nheroes.sort()\nheroes_sum = sum(heroes[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(heroes, x)\n    print(min(max(0, x - heroes[l - 1]) + max(0, y - heroes_sum + heroes[l - 1]), max(0, x - heroes[l]) + max(0, y - heroes_sum + heroes[l])))", "from string import ascii_lowercase\nfrom decimal import Decimal\nfrom random import randrange, choice, randint, shuffle\nimport time\nfrom heapq import heappop, heappush, heapify\nfrom copy import copy\nfrom bisect import bisect_right, bisect_left\nfrom sys import stdin\nfrom functools import reduce\nfrom math import sqrt, gcd, pi, factorial, ceil, floor, sin\nfrom itertools import permutations\nfrom collections import defaultdict, deque, Counter\nimport sys\ninput = sys.stdin.readline\nMAX = 10 ** 19\n\ndef solve(n, a, x, y, s):\n    index = bisect_left(a, x)\n    ret = MAX\n    if index > 0:\n        attacker = a[index - 1]\n        ret = min(ret, max(x - attacker, 0) + max(y - (s - attacker), 0))\n    if index < n - 1:\n        attacker = a[index]\n        ret = min(ret, max(x - attacker, 0) + max(y - (s - attacker), 0))\n    return ret\nn = int(input())\na = sorted(list(map(int, input().split())))\nm = int(input())\ns = sum(a)\nans = [0 for _ in range(m)]\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    ans[i] = solve(n, a, x, y, s)\nfor a in ans:\n    print(a)", "from sys import stdin, stdout\nfrom bisect import bisect_left as bl\nn = int(input())\na = []\nss = 0\nfor ele in map(int, input().split()):\n    a.append(ele)\n    ss += ele\na.sort()\nm = int(input())\nanss = []\nwhile m:\n    m -= 1\n    (x, y) = map(int, input().split())\n    ind = bl(a, x)\n    if ind > 0 and ind < n:\n        ans1 = x - a[ind - 1]\n        if ss - a[ind - 1] < y:\n            ans1 += y - (ss - a[ind - 1])\n        ans2 = 0\n        if ss - a[ind] < y:\n            ans2 += y - (ss - a[ind])\n        anss.append(min(ans1, ans2))\n    elif ind == 0:\n        ans = 0\n        if ss - a[ind] < y:\n            ans += y - (ss - a[ind])\n        anss.append(ans)\n    else:\n        ans1 = x - a[ind - 1]\n        if ss - a[ind - 1] < y:\n            ans1 += y - (ss - a[ind - 1])\n        anss.append(ans1)\nprint(*anss, sep='\\n')", "import collections\nfrom math import ceil, gcd, sqrt, log\nimport bisect\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    net = sum(A)\n    m = int(input())\n    dragon = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        dragon.append([x, y])\n    for i in dragon:\n        (x, y) = i\n        e = bisect.bisect_left(A, x)\n        if e == 0:\n            add_to_attack = 0\n            rem = net - A[0]\n            add_to_defend = max(0, y - rem)\n        elif e == n:\n            add_to_attack = x - A[n - 1]\n            rem = net - A[n - 1]\n            add_to_defend = max(0, y - rem)\n        else:\n            one = x - A[e - 1] + max(0, y - (net - A[e - 1]))\n            two = 0 + max(0, y - (net - A[e]))\n            print(min(one, two))\n            continue\n        print(add_to_attack + add_to_defend)\nt = 1\nwhile t != 0:\n    solve()\n    t -= 1", "import bisect\nimport sys\nreadline = sys.stdin.readline\nii = lambda : int(readline())\nmi = lambda : map(int, readline().split())\nli = lambda : list(map(int, readline().split()))\nINF = 2 ** 63 - 1\nN = ii()\nA = li()\nM = ii()\n(X, Y) = ([0] * M, [0] * M)\nfor i in range(M):\n    (X[i], Y[i]) = mi()\nA.append(0)\nA.sort()\ns = sum(A)\nA.append(INF)\nfor i in range(M):\n    high = bisect.bisect_left(A, X[i])\n    low = max(high - 1, 0)\n    if high != N + 1:\n        c = max(Y[i] - (s - A[high]), 0)\n    else:\n        c = INF\n    if low != 0:\n        d = X[i] - A[low] + max(Y[i] - (s - A[low]), 0)\n    else:\n        d = INF\n    print(min(c, d))", "import sys\ninput = sys.stdin.readline\n\ndef I():\n    return input().strip()\n\ndef II():\n    return int(input().strip())\n\ndef LI():\n    return [*map(int, input().strip().split())]\nimport copy, string, math, time, functools, random, fractions\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom itertools import permutations, chain, combinations, groupby\nfrom operator import itemgetter\nfrom types import GeneratorType\nfrom typing import Iterable, TypeVar, Union\nfor _ in range(1):\n    n = II()\n    a = LI()\n    m = II()\n    a.sort()\n    s = sum(a)\n    for q in range(m):\n        (r, t) = LI()\n        left = s\n        if r > a[-1]:\n            ans = r - a[-1]\n            left -= a[-1]\n            ans += max(t - left, 0)\n            print(ans)\n        else:\n            ind = bisect_left(a, r)\n            left -= a[ind]\n            ans = max(t - left, 0)\n            if ind > 0:\n                temp = r - a[ind - 1]\n                left = s - a[ind - 1]\n                temp += max(t - left, 0)\n                ans = min(ans, temp)\n            print(ans)", "from bisect import bisect_left\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [10 ** 17]\na.sort()\ns = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - s + a[l - 1]), max(0, x - a[l]) + max(0, y - s + a[l])))", "import math, sys\nfrom collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappush, heappop\nfrom bisect import bisect_left\nINF = float('inf')\n\ndef solve():\n    n = int(input())\n    a = sorted(list(map(int, input().split())))\n    b = []\n    total = sum(a)\n    m = int(input())\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        i = bisect_left(a, x)\n        coin = INF\n        if i > 0:\n            coin = min(coin, x - a[i - 1] + max(0, y - total + a[i - 1]))\n        if i < n:\n            coin = min(coin, max(0, y - total + a[i]))\n        print(coin)\n\ndef input():\n    return sys.stdin.readline().rstrip('\\n').strip()\n\ndef print(*args, sep=' ', end='\\n'):\n    first = True\n    for arg in args:\n        if not first:\n            sys.stdout.write(sep)\n        sys.stdout.write(str(arg))\n        first = False\n    sys.stdout.write(end)\nts = 1\nfor t in range(1, ts + 1):\n    solve()", "from sys import stdin\ninput = stdin.readline\nfrom bisect import bisect_left, bisect_right\nn = int(input())\nheroes = list(map(int, input().split()))\nheroes = sorted(heroes)\n(d, total) = (int(input()), sum(heroes))\nseen = {}\nfor _ in range(d):\n    (attack, defense) = map(int, input().split())\n    if attack in seen:\n        i = seen[attack]\n    else:\n        i = bisect_left(heroes, attack)\n        seen[attack] = i\n    if i == n:\n        print(attack - heroes[-1] + max(0, defense - total + heroes[-1]))\n    elif i == 0:\n        print(max(0, defense - total + heroes[0]))\n    else:\n        val1 = max(0, defense - total + heroes[i])\n        val2 = attack - heroes[i - 1] + max(0, defense - total + heroes[i - 1])\n        print(min(val1, val2))", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\ntotal = sum(a)\na.sort()\nm = int(input())\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    pos = bisect_left(a, x)\n    pos = max(0, min(n - 1, pos))\n    ans1 = max(0, x - a[pos - 1]) + max(0, y - (total - a[pos - 1]))\n    ans2 = max(0, x - a[pos]) + max(0, y - (total - a[pos]))\n    print(min(ans1, ans2))", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\nn = int(input())\nli = list(map(int, input().split()))\nli.sort()\nstrong = sum(li)\nm = int(input())\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    k = bisect_left(li, a)\n    k = min(n - 1, k)\n    k = max(0, k)\n    ans = 0\n    ans1 = max(0, a - li[k - 1]) + max(0, b - (strong - li[k - 1]))\n    ans2 = max(0, a - li[k]) + max(0, b - (strong - li[k]))\n    ans = min(ans1, ans2)\n    print(ans)", "import sys\nimport math\nimport collections\nimport bisect\ndy = [1, 0, -1, 0]\ndx = [0, 1, 0, -1]\nr = sys.stdin.readline\nN = int(r())\nL = list(map(int, r().split()))\nM = int(r())\nL.sort()\nS = sum(L)\nfor i in range(M):\n    (a, b) = map(int, r().split())\n    big = bisect.bisect_left(L, a)\n    if big == N:\n        ans = a - L[-1]\n        if b > S - L[-1]:\n            ans += b - (S - L[-1])\n        print(ans)\n        continue\n    ans1 = 0\n    if b > S - L[big]:\n        ans1 += b - (S - L[big])\n    if big != 0:\n        ans2 = 0\n        ans2 += a - L[big - 1]\n        if b > S - L[big - 1]:\n            ans2 += b - (S - L[big - 1])\n        ans1 = min(ans1, ans2)\n    print(ans1)", "from math import sqrt, gcd, ceil, floor, log, factorial\nfrom itertools import permutations, combinations\nfrom collections import Counter, defaultdict\nimport collections, sys, threading\nimport collections, sys, threading\nfrom bisect import *\ninput = sys.stdin.readline\n\ndef ii():\n    return int(input())\n\ndef si():\n    return input()\n\ndef mi():\n    return map(int, input().split())\n\ndef msi():\n    return map(str, input().split())\n\ndef li():\n    return list(mi())\n\ndef f(n, a, x, y, summ):\n    ll = bisect_left(a, x, 0, n)\n    if ll == n:\n        req = x - a[ll - 1]\n        power = max(y - summ + a[ll - 1], 0)\n        return req + power\n    elif ll > 0:\n        req = min(max(0, x - a[ll]) + max(0, y - summ + a[ll]), max(0, x - a[ll - 1]) + max(0, y - summ + a[ll - 1]))\n        return req\n    else:\n        power = max(y - sum(a) + a[ll], 0) + max(x - a[ll], 0)\n        return power\nn = ii()\na = li()\na.sort()\nsumm = sum(a)\nm = ii()\nfor i in range(m):\n    (x, y) = mi()\n    print(f(n, a, x, y, summ))", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\narr = list(map(int, input().split()))\narr.sort()\nt = sum(arr)\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    idx = bisect_left(arr, x)\n    if idx == n:\n        ans = abs(x - arr[-1]) + max(0, y - (t - arr[-1]))\n    elif idx == 0 or arr[idx] == x:\n        ans = max(0, y - (t - arr[idx]))\n    else:\n        (val1, val2) = (arr[idx - 1], arr[idx])\n        ans1 = max(x - val1, 0) + max(0, y - (t - val1))\n        ans2 = max(x - val2, 0) + max(0, y - (t - val2))\n        ans = min(ans1, ans2)\n    print(ans)", "import sys\nimport bisect\ninput = sys.stdin.readline\n\ndef fun(x, y, sumi):\n    idx = bisect.bisect_left(arr, x)\n    if idx == len(arr):\n        idx = len(arr) - 1\n    attack = max(x - arr[idx], 0)\n    defense = max(y - sumi + arr[idx], 0)\n    ans = attack + defense\n    if idx > 0:\n        idx -= 1\n        attack = max(x - arr[idx], 0)\n        defense = max(y - sumi + arr[idx], 0)\n        ans = min(ans, attack + defense)\n    return ans\nn = int(input())\narr = list(map(int, input().split()))\nm = int(input())\narr.sort()\nsumi = sum(arr)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    print(fun(x, y, sumi))", "import math\nfrom collections import defaultdict\nfrom bisect import bisect_left\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\na = list(map(int, input().split()))\ns = sum(a)\na.sort()\nm = int(input())\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    index = bisect_left(a, x)\n    if index != 0:\n        index -= 1\n    f_ans = 0\n    ans = 0\n    if a[index] < x:\n        ans += x - a[index]\n    new_s = s - a[index]\n    if new_s < y:\n        ans += y - new_s\n    if index != len(a) - 1:\n        index += 1\n    f_ans = ans\n    ans = 0\n    if a[index] < x:\n        ans += x - a[index]\n    new_s = s - a[index]\n    if new_s < y:\n        ans += y - new_s\n    f_ans = min(f_ans, ans)\n    print(f_ans)", "import sys\nimport bisect as b\nimport math\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\na.sort()\ns = sum(a)\nm = int(input())\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    z = b.bisect_left(a, x)\n    ans = 0\n    ans += max(0, x - a[z - 1])\n    ans += max(0, y - (s - a[z - 1]))\n    ans1 = math.inf\n    if z != len(a):\n        ans1 = max(0, x - a[z])\n        ans1 += max(0, y - (s - a[z]))\n    print(min(ans, ans1))", "from bisect import bisect_left\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\na = [int(x) for x in input().split()] + [1000000000001]\na.sort()\nss = sum(a[:-1])\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = bisect_left(a, x)\n    print(min(max(0, x - a[l - 1]) + max(0, y - ss + a[l - 1]), max(0, x - a[l]) + max(0, y - ss + a[l])))", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nn = int(input())\nl = sorted(list(map(int, input().split())))\nm = int(input())\ntot = sum(l)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    p = bisect_left(l, x) - 1\n    if p == -1:\n        p = 0\n        print(max(0, y - tot + l[0]))\n    elif p == n - 1:\n        print(max(0, x - l[n - 1]) + max(0, y - tot + l[n - 1]))\n    else:\n        res1 = max(0, x - l[p])\n        res1 += max(0, y - tot + l[p])\n        res2 = max(0, x - l[p + 1])\n        res2 += max(0, y - tot + l[p + 1])\n        print(min(res1, res2))", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\nrn = lambda : int(input())\nrns = lambda : map(int, input().split())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input().strip()\nYN = lambda x: print('YES') if x else print('NO')\nmod = 10 ** 9 + 7\nn = rn()\na = rl()\na.sort()\ns = sum(a)\nm = rn()\nfor _ in range(m):\n    (de, atk) = rns()\n    j = bisect_left(a, de)\n    if j == n:\n        j -= 1\n    ans = []\n    if j > 0:\n        ans.append(max(0, de - a[j - 1]) + max(0, atk - (s - a[j - 1])))\n    ans.append(max(0, de - a[j]) + max(0, atk - (s - a[j])))\n    print(min(ans))", "from bisect import *\nimport sys\ninf = float('inf')\nip = sys.stdin.readline\n\ndef ipl():\n    return list(map(int, ip().split()))\n\ndef ipn():\n    return int(ip())\n\ndef ipf():\n    return float(ip())\n\ndef solve():\n    n = ipn()\n    a = ipl()\n    a.sort()\n    s = sum(a)\n    for _ in range(ipn()):\n        (x, y) = ipl()\n        i = bisect_right(a, x)\n        r = inf\n        if i < n:\n            r = min(r, abs(min(a[i] - x, 0)) + abs(min(s - a[i] - y, 0)))\n        if i - 1 >= 0:\n            r = min(r, abs(min(a[i - 1] - x, 0)) + abs(min(s - a[i - 1] - y, 0)))\n        print(r)\nt = 1\nfor _ in range(t):\n    solve()", "from bisect import bisect_left as bl\nimport sys\ninput = sys.stdin.readline\nw = int(input())\na = sorted(map(int, input().split()))\nb = sum(a)\nfor i in range(int(input())):\n    (x, y) = map(int, input().split())\n    g = []\n    c = bl(a, x)\n    (d, e) = (0, 0)\n    if c > len(a) - 1:\n        c -= 1\n    d = max(0, x - a[c]) + max(0, y - b + a[c])\n    e = max(0, x - a[c - 1]) + max(0, y - b + a[c - 1])\n    f = min(d, e)\n    g.append(f)\n    print(min(g))", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\n\ndef SlayD(n, Power, Dragon, E):\n    key = bisect_left(Power, Dragon[0])\n    key = max(0, min(n - 1, key))\n    CoinA = max(0, Dragon[1] - (E - Power[key])) + max(0, Dragon[0] - Power[key])\n    CoinB = max(0, Dragon[1] - (E - Power[key - 1])) + max(0, Dragon[0] - Power[key - 1])\n    Coin = min(CoinA, CoinB)\n    return Coin\nnum_of_hero = int(input())\nI = [int(x) for x in input().split()]\nI.sort()\nE = sum(I)\nnum_of_d = int(input())\nfor i in range(num_of_d):\n    (x, y) = map(int, input().split())\n    print(SlayD(num_of_hero, I, [x, y], E))", "from bisect import bisect_left as bl\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = sorted(map(int, input().split()))\ntotal = sum(a)\nm = int(input())\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    l = bl(a, x)\n    ans = 0\n    p = max(l - 1, 0)\n    q = min(l, n - 1)\n    a1 = x - min(a[p], x)\n    r = total - a[p]\n    if r < y:\n        a1 += y - r\n    a2 = x - min(a[q], x)\n    r = total - a[q]\n    if r < y:\n        a2 += y - r\n    print(min(a1, a2))", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\ns = sum(a)\na.sort()\nfor _ in range(int(input())):\n    (x, y) = map(int, input().split())\n    i = bisect_left(a, x)\n    i = max(0, min(n - 1, i))\n    h1 = max(x - a[i - 1], 0) + max(y - (s - a[i - 1]), 0)\n    h2 = max(x - a[i], 0) + max(y - (s - a[i]), 0)\n    print(min(h1, h2))", "import collections\nfrom math import ceil, gcd, sqrt, log\nimport bisect\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    net = sum(A)\n    m = int(input())\n    dragon = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        dragon.append([x, y])\n    for i in dragon:\n        (x, y) = i\n        e = bisect.bisect_left(A, x)\n        if e == 0:\n            add_to_attack = 0\n            rem = net - A[0]\n            add_to_defend = max(0, y - rem)\n        elif e == n:\n            add_to_attack = x - A[n - 1]\n            rem = net - A[n - 1]\n            add_to_defend = max(0, y - rem)\n        else:\n            one = x - A[e - 1] + max(0, y - (net - A[e - 1]))\n            two = 0 + max(0, y - (net - A[e]))\n            print(min(one, two))\n            continue\n        print(add_to_attack + add_to_defend)\nt = 1\nwhile t != 0:\n    solve()\n    t -= 1", "import sys\nimport bisect\nimport math\ninput = sys.stdin.readline\nn = int(input())\na = [*map(int, input().split())]\na.sort()\nm = int(input())\ns = sum(a)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    ans = 0\n    ind = bisect.bisect_left(a, x)\n    ans += max(0, x - a[ind - 1])\n    ans += max(0, y - (s - a[ind - 1]))\n    ans1 = math.inf\n    if ind != len(a):\n        ans1 = max(0, x - a[ind])\n        ans1 += max(0, y - (s - a[ind]))\n    print(min(ans, ans1))", "import sys\nimport bisect\nimport math\ninput = sys.stdin.readline\nn = int(input())\na = [*map(int, input().split())]\na.sort()\nm = int(input())\ns = sum(a)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    ans = 0\n    ind = bisect.bisect_left(a, x)\n    ans += max(0, x - a[ind - 1])\n    ans += max(0, y - (s - a[ind - 1]))\n    ans1 = math.inf\n    if ind != len(a):\n        ans1 = max(0, x - a[ind])\n        ans1 += max(0, y - (s - a[ind]))\n    print(min(ans, ans1))", "import sys\nimport bisect\nimport math\ninput = sys.stdin.readline\nn = int(input())\na = [*map(int, input().split())]\na.sort()\nm = int(input())\ns = sum(a)\nfor _ in range(m):\n    (x, y) = map(int, input().split())\n    ans = 0\n    ind = bisect.bisect_left(a, x)\n    ans += max(0, x - a[ind - 1])\n    ans += max(0, y - (s - a[ind - 1]))\n    ans1 = math.inf\n    if ind != len(a):\n        ans1 = max(0, x - a[ind])\n        ans1 += max(0, y - (s - a[ind]))\n    print(min(ans, ans1))", "import bisect\n\ndef slayTheDragon(n, heros, m, dragons):\n    heros.sort()\n    s = sum(heros)\n    for x in dragons:\n        strength = x[0]\n        power = x[1]\n        i = bisect.bisect_left(heros, strength)\n        if i == 0:\n            first = max(0, power - (s - heros[i]))\n            second = float('inf')\n        elif i == n:\n            first = strength - heros[n - 1] + max(0, power - (s - heros[n - 1]))\n            second = float('inf')\n        else:\n            first = strength - heros[i - 1] + max(0, power - (s - heros[i - 1]))\n            second = max(0, power - (s - heros[i]))\n        print(min(first, second))\n    return\nn = int(input())\nheros = list(map(int, input().split()))\nm = int(input())\ndragons = []\nfor x in range(m):\n    dragons.append(list(map(int, input().split())))\nslayTheDragon(n, heros, m, dragons)", "import math\nimport heapq\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nn = I()\nl = L()\nl.sort()\ns = sum(l)\nm = I()\nfor i in range(m):\n    (a, b) = M()\n    c = 0\n    i = bisect_left(l, a)\n    if i == n:\n        print(a - l[-1] + max(0, b - s + l[-1]))\n    elif i == 0:\n        print(max(0, b - s + l[i]))\n    elif abs(l[i - 1] - a) + max(0, b - s + l[i - 1]) < max(0, b - s + l[i]):\n        print(abs(l[i - 1] - a) + max(0, b - s + l[i - 1]))\n    else:\n        print(max(0, b - s + l[i]))", "from sys import stdin\nfrom bisect import bisect_left\ninput = stdin.readline\n\ndef SlayD(n, Power, Dragon, E):\n    key = bisect_left(Power, Dragon[0])\n    key = max(0, min(n - 1, key))\n    CoinA = max(0, Dragon[1] - (E - Power[key])) + max(0, Dragon[0] - Power[key])\n    CoinB = max(0, Dragon[1] - (E - Power[key - 1])) + max(0, Dragon[0] - Power[key - 1])\n    Coin = min(CoinA, CoinB)\n    return Coin\nnum_of_hero = int(input())\nI = [int(x) for x in input().split()]\nI.sort()\nE = sum(I)\nnum_of_d = int(input())\nfor i in range(num_of_d):\n    t = list(map(int, input().split()))\n    print(SlayD(num_of_hero, I, t, E))", "import sys\nfrom bisect import *\ninput = sys.stdin.readline\nn = int(input())\nh = sorted(list(map(int, input().split())))\nm = int(input())\nsu = sum(h)\nfor i in range(m):\n    ans = 0\n    (k, d) = map(int, input().split())\n    f = bisect_left(h, k)\n    if f > n - 1:\n        f -= 1\n    u = 0\n    o = 0\n    u += max(0, k - h[f]) + max(0, d - (su - h[f]))\n    o += max(0, k - h[f - 1]) + max(0, d - (su - h[f - 1]))\n    ans = min(u, o)\n    print(ans)"]