["import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    A = [0] + list(map(int, input().split()))\n    B = [0] + list(map(int, input().split()))\n    ans = []\n    (lo, hi) = (n, n - A[n])\n    if hi <= 0:\n        print(1)\n        print(0)\n        return\n    while lo > 0:\n        nextStep = hi\n        idx = hi\n        for i in range(hi, lo + 1):\n            j = i + B[i]\n            if nextStep > j - A[j]:\n                nextStep = j - A[j]\n                idx = i\n        if nextStep == hi > 0:\n            print(-1)\n            return\n        ans.append(idx)\n        if nextStep <= 0:\n            ans.append(0)\n            print(len(ans))\n            print(*ans)\n            return\n        (lo, hi) = (hi - 1, nextStep)\n    return\nsolve()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    A = [0] + list(map(int, input().split()))\n    B = [0] + list(map(int, input().split()))\n    ans = []\n    (lo, hi) = (n, n - A[n])\n    while hi > 0:\n        nextStep = hi\n        idx = hi\n        for i in range(hi, lo + 1):\n            j = i + B[i]\n            if nextStep > j - A[j]:\n                nextStep = j - A[j]\n                idx = i\n        if nextStep == hi:\n            print(-1)\n            return\n        ans.append(idx)\n        (lo, hi) = (hi - 1, nextStep)\n    ans.append(0)\n    print(len(ans))\n    print(*ans)\n    return\nsolve()", "from collections import deque\n\ndef solve():\n    n = int(input())\n    arr = [0] + list(map(int, input().split()))\n    brr = [0] + list(map(int, input().split()))\n    p = [-1] * (n + 1)\n    p[n] = n\n    bd = n\n    queue = deque()\n    queue.append((n, n))\n    while queue:\n        (a, b) = queue.popleft()\n        for x in range(b - arr[b], min(b + 1, bd)):\n            if p[x] == -1:\n                p[x] = a\n                queue.append((x, x + brr[x]))\n        bd = min(bd, b - arr[b])\n    if p[0] == -1:\n        print(-1)\n    else:\n        ans = [0]\n        while ans[-1] != n:\n            ans.append(p[ans[-1]])\n        ans.pop()\n        print(len(ans))\n        print(*ans[::-1])\nimport sys\ninput = lambda : sys.stdin.readline().rstrip()\nsolve()", "def task5(n, a, b):\n    F = [None] * (n + 1)\n    paths = [[] for i in range(n + 1)]\n    F[n] = 0\n    visited = set()\n    current = [n]\n    high = n\n    while True:\n        new_vertexes = []\n        for i in current:\n            for j in range(i - a[i], high + 1):\n                k = j + b[j]\n                if k not in visited:\n                    new_vertexes.append(k)\n                    visited.add(k)\n                if F[k] is None:\n                    paths[k] = (i, j)\n                    F[k] = F[i] + 1\n                elif F[i] + 1 < F[k]:\n                    paths[k] = (i, j)\n                    F[k] = F[i] + 1\n            high = min(high, i - a[i])\n        current = new_vertexes\n        if not current:\n            break\n    path = []\n    if F[0] is not None:\n        current = paths[0]\n        while current[0] != n:\n            path.append(current[1])\n            current = paths[current[0]]\n        path.append(current[1])\n    return (-1 if F[0] is None else F[0], path[::-1])\n\ndef main():\n    n = int(input().strip())\n    arr_a = [0] + list(map(int, input().strip().split()))\n    arr_b = [0] + list(map(int, input().strip().split()))\n    result = task5(n, arr_a, arr_b)\n    print(result[0])\n    if result[1]:\n        print(*result[1], sep=' ')\nmain()"]