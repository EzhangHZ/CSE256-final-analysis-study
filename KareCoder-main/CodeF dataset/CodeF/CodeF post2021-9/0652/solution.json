["from collections import deque\n(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\ngraph = [list(map(int, input().split())) for _ in range(m)]\ninv = [0] * n\noutv = [0] * n\nfor i in range(m):\n    graph[i][0] -= 1\n    graph[i][1] -= 1\n    inv[graph[i][0]] += 1\n    outv[graph[i][1]] += 1\nS = set()\nfor (u, v) in graph:\n    if inv[u] > 1 and outv[v] > 1:\n        g[u].append(v)\n    else:\n        S.add((u, v))\nfor (a, b) in S:\n    inv[a] -= 1\n    outv[b] -= 1\nq = deque()\nfor i in range(n):\n    if outv[i] <= 0:\n        q.append(i)\ndp = [0] * n\nwhile q:\n    node = q.pop()\n    for nextNode in g[node]:\n        dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n        outv[nextNode] -= 1\n        if outv[nextNode] == 0:\n            q.appendleft(nextNode)\nprint(max(dp) + 1)", "from collections import deque\n(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\ngraph = [list(map(int, input().split())) for _ in range(m)]\ninv = [0] * n\noutv = [0] * n\nfor i in range(m):\n    graph[i][0] -= 1\n    graph[i][1] -= 1\n    inv[graph[i][0]] += 1\n    outv[graph[i][1]] += 1\nS = set()\nfor (u, v) in graph:\n    if inv[u] > 1 and outv[v] > 1:\n        g[u].append(v)\n    else:\n        S.add((u, v))\nfor (a, b) in S:\n    inv[a] -= 1\n    outv[b] -= 1\nq = deque()\nfor i in range(n):\n    if outv[i] <= 0:\n        q.append(i)\ndp = [0] * n\nwhile q:\n    node = q.pop()\n    for nextNode in g[node]:\n        dp[nextNode] = max(dp[nextNode], dp[node] + 1)\n        outv[nextNode] -= 1\n        if outv[nextNode] == 0:\n            q.appendleft(nextNode)\nprint(max(dp) + 1)", "from collections import deque\n(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\nab = [list(map(int, input().split())) for _ in range(m)]\ninv = [0] * n\noutv = [0] * n\nfor i in range(m):\n    ab[i][0] -= 1\n    ab[i][1] -= 1\n    inv[ab[i][0]] += 1\n    outv[ab[i][1]] += 1\nS = set()\nfor (a, b) in ab:\n    if inv[a] > 1 and outv[b] > 1:\n        g[a].append(b)\n    else:\n        S.add((a, b))\nfor (a, b) in S:\n    inv[a] -= 1\n    outv[b] -= 1\ngo = deque()\nfor i in range(n):\n    if outv[i] <= 0:\n        go.append(i)\ndp = [0] * n\nwhile go:\n    node = go.pop()\n    for nex in g[node]:\n        dp[nex] = max(dp[nex], dp[node] + 1)\n        outv[nex] -= 1\n        if outv[nex] == 0:\n            go.appendleft(nex)\nprint(max(dp) + 1)"]