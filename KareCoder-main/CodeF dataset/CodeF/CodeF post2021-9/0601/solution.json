["import heapq\n\ndef solve(arr):\n    ranges_begin = [[] for _ in range(len(arr) + 1)]\n    for j in range(len(arr)):\n        val = arr[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = len(arr)\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0 for _ in range(len(arr))]\n    my_heap = []\n    for val in range(len(arr), 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    res_arr = solve(arr)\n    print(' '.join(map(str, res_arr)))", "import sys\nimport heapq\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    B = list(map(int, input().split()))\n    intervals = [[] for _ in range(n + 1)]\n    heads = []\n    for i in range(n):\n        f = (i + 1) // (B[i] + 1) + 1\n        b = (i + 1) // B[i] if B[i] else n\n        heapq.heappush(intervals[f], (b, i))\n    cnt = 1\n    ans = [0] * n\n    while cnt <= n:\n        if intervals[cnt]:\n            if heads and intervals[cnt][0][0] > heads[0][0]:\n                ans[heapq.heappop(heads)[-1]] = cnt\n            else:\n                ans[heapq.heappop(intervals[cnt])[-1]] = cnt\n            while intervals[cnt]:\n                heapq.heappush(heads, heapq.heappop(intervals[cnt]))\n        else:\n            ans[heapq.heappop(heads)[-1]] = cnt\n        cnt += 1\n    return ans\nfor _ in range(int(input())):\n    print(*solve())", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    b = map(int, input().split())\n    u = sorted((((i + 1) // (x + 1), n if x == 0 else (i + 1) // x, i) for (i, x) in enumerate(b)))\n    a = [0] * n\n    heap = []\n    j = 0\n    for i in range(n):\n        while j < n and u[j][0] <= i:\n            heapq.heappush(heap, u[j][1:])\n            j += 1\n        a[heapq.heappop(heap)[1]] = i + 1\n    print(*a)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    b = map(int, input().split())\n    u = sorted((((i + 1) // (x + 1), n if x == 0 else (i + 1) // x, i) for (i, x) in enumerate(b)))\n    a = [0] * n\n    heap = []\n    j = 0\n    for i in range(n):\n        while j < n and u[j][0] <= i:\n            heapq.heappush(heap, u[j][1:])\n            j += 1\n        a[heapq.heappop(heap)[1]] = i + 1\n    print(*a)", "import heapq\nfor _ in range(int(input())):\n    N = int(input())\n    Arr = list(map(int, input().split()))\n    ranges_begin = [[] for i in range(N + 1)]\n    for j in range(N):\n        val = Arr[j]\n        i = j + 1\n        min_real = i + 1 if val == 0 else i // (val + 1) + 1\n        max_real = N if val == 0 else i // val\n        ranges_begin[max_real].append((-min_real, j))\n    answer = [0] * N\n    my_heap = []\n    for val in range(N, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        answer[mini_of_heap[1]] = val\n    print(*answer)", "import heapq\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = sorted((((i + 1) // (x + 1), N if x == 0 else (i + 1) // x, i) for (i, x) in enumerate(A)))\n    answer = [0] * N\n    heap = []\n    j = 0\n    for i in range(N):\n        while j < N and B[j][0] <= i:\n            heapq.heappush(heap, B[j][1:])\n            j += 1\n        answer[heapq.heappop(heap)[1]] = i + 1\n    print(*answer)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    b = map(int, input().split())\n    u = sorted((((i + 1) // (x + 1), n if x == 0 else (i + 1) // x, i) for (i, x) in enumerate(b)))\n    a = [None] * n\n    heap = []\n    j = 0\n    for i in range(n):\n        while j < n and u[j][0] <= i:\n            heapq.heappush(heap, u[j][1:])\n            j += 1\n        a[heapq.heappop(heap)[1]] = i + 1\n    print(*a)", "import heapq\nfor _ in range(int(input())):\n    N = int(input())\n    Arr = list(map(int, input().split()))\n    ranges_begin = [[] for i in range(len(Arr) + 1)]\n    for j in range(len(Arr)):\n        val = Arr[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = len(Arr)\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    answer = [0 for i in range(len(Arr))]\n    my_heap = []\n    for val in range(len(Arr), 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        answer[mini_of_heap[1]] = val\n    print(*answer)", "import sys\nimport collections\n\ndef maximum(a, b):\n    return max(a, b)\n\ndef minimum(a, b):\n    return min(a, b)\n\ndef leftshift(a):\n    return a << 1\n\ndef INPUT():\n    return int(input())\n\ndef GINPUT():\n    return input()\n\ndef MAPINPUT():\n    return map(int, input().split())\n\ndef LIST_INPUT():\n    return list(map(int, input().split()))\nimport sys\ninput = sys.stdin.readline\nfrom heapq import heappush, heappop, heappushpop, heapify\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = list(map(int, input().split()))\n    L = []\n    for i in range(n):\n        l = (i + 1) // (b[i] + 1) + 1\n        if b[i] == 0:\n            r = n\n        else:\n            r = (i + 1) // b[i]\n        L.append((l, r, i + 1))\n    L.sort()\n    ans = [0] * n\n    l = []\n    idx = 0\n    for i in range(1, n + 1):\n        while idx < n and L[idx][0] <= i:\n            heappush(l, (L[idx][1], L[idx][2]))\n            idx += 1\n        (x, y) = heappop(l)\n        ans[y - 1] = i\n    print(*ans)", "import queue\nimport sys, math\nimport heapq\nfrom collections import deque\nfrom bisect import bisect_left, bisect_right\ninput = sys.stdin.readline\npop = heapq.heappop\npush = heapq.heappush\n\ndef ip():\n    return int(input())\n\ndef sp():\n    return str(input().rstrip())\n\ndef mip():\n    return map(int, input().split())\n\ndef msp():\n    return map(str, input().split())\n\ndef lmip():\n    return list(map(int, input().split()))\n\ndef lmsp():\n    return list(map(str, input().split()))\nfor tcs in range(int(input())):\n    n = ip()\n    b = [0] + [int(x) for x in input().split()]\n    a = []\n    for i in range(1, n + 1):\n        if b[i] == 0:\n            a.append([i + 1, n, i])\n        else:\n            a.append([i // (b[i] + 1) + 1, i // b[i], i])\n    a.sort(key=lambda x: (x[0], -x[1]))\n    pq = []\n    ans = [0] * n\n    now = 1\n    i = 0\n    f = 0\n    for f in range(n):\n        while i < n and a[i][0] <= now <= a[i][1]:\n            push(pq, [a[i][1], a[i][2]])\n            i += 1\n        g = pop(pq)\n        ans[g[1] - 1] = now\n        now += 1\n    print(*ans)", "from sys import stdin\ninput = stdin.readline\ninp = lambda : list(map(int, input().split()))\nimport heapq\n\ndef answer():\n    start = [[] for i in range(n + 2)]\n    end = [[] for i in range(n + 2)]\n    for i in range(n):\n        l = (i + 1) // (b[i] + 1)\n        if b[i]:\n            r = (i + 1) // b[i]\n        else:\n            r = n\n        start[l + 1].append([r, i])\n        end[r].append([r, i])\n    ans = [-1 for i in range(n)]\n    (take, done) = ([], dict())\n    for i in range(1, n + 1):\n        for x in start[i]:\n            heapq.heappush(take, x)\n        x = heapq.heappop(take)\n        while done.get(tuple(x), False):\n            x = heapq.heappop(take)\n        ans[x[1]] = i\n        for x in end[i]:\n            done[tuple(x)] = True\n    return ans\nfor T in range(int(input())):\n    n = int(input())\n    b = inp()\n    print(*answer())"]