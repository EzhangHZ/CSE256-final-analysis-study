["import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    (*a,) = map(int, input().split())\n    b = [None] * n\n    s = sum(a)\n    for i in range(n):\n        if a[i] > s // 2:\n            while a[i] > s // 2:\n                a[i] -= 1\n                s -= 1\n            break\n    c = []\n    for i in range(n):\n        for j in range(a[i]):\n            c.append(i)\n    if len(c) % 2 == 1:\n        c.pop()\n    r = []\n    for i in range(len(c) // 2):\n        r.append(str(c[i] + 1) + ' ' + str(c[i + len(c) // 2] + 1))\n    print(len(r))\n    if len(r) > 0:\n        print('\\n'.join(r))\nfor i in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    (*a,) = map(int, input().split())\n    b = [None] * n\n    for i in range(n):\n        b[i] = (-a[i], i)\n    b.sort()\n    c = []\n    l = 0\n    s = sum(a)\n    z = b[0][1]\n    while a[z] > s // 2:\n        a[z] -= 1\n        s -= 1\n    for i in range(n):\n        z = b[i][1]\n        for j in range(a[z]):\n            c.append(z)\n    if len(c) % 2 == 1:\n        c.pop()\n    r = []\n    for i in range(len(c) // 2):\n        r.append(str(c[i] + 1) + ' ' + str(c[i + len(c) // 2] + 1))\n    print(len(r))\n    if len(r) > 0:\n        print('\\n'.join(r))\nfor i in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    (*a,) = map(int, input().split())\n    b = [None] * n\n    for i in range(n):\n        b[i] = (-a[i], i)\n    b.sort()\n    c = []\n    l = 0\n    s = sum(a)\n    while True:\n        if a[b[0][1]] > s // 2:\n            for i in range(0, n):\n                z = b[i][1]\n                if a[z] > s // 2:\n                    a[z] -= 1\n                    s -= 1\n                else:\n                    break\n        else:\n            break\n    for i in range(n):\n        id = b[i][1]\n        for j in range(a[id]):\n            c.append(id)\n    if len(c) % 2 == 1:\n        c.pop()\n    r = []\n    for i in range(len(c) // 2):\n        r.append(str(c[i] + 1) + ' ' + str(c[i + len(c) // 2] + 1))\n    print(len(r))\n    if len(r) > 0:\n        print('\\n'.join(r))\nfor i in range(int(input())):\n    solve()", "import sys\nN = int(200000.0 + 5)\nsys.setrecursionlimit(N)\n\ndef charming():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = list(zip(a, range(1, n + 1)))\n    a.sort(key=lambda x: x[0], reverse=True)\n    res = list()\n    id = 0\n    for i in range(1, n):\n        while a[i][0] > 0 and a[id][0] > 0:\n            res += [[a[i][1], a[id][1]]]\n            a[id] = (a[id][0] - 1, a[id][1])\n            a[i] = (a[i][0] - 1, a[i][1])\n        if a[id][0] <= 0:\n            id = i\n    if a[id][0] > 0:\n        siz = len(res)\n        for i in range(siz):\n            if a[id][0] <= 0:\n                break\n            if res[i][0] != a[id][1] and res[i][1] != a[id][1]:\n                a[id] = (a[id][0] - 1, a[id][1])\n                tmp = res[i][0]\n                res[i][0] = a[id][1]\n                if a[id][0] > 0:\n                    res.append([tmp, a[id][1]])\n                    a[id] = (a[id][0] - 1, a[id][1])\n    print(len(res))\n    for (i, j) in res:\n        print(i, j)\nfor t in range(int(input())):\n    charming()", "import sys\nN = int(200000.0 + 5)\nsys.setrecursionlimit(N)\n\ndef charming():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a = list(zip(a, range(1, n + 1)))\n    a.sort(key=lambda x: x[0], reverse=True)\n    res = list()\n    id = 0\n    for i in range(1, n):\n        while a[i][0] > 0 and a[id][0] > 0:\n            res += [[a[i][1], a[id][1]]]\n            a[id] = (a[id][0] - 1, a[id][1])\n            a[i] = (a[i][0] - 1, a[i][1])\n        if a[id][0] <= 0:\n            id = i\n    if a[id][0] > 0:\n        siz = len(res)\n        for i in range(siz):\n            if a[id][0] <= 0:\n                break\n            if res[i][0] != a[id][1] and res[i][1] != a[id][1]:\n                a[id] = (a[id][0] - 1, a[id][1])\n                tmp = res[i][0]\n                res[i][0] = a[id][1]\n                if a[id][0] > 0:\n                    res.append([tmp, a[id][1]])\n                    a[id] = (a[id][0] - 1, a[id][1])\n    print(len(res))\n    for (i, j) in res:\n        print(i, j)\nfor t in range(int(input())):\n    charming()", "import sys\nimport math\nttime = int(input())\nfor ccount in range(ttime):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(n):\n        for j in range(a[i]):\n            b.append((a[i], i))\n    b.sort()\n    if len(b) % 2:\n        b.pop()\n    k = len(b) // 2\n    ans = []\n    for i in range(k):\n        if b[i][1] != b[i + k][1]:\n            ans.append((b[i][1], b[i + k][1]))\n    print(len(ans))\n    for x in ans:\n        print(x[0] + 1, x[1] + 1)", "import sys\ninput = sys.stdin.readline\nimport heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    h = []\n    people = 0\n    for i in range(n):\n        if a[i] > 0:\n            people += 1\n            heapq.heappush(h, (-a[i], i))\n    total = 0\n    meetings = []\n    while people > 1:\n        (x, i) = heapq.heappop(h)\n        (y, j) = heapq.heappop(h)\n        x += 1\n        y += 1\n        total += 1\n        meetings.append(str(i + 1) + ' ' + str(j + 1))\n        if x < 0:\n            heapq.heappush(h, (x, i))\n        if y < 0:\n            heapq.heappush(h, (y, j))\n        if x == 0:\n            people -= 1\n        if y == 0:\n            people -= 1\n    print(total)\n    if total > 0:\n        print('\\n'.join(meetings))", "def solution_d(l):\n    lidx = [(_, i + 1) for (i, _) in enumerate(l)]\n    lidx.sort()\n    l.sort()\n    if len(l) <= 1:\n        return (0, [])\n    if len(l) == 2:\n        return (l[0], [[1, 2] for _ in range(l[0])])\n    i = 0\n    cnt = 0\n    result = []\n    diff = sum(l) - 2 * l[-1]\n    while diff > 0:\n        while l[i] == 0:\n            i += 1\n        maxminus = min((diff + 1) // 2, l[i])\n        l[i] -= maxminus\n        l[i + 1] -= maxminus\n        result += [[lidx[i][1], lidx[i + 1][1]] for _ in range(maxminus)]\n        cnt += maxminus\n        diff -= 2 * maxminus\n    while i < len(l) - 1:\n        cnt += l[i]\n        result += [[lidx[i][1], lidx[len(l) - 1][1]] for _ in range(l[i])]\n        i += 1\n    return (cnt, result)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ri = input()\n    l = [int(_) for _ in ri.split(' ')]\n    (cnt, pairs) = solution_d(l)\n    print(cnt)\n    for (x, y) in pairs:\n        print(x, y)", "from heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heap = []\n    for i in range(n):\n        if arr[i] > 0:\n            heappush(heap, (-arr[i], i + 1))\n    ans = []\n    while len(heap) >= 2:\n        (s1, p1) = heappop(heap)\n        (s2, p2) = heappop(heap)\n        ans.append([p1, p2])\n        s1 += 1\n        s2 += 1\n        if s1 < 0:\n            heappush(heap, (s1, p1))\n        if s2 < 0:\n            heappush(heap, (s2, p2))\n    sys.stdout.write(str(len(ans)) + '\\n')\n    for p in ans:\n        sys.stdout.write(str(p[0]) + ' ' + str(p[1]) + '\\n')", "from heapq import heappop, heappush\nimport sys\ninput = sys.stdin.readline\ninp = sys.stdin.readline\n\ndef input():\n    return inp().strip()\n\ndef ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(map(int, input().split()))\n\ndef solve():\n    n = ii()\n    arr = li()\n    queue = []\n    for i in range(1, n + 1):\n        if arr[i - 1] != 0:\n            heappush(queue, (-1 * arr[i - 1], i))\n    ans = []\n    count = 0\n    while queue:\n        if len(queue) > 1:\n            (fp, f) = heappop(queue)\n            (sp, s) = heappop(queue)\n            count += 1\n            ans.append((f, s))\n            if fp + 1 != 0:\n                heappush(queue, (fp + 1, f))\n            if sp + 1 != 0:\n                heappush(queue, (sp + 1, s))\n        else:\n            break\n    print(count)\n    for (x, y) in ans:\n        print(x, y)\n\ndef main():\n    t = ii()\n    for _ in range(t):\n        solve()\nmain()", "from heapq import heapify, heappop, heappush\n\nclass Solution:\n\n    def productiveMeetings(self, n, ais):\n        pq = []\n        for (i, ai) in enumerate(ais):\n            if ai != 0:\n                heappush(pq, (-ai, i + 1))\n        vals = []\n        while len(pq) > 1:\n            (ai1, idx1) = heappop(pq)\n            (ai2, idx2) = heappop(pq)\n            vals.append((idx1, idx2))\n            ai1 += 1\n            ai2 += 1\n            if ai1 != 0:\n                heappush(pq, (ai1, idx1))\n            if ai2 != 0:\n                heappush(pq, (ai2, idx2))\n        print(len(vals))\n        for ps in vals:\n            print(*ps)\nsol = Solution()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ais = list(map(int, input().split()))\n    sol.productiveMeetings(n, ais)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    (*a,) = map(int, input().split())\n    b = [None] * n\n    for i in range(n):\n        b[i] = (-a[i], i)\n    b.sort()\n    c = []\n    l = 0\n    s = sum(a)\n    while True:\n        done = True\n        for i in range(0, n):\n            z = b[i][1]\n            if a[i] > s // 2:\n                a[i] -= 1\n                s -= 1\n                done = False\n        if done:\n            break\n    for i in range(n):\n        id = b[i][1]\n        for j in range(a[id]):\n            c.append(id)\n    if len(c) % 2 == 1:\n        c.pop()\n    r = []\n    for i in range(len(c) // 2):\n        r.append(str(c[i] + 1) + ' ' + str(c[i + len(c) // 2] + 1))\n    print(len(r))\n    if len(r) > 0:\n        print('\\n'.join(r))\nfor i in range(int(input())):\n    solve()", "from heapq import heapify, heappop, heappush\n\ndef f():\n    n = int(input())\n    l = list(map(int, input().split()))\n    m = []\n    for (i, x) in enumerate(l):\n        if x != 0:\n            m.append((-x, i + 1))\n    heapify(m)\n    c = 0\n    t = []\n    while len(m) > 1:\n        (a, b) = heappop(m)\n        (x, y) = heappop(m)\n        c += 1\n        t.append([b, y])\n        a += 1\n        x += 1\n        if a != 0:\n            heappush(m, (a, b))\n        if x != 0:\n            heappush(m, (x, y))\n    print(len(t))\n    for i in t:\n        print(*i)\nfor _ in range(int(input())):\n    f()", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import sys, math, collections\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nMOD = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    arr = get_array()\n    A = [[arr[i], i + 1] for i in range(n)]\n    A.sort()\n    s = sum([A[i][0] for i in range(n - 1)])\n    mx = A[-1][0]\n    ans = []\n    for i in range(n - 1):\n        if s <= mx:\n            break\n        while s > mx and A[i][0]:\n            ans.append((A[i][1], A[i + 1][1]))\n            A[i][0] -= 1\n            A[i + 1][0] -= 1\n            s -= 2\n    for i in range(n - 1):\n        while A[i][0] and mx:\n            ans.append((A[i][1], A[-1][1]))\n            A[i][0] -= 1\n            mx -= 1\n    print(len(ans))\n    for ele in ans:\n        print(*ele)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heapify, heappop, heappush\n\ndef f():\n    n = int(input())\n    l = list(map(int, input().split()))\n    m = []\n    for (i, x) in enumerate(l):\n        if x != 0:\n            m.append((-x, i + 1))\n    heapify(m)\n    c = 0\n    t = []\n    while len(m) > 1:\n        (a, b) = heappop(m)\n        (x, y) = heappop(m)\n        c += 1\n        t.append([b, y])\n        a += 1\n        x += 1\n        if a != 0:\n            heappush(m, (a, b))\n        if x != 0:\n            heappush(m, (x, y))\n    print(len(t))\n    for i in t:\n        print(*i)\nfor _ in range(int(input())):\n    f()", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import heapq\nfor _ in range(int(input())):\n    input()\n    heap = []\n    for (i, x) in enumerate(map(int, input().split())):\n        if x:\n            heapq.heappush(heap, (-x, i))\n    talks = []\n    while len(heap) > 1:\n        (x, i) = heapq.heappop(heap)\n        (y, j) = heapq.heappop(heap)\n        if x != -1:\n            heapq.heappush(heap, (x + 1, i))\n        if y != -1:\n            heapq.heappush(heap, (y + 1, j))\n        talks.append((i, j))\n    print(len(talks))\n    for (i, j) in talks:\n        print(i + 1, j + 1)", "import sys\nimport heapq\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(n, arr):\n    final = []\n    temp = []\n    for (i, ele) in enumerate(arr):\n        if ele != 0:\n            temp.append([-ele, i + 1])\n    heapq.heapify(temp)\n    l = len(temp)\n    while l > 1:\n        f = heapq.heappop(temp)\n        s = heapq.heappop(temp)\n        l -= 2\n        c1 = abs(f[0])\n        c2 = abs(s[0])\n        c1 -= 1\n        c2 -= 1\n        final.append([f[1], s[1]])\n        if c1 > 0:\n            heapq.heappush(temp, [-c1, f[1]])\n            l += 1\n        if c2 > 0:\n            heapq.heappush(temp, [-c2, s[1]])\n            l += 1\n    sys.stdout.write(str(len(final)) + '\\n')\n    for ele in final:\n        sys.stdout.write(' '.join(map(str, ele)) + '\\n')\nT = get_int()\nwhile T:\n    n = get_int()\n    arr = get_list()\n    solve(n, arr)\n    T -= 1", "import collections\nimport math\nfrom functools import lru_cache\nimport heapq\n\ndef process(tc, N, A):\n    res = 0\n    h = []\n    out = []\n    for i in range(N):\n        if A[i] > 0:\n            heapq.heappush(h, (-A[i], i + 1))\n    while len(h) > 1:\n        (fc, f) = heapq.heappop(h)\n        (sc, s) = heapq.heappop(h)\n        res += 1\n        fc += 1\n        sc += 1\n        out.append([f, s])\n        if fc < 0:\n            heapq.heappush(h, (fc, f))\n        if sc < 0:\n            heapq.heappush(h, (sc, s))\n    print(res)\n    if res:\n        for v in out:\n            print(*v)\ntcs = int(input())\nfor tc in range(tcs):\n    N = int(input())\n    A = list(map(int, input().split()))\n    process(tc + 1, N, A)", "from heapq import heappush, heappop\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappop, heappush\n\ndef cf_744D(numbers: list):\n    heap = []\n    for (index, num) in enumerate(numbers, start=1):\n        if num:\n            heappush(heap, (-num, index))\n    answer = []\n    while len(heap) > 1:\n        (a, x) = heappop(heap)\n        (b, y) = heappop(heap)\n        answer.append((x, y))\n        if a + 1:\n            heappush(heap, (a + 1, x))\n        if b + 1:\n            heappush(heap, (b + 1, y))\n    return answer\nfor _ in range(int(input())):\n    input()\n    answer = cf_744D(list(map(int, input().split())))\n    print(len(answer))\n    for a in answer:\n        print(*a)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heap = []\n    ans = []\n    x = 1\n    for element in arr:\n        if element != 0:\n            heapq.heappush(heap, (-element, x))\n        x += 1\n    while len(heap) > 1:\n        (first, id1) = heapq.heappop(heap)\n        (second, id2) = heapq.heappop(heap)\n        if first + 1 != 0:\n            heapq.heappush(heap, (first + 1, id1))\n        if second + 1 != 0:\n            heapq.heappush(heap, (second + 1, id2))\n        ans.append((id1, id2))\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    q = []\n    x = 1\n    ans = []\n    for c in A:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, d) = heappop(q)\n        (e, f) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, d))\n        if e + 1 != 0:\n            heappush(q, (e + 1, f))\n        ans.append([d, f])\n    print(len(ans))\n    for i in ans:\n        print(*i)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import heapq\nnumCases = int(input())\nfor _ in range(numCases):\n    n = int(input())\n    invertedSocial = []\n    temp = [int(x) for x in input().split()]\n    for ind in range(len(temp)):\n        if temp[ind] != 0:\n            heapq.heappush(invertedSocial, (-temp[ind], ind + 1))\n    numMeetings = 0\n    meetings = []\n    heapq.heapify(invertedSocial)\n    while True:\n        if len(invertedSocial) < 2:\n            break\n        (v1, p1) = heapq.heappop(invertedSocial)\n        (v2, p2) = heapq.heappop(invertedSocial)\n        v1 = -v1\n        v2 = -v2\n        meetings.append(str(p1) + ' ' + str(p2))\n        numMeetings += 1\n        if v1 - 1 > 0:\n            heapq.heappush(invertedSocial, (-v1 + 1, p1))\n        if v2 - 1 > 0:\n            heapq.heappush(invertedSocial, (-v2 + 1, p2))\n    print(numMeetings)\n    for each in meetings:\n        print(each)", "from heapq import heappush, heappop\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappush, heappop\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    peeps = list(map(int, input().split()))\n    ans = []\n    a = [(-i, index) for (index, i) in enumerate(peeps, start=1) if i]\n    heapq.heapify(a)\n    while len(a) > 1:\n        (p1, i1) = heapq.heappop(a)\n        (p2, i2) = heapq.heappop(a)\n        p1 += 1\n        p2 += 1\n        ans.append([i1, i2])\n        if p1:\n            heapq.heappush(a, (p1, i1))\n        if p2:\n            heapq.heappush(a, (p2, i2))\n    print(len(ans))\n    for i in ans:\n        print(*i)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappop, heappush\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = []\n    he = []\n    for i in range(n):\n        if a[i] > 0:\n            heapq.heappush(he, (-a[i], i + 1))\n    while len(he) > 1:\n        (x, i1) = heapq.heappop(he)\n        (y, i2) = heapq.heappop(he)\n        ans.append([i1, i2])\n        x += 1\n        y += 1\n        if x < 0:\n            heapq.heappush(he, (x, i1))\n        if y < 0:\n            heapq.heappush(he, (y, i2))\n    if len(ans) >= 1:\n        print(len(ans))\n        for i in ans:\n            print(*i)\n    else:\n        print(0)", "from heapq import heappush, heappop\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1:\n            heappush(q, (c + 1, x))\n        if d + 1:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappop, heappush\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappush, heappop\nfor t in range(int(input())):\n    n = input()\n    a = list(map(int, input().split()))\n    q = []\n    ans = []\n    x = 1\n    for c in a:\n        if c != 0:\n            heappush(q, (-c, x))\n        x += 1\n    while len(q) > 1:\n        (c, x) = heappop(q)\n        (d, y) = heappop(q)\n        if c + 1 != 0:\n            heappush(q, (c + 1, x))\n        if d + 1 != 0:\n            heappush(q, (d + 1, y))\n        ans += ((x, y),)\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import heapq as hp\nt = int(input())\nfor i in range(t):\n    answers = [[] for i in range(2)]\n    _ = int(input())\n    heap = [(-1 * int(item), idx + 1) for (idx, item) in enumerate(input().split()) if int(item) > 0]\n    hp.heapify(heap)\n    while len(heap) >= 2:\n        person1 = hp.heappop(heap)\n        person2 = hp.heappop(heap)\n        answers[0].append(person1[1])\n        answers[1].append(person2[1])\n        if person1[0] <= -2:\n            hp.heappush(heap, (person1[0] + 1, person1[1]))\n        if person2[0] <= -2:\n            hp.heappush(heap, (person2[0] + 1, person2[1]))\n    print(len(answers[0]))\n    for (i, ele) in enumerate(answers[0]):\n        print(answers[1][i], answers[0][i])", "from heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    s = int(input())\n    r = list(map(int, input().split()))\n    m = []\n    result = []\n    count = 0\n    for (i, e) in enumerate(r):\n        if e != 0:\n            m.append((-1 * e, i + 1))\n    heapify(m)\n    while len(m) > 1:\n        (x, y) = heappop(m)\n        x = -x\n        (a, b) = heappop(m)\n        a = -a\n        count += a\n        result.append((y, b))\n        x -= 1\n        a -= 1\n        if x > 0:\n            heappush(m, (-x, y))\n        if a > 0:\n            heappush(m, (-a, b))\n    print(len(result))\n    for (x, y) in result:\n        print(x, y)", "from heapq import heappush, heappop\nfor i in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    h = []\n    z = 0\n    ans = 0\n    talks = []\n    for i in s:\n        if i != 0:\n            heappush(h, (-i, z))\n        z += 1\n    while len(h) > 1:\n        (a, x) = heappop(h)\n        (b, y) = heappop(h)\n        if a != -1:\n            heappush(h, (a + 1, x))\n        if b != -1:\n            heappush(h, (b + 1, y))\n        talks += [[x + 1, y + 1]]\n        ans += 1\n    print(ans)\n    for i in talks:\n        print(*i)", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    meet = [[-arr[i], i] for i in range(n) if arr[i] != 0]\n    heapify(meet)\n    ans = []\n    while len(meet) > 1:\n        p1 = heappop(meet)\n        p2 = heappop(meet)\n        p1[0] += 1\n        p2[0] += 1\n        ans.append([p1[1] + 1, p2[1] + 1])\n        if p1[0] != 0:\n            heappush(meet, p1)\n        if p2[0] != 0:\n            heappush(meet, p2)\n    print(len(ans))\n    for x in ans:\n        print(*x)", "import collections\nfrom math import ceil, gcd, sqrt, log\nfrom heapq import *\nINF = float('inf')\nmod = 1000000007\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    maxHeap = []\n    for i in range(n):\n        if A[i] > 0:\n            k = [-A[i], i]\n            heappush(maxHeap, k)\n    count = 0\n    ans = []\n    while len(maxHeap) > 1:\n        x = heappop(maxHeap)\n        y = heappop(maxHeap)\n        net = [x[1] + 1, y[1] + 1]\n        ans.append(net)\n        count += 1\n        k1 = -x[0]\n        k2 = -y[0]\n        if k1 - 1 > 0:\n            net = [-(k1 - 1), x[1]]\n            heappush(maxHeap, net)\n        if k2 - 1 > 0:\n            net = [-(k2 - 1), y[1]]\n            heappush(maxHeap, net)\n    print(count)\n    for i in ans:\n        print(*i)\nt = int(input())\nwhile t != 0:\n    solve()\n    t -= 1", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heap = []\n    for i in range(n):\n        if arr[i] > 0:\n            heappush(heap, (-arr[i], i + 1))\n    ans = []\n    while len(heap) >= 2:\n        (s1, p1) = heappop(heap)\n        (s2, p2) = heappop(heap)\n        ans.append([p1, p2])\n        s1 += 1\n        s2 += 1\n        if s1 < 0:\n            heappush(heap, (s1, p1))\n        if s2 < 0:\n            heappush(heap, (s2, p2))\n    print(len(ans))\n    for p in ans:\n        print(p[0], p[1])", "import sys, math, collections\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nMOD = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    arr = get_array()\n    A = [[arr[i], i + 1] for i in range(n)]\n    A.sort()\n    s = 0\n    for i in range(n - 1):\n        s += A[i][0]\n    mx = A[-1][0]\n    ans = []\n    for i in range(n - 1):\n        if s <= mx:\n            break\n        while s > mx and A[i][0]:\n            ans.append((A[i][1], A[i + 1][1]))\n            A[i][0] -= 1\n            A[i + 1][0] -= 1\n            s -= 2\n    for i in range(n - 1):\n        while A[i][0] and mx:\n            ans.append((A[i][1], A[-1][1]))\n            A[i][0] -= 1\n            mx -= 1\n    print(len(ans))\n    for ele in ans:\n        print(*ele)", "for _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = []\n    for i in range(n):\n        if ar[i] == 0:\n            pass\n        else:\n            arr.append([-ar[i], i + 1])\n    ans = 0\n    li = []\n    import heapq\n    heapq.heapify(arr)\n    while len(arr) > 1:\n        fst = heapq.heappop(arr)\n        snd = heapq.heappop(arr)\n        ans += -1\n        if fst[0] + 1:\n            heapq.heappush(arr, [fst[0] + 1, fst[1]])\n        if snd[0] + 1:\n            heapq.heappush(arr, [snd[0] + 1, snd[1]])\n        li.append(str(snd[1]) + ' ' + str(fst[1]))\n    print(-ans)\n    for x in li:\n        print(x)", "from heapq import heappop, heappush\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    soc = list(map(int, input().split()))\n    heap = []\n    for i in range(len(soc)):\n        if soc[i] > 0:\n            heappush(heap, (-soc[i], i + 1))\n    sol = []\n    while len(heap) > 1:\n        (s1, i1) = heappop(heap)\n        (s2, i2) = heappop(heap)\n        sol.append([i1, i2])\n        s1 += 1\n        s2 += 1\n        if s1 < 0:\n            heappush(heap, (s1, i1))\n        if s2 < 0:\n            heappush(heap, (s2, i2))\n    print(len(sol))\n    for (i, j) in sol:\n        print(i, j)", "import sys\nimport heapq\ninput = sys.stdin.readline\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    h = []\n    x = []\n    for i in range(n):\n        if a[i] > 0:\n            heapq.heappush(h, (-a[i], i + 1))\n    while len(h) > 1:\n        (f, fi) = heapq.heappop(h)\n        (s, si) = heapq.heappop(h)\n        ans += 1\n        f += 1\n        s += 1\n        x.append([fi, si])\n        if f < 0:\n            heapq.heappush(h, (f, fi))\n        if s < 0:\n            heapq.heappush(h, (s, si))\n    print(ans)\n    if ans:\n        for i in x:\n            print(*i)\n    t -= 1", "import heapq as hp\nt = int(input())\nfor i in range(t):\n    answers = [[] for i in range(2)]\n    n = int(input())\n    arr = [int(el) for el in input().split()]\n    heap = []\n    for i in range(n):\n        if arr[i] > 0:\n            heap.append((-1 * arr[i], i + 1))\n    hp.heapify(heap)\n    while len(heap) >= 2:\n        person1 = hp.heappop(heap)\n        person2 = hp.heappop(heap)\n        answers[0].append(person1[1])\n        answers[1].append(person2[1])\n        if person1[0] <= -2:\n            hp.heappush(heap, (person1[0] + 1, person1[1]))\n        if person2[0] <= -2:\n            hp.heappush(heap, (person2[0] + 1, person2[1]))\n    print(len(answers[0]))\n    for (i, ele) in enumerate(answers[0]):\n        print(answers[1][i], answers[0][i])", "from heapq import heappush, heappop\n\ndef gs():\n    return input()\n\ndef gi():\n    return int(input())\n\ndef gl():\n    return list(map(int, input().split()))\n\ndef gt():\n    return map(int, input().split())\nt = gi()\nfor _ in range(t):\n    n = gi()\n    array = gl()\n    heap = []\n    for i in range(n):\n        if array[i]:\n            heappush(heap, (-array[i], i + 1))\n    talks = []\n    while len(heap) > 1:\n        (one, i) = heappop(heap)\n        (two, j) = heappop(heap)\n        one += 1\n        two += 1\n        talks.append([i, j])\n        if one < 0:\n            heappush(heap, (one, i))\n        if two < 0:\n            heappush(heap, (two, j))\n    print(len(talks))\n    for talk in talks:\n        print(*talk)", "from heapq import *\nfrom sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    meet = [[-arr[i], i] for i in range(n) if arr[i] != 0]\n    heapify(meet)\n    ans = []\n    while len(meet) > 1:\n        p1 = heappop(meet)\n        p2 = heappop(meet)\n        p1[0] += 1\n        p2[0] += 1\n        ans.append([p1[1] + 1, p2[1] + 1])\n        if p1[0] != 0:\n            heappush(meet, p1)\n        if p2[0] != 0:\n            heappush(meet, p2)\n    print(len(ans))\n    for x in ans:\n        print(*x)", "from heapq import heappush, heappop, heapify\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heap = [(-arr[i], i) for i in range(n)]\n    heapify(heap)\n    ans = []\n    while True:\n        (a, x1) = heappop(heap)\n        (b, x2) = heappop(heap)\n        if a == 0 or b == 0:\n            break\n        ans.append([x1 + 1, x2 + 1])\n        heappush(heap, (a + 1, x1))\n        heappush(heap, (b + 1, x2))\n    print(len(ans))\n    for each in ans:\n        print(*each)", "from collections import defaultdict, deque, Counter\nfrom functools import lru_cache\nfrom heapq import heappush, heappop\nfrom bisect import bisect_right, bisect_left\n\ndef inpNum():\n    return int(input())\n\ndef inpStr():\n    return input()\n\ndef inpSepNum():\n    return map(int, input().split())\n\ndef inpNumList():\n    return list(map(int, input().split()))\n\ndef inpChList():\n    return list(input().split())\n\ndef finder(n, nums):\n    maxH = []\n    ans = 0\n    res = []\n    for i in range(n):\n        if nums[i] != 0:\n            heappush(maxH, (-nums[i], i + 1))\n    while len(maxH) > 1:\n        mx1 = heappop(maxH)\n        mx2 = heappop(maxH)\n        newmx1 = mx1[0] + 1\n        newmx2 = mx2[0] + 1\n        ans += 1\n        if newmx2:\n            heappush(maxH, (newmx2, mx2[1]))\n        if newmx1:\n            heappush(maxH, (newmx1, mx1[1]))\n        res.append([mx2[1], mx1[1]])\n    return (ans, res)\ntc = inpNum()\nfor _ in range(tc):\n    n = inpNum()\n    nums = inpNumList()\n    (answer, result) = finder(n, nums)\n    if not answer:\n        print(0)\n    else:\n        print(answer)\n        for r in sorted(result):\n            print(*r)", "from heapq import heappush, heappop, heapify\n\ndef getIntegerInputs():\n    return map(int, input().split())\n\ndef getListInput():\n    return list(map(int, input().split()))\n\ndef inbound(r, c, n, m):\n    return 0 <= r < n and 0 <= c < m\n\ndef solve():\n    for _ in range(int(input())):\n        ans = []\n        n = int(input())\n        arr = getListInput()\n        heap = [(-val, i) for (i, val) in enumerate(arr)]\n        heapify(heap)\n        while len(heap) > 1:\n            r = heappop(heap)\n            l = heappop(heap)\n            if r[0] == 0 or l[0] == 0:\n                break\n            heappush(heap, (l[0] + 1, l[1]))\n            heappush(heap, (r[0] + 1, r[1]))\n            ans.append((r[1] + 1, l[1] + 1))\n        print(len(ans))\n        for a in ans:\n            print(*a)\nsolve()", "import heapq\n\ndef solve(n, array):\n    modified = []\n    for i in range(n):\n        if array[i] != 0:\n            heapq.heappush(modified, [-array[i], i + 1])\n    heapq.heapify(modified)\n    result = []\n    count = 0\n    while len(modified) > 1:\n        (first, firstIndex) = heapq.heappop(modified)\n        (second, secondIndex) = heapq.heappop(modified)\n        if first + 1 != 0:\n            heapq.heappush(modified, [first + 1, firstIndex])\n        if second + 1 != 0:\n            heapq.heappush(modified, [second + 1, secondIndex])\n        result.append([firstIndex, secondIndex])\n        count += 1\n    return [count, result]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    array = [int(x) for x in input().split()]\n    (count, result) = solve(n, array)\n    print(count)\n    for x in result:\n        print(x[0], x[1])", "t = int(input())\nimport heapq\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    maxHeap = []\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            maxHeap.append((-arr[i], i))\n    heapq.heapify(maxHeap)\n    answer = []\n    while len(maxHeap) > 1:\n        (first, fidx) = heapq.heappop(maxHeap)\n        (second, sidx) = heapq.heappop(maxHeap)\n        answer.append([sidx + 1, fidx + 1])\n        if -1 * first - 1 > 0:\n            heapq.heappush(maxHeap, (first + 1, fidx))\n        if -1 * second - 1 > 0:\n            heapq.heappush(maxHeap, (second + 1, sidx))\n    print(len(answer))\n    for a in answer:\n        print(*a)", "import heapq\n\ndef solve(n, array):\n    modified = []\n    for i in range(n):\n        if array[i] != 0:\n            heapq.heappush(modified, [-array[i], i + 1])\n    heapq.heapify(modified)\n    result = []\n    count = 0\n    while len(modified) > 1:\n        (first, firstIndex) = heapq.heappop(modified)\n        (second, secondIndex) = heapq.heappop(modified)\n        if first + 1 != 0:\n            heapq.heappush(modified, [first + 1, firstIndex])\n        if second + 1 != 0:\n            heapq.heappush(modified, [second + 1, secondIndex])\n        result.append([firstIndex, secondIndex])\n        count += 1\n    return [count, result]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    array = [int(x) for x in input().split()]\n    (count, result) = solve(n, array)\n    print(count)\n    for x in result:\n        print(x[0], x[1])", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    people = list(map(int, input().split()))\n    h = []\n    for i in range(n):\n        if people[i] != 0:\n            heapq.heappush(h, [-people[i], i])\n    ans = []\n    while len(h) > 1:\n        a = heapq.heappop(h)\n        b = heapq.heappop(h)\n        a[0] = a[0] + 1\n        b[0] = b[0] + 1\n        if a[0] != 0:\n            heapq.heappush(h, a)\n        if b[0] != 0:\n            heapq.heappush(h, b)\n        ans.append([a[1] + 1, b[1] + 1])\n    print(len(ans))\n    for r in ans:\n        print(*r)", "import heapq\nfor i in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    arr = []\n    c = 0\n    for i in ar:\n        if i != 0:\n            arr.append([-1 * i, c])\n        c += 1\n    heapq.heapify(arr)\n    ans = []\n    while len(arr) > 1:\n        x = heapq.heappop(arr)\n        y = heapq.heappop(arr)\n        ans.append([x[1] + 1, y[1] + 1])\n        x[0] += 1\n        y[0] += 1\n        if x[0] < 0:\n            heapq.heappush(arr, x)\n        if y[0] < 0:\n            heapq.heappush(arr, y)\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import heapq\n\ndef solve():\n    N = int(input())\n    arr = list(map(int, input().split()))\n    data = []\n    output = []\n    for i in range(N):\n        if arr[i] > 0:\n            data.append([-arr[i], i + 1])\n    heapq.heapify(data)\n    while len(data) > 1:\n        a1 = heapq.heappop(data)\n        b1 = heapq.heappop(data)\n        output.append([a1[1], b1[1]])\n        if a1[0] < -1:\n            heapq.heappush(data, [a1[0] + 1, a1[1]])\n        if b1[0] < -1:\n            heapq.heappush(data, [b1[0] + 1, b1[1]])\n    return output\nremained_test_cases = 1\nremained_test_cases = int(input())\nwhile remained_test_cases > 0:\n    output = solve()\n    print(len(output))\n    for i in range(len(output)):\n        print(output[i][0], output[i][1])\n    remained_test_cases -= 1", "import heapq\nfor case in range(int(input())):\n    ans = 0\n    n = int(input())\n    soci = list(map(int, input().split()))\n    soci_maxheap = [(-i, i, idx + 1) for (idx, i) in enumerate(soci)]\n    heapq.heapify(soci_maxheap)\n    out = []\n    while True:\n        maxi = heapq.heappop(soci_maxheap)\n        maxi_2 = heapq.heappop(soci_maxheap)\n        if maxi_2[0] == 0:\n            break\n        out.append((maxi[2], maxi_2[2]))\n        after = (maxi[0] + 1, maxi[1], maxi[2])\n        after_2 = (maxi_2[0] + 1, maxi_2[1], maxi_2[2])\n        ans += 1\n        heapq.heappush(soci_maxheap, after)\n        heapq.heappush(soci_maxheap, after_2)\n    print(ans)\n    for i in out:\n        print(*i)", "import heapq\ntest = eval(input())\nfor i in range(test):\n    n = eval(input())\n    numbers = list(map(int, input().split()))\n    heap = []\n    ans = []\n    for i in range(len(numbers)):\n        heapq.heappush(heap, (-numbers[i], i + 1))\n    while True:\n        (x, i) = heapq.heappop(heap)\n        (y, j) = heapq.heappop(heap)\n        if x == 0 or y == 0:\n            break\n        ans.append([i, j])\n        heapq.heappush(heap, (x + 1, i))\n        heapq.heappush(heap, (y + 1, j))\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import heapq\nimport math\nimport sys\nimport collections\nimport bisect\nimport random\nimport itertools\nimport string\nfrom collections import Counter, defaultdict\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nfor t in range(int(input())):\n    n = int(input())\n    temp = get_list()\n    arr = []\n    for (i, j) in enumerate(temp):\n        if j == 0:\n            continue\n        arr.append([-j, i + 1])\n    heapq.heapify(arr)\n    ans = []\n    while len(arr) > 1:\n        (m1, p1) = heapq.heappop(arr)\n        (m2, p2) = heapq.heappop(arr)\n        ans.append([p1, p2])\n        m1 += 1\n        m2 += 1\n        if m1 != 0:\n            heapq.heappush(arr, [m1, p1])\n        if m2 != 0:\n            heapq.heappush(arr, [m2, p2])\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import heapq\n\ndef get_first_and_second_largest(A):\n    fl = A[0]\n    fli = 0\n    sl = -math.inf\n    sli = -1\n    for i in range(1, len(A)):\n        v = A[i]\n        if v >= fl:\n            sl = fl\n            sli = fli\n            fl = v\n            fli = i\n        elif v > sl:\n            sl = v\n            sli = i\n    assert sl != -math.inf\n    assert sli != fli\n    return ((fl, fli), (sl, sli))\n\ndef main():\n    t = int(input())\n    i = 0\n    for _ in range(t):\n        i += 1\n        n = int(input())\n        A = [int(i) for i in input().split(' ')]\n        heap = [(-v, i) for (i, v) in enumerate(A)]\n        heapq.heapify(heap)\n        c = 0\n        ans = []\n        while True:\n            (_, i) = heapq.heappop(heap)\n            (_, j) = heapq.heappop(heap)\n            if A[j] == 0:\n                break\n            c += 1\n            ans.append(sorted([i + 1, j + 1]))\n            A[i] -= 1\n            A[j] -= 1\n            heapq.heappush(heap, (-A[i], i))\n            heapq.heappush(heap, (-A[j], j))\n        print(c)\n        for (l, r) in ans:\n            print(l, r)\nmain()", "from heapq import *\nfrom sys import stdin\nread = stdin.readline\nfor _ in range(int(read())):\n    n = int(read())\n    arr = list(map(int, read().split()))\n    arr = [[-arr[i], i] for i in range(n)]\n    heapify(arr)\n    ans = []\n    while 1:\n        l1 = heappop(arr)\n        l2 = heappop(arr)\n        if l1[0] == 0 or l2[0] == 0:\n            break\n        l1[0] += 1\n        l2[0] += 1\n        heappush(arr, l1)\n        heappush(arr, l2)\n        ans.append((l1[1] + 1, l2[1] + 1))\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import heapq as hp\nI = lambda : list(map(int, input().split()))\nfor tc in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    mx = []\n    for i in range(n):\n        if ar[i] > 0:\n            hp.heappush(mx, [-ar[i], i])\n    ans = 0\n    temp = []\n    while len(mx) > 1:\n        l = hp.heappop(mx)\n        r = hp.heappop(mx)\n        l[0] = l[0] * -1\n        r[0] = r[0] * -1\n        temp.append([l[1] + 1, r[1] + 1])\n        l[0] -= 1\n        r[0] -= 1\n        ans += 1\n        if l[0] > 0:\n            hp.heappush(mx, [-l[0], l[1]])\n        if r[0] > 0:\n            hp.heappush(mx, [-r[0], r[1]])\n    print(ans)\n    for i in temp:\n        print(*i)", "from math import *\nfrom collections import *\nfrom functools import *\nfrom bisect import *\nfrom itertools import *\nfrom heapq import *\nimport sys\ninf = float('inf')\nninf = -float('inf')\nip = input\nalphal = 'abcdefghijklmnopqrstuvwxyz'\nalphau = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nmod = 10 ** 9 + 7\n\ndef ipl():\n    return list(map(int, ip().split()))\n\ndef ipn():\n    return int(ip())\n\ndef ipf():\n    return float(ip())\n\ndef solve():\n    n = ipn()\n    a = ipl()\n    if n == 1:\n        print(0)\n        return\n    heap = []\n    for i in range(n):\n        if a[i] != 0:\n            heappush(heap, (-a[i], i + 1))\n        a[i] = [a[i], i + 1]\n    r = []\n    c = set()\n    while len(heap) > 1:\n        (e1, i) = heappop(heap)\n        (e2, j) = heappop(heap)\n        e1 += 1\n        e2 += 1\n        r.append((i, j))\n        if e1 < 0:\n            heappush(heap, (e1, i))\n        if e2 < 0:\n            heappush(heap, (e2, j))\n        i += 1\n    print(len(r))\n    for (i, j) in r:\n        print(i, j)\nt = ipn()\nfor _ in range(t):\n    solve()", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = [[-arr[i], i] for i in range(n)]\n    heapify(arr)\n    ans = []\n    while 1:\n        l1 = heappop(arr)\n        l2 = heappop(arr)\n        if l1[0] == 0 or l2[0] == 0:\n            break\n        l1[0] += 1\n        l2[0] += 1\n        heappush(arr, l1)\n        heappush(arr, l2)\n        ans.append((l1[1] + 1, l2[1] + 1))\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = []\n    for i in range(n):\n        q.append((-a[i], i + 1))\n    heapq.heapify(q)\n    ans = 0\n    l = []\n    while True:\n        (x1, y1) = heapq.heappop(q)\n        (x2, y2) = heapq.heappop(q)\n        x1 = -x1\n        x2 = -x2\n        if x1 == 0 or x2 == 0:\n            break\n        ans += 1\n        l.append([y1, y2])\n        heapq.heappush(q, (-max(x1 - 1, 0), y1))\n        heapq.heappush(q, (-max(x2 - 1, 0), y2))\n    print(ans)\n    for (x, y) in l:\n        print(x, y)", "from collections import deque, defaultdict, Counter\nfrom itertools import product, groupby, permutations, combinations, accumulate, zip_longest, combinations_with_replacement\nfrom math import gcd, floor, inf, log2, sqrt, log10, factorial\nfrom bisect import bisect_right, bisect_left, insort_left\nfrom statistics import mode\nfrom string import ascii_lowercase, ascii_uppercase\nfrom heapq import heapify, heappop, heappush, heappushpop, heapreplace, nlargest, nsmallest, merge\nfrom copy import deepcopy\nfrom random import shuffle\ncases = int(input())\nfor _ in range(cases):\n    num = int(input())\n    arr = list(map(int, input().split()))\n    new_arr = [(-n, i) for (i, n) in enumerate(arr, start=1)]\n    heapify(new_arr)\n    ans = []\n    while len(new_arr) > 1:\n        (n1, p1) = heappop(new_arr)\n        (n2, p2) = heappop(new_arr)\n        if n1 == 0 or n2 == 0:\n            break\n        ans.append([p1, p2])\n        n1 += 1\n        n2 += 1\n        if n1 != 0:\n            heappush(new_arr, (n1, p1))\n        if n2 != 0:\n            heappush(new_arr, (n2, p2))\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "import heapq\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = []\n    q = []\n    for i in range(n):\n        heapq.heappush(q, (-a[i], i + 1))\n    while q:\n        (value1, node1) = heapq.heappop(q)\n        (value2, node2) = heapq.heappop(q)\n        if value1 == 0 or value2 == 0:\n            break\n        value1 *= -1\n        value2 *= -1\n        ans.append([node1, node2])\n        heapq.heappush(q, (-(value1 - 1), node1))\n        heapq.heappush(q, (-(value2 - 1), node2))\n    m = len(ans)\n    print(m)\n    for i in range(m):\n        print(*ans[i])", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    nums = list(map(int, input().split(' ')))\n    times = 0\n    max_heap = []\n    ans = []\n    for i in range(n):\n        heapq.heappush(max_heap, (-1 * nums[i], i + 1))\n    while len(max_heap) > 1:\n        (a, b) = heapq.heappop(max_heap)\n        (c, d) = heapq.heappop(max_heap)\n        if a == 0 or c == 0:\n            break\n        a *= -1\n        c *= -1\n        a -= 1\n        c -= 1\n        times += 1\n        ans.append([d, b])\n        heapq.heappush(max_heap, (-1 * a, b))\n        heapq.heappush(max_heap, (-1 * c, d))\n    print(times)\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappush, heappop\n\ndef mgc(a, n):\n    mp = {}\n    h = []\n    tot = 0\n    ans = []\n    for i in range(n):\n        heappush(h, [-a[i], i + 1])\n    while True:\n        first_person = heappop(h)\n        second_person = heappop(h)\n        if second_person[0] == 0:\n            break\n        first_person[0] += 1\n        second_person[0] += 1\n        ans.append([first_person[1], second_person[1]])\n        heappush(h, first_person)\n        heappush(h, second_person)\n    print(len(ans))\n    for i in ans:\n        print(*i)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    mgc(a, n)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = []\n    for i in range(n):\n        q.append((-a[i], i + 1))\n    heapq.heapify(q)\n    ans = 0\n    l = []\n    while True:\n        (x1, y1) = heapq.heappop(q)\n        (x2, y2) = heapq.heappop(q)\n        x1 = -x1\n        x2 = -x2\n        if x1 == 0 or x2 == 0:\n            break\n        ans += 1\n        l.append([y1, y2])\n        heapq.heappush(q, (-max(x1 - 1, 0), y1))\n        heapq.heappush(q, (-max(x2 - 1, 0), y2))\n    print(ans)\n    for (x, y) in l:\n        print(x, y)", "import itertools\nimport math\nimport sys\nimport queue\nimport itertools\nfrom heapq import heappop, heappush\nimport random\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    h = []\n    for i in range(n):\n        heappush(h, (-a[i], i))\n    res = []\n    while len(h) >= 2:\n        (f, s) = (heappop(h), heappop(h))\n        (f, fi, s, si) = (-f[0], f[1], -s[0], s[1])\n        if f > 0 and s > 0:\n            res.append([fi, si])\n            heappush(h, (-f + 1, fi))\n            heappush(h, (-s + 1, si))\n    sys.stdout.write(str(len(res)) + '\\n')\n    for i in res:\n        sys.stdout.write(str(i[0] + 1) + ' ' + str(i[1] + 1) + '\\n')\nmulti_test = 1\nif multi_test:\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        solve()\nelse:\n    solve()", "import math\nfrom collections import defaultdict\nfrom heapq import heapify, heappush, heappop\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    lis = list(map(int, input().split()))\n    out = []\n    for i in range(0, n):\n        out.append([0 - lis[i], i + 1])\n    heapify(out)\n    flag = True\n    s = 0\n    ans = []\n    while flag:\n        a = heappop(out)\n        b = heappop(out)\n        if a[0] == 0 or b[0] == 0:\n            break\n        ans.append([a[1], b[1]])\n        s = s + 1\n        a[0] = 0 - (abs(a[0]) - 1)\n        b[0] = 0 - (abs(b[0]) - 1)\n        heappush(out, a)\n        heappush(out, b)\n    print(s)\n    for i in ans:\n        print(f'{i[0]} {i[1]}')", "from collections import deque, defaultdict, Counter\nfrom itertools import product, groupby, permutations, combinations, accumulate, zip_longest, combinations_with_replacement\nfrom math import gcd, floor, inf, log2, sqrt, log10, factorial\nfrom bisect import bisect_right, bisect_left, insort_left\nfrom statistics import mode\nfrom string import ascii_lowercase, ascii_uppercase\nfrom heapq import heapify, heappop, heappush, heappushpop, heapreplace, nlargest, nsmallest, merge\nfrom copy import deepcopy\nfrom random import shuffle\ncases = int(input())\nfor _ in range(cases):\n    num = int(input())\n    arr = list(map(int, input().split()))\n    new_arr = [(-n, i) for (i, n) in enumerate(arr, start=1)]\n    heapify(new_arr)\n    ans = []\n    while len(new_arr) > 1:\n        (n1, p1) = heappop(new_arr)\n        (n2, p2) = heappop(new_arr)\n        if n1 == 0 or n2 == 0:\n            break\n        ans.append([p1, p2])\n        n1 += 1\n        n2 += 1\n        if n1 != 0:\n            heappush(new_arr, (n1, p1))\n        if n2 != 0:\n            heappush(new_arr, (n2, p2))\n    print(len(ans))\n    for (i, j) in ans:\n        print(i, j)", "from heapq import heappush, heappop\n\ndef solve(n, a):\n    h = []\n    for i in range(n):\n        heappush(h, (-1 * a[i], i))\n    res = []\n    while len(h) >= 2:\n        (val1, index1) = heappop(h)\n        val1 *= -1\n        (val2, index2) = heappop(h)\n        val2 *= -1\n        if val1 <= 0 or val2 <= 0:\n            break\n        val1 -= 1\n        val2 -= 1\n        if val1 > 0:\n            heappush(h, (-1 * val1, index1))\n        if val2 > 0:\n            heappush(h, (-1 * val2, index2))\n        res.append(sorted((index1 + 1, index2 + 1)))\n    return res\nt = int(input().strip())\ninputs = []\nfor _ in range(t):\n    n = int(input().strip())\n    ls = list(map(int, input().strip().split()))\n    inputs.append((n, ls))\nfor (n, ls) in inputs:\n    res = solve(n, ls)\n    print(len(res))\n    for s in res:\n        print(*s)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = []\n    for i in range(n):\n        heapq.heappush(q, [-a[i], i + 1])\n    res = []\n    while True:\n        (high, low) = (heapq.heappop(q), heapq.heappop(q))\n        if not low[0]:\n            break\n        res.append([high[1], low[1]])\n        high[0] += 1\n        low[0] += 1\n        heapq.heappush(q, high)\n        heapq.heappush(q, low)\n    print(len(res))\n    for k in res:\n        print(*k)", "from heapq import *\nfrom sys import stdin\nread = stdin.readline\nfor _ in range(int(read())):\n    n = int(read())\n    arr = list(map(int, read().split()))\n    arr = [[-arr[i], i] for i in range(n)]\n    heapify(arr)\n    ans = []\n    while 1:\n        l1 = heappop(arr)\n        l2 = heappop(arr)\n        if l1[0] == 0 or l2[0] == 0:\n            break\n        l1[0] += 1\n        l2[0] += 1\n        heappush(arr, l1)\n        heappush(arr, l2)\n        ans.append((l1[1] + 1, l2[1] + 1))\n    print(len(ans))\n    for i in ans:\n        print(*i)", "from heapq import *\n\ndef get_max(a):\n    a = [(-i, index + 1) for (index, i) in enumerate(a) if i > 0]\n    heapify(a)\n    ans = 0\n    m = []\n    while len(a) > 1:\n        ans += 1\n        (f, i1) = heappop(a)\n        (s, i2) = heappop(a)\n        m.append((min(i1, i2), max(i1, i2)))\n        s += 1\n        if s != 0:\n            heappush(a, (s, i2))\n        f += 1\n        if f != 0:\n            heappush(a, (f, i1))\n    return (ans, m)\nfor _ in range(int(input())):\n    n = input()\n    a = input().split()\n    a = [int(i) for i in a]\n    (ans, m) = get_max(a)\n    print(ans)\n    for i in m:\n        print(*i)", "from heapq import heappop, heappush\n\ndef List():\n    return list(map(int, input().split()))\n\ndef Lst():\n    return list(input())\n\ndef Int():\n    return int(input())\n\ndef two():\n    return map(int, input().split())\nfor _ in range(Int()):\n    tot_num_of_attendants = Int()\n    mx_heap = []\n    attendants_talk = List()\n    for (index, talk) in enumerate(attendants_talk):\n        if talk != 0:\n            heappush(mx_heap, (-talk, index + 1))\n    output = []\n    length = len(mx_heap)\n    while length > 1:\n        (talk1, id1) = heappop(mx_heap)\n        (talk2, id2) = heappop(mx_heap)\n        talk3 = -1\n        if mx_heap:\n            (talk3, id3) = heappop(mx_heap)\n            heappush(mx_heap, (talk3, id3))\n        num_of_talks = abs(talk2 - talk3) + 1\n        for _ in range(num_of_talks):\n            output.append([id2, id1])\n        remaining = abs(talk1) - num_of_talks\n        if remaining != 0:\n            heappush(mx_heap, (-remaining, id1))\n        remaining = abs(talk2) - num_of_talks\n        if remaining != 0:\n            heappush(mx_heap, (-remaining, id2))\n        length = len(mx_heap)\n    print(len(output))\n    for op in output:\n        print(*op)", "import heapq\nfor _ in range(int(input())):\n    a = int(input())\n    b = list(map(int, input().split()))\n    h = []\n    for i in range(a):\n        heapq.heappush(h, [-b[i], i + 1])\n    li = []\n    while 1:\n        c = heapq.heappop(h)\n        d = heapq.heappop(h)\n        if d[0] == 0:\n            break\n        li += [[c[1], d[1]]]\n        c[0] += 1\n        d[0] += 1\n        heapq.heappush(h, c)\n        heapq.heappush(h, d)\n    print(len(li))\n    for j in li:\n        print(*sorted(j))", "import heapq\nfor _ in range(int(input())):\n    a = int(input())\n    b = list(map(int, input().split()))\n    h = []\n    for i in range(a):\n        heapq.heappush(h, [-b[i], i + 1])\n    li = []\n    while 1:\n        c = heapq.heappop(h)\n        d = heapq.heappop(h)\n        if d[0] == 0:\n            break\n        li += [[c[1], d[1]]]\n        c[0] += 1\n        d[0] += 1\n        heapq.heappush(h, c)\n        heapq.heappush(h, d)\n    print(len(li))\n    for j in li:\n        print(*sorted(j))", "import math\nimport heapq\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nfor _ in range(I()):\n    n = I()\n    l = L()\n    ans = []\n    for i in range(n):\n        l[i] = [-l[i], i]\n    heapq.heapify(l)\n    while True:\n        b = heapq.heappop(l)\n        a = heapq.heappop(l)\n        if a[0] < 0 and b[0] < 0:\n            ans.append([a[1] + 1, b[1] + 1])\n        else:\n            break\n        b[0] += 1\n        a[0] += 1\n        heapq.heappush(l, a)\n        heapq.heappush(l, b)\n    print(len(ans))\n    for i in ans:\n        print(*i)", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    t = []\n    for i in range(n):\n        t.append([-l[i], i])\n    t.sort(reverse=True)\n    heapq.heapify(t)\n    ans = 0\n    out = []\n    while len(t) > 1:\n        a = heapq.heappop(t)\n        b = heapq.heappop(t)\n        a[0] *= -1\n        b[0] *= -1\n        if a[0] > 0 and b[0] > 0:\n            a[0] -= 1\n            b[0] -= 1\n            if a[0]:\n                a[0] *= -1\n                heapq.heappush(t, a)\n            if b[0] != 0:\n                b[0] *= -1\n                heapq.heappush(t, b)\n            out.append((a[1] + 1, b[1] + 1))\n            ans += 1\n    print(ans)\n    for i in out:\n        print(*i)", "def bisect_right(nums, val):\n    (lo, hi) = (0, len(nums) - 1)\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if nums[mid][0] > val:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    nums = [[int(x), i + 1] for (i, x) in enumerate(input().split())]\n    nums.sort()\n    left = 0\n    right = n - 1\n    pairs = []\n    while left < right:\n        if left < right and nums[left][0] == 0:\n            left += 1\n        else:\n            nums[left][0] -= 1\n            nums[right][0] -= 1\n            pairs.append([nums[left][1], nums[right][1]])\n            if nums[right][0] < nums[right - 1][0]:\n                index = bisect_right(nums, nums[right][0])\n                if nums[index][0] == nums[right][0]:\n                    (nums[right], nums[index + 1]) = (nums[index + 1], nums[right])\n                else:\n                    (nums[right], nums[index]) = (nums[index], nums[right])\n    print(len(pairs))\n    for (i, j) in pairs:\n        print(i, j)", "import sys\nfrom heapq import heappop, heappush, heapify\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = []\n    for i in range(n):\n        b.append([a[i], i + 1])\n    a = sorted(b, reverse=True)\n    ans = []\n    heap = []\n    (first, second) = (a[0], a[1])\n    heapify(heap)\n    for i in range(2, n):\n        a[i][0] = a[i][0] * -1\n        heappush(heap, a[i])\n    if n == 2:\n        for _ in range(a[1][0]):\n            ans.append([1, 2])\n    else:\n        while first[0] > 0 and second[0] > 0:\n            x = heappop(heap)\n            if second[0] == x[0] * -1:\n                talks = 1\n            else:\n                talks = second[0] + x[0]\n            for _ in range(talks):\n                ans.append([first[1], second[1]])\n            first[0] -= talks\n            second[0] -= talks\n            first[0] = first[0] * -1\n            second[0] = second[0] * -1\n            heappush(heap, x)\n            heappush(heap, first)\n            heappush(heap, second)\n            first = heappop(heap)\n            second = heappop(heap)\n            first[0] = first[0] * -1\n            second[0] = second[0] * -1\n    print(len(ans))\n    for i in ans:\n        print(i[0], i[1])\nfor _t in range(int(input())):\n    main()", "import heapq\n\nclass pers:\n\n    def __init__(self, s, i):\n        self.s = s\n        self.i = i\n\n    def __lt__(self, other):\n        return self.s > other.s\n\n    def __repr__(self):\n        return '(%d %d)' % (self.s, self.i)\nt = int(input())\nfor case in range(t):\n    n = int(input())\n    a = [int(x) for x in input().split(' ')]\n    soc = [pers(a[i], i + 1) for i in range(n)]\n    soc = [x for x in soc if x.s > 0]\n    heapq.heapify(soc)\n    pairs = []\n    while len(soc) > 1:\n        first = heapq.heappop(soc)\n        second = heapq.heappop(soc)\n        pairs.append((first.i, second.i))\n        first.s -= 1\n        second.s -= 1\n        if second.s > 0:\n            heapq.heappush(soc, second)\n        if first.s > 0:\n            heapq.heappush(soc, first)\n    print(len(pairs))\n    for p in pairs:\n        print('%d %d' % p)", "import heapq\n\nclass pers:\n\n    def __init__(self, s, i):\n        self.s = s\n        self.i = i\n\n    def __lt__(self, next):\n        return self.s > next.s\n\n    def __repr__(self):\n        return '(%d, %d)' % (self.s, self.i)\nT = int(input())\nfor x in range(T):\n    n = int(input())\n    s = [int(x) for x in input().split(' ')]\n    ss = [pers(s[i], i + 1) for i in range(n)]\n    ss = [x for x in ss if x.s > 0]\n    heapq.heapify(ss)\n    pairs = []\n    while len(ss) > 1:\n        first = heapq.heappop(ss)\n        second = heapq.heappop(ss)\n        pairs.append((first.i, second.i))\n        first.s -= 1\n        second.s -= 1\n        if first.s > 0:\n            heapq.heappush(ss, first)\n        if second.s > 0:\n            heapq.heappush(ss, second)\n    print(len(pairs))\n    for p in pairs:\n        print('%d %d' % p)", "from heapq import heapify, heappop, heappush\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    heap = [(-el, i + 1) for (i, el) in enumerate(arr)]\n    heapify(heap)\n    res = []\n    while len(heap) > 1:\n        (start, ind) = heappop(heap)\n        (end, pos) = heappop(heap)\n        if end == 0:\n            heappush(heap, (start, ind))\n        else:\n            res.append([ind, pos])\n            start += 1\n            end += 1\n            heappush(heap, (start, ind))\n            heappush(heap, (end, pos))\n    print(len(res))\n    for r in res:\n        print(*r)", "from heapq import heappush, heappop\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    lst = []\n    cnt = 0\n    hq = []\n    for i in range(n):\n        heappush(hq, [-1 * arr[i], i])\n    while len(hq) > 1:\n        x = heappop(hq)\n        y = heappop(hq)\n        while len(hq) > 0 and hq[0][0] == 0:\n            heappop(hq)\n        if len(hq) == 0:\n            cnt += min(-1 * x[0], -1 * y[0])\n            lst.append([x[1], y[1], min(-1 * x[0], -1 * y[0])])\n            break\n        z = hq[0]\n        cnt += -1 * y[0] - -1 * z[0] + 1\n        lst.append([x[1], y[1], -1 * y[0] - -1 * z[0] + 1])\n        if x[0] + -1 * y[0] - -1 * z[0] + 1 != 0:\n            heappush(hq, [x[0] + -1 * y[0] - -1 * z[0] + 1, x[1]])\n        if y[0] + -1 * y[0] - -1 * z[0] + 1 != 0:\n            heappush(hq, [y[0] + -1 * y[0] - -1 * z[0] + 1, y[1]])\n    print(cnt)\n    for i in lst:\n        for j in range(i[2]):\n            print(i[0] + 1, i[1] + 1)", "from sys import stdin\nimport bisect\n\ndef read_input():\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    return (n, a)\n\ndef reverse_insort(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x > a[mid]:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo - 1\n\ndef solve(n, a):\n    answer = []\n    if n == 2:\n        for _ in range(min(a)):\n            answer.append((1, 2))\n        return answer\n    a = sorted([[ai, i] for (i, ai) in enumerate(a, 1)], reverse=True)\n    while a[1][0] != 0:\n        j = reverse_insort(a, [a[1][0], 0], lo=1)\n        i = reverse_insort(a, [a[0][0], 0], hi=j)\n        answer.append((a[i][1], a[j][1]))\n        a[i][0] -= 1\n        a[j][0] -= 1\n    return answer\n\ndef main():\n    t = int(stdin.readline())\n    for _ in range(t):\n        (n, a) = read_input()\n        answer = solve(n, a)\n        print(len(answer))\n        for (i, j) in answer:\n            print(i, j)\nmain()", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    li = []\n    j = 1\n    for i in input().split():\n        heapq.heappush(li, [-int(i), j])\n        j += 1\n    res = []\n    while len(li) >= 2:\n        x = heapq.heappop(li)\n        y = heapq.heappop(li)\n        if y[0] == 0:\n            heapq.heappush(li, x)\n        else:\n            res.append([x[1], y[1]])\n            x[0] += 1\n            y[0] += 1\n            heapq.heappush(li, x)\n            heapq.heappush(li, y)\n    print(len(res))\n    for r in res:\n        print(*r)"]