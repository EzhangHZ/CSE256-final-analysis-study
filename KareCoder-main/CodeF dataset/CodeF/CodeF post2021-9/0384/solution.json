["import sys\ninput = sys.stdin.readline\nimport math\n\ndef readList():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readInts():\n    return map(int, input().split())\n\ndef readStr():\n    return input().strip()\n\ndef solve():\n    (n, k) = readInts()\n    H = readList()\n    P = readList()\n    arr = sorted([[P[i], H[i]] for i in range(n)])\n    offset = 0\n    for i in range(n):\n        (p, h) = arr[i]\n        h -= offset\n        if h <= 0:\n            continue\n        k -= p if i > 0 else 0\n        if k >= h:\n            offset += k\n            continue\n        elif k <= 0:\n            return 'NO'\n        D = (p + 2 * k) ** 2 - 8 * p * h\n        if D < 0:\n            return 'NO'\n        x1 = math.ceil((p + 2 * k - D ** 0.5) / (2 * p))\n        if x1 > 0 and p * x1 ** 2 - x1 * (p + 2 * k) + 2 * h <= 0:\n            offset += k * x1 - p * (x1 - 1) * x1 // 2\n            k -= p * (x1 - 1)\n        else:\n            return 'NO'\n    return 'YES'\nfor _ in range(int(input())):\n    print(solve())", "import heapq\nimport math\neps = 10 ** (-9)\n\ndef solve():\n    (n, k) = input().split(' ')\n    (n, k) = (int(n), int(k))\n    h = input().split()\n    p = input().split()\n    a = [(int(p[i]), int(h[i])) for i in range(n)]\n    a.sort()\n    i = 0\n    lost = 0\n    while i < n:\n        (p, h) = a[i]\n        h -= lost\n        if h <= 0:\n            i += 1\n            continue\n        if i > 0:\n            k -= p\n        if k <= 0:\n            break\n        sq = (1 + 2 * k / p) ** 2 - 4 * 2 * h / p\n        b = 1 + 2 * k / p\n        if sq < 0:\n            print('NO')\n            return\n        x = math.ceil((b - math.sqrt(sq)) / 2)\n        if x < 0:\n            x = math.floor((b + math.sqrt(sq)) / 2)\n            if x < 0:\n                print('NO')\n                return\n        lost += k * x - x * (x - 1) * p / 2\n        k -= (x - 1) * p\n        i += 1\n    if i == n:\n        print('YES')\n    else:\n        print('No')\n    return\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\ninput = sys.stdin.readline\nimport math\n\ndef readList():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readInts():\n    return map(int, input().split())\n\ndef readStr():\n    return input().strip()\n\ndef solve():\n    (n, k) = readInts()\n    H = readList()\n    P = readList()\n    arr = sorted([[P[i], H[i]] for i in range(n)])\n    offset = 0\n    for i in range(n):\n        (p, h) = arr[i]\n        h -= offset\n        if h <= 0:\n            continue\n        k -= p if i > 0 else 0\n        D = (p + 2 * k) ** 2 - 8 * p * h\n        if D < 0:\n            return 'NO'\n        x1 = math.ceil((p + 2 * k - D ** 0.5) / (2 * p))\n        if x1 > 0 and p * x1 ** 2 - x1 * (p + 2 * k) + 2 * h <= 0:\n            offset += k * x1 - p * (x1 - 1) * x1 // 2\n            k -= p * (x1 - 1)\n        else:\n            return 'NO'\n    return 'YES'\nfor _ in range(int(input())):\n    print(solve())", "def solve():\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    hp = sorted(zip(p, h))\n    del h, p\n    dmg = 0\n    for (i, item) in enumerate(hp):\n        if item[1] <= dmg:\n            continue\n        if i != 0:\n            k -= item[0]\n        if k > 0:\n            dmg += k\n            while item[1] > dmg:\n                k -= item[0]\n                if k < 0:\n                    break\n                dmg += k\n        if item[1] > dmg:\n            print('NO')\n            return\n    print('YES')\nfor _ in range(int(input())):\n    solve()", "import sys\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = list(map(int, input().split()))\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        v = [(b[i], a[i]) for i in range(n)]\n        v.sort()\n        sum = 0\n        k = 0\n        cnt = 0\n        while cnt < n and m > 0:\n            k += m\n            p = v[cnt]\n            while p[1] <= k and cnt < n:\n                cnt += 1\n                if cnt < n:\n                    p = v[cnt]\n            m -= p[0]\n        if cnt == n:\n            print('YES')\n        else:\n            print('NO')\nmain()", "import math\n\ndef func(n, k, h, p):\n    z = list(zip(h, p))\n    z.sort(key=lambda x: x[0])\n    minr = [0 for i in range(n)]\n    minr[-1] = z[-1][1]\n    for i in range(n - 2, -1, -1):\n        minr[i] = min(minr[i + 1], z[i][1])\n    cv = 0\n    cp = 0\n    while k > 0:\n        cv += k\n        while cp < n and z[cp][0] <= cv:\n            cp += 1\n        if cp == n:\n            return 'YES'\n        k -= minr[cp]\n    return 'NO'\nq = int(input())\nfor i in range(q):\n    (n, k) = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    print(func(n, k, h, p))", "from heapq import heapify\nimport heapq\nimport math\nimport sys\ninput = sys.stdin.readline\ninp = sys.stdin.readline\n\ndef input():\n    return inp().strip()\n\ndef ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(map(int, input().split()))\n\ndef solve():\n    (n, k) = mi()\n    health = li()\n    power = li()\n    heap = []\n    for (p, h) in zip(power, health):\n        heapq.heappush(heap, (p, h))\n    curr = k\n    while k > 0 and heap:\n        while heap and heap[0][1] <= curr:\n            heapq.heappop(heap)\n        if heap:\n            k -= heap[0][0]\n            curr += k\n    if not heap:\n        print('YES')\n    else:\n        print('NO')\n\ndef main():\n    for _ in range(ii()):\n        solve()\nmain()", "import heapq\nfrom collections import defaultdict, Counter\ngraph = defaultdict(set)\n\ndef listinput():\n    return list(map(int, input().split()))\n\ndef solve(k, health, power):\n    monsters = sorted(((p, h) for (p, h) in zip(power, health)))\n    damage_done = 0\n    i = 0\n    while k > 0:\n        damage_done += k\n        while i < len(monsters) and monsters[i][1] <= damage_done:\n            i += 1\n        if i == len(monsters):\n            return 'YES'\n        k -= monsters[i][0]\n    return 'NO'\nfor _ in range(int(input())):\n    (n, k) = listinput()\n    h = listinput()\n    p = listinput()\n    print(solve(k, h, p))", "def solution():\n    (n, k) = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    occurrences = {}\n    p_unique = []\n    for x in p:\n        if x in occurrences:\n            occurrences[x] += 1\n        else:\n            occurrences[x] = 1\n            p_unique.append(x)\n    p_unique.sort()\n    tuples_sorted = sorted(zip(h, p))\n    tuples_sorted = zip(*tuples_sorted)\n    (h, p) = [list(tuple) for tuple in tuples_sorted]\n    ptr = 0\n    ptr_unique = 0\n    total_k = k\n    minimun_power = p_unique[ptr_unique]\n    while ptr < n:\n        if k <= 0:\n            print('NO')\n            return\n        if h[ptr] > total_k:\n            k -= minimun_power\n            total_k += k\n        else:\n            occurrences[p[ptr]] -= 1\n            while occurrences[p_unique[ptr_unique]] == 0:\n                ptr_unique += 1\n                if ptr_unique == len(p_unique):\n                    break\n            if ptr_unique != len(p_unique):\n                minimun_power = p_unique[ptr_unique]\n            ptr += 1\n    print('YES')\nfor _ in range(int(input())):\n    solution()", "for _ in range(int(input())):\n    (monsters, att_dmg) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    h_p = sorted([[h[i], p[i]] for i in range(monsters)], key=lambda x: x[1], reverse=True)\n    cur_dealt = 0\n    while True:\n        if att_dmg <= 0:\n            print('NO')\n            break\n        cur_dealt += att_dmg\n        while h_p:\n            if h_p[-1][0] - cur_dealt > 0:\n                att_dmg -= h_p[-1][1]\n                break\n            h_p.pop()\n        else:\n            print('YES')\n            break", "import sys, math, cmath, time\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nstart_time = time.time()\n\ndef solve(t):\n    (n, k) = map(int, inps())\n    l = [int(p) for p in input().split()]\n    d = {}\n    for i in l:\n        d[i] = 0\n    l1 = [int(p) for p in input().split()]\n    f = []\n    for i in range(n):\n        f.append([l[i], l1[i]])\n    f = sorted(f, key=lambda x: (x[1], x[0]))\n    i = 0\n    tot = k\n    while k > 0 and i < n:\n        if tot < f[i][0]:\n            k = k - f[i][1]\n            tot = tot + k\n        else:\n            i = i + 1\n    if i == n:\n        print('YES')\n    else:\n        print('NO')\n\ndef main():\n    testcases = 1\n    testcases = inp()\n    for t in range(1, testcases + 1):\n        solve(t)\n\ndef inp():\n    return int(input())\n\ndef inps():\n    return input().split()\nONLINE_JUDGE = __debug__\nif ONLINE_JUDGE:\n    input = sys.stdin.readline\nmain()", "for x in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    zipped = zip(h, p)\n    res = sorted(zipped, key=lambda sol: sol[1])\n    dem = k\n    index = 0\n    while index < n and k > 0:\n        if res[index][0] <= dem:\n            index += 1\n        else:\n            dem += k - res[index][1]\n            k -= res[index][1]\n    if index == n:\n        print('YES')\n    else:\n        print('NO')", "import math\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    arr = [(p[i], -1 * h[i]) for i in range(n)]\n    arr.sort()\n    tot = 0\n    possible = True\n    t = False\n    for (pi, hi) in arr:\n        hi = -1 * hi\n        if hi > tot:\n            if t:\n                k -= pi\n            hi -= tot\n            while hi > 0 and k > 0:\n                hi -= k\n                tot += k\n                if hi > 0:\n                    k -= pi\n                else:\n                    t = True\n        else:\n            hi = 0\n        if k < 0 or (k == 0 and hi != 0):\n            possible = False\n            break\n    if possible:\n        print('YES')\n    else:\n        print('NO')", "import math\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    arr = [(p[i], -1 * h[i]) for i in range(n)]\n    arr.sort()\n    tot = 0\n    possible = True\n    t = False\n    for (pi, hi) in arr:\n        hi = -1 * hi\n        if hi > tot:\n            if t:\n                k -= pi\n            hi -= tot\n            while hi > 0 and k > 0:\n                hi -= k\n                tot += k\n                if hi > 0:\n                    k -= pi\n                else:\n                    t = True\n        else:\n            hi = 0\n        if k < 0 or (k == 0 and hi != 0):\n            possible = False\n            break\n    if possible:\n        print('YES')\n    else:\n        print('NO')", "from dataclasses import dataclass\n\ndef dumb_kill(monster, atk, dmg):\n    monster.hp -= dmg\n    while True:\n        atk -= monster.atk\n        monster.hp -= atk\n        dmg += atk\n        if monster.hp <= 0:\n            break\n        if atk <= 0:\n            break\n    return (dmg, atk)\n\ndef kill(monster, atk, dmg):\n    return dumb_kill(monster, atk, dmg)\n\n@dataclass\nclass Monster:\n    atk: int\n    hp: int\n\ndef solve(a, H, P):\n    atk = a\n    dmg = 0\n    monsters = [Monster(atk=p, hp=h) for (h, p) in zip(H, P)]\n    monsters = sorted(monsters, key=lambda m: m.atk)\n    atk += monsters[0].atk\n    for monster in monsters:\n        if dmg >= monster.hp:\n            continue\n        (dmg, atk) = kill(monster, atk, dmg)\n        if atk <= 0:\n            break\n    if atk <= 0:\n        return 'NO'\n    else:\n        return 'YES'\n\ndef run(i):\n    (n, attack) = (int(x) for x in input().split())\n    healths = [int(x) for x in input().split()]\n    powers = [int(x) for x in input().split()]\n    ans = solve(attack, healths, powers)\n    print(ans)\nfor i in range(int(input())):\n    run(i)", "import heapq\n\ndef solve():\n    (n, k) = list(map(int, input().split()))\n    health = list(map(int, input().split()))\n    atk = list(map(int, input().split()))\n    q = []\n    for (i, a) in enumerate(atk):\n        heapq.heappush(q, (a, i))\n    atkSoFar = 0\n    while k > 0 and q:\n        atkSoFar += k\n        while q and health[q[0][1]] <= atkSoFar:\n            heapq.heappop(q)\n        if q:\n            k -= q[0][0]\n    if q:\n        print('NO')\n    else:\n        print('YES')\nT = int(input())\nfor _ in range(T):\n    solve()", "from itertools import accumulate, repeat\nfrom operator import getitem\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = sorted(zip(h, p), key=lambda t: t[0])\n    mins = list(accumulate(map(getitem, reversed(a), repeat(1)), min))\n    mins.reverse()\n    (i, acc) = (0, 0)\n    while m > 0:\n        acc += m\n        while i < n and acc >= a[i][0]:\n            i += 1\n        if i == n:\n            break\n        m -= mins[i]\n    print(('NO', 'YES')[i == n])", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    lh = list(map(int, input().split()))\n    lp = list(map(int, input().split()))\n    d = defaultdict(int)\n    for x in range(n):\n        d[lp[x]] = max(d[lp[x]], lh[x])\n    lp.sort()\n    crr = k\n    x = 0\n    f = 0\n    while k > 0:\n        while d[lp[x]] <= crr:\n            x += 1\n            if x == n:\n                f = 1\n                break\n        if x == n:\n            break\n        k -= lp[x]\n        crr += k\n    if f:\n        print('YES')\n    else:\n        print('NO')", "def solve(n, k, h, p):\n    monsters = sorted(((power, health) for (power, health) in zip(p, h)))\n    damage_done = 0\n    monster_index = 0\n    while k > 0:\n        damage_done += k\n        while monster_index < len(monsters) and monsters[monster_index][1] <= damage_done:\n            monster_index += 1\n        if monster_index == len(monsters):\n            return 'YES'\n        k -= monsters[monster_index][0]\n    return 'NO'\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(component) for component in input().split(' ')]\n    h = [int(component) for component in input().split(' ')]\n    p = [int(component) for component in input().split(' ')]\n    print(solve(n, k, h, p))", "import heapq\nfor _ in range(int(input())):\n    (_, k) = map(int, input().split())\n    h = tuple(map(int, input().split()))\n    p = tuple(map(int, input().split()))\n    a = list(zip(p, h))\n    heapq.heapify(a)\n    min_h = 0\n    while True:\n        min_h += k\n        while a:\n            (p, h) = a[0]\n            if h <= min_h:\n                heapq.heappop(a)\n                continue\n            k -= p\n            break\n        if not a:\n            print('YES')\n            break\n        if k <= 0:\n            print('NO')\n            break", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    lh = list(map(int, input().split()))\n    lp = list(map(int, input().split()))\n    d = defaultdict(int)\n    for x in range(n):\n        d[lp[x]] = max(d[lp[x]], lh[x])\n    lp.sort()\n    crr = k\n    x = 0\n    f = 0\n    while k > 0:\n        while d[lp[x]] <= crr:\n            x += 1\n            if x == n:\n                f = 1\n                break\n        if x == n:\n            break\n        k -= lp[x]\n        crr += k\n    if f:\n        print('YES')\n    else:\n        print('NO')", "for ttt in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    zipped = zip(h, p)\n    res = sorted(zipped, key=lambda sol: sol[1])\n    dem = k\n    index = 0\n    while index < n and k > 0:\n        if res[index][0] <= dem:\n            index += 1\n        else:\n            dem += k - res[index][1]\n            k -= res[index][1]\n    if index == n:\n        print('YES')\n    else:\n        print('NO')", "def solve():\n    (_, atack) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = sorted((list(i) for i in zip(p, h)))\n    cum_atack = 0\n    pointer = 0\n    while atack > 0:\n        cum_atack += atack\n        while pointer < len(a) and a[pointer][1] <= cum_atack:\n            pointer += 1\n        if pointer == len(a):\n            break\n        atack -= a[pointer][0]\n    if pointer == len(a):\n        print('YES')\n    else:\n        print('NO')\nfor _ in range(int(input())):\n    solve()", "for _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split(' ')]\n    h = [int(x) for x in input().split(' ')]\n    p = [int(x) for x in input().split(' ')]\n    m = sorted(zip(p, h))\n    attack_now = k\n    pos = 0\n    all_damage = 0\n    while attack_now > 0:\n        all_damage += attack_now\n        while pos < n and all_damage >= m[pos][1]:\n            pos += 1\n        if pos < n:\n            attack_now -= m[pos][0]\n        if pos == n:\n            break\n    if pos == n:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    L = []\n    for i in range(n):\n        L.append((p[i], h[i]))\n    L.sort()\n    f = True\n    a = k\n    i = 0\n    while i < n:\n        (b, c) = L[i]\n        if c > a:\n            if k < b:\n                f = False\n                break\n            else:\n                k -= b\n                a += k\n        else:\n            i += 1\n    if f:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split(' ')]\n    h = [int(x) for x in input().split(' ')]\n    p = [int(x) for x in input().split(' ')]\n    m = sorted(zip(p, h))\n    attack_now = k\n    pos = 0\n    all_damage = 0\n    while attack_now > 0:\n        all_damage += attack_now\n        while pos < n and all_damage >= m[pos][1]:\n            pos += 1\n        if pos < n:\n            attack_now -= m[pos][0]\n        if pos == n:\n            break\n    if pos == n:\n        print('YES')\n    else:\n        print('NO')", "import heapq\n\ndef incerenate(k, hstr, pstr):\n    monsterh = hstr.split()\n    monsterp = pstr.split()\n    intmon = []\n    i = 0\n    while i < len(monsterh):\n        intmon.append((int(monsterp[i]), int(monsterh[i])))\n        i = i + 1\n    totalpower = 0\n    heapq.heapify(intmon)\n    while True:\n        totalpower = totalpower + k\n        while intmon[0][1] - totalpower <= 0:\n            heapq.heappop(intmon)\n            if len(intmon) == 0:\n                return True\n        k = k - intmon[0][0]\n        if k <= 0:\n            if len(intmon) == 0:\n                return True\n            else:\n                return False\n        if len(intmon) == 0:\n            return True\nfor j in range(int(input())):\n    ing = input()\n    k = int(ing.split()[1])\n    if incerenate(k, input(), input()):\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, r) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(sorted(zip(p, h)))\n    k = r\n    i = 0\n    while i < n and r != 0:\n        if z[i][1] <= k:\n            i += 1\n        else:\n            r = max(0, r - z[i][0])\n            k += r\n    if k < max(h):\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    nums = [[a, b] for (a, b) in zip(h, p)]\n    nums.sort()\n    for i in range(n - 2, -1, -1):\n        nums[i][1] = min(nums[i][1], nums[i + 1][1])\n    lei = k\n    for (i, (x, y)) in enumerate(nums):\n        while lei < x:\n            k -= y\n            lei += k\n            if k < 0:\n                break\n    if lei >= nums[-1][0]:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n    d = []\n    for i in range(n):\n        t = (h[i], p[i])\n        d.append(t)\n    d = sorted(d, key=lambda x: x[1])\n    i = 0\n    m = d[0][1]\n    hi = k\n    while i < n:\n        if hi < d[i][0]:\n            m = d[i][1]\n            k -= m\n            hi += k\n        else:\n            i += 1\n        if k < 0:\n            break\n    if max(h) > hi:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(zip(p, h))\n    z.sort()\n    tongst = k\n    M = max(h)\n    i = 0\n    x = len(z)\n    while i < x and k != 0:\n        if z[i][1] > tongst:\n            k = max(0, k - z[i][0])\n            tongst = tongst + k\n        else:\n            i = i + 1\n    if tongst < M:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(zip(p, h))\n    z.sort()\n    tongst = k\n    M = max(h)\n    i = 0\n    x = len(z)\n    while i < x and k != 0:\n        if z[i][1] > tongst:\n            k = max(0, k - z[i][0])\n            tongst = tongst + k\n        else:\n            i = i + 1\n    if tongst < M:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(sorted(zip(p, h)))\n    M = max(h)\n    tot = k\n    i = 0\n    while i < len(z) and k != 0:\n        if z[i][1] > tot:\n            k = max(0, k - z[i][0])\n            tot += k\n        else:\n            i += 1\n    if tot < M:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    mx = max(h)\n    p = list(map(int, input().split()))\n    c = list(sorted(zip(p, h)))\n    sum = k\n    i = 0\n    while i < len(c) and k != 0:\n        if sum < c[i][1]:\n            k = k - c[i][0]\n            if k < 0:\n                k = 0\n            sum = sum + k\n        else:\n            i = i + 1\n    if sum >= mx:\n        print('YES')\n    else:\n        print('NO')", "from heapq import heapify, heappop, heappush\nfor tcase in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    monsters = sorted(zip(p, h))\n    damage = 0\n    i = 0\n    while i < n and k > 0:\n        damage += k\n        while i < n and monsters[i][1] <= damage:\n            i += 1\n        if i < n:\n            k -= monsters[i][0]\n    print('YES' if i == n else 'NO')", "for _ in range(int(input())):\n    (n, r) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = [x for (_, x) in sorted(zip(p, h))]\n    p.sort()\n    k = r\n    i = 0\n    Max_Alien_health = max(h)\n    while i < n and r != 0:\n        if z[i] <= k:\n            i += 1\n        else:\n            r = max(0, r - p[i])\n            k += r\n    if k < Max_Alien_health:\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if p[i] not in d:\n            d[p[i]] = h[i]\n        elif h[i] > d[p[i]]:\n            d[p[i]] = h[i]\n    arr = sorted(list(d.keys()))\n    dmg = 0\n    for x in arr:\n        d[x] -= dmg\n        while d[x] - k > 0:\n            d[x] -= k\n            dmg += k\n            k -= x\n            if k <= 0:\n                break\n    print('YES' if k > 0 else 'NO')", "for _ in range(int(input())):\n    (n, r) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = [x for (_, x) in sorted(zip(p, h))]\n    p.sort()\n    k = r\n    i = 0\n    Max_Alien_health = max(h)\n    while i < n and r != 0:\n        if z[i] <= k:\n            i += 1\n        else:\n            r = max(0, r - p[i])\n            k += r\n    if k < Max_Alien_health:\n        print('NO')\n    else:\n        print('YES')", "import sys, os\nif os.getlogin() == 'arun':\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfrom collections import defaultdict\nimport math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    hp = list(map(int, input().split()))\n    po = list(map(int, input().split()))\n    minval = 2 ** 40\n    fin = [[hp[i], po[i]] for i in range(n)]\n    fin = sorted(fin, key=lambda x: x[0])\n    mn = [0 for x in range(n)]\n    mn[-1] = fin[-1][1]\n    for i in range(-1, -n - 1, -1):\n        if fin[i][1] < minval:\n            minval = fin[i][1]\n        fin[i][1] = minval\n    sm = 0\n    i = 0\n    while i < n and k > 0:\n        sm += k\n        while i < n and fin[i][0] <= sm:\n            i += 1\n        if i < n:\n            k -= fin[i][1]\n    print('YES' if i == n else 'NO')", "import math\nt = int(input())\nfor _ in range(0, t):\n    inputs = [int(num) for num in input().split()]\n    n = inputs[0]\n    k = inputs[1]\n    list2 = [int(num) for num in input().split()]\n    list1 = [int(num) for num in input().split()]\n    zipped_lists = zip(list1, list2)\n    sorted_pairs = sorted(zipped_lists)\n    tuples = zip(*sorted_pairs)\n    (list1, list2) = [list(tuple) for tuple in tuples]\n    dam = 0\n    c = 0\n    for i in range(0, len(list1)):\n        if list2[i] > dam:\n            list2[i] = list2[i] - dam\n            if i != 0:\n                k = k - list1[i]\n            while list2[i] > 0:\n                list2[i] = list2[i] - k\n                dam += k\n                if list2[i] > 0:\n                    k = k - list1[i]\n                if k <= 0:\n                    break\n            if list2[i] <= 0:\n                c += 1\n            if k <= 0:\n                break\n        else:\n            c += 1\n    if c == n:\n        print('YES')\n    else:\n        print('NO')", "for a in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    h = [int(x) for x in input().split()]\n    p = [int(x) for x in input().split()]\n    hp = sorted(zip(p, h))\n    current_dmg = k\n    pos = 0\n    total_dmg = 0\n    while current_dmg > 0:\n        total_dmg += current_dmg\n        while pos < n and total_dmg >= hp[pos][1]:\n            pos += 1\n        if pos < n:\n            current_dmg -= hp[pos][0]\n        if pos == n:\n            break\n    if pos == n:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, r) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = [x for (_, x) in sorted(zip(p, h))]\n    p.sort()\n    k = r\n    i = 0\n    while i < n and r != 0:\n        if z[i] <= k:\n            i += 1\n        else:\n            r = max(0, r - p[i])\n            k += r\n    if k < max(h):\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    l = []\n    f = 0\n    for i in range(n):\n        l.append((p[i], h[i]))\n    l = sorted(l)\n    cur = 0\n    for i in range(n):\n        while l[i][1] - cur > k:\n            cur += k\n            k = k - l[i][0]\n            if k <= 0:\n                f = 1\n                break\n            continue\n        i += 1\n    if f == 0:\n        print('YES')\n    else:\n        print('NO')\n    t = t - 1", "cases = int(input())\nfor i in range(cases):\n    (n, k) = [int(i) for i in input().split()]\n    h = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    c = []\n    for i in range(len(h)):\n        c.append((p[i], h[i]))\n    c.sort(key=lambda x: x[0])\n    j = 0\n    sum1 = k\n    while j < len(h) and k != 0:\n        if sum1 < c[j][1]:\n            k = k - c[j][0]\n            if k < 0:\n                k = 0\n            sum1 = sum1 + k\n        else:\n            j = j + 1\n    if sum1 >= max(h):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nresult = []\nfor i in range(t):\n    (n, k) = list(map(int, input().split(' ')))\n    hi = list(map(int, input().split(' ')))\n    pi = list(map(int, input().split(' ')))\n    d = {}\n    for j in range(n):\n        if pi[j] not in d:\n            d[pi[j]] = hi[j]\n        elif hi[j] > d[pi[j]]:\n            d[pi[j]] = hi[j]\n    l = list(d.keys())\n    l.sort()\n    totalDamage = 0\n    for j in l:\n        d[j] -= totalDamage\n        while d[j] - k > 0:\n            d[j] -= k\n            totalDamage += k\n            k -= j\n            if k <= 0:\n                break\n    if k > 0:\n        result.append('YES')\n    else:\n        result.append('NO')\nfor i in result:\n    print(i)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(sorted(zip(p, h)))\n    i = 0\n    m = max(h)\n    dmg = k\n    while i < len(p) and k != 0:\n        if z[i][1] > dmg:\n            k = max(0, k - z[i][0])\n            dmg += k\n        else:\n            i += 1\n    if dmg < m:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    h = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    m = sorted(zip(h, p), key=lambda i: i[1])\n    i = 0\n    d = 0\n    dam = False\n    while i < len(m):\n        if d >= m[i][0]:\n            i += 1\n        elif k <= 0:\n            break\n        else:\n            if dam:\n                k -= m[i][1]\n                dam = False\n            d += k\n            if k > d:\n                k -= m[i][1]\n            else:\n                dam = True\n    if i == len(m):\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor i in range(t):\n    (x, y) = map(int, input().split(' '))\n    hrr = list(map(int, input().split(' ')))\n    prr = list(map(int, input().split(' ')))\n    arr = []\n    for j in range(x):\n        arr.append([prr[j], j])\n    arr.sort()\n    temp = y\n    k = 0\n    while k < x and y > 0:\n        if hrr[arr[k][1]] - temp > 0:\n            y -= arr[k][0]\n            temp += y\n        else:\n            k += 1\n    if y <= 0:\n        print('NO')\n    else:\n        print('YES')", "for _ in range(int(input())):\n    (n, r) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = [x for (_, x) in sorted(zip(p, h))]\n    p.sort()\n    k = r\n    i = 0\n    while i < n and r != 0:\n        if z[i] <= k:\n            i += 1\n        else:\n            r = max(0, r - p[i])\n            k += r\n    if k < max(h):\n        print('NO')\n    else:\n        print('YES')", "import heapq\niter = int(input())\nfor _ in range(iter):\n    (n, k) = list(map(int, input().split(' ')))\n    h = list(map(int, input().split(' ')))\n    p = list(map(int, input().split(' ')))\n    total_damage = 0\n    a = list(zip(p, h))\n    heapq.heapify(a)\n    while len(a):\n        total_damage += k\n        while a[0][1] <= total_damage:\n            heapq.heappop(a)\n            if len(a) == 0:\n                break\n        if len(a) == 0:\n            break\n        d = a[0][0]\n        k -= d\n        if k <= 0:\n            break\n    if k > 0:\n        print('YES')\n    else:\n        print('NO')", "import math\nfrom collections import Counter, deque\nfrom heapq import heapify, heappop, heappush\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr1 = [int(x) for x in input().split()]\n    arr2 = [int(x) for x in input().split()]\n    arr = [[arr2[i], arr1[i]] for i in range(n)]\n    p = []\n    count = 0\n    for j in arr:\n        if j[1] > k:\n            p.append(j)\n            count += 1\n    if count == 0:\n        print('YES')\n        continue\n    res = 0\n    flag = 0\n    heapify(p)\n    while len(p) != 0:\n        x = heappop(p)\n        x[1] -= res\n        while x[1] > 0:\n            if k <= 0:\n                flag = 1\n                break\n            if x[1] <= 0:\n                break\n            res += k\n            x[1] -= k\n            k -= x[0]\n        if flag == 1:\n            break\n    if flag == 1:\n        print('NO')\n    else:\n        print('YES')", "import heapq as hp\ncases = int(input())\ninp = []\nfor _ in range(cases):\n    inp.append([])\n    for x in range(3):\n        inp[-1].append([int(y) for y in input().split(' ')])\nfor inpt in inp:\n    hpp = []\n    hp.heapify(hpp)\n    for (h, p) in zip(inpt[1], inpt[2]):\n        hp.heappush(hpp, (p, h))\n    (k, dm) = (inpt[0][1], 0)\n    while k != 0 and hpp:\n        dm += k\n        while hpp and hpp[0][1] <= dm:\n            hp.heappop(hpp)\n        if hpp:\n            k = max(0, k - hpp[0][0])\n    print('YES') if k != 0 else print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    m = max(h)\n    arr = [[h[i], p[i]] for i in range(n)]\n    arr = sorted(arr, key=lambda x: x[0])\n    arr = sorted(arr, key=lambda x: x[1])\n    curr = 0\n    m -= k\n    i = 0\n    curr += k\n    while i < n and m > 0 and (k > 0):\n        if curr >= arr[i][0]:\n            i += 1\n            continue\n        k -= arr[i][1]\n        m -= k\n        curr += k\n    if m > 0:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().split()))\n    health = list(map(int, input().split()))\n    power = list(map(int, input().split()))\n    alive = list(range(n))\n    order = []\n    for i in range(n):\n        order.append([power[i], health[i]])\n    order.sort(key=lambda x: (x[0], x[1]))\n    maxhealth = max(health)\n    damage = 0\n    i = 0\n    while k > 0 and i < n and (damage < maxhealth):\n        damage += k\n        while order[i][1] <= damage and i < n - 1:\n            i += 1\n        if i < n:\n            k -= order[i][0]\n        else:\n            break\n    if damage >= maxhealth:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(sorted(zip(p, h)))\n    M = max(h)\n    tot = k\n    i = 0\n    while i < len(z) and k != 0:\n        if z[i][1] > tot:\n            k = max(0, k - z[i][0])\n            tot += k\n        else:\n            i += 1\n    if tot < M:\n        print('NO')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    z = list(sorted(zip(p, h)))\n    M = max(h)\n    tot = k\n    i = 0\n    while i < len(z) and k != 0:\n        if z[i][1] > tot:\n            k = max(0, k - z[i][0])\n            tot += k\n        else:\n            i += 1\n    if tot < M:\n        print('NO')\n    else:\n        print('YES')", "import sys\nt = int(sys.stdin.readline())\nfor i in range(t):\n    (n, k) = map(int, sys.stdin.readline().split())\n    lsth = list(map(int, sys.stdin.readline().split()))\n    lstp = list(map(int, sys.stdin.readline().split()))\n    vec = []\n    for j in range(n):\n        vec.append([lstp[j], lsth[j]])\n    vec.sort(key=lambda x: x[0])\n    er = 0\n    ele = 0\n    ind = 0\n    while True:\n        if k <= 0:\n            er += 1\n            break\n        ele += k\n        e = 0\n        while True:\n            if ind > n - 1:\n                e += 1\n                break\n            p = vec[ind][0]\n            h = vec[ind][1] - ele\n            if h > 0:\n                break\n            ind += 1\n        if ind > n - 1:\n            break\n        k -= vec[ind][0]\n    if er > 0:\n        print('NO')\n    else:\n        print('YES')", "import sys, collections\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l = []\n    for i in range(n):\n        l.append([a[i], b[i]])\n    l.sort(key=lambda x: x[1], reverse=True)\n    s = collections.deque()\n    s.append(l[0])\n    for i in range(1, n):\n        if s[-1][1] == l[i][1]:\n            s[-1][0] = max(s[-1][0], l[i][0])\n        else:\n            s.append(l[i])\n    r = 0\n    while s:\n        if s[-1][0] - r > 0:\n            if k <= 0:\n                print('NO')\n                break\n            elif k >= s[-1][0] - r:\n                s.pop()\n                r += k\n                while len(s) > 0:\n                    if s[-1][0] - r > 0:\n                        k = k - s[-1][1]\n                        break\n                    else:\n                        s.pop()\n                else:\n                    print('YES')\n                    break\n            else:\n                r += k\n                k = k - s[-1][1]\n        else:\n            s.pop()\n    else:\n        print('YES')", "def ii(num=False):\n    i = input().split()\n    if num:\n        return int(i[0])\n    try:\n        return list(map(int, i))\n    except Exception:\n        return i\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfor _ in range(ii(1)):\n    (n, k) = ii()\n    h = ii()\n    p = ii()\n    a = sorted(list(zip(p, h)))\n    accDamage = 0\n    i = 0\n    while i < n:\n        (cp, ch) = a[i]\n        if accDamage >= ch:\n            i += 1\n        else:\n            accDamage += k\n            while i < n and a[i][1] <= accDamage:\n                i += 1\n            if i == n:\n                break\n            k -= a[i][0]\n            if k <= 0 and (not all([accDamage >= hh for (pp, hh) in a])):\n                break\n    print('YES' if i == n else 'NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    d = 0\n    monsters = sorted(zip(h, p), key=lambda x: x[1])\n    while k > 0:\n        d += k\n        for (hp, power) in monsters:\n            if hp > d:\n                k -= power\n                break\n        else:\n            break\n    else:\n        print('NO')\n        continue\n    print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    l3 = []\n    for i in range(n):\n        l3.append([l1[i], l2[i]])\n    l3.sort()\n    min = l3[n - 1][1]\n    for i in range(n - 2, -1, -1):\n        if min > l3[i][1]:\n            min = l3[i][1]\n        else:\n            l3[i][1] = min\n    j = k\n    index = 0\n    found = False\n    while k > 0 and index < n:\n        while index < n and l3[index][0] <= j:\n            index += 1\n        if index == n:\n            found = True\n            break\n        k -= l3[index][1]\n        j += k\n    if index < n:\n        print('NO')\n    if found:\n        print('YES')", "import operator\nimport itertools as it\nimport functools as ft\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    m = list(zip(map(int, input().split()), map(int, input().split())))\n    m.sort(key=lambda monster: monster[1])\n    dmg = k\n    i = 0\n    while i < len(m):\n        if m[i][0] <= dmg:\n            i += 1\n        elif m[i][1] >= k:\n            print('NO')\n            break\n        else:\n            k = max(0, k - m[i][1])\n            dmg += k\n    if i == len(m):\n        print('YES')", "for _ in range(int(input())):\n    (n, k) = tuple(map(int, input().split()))\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    ph = {}\n    for i in range(n):\n        ph[p[i]] = max(ph.get(p[i], 0), h[i])\n    (pu, hu) = ([], [])\n    for pi in sorted(ph.keys(), reverse=True):\n        pu.append(pi)\n        hu.append(ph[pi])\n    a = 1\n    total_damage = 0\n    while k > 0 and len(pu) != 0:\n        (x, y) = (pu[-1], hu[-1])\n        total_damage += k\n        if total_damage >= y:\n            while len(hu) > 0 and hu[-1] - total_damage <= 0:\n                pu.pop()\n                hu.pop()\n            a = 1\n        else:\n            a += 1\n        k -= pu[-1] if len(pu) > 0 else 0\n    print('YES' if len(pu) == 0 else 'NO')", "from bisect import bisect_right\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().strip().split()]\n    h = [int(i) for i in input().strip().split()]\n    p = [int(i) for i in input().strip().split()]\n    (h, p) = zip(*sorted(zip(h, p)))\n    min_p = [None for i in range(n)]\n    curr_min = float('inf')\n    for i in range(n - 1, -1, -1):\n        curr_min = min(curr_min, p[i])\n        min_p[i] = curr_min\n    curr_damage = k\n    check = False\n    while True:\n        i = bisect_right(h, curr_damage)\n        if i >= n:\n            check = True\n            break\n        k -= min_p[i]\n        if k <= 0:\n            break\n        curr_damage += k\n    if check:\n        print('YES')\n    else:\n        print('NO')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    health = list(map(int, input().split()))\n    power = list(map(int, input().split()))\n    main = []\n    for i in range(n):\n        main.append([power[i], health[i]])\n    main.sort()\n    k1 = k\n    s = 0\n    for j in range(n):\n        sta = 0\n        while main[j][1] > 0:\n            if k < 0:\n                break\n            if sta == 0:\n                main[j][1] -= k1\n            else:\n                main[j][1] -= k\n            if main[j][1] <= 0:\n                break\n            else:\n                k -= main[j][0]\n            if k < 0:\n                break\n            k1 += k\n            sta = 1\n        if k <= 0:\n            if main[-1][1] > 0:\n                s = 1\n                print('NO')\n                break\n                s = 1\n    if s != 1:\n        print('YES')", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    for i in range(n):\n        h[i] = (i, h[i])\n        p[i] = (i, p[i])\n    h.sort(key=lambda x: x[1])\n    p.sort(key=lambda x: x[1])\n    dead = set()\n    (i, j) = (0, 0)\n    damage = 0\n    while i < n and j < n and (k > 0):\n        damage += k\n        while i < n:\n            if h[i][1] <= damage:\n                dead.add(h[i][0])\n            else:\n                break\n            i += 1\n        while j < n:\n            if p[j][0] not in dead:\n                k -= p[j][1]\n                break\n            j += 1\n    if len(dead) == n:\n        print('YES')\n    else:\n        print('NO')", "t = int(input())\nfor _ in range(t):\n    (n, k) = [int(_) for _ in input().split()]\n    hp = [int(_) for _ in input().split()]\n    d = [int(_) for _ in input().split()]\n    h = []\n    dc = {}\n    for i in range(len(hp)):\n        h.append((hp[i], d[i]))\n        dc[d[i]] = dc.get(d[i], 0) + 1\n    h.sort(reverse=True)\n    d.sort(reverse=True)\n    limit = 0\n    while True:\n        limit += k\n        while len(h) > 0 and h[-1][0] <= limit:\n            dc[h[-1][1]] -= 1\n            h.pop()\n        if len(h) == 0:\n            print('YES')\n            break\n        while dc[d[-1]] == 0:\n            d.pop()\n        k -= d[-1]\n        if k <= 0:\n            print('NO')\n            break", "from collections import deque\nfrom heapq import *\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    h = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    p_heap = []\n    h_heap = []\n    killed = set()\n    for i in range(n):\n        p_heap.append((p[i], i))\n        h_heap.append((h[i], i))\n    h_heap.sort()\n    p_heap.sort()\n    cur = 0\n    removed = set()\n    ptr = 0\n    ptr2 = 0\n    while k > 0 and ptr < n:\n        cur += k\n        while ptr < n and cur >= h_heap[ptr][0]:\n            removed.add(h_heap[ptr][1])\n            ptr += 1\n        while ptr2 < n and p_heap[ptr2][1] in removed:\n            ptr2 += 1\n        if ptr2 < n:\n            k -= p_heap[ptr2][0]\n    if ptr == n:\n        print('YES')\n    else:\n        print('NO')", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    health = list(map(int, input().split()))\n    power = list(map(int, input().split()))\n    main = []\n    for i in range(n):\n        main.append([power[i], health[i]])\n    main.sort()\n    k1 = k\n    s = 0\n    for j in range(n):\n        sta = 0\n        while main[j][1] > 0:\n            if k < 0:\n                break\n            if sta == 0:\n                main[j][1] -= k1\n            else:\n                main[j][1] -= k\n            if main[j][1] <= 0:\n                break\n            else:\n                k -= main[j][0]\n            if k < 0:\n                break\n            k1 += k\n            sta = 1\n        if k <= 0:\n            if main[-1][1] > 0:\n                s = 1\n                print('NO')\n                break\n                s = 1\n    if s != 1:\n        print('YES')", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(h, p, n, k):\n    q = [[p[i], i] for i in range(n)]\n    r = [0] * n\n    heapq.heapify(q)\n    x = k\n    while k > 0:\n        while q and h[q[0][1]] - (x - r[q[0][1]]) <= 0:\n            heapq.heappop(q)\n        if not q:\n            return 'YES'\n        h[q[0][1]] -= x - r[q[0][1]]\n        r[q[0][1]] = x\n        k -= q[0][0]\n        x += k\n    return 'NO'\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    print(solve(h, p, n, k))", "t = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    p_heap = []\n    for i in range(n):\n        p_heap.append((p[i], h[i]))\n    p_heap = sorted(p_heap, key=lambda x: x[0])\n    dec_pow = k\n    while k > 0 and p_heap:\n        while p_heap and p_heap[0][1] <= dec_pow:\n            p_heap.pop(0)\n        if not p_heap:\n            break\n        k -= p_heap[0][0]\n        dec_pow += k\n    print('YES' if not p_heap else 'NO')", "t = int(input())\nwhile t > 0:\n    (n, k) = map(int, input().split())\n    H = list(map(int, input().split()))\n    P = list(map(int, input().split()))\n    h = []\n    p = []\n    for i in range(n):\n        h.append((i, H[i]))\n        p.append((H[i], P[i]))\n    count = k\n    left = 0\n    right = 0\n    h.sort(key=lambda x: x[1])\n    p.sort(key=lambda x: x[1])\n    ss = 0\n    DEL = p[0][1]\n    while count > 0:\n        while left < n and k >= h[left][1]:\n            left += 1\n        if left == n:\n            ss = 1\n            break\n        while right < n and k >= p[right][0]:\n            right += 1\n        DEL = p[right][1]\n        count -= DEL\n        k += count\n    if ss:\n        print('YES')\n    else:\n        print('NO')\n    t -= 1", "def fun(lp, lh, n, k):\n    l = []\n    for i in range(n):\n        l.append((lp[i], lh[i]))\n    l.sort(key=lambda x: x[0])\n    cnt = k\n    while len(l) != 0:\n        if k <= 0:\n            print('NO')\n            return\n        elif l[0][1] - cnt > 0:\n            k = k - l[0][0]\n            cnt = cnt + k\n        elif l[0][1] - cnt <= 0:\n            l.remove(l[0])\n    print('YES')\nt = int(input())\nfor j in range(t):\n    (n, k) = map(int, input().split())\n    lh = list(map(int, input().split()))\n    lp = list(map(int, input().split()))\n    fun(lp, lh, n, k)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    h = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    a = []\n    mx = max(h)\n    for i in range(n):\n        a.append((h[i], p[i]))\n    a.sort()\n    z = k\n    cnt = 0\n    pm = [0] * n\n    pm[n - 1] = a[n - 1][1]\n    for j in range(n - 2, -1, -1):\n        pm[j] = min(pm[j + 1], a[j][1])\n    while k > 0 and mx > 0 and (cnt < n):\n        while cnt < n and z >= a[cnt][0]:\n            cnt += 1\n        mx -= k\n        if cnt < n:\n            k -= pm[cnt]\n            if k > 0:\n                z += k\n    if mx <= 0:\n        print('YES')\n    else:\n        print('NO')", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    hh = list(map(int, input().split()))\n    pp = list(map(int, input().split()))\n    hh = [[x, i] for (i, x) in enumerate(hh)]\n    pp = [[x, i] for (i, x) in enumerate(pp)]\n    heapq.heapify(hh)\n    heapq.heapify(pp)\n    rep = set()\n    lei = 0\n    while k > 0 and hh and pp:\n        lei += k\n        while hh and hh[0][0] <= lei:\n            (a, b) = heapq.heappop(hh)\n            rep.add(b)\n        while pp and pp[0][1] in rep:\n            heapq.heappop(pp)\n        if pp:\n            k -= pp[0][0]\n    if n == len(rep):\n        print('YES')\n    else:\n        print('NO')", "from heapq import heapify\nimport heapq\nimport sys\ninput = sys.stdin.readline\ninp = sys.stdin.readline\n\ndef input():\n    return inp().strip()\n\ndef ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(map(int, input().split()))\n\ndef solve():\n    (n, k) = mi()\n    health = li()\n    x = li()\n    power = []\n    for (tk, v) in enumerate(x):\n        heapq.heappush(power, (v, tk))\n    curr = k\n    maxH = max(health)\n    while k > 0 and maxH > 0 and power:\n        (currV, currK) = heapq.heappop(power)\n        if health[currK] <= curr:\n            continue\n        k -= currV\n        curr += k\n        heapq.heappush(power, (currV, currK))\n    if maxH - curr <= 0:\n        print('YES')\n        return\n    else:\n        print('NO')\n\ndef main():\n    for _ in range(ii()):\n        solve()\nmain()", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    hh = list(map(int, input().split()))\n    pp = list(map(int, input().split()))\n    hh = [[x, i] for (i, x) in enumerate(hh)]\n    pp = [[x, i] for (i, x) in enumerate(pp)]\n    heapq.heapify(hh)\n    heapq.heapify(pp)\n    rep = set()\n    lei = 0\n    while k > 0 and hh and pp:\n        lei += k\n        while hh and hh[0][0] <= lei:\n            (a, b) = heapq.heappop(hh)\n            rep.add(b)\n        while pp and pp[0][1] in rep:\n            heapq.heappop(pp)\n        if pp:\n            k -= pp[0][0]\n    if len(rep) == n:\n        print('YES')\n    else:\n        print('NO')"]