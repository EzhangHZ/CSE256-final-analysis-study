["import sys, collections, bisect\nfor _ in range(int(sys.stdin.readline())):\n    (n, m, k) = [int(i) for i in sys.stdin.readline().split()]\n    x = [int(i) for i in sys.stdin.readline().split()]\n    y = [int(i) for i in sys.stdin.readline().split()]\n    (sx, sy) = (set(x), set(y))\n    px = collections.defaultdict(lambda : collections.defaultdict(int))\n    py = collections.defaultdict(lambda : collections.defaultdict(int))\n    for i in range(k):\n        (a, b) = [int(i) for i in sys.stdin.readline().split()]\n        if not (a in sx and b in sy):\n            if a in sx:\n                px[bisect.bisect(y, b)][a] += 1\n            else:\n                py[bisect.bisect(x, a)][b] += 1\n    r = sum((sum(dd.values()) ** 2 - sum((x * x for x in dd.values())) for dd in px.values())) + sum((sum(dd.values()) ** 2 - sum((x * x for x in dd.values())) for dd in py.values()))\n    sys.stdout.write(str(r // 2) + '\\n')", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nfor _ in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    V = list(map(int, input().split()))\n    H = list(map(int, input().split()))\n    P = [tuple(map(int, input().split())) for _ in range(K)]\n    XS = P\n    YS = [(y, x) for (x, y) in P]\n\n    def f(C, bord) -> int:\n        C.sort(key=lambda v: v[0])\n        N = len(bord)\n        bi = 0\n        cnt = 0\n        res = 0\n        D = Counter()\n\n        def fin():\n            nonlocal cnt, res\n            if cnt:\n                for (k, v) in D.items():\n                    res += v * (cnt - v)\n                cnt = 0\n                D.clear()\n        for (c, o) in C:\n            while c > bord[bi + 1]:\n                fin()\n                bi += 1\n                cnt = 0\n            if bord[bi] < c < bord[bi + 1]:\n                cnt += 1\n                D[o] += 1\n        fin()\n        return res\n    print((f(YS, H) + f(XS, V)) // 2)", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    ps = list((tuple(map(int, input().split())) for _ in range(k)))\n    (sx, sy) = (set(x), set(y))\n    px = sorted(((i, j) for (i, j) in ps if i not in sx))\n    py = sorted(((j, i) for (i, j) in ps if j not in sy))\n    s = 0\n    l = r = 0\n    for i in range(n - 1):\n        while r < len(px) and px[r][0] < x[i + 1]:\n            r += 1\n        while l < r and px[l][0] <= x[i]:\n            l += 1\n        if l < r - 1:\n            s += (l - r + 1) * (l - r) // 2\n            c = {}\n            for (i, j) in px[l:r]:\n                c[j] = c.get(j, 0) + 1\n            for i in c.values():\n                if i > 1:\n                    s -= i * (i - 1) // 2\n    l = r = 0\n    for i in range(m - 1):\n        while r < len(py) and py[r][0] < y[i + 1]:\n            r += 1\n        while l < r and py[l][0] <= y[i]:\n            l += 1\n        if l < r - 1:\n            s += (l - r + 1) * (l - r) // 2\n            c = {}\n            for (i, j) in py[l:r]:\n                c[j] = c.get(j, 0) + 1\n            for i in c.values():\n                if i > 1:\n                    s -= i * (i - 1) // 2\n    print(s)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nfor _ in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    V = list(map(int, input().split()))\n    H = list(map(int, input().split()))\n    P = [tuple(map(int, input().split())) for _ in range(K)]\n    XS = P\n    YS = [(y, x) for (x, y) in P]\n\n    def f(C, bord) -> int:\n        C.sort(key=lambda v: v[0])\n        N = len(bord)\n        bi = 0\n        cnt = 0\n        res = 0\n        D = Counter()\n\n        def fin():\n            nonlocal cnt, res\n            if cnt:\n                for (k, v) in D.items():\n                    res += v * (cnt - v)\n                cnt = 0\n                D.clear()\n        for (c, o) in C:\n            while c > bord[bi + 1]:\n                fin()\n                bi += 1\n                cnt = 0\n            if bord[bi] < c < bord[bi + 1]:\n                cnt += 1\n                D[o] += 1\n        fin()\n        return res\n    print((f(YS, H) + f(XS, V)) // 2)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef input_list():\n    return list(map(int, input().split()))\n\ndef input_string():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef input_int_gen():\n    return map(int, input().split())\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom math import comb\ntests = inp()\nfor _ in range(tests):\n    (n, m, k) = input_int_gen()\n    xs = input_list()\n    ys = input_list()\n    horis_total = defaultdict(int)\n    vertis_total = defaultdict(int)\n    horis = defaultdict(lambda : defaultdict(int))\n    vertis = defaultdict(lambda : defaultdict(int))\n    for _ in range(k):\n        (a, b) = input_int_gen()\n        ix = bisect_left(xs, a)\n        iy = bisect_left(ys, b)\n        if xs[ix] != a:\n            horis_total[ix] += 1\n            horis[ix][iy] += 1\n        elif ys[iy] != b:\n            vertis_total[iy] += 1\n            vertis[iy][ix] += 1\n    res = 0\n    for d in horis.values():\n        for x in d.values():\n            res -= comb(x, 2)\n    for d in vertis.values():\n        for x in d.values():\n            res -= comb(x, 2)\n    for c in horis_total.values():\n        res += comb(c, 2)\n    for c in vertis_total.values():\n        res += comb(c, 2)\n    print(res)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m, k) = map(int, input().split())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    P = [list(map(int, input().split())) for _ in range(k)]\n    P.sort(key=lambda x: x[0])\n    ans = 0\n    j = 0\n    for i in range(n):\n        cnt = 0\n        tmp = {}\n        while j < k and P[j][0] <= X[i]:\n            if P[j][0] == X[i]:\n                j += 1\n                continue\n            if P[j][1] not in tmp:\n                tmp[P[j][1]] = 0\n            tmp[P[j][1]] += 1\n            cnt += 1\n            j += 1\n        ans += cnt * (cnt - 1) // 2\n        for key in tmp:\n            ans -= tmp[key] * (tmp[key] - 1) // 2\n    j = 0\n    P.sort(key=lambda x: x[1])\n    for i in range(m):\n        cnt = 0\n        tmp = {}\n        while j < k and P[j][1] <= Y[i]:\n            if P[j][1] == Y[i]:\n                j += 1\n                continue\n            if P[j][0] not in tmp:\n                tmp[P[j][0]] = 0\n            tmp[P[j][0]] += 1\n            cnt += 1\n            j += 1\n        ans += cnt * (cnt - 1) // 2\n        for key in tmp:\n            ans -= tmp[key] * (tmp[key] - 1) // 2\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "from collections import defaultdict\nfrom bisect import bisect_left\nT = int(input())\nfor t in range(T):\n    (N, M, K) = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    arrx = defaultdict(lambda : defaultdict(int))\n    arry = defaultdict(lambda : defaultdict(int))\n    for i in range(K):\n        (xp, yp) = map(int, input().split())\n        indx = bisect_left(x, xp)\n        if x[indx] != xp:\n            arrx[indx][yp] += 1\n        else:\n            indy = bisect_left(y, yp)\n            if y[indy] != yp:\n                arry[indy][xp] += 1\n    ans = 0\n    ans += sum(map(lambda x: sum(x.values()) ** 2 - sum(map(lambda y: y * y, x.values())), arrx.values()))\n    ans += sum(map(lambda x: sum(x.values()) ** 2 - sum(map(lambda y: y * y, x.values())), arry.values()))\n    print(ans // 2)", "from collections import defaultdict\nfrom bisect import bisect\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ys = list(map(int, input().split()))\n    xss = set(xs)\n    yss = set(ys)\n    zx = defaultdict(lambda : defaultdict(int))\n    zy = defaultdict(lambda : defaultdict(int))\n    for _ in range(k):\n        (x, y) = map(int, input().split())\n        if x in xss and y in yss:\n            continue\n        if x in xss:\n            iy = bisect(ys, y)\n            zx[iy][x] += 1\n        else:\n            ix = bisect(xs, x)\n            zy[ix][y] += 1\n    ans = 0\n    for z in (zx, zy):\n        for l in [list(v.values()) for v in z.values()]:\n            s = sum(l)\n            if s < 2:\n                continue\n            ans += s * (s - 1) // 2 - sum((q * (q - 1) // 2 for q in l))\n    print(ans)", "def solve(points, ver, hor):\n    sol = 0\n    points.sort()\n    i = 0\n    for x in sorted(ver):\n        (curr, total) = ({}, 0)\n        while i < len(points) and points[i][0] <= x:\n            if points[i][0] < x:\n                total += 1\n                curr[points[i][1]] = curr.get(points[i][1], 0) + 1\n            i += 1\n        for v in curr.values():\n            sol += v * (total - v)\n    points.sort(key=lambda x: x[1])\n    i = 0\n    for y in sorted(hor):\n        (curr, total) = ({}, 0)\n        while i < len(points) and points[i][1] <= y:\n            if points[i][1] < y:\n                total += 1\n                curr[points[i][0]] = curr.get(points[i][0], 0) + 1\n            i += 1\n        for v in curr.values():\n            sol += v * (total - v)\n    return sol // 2\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    ver = list(map(int, input().split()))\n    hor = list(map(int, input().split()))\n    points = [tuple(map(int, input().split())) for _ in range(k)]\n    print(solve(points, ver, hor))", "from collections import defaultdict\nfrom bisect import bisect\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ys = list(map(int, input().split()))\n    xss = set(xs)\n    yss = set(ys)\n    zx = defaultdict(lambda : defaultdict(int))\n    zy = defaultdict(lambda : defaultdict(int))\n    ans = 0\n    for _ in range(k):\n        (x, y) = map(int, input().split())\n        if x in xss and y in yss:\n            continue\n        if x in xss:\n            iy = bisect(ys, y)\n            zx[iy][x] += 1\n        else:\n            ix = bisect(xs, x)\n            zy[ix][y] += 1\n    for z in (zx, zy):\n        for l in [list(v.values()) for v in z.values()]:\n            s = sum(l)\n            if s < 2:\n                continue\n            ans += s * (s - 1) // 2 - sum((q * (q - 1) // 2 for q in l))\n    print(ans)"]