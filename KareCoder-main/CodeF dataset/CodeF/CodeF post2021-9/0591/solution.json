["def solve(n, k, x, y, a, graph):\n    a.add(x)\n    a.add(y)\n    stack = [(x, 0)]\n    parent = (n + 1) * [-1]\n    y_height = None\n    while stack:\n        (node, height) = stack.pop()\n        if node == y:\n            y_height = height\n        for child in graph[node]:\n            if child != parent[node]:\n                parent[child] = node\n                stack.append((child, height + 1))\n    lst = list(a)\n    edge_ct = 0\n    for node in lst:\n        if node != x and parent[node] not in a:\n            a.add(parent[node])\n            lst.append(parent[node])\n        if node != x:\n            edge_ct += 2\n    return edge_ct - y_height\nt = int(input())\nfor case in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    (x, y) = map(int, input().split())\n    a = set(map(int, input().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    print(solve(n, k, x, y, a, graph))", "import sys\ninput = sys.stdin.readline\nimport math\nsys.setrecursionlimit(200020)\nimport threading\nthreading.stack_size(2 ** 27)\n\ndef main():\n    for _ in range(int(input())):\n        line = input()\n        (N, K) = map(int, input().split())\n        (X, Y) = map(int, input().split())\n        Nodes = set(map(int, input().split()))\n        Nodes.add(X)\n        Nodes.add(Y)\n        Graph = []\n        for i in range(N + 1):\n            Graph.append([])\n        for i in range(N - 1):\n            (A, B) = map(int, input().split())\n            Graph[A].append(B)\n            Graph[B].append(A)\n        visited = [False] * (N + 1)\n        dist = [10 ** 6] * (N + 1)\n        total = [0]\n\n        def DFS(node):\n            visited[node] = True\n            found = False\n            for nie in Graph[node]:\n                if not visited[nie]:\n                    dist[nie] = min(dist[nie], dist[node] + 1)\n                    good = DFS(nie)\n                    if good:\n                        total[0] = total[0] + 2\n                    found = found or good\n            if node in Nodes:\n                return True\n            else:\n                return found\n        dist[X] = 0\n        DFS(X)\n        print(total[0] - dist[Y])\nthreading.Thread(target=main).start()", "import sys\ninput = sys.stdin.readline\nimport math\nsys.setrecursionlimit(200020)\nimport threading\nthreading.stack_size(2 ** 27)\n\ndef main():\n    for _ in range(int(input())):\n        line = input()\n        (N, K) = map(int, input().split())\n        (X, Y) = map(int, input().split())\n        Nodes = set(map(int, input().split()))\n        Nodes.add(X)\n        Nodes.add(Y)\n        Graph = []\n        for i in range(N + 1):\n            Graph.append([])\n        for i in range(N - 1):\n            (A, B) = map(int, input().split())\n            Graph[A].append(B)\n            Graph[B].append(A)\n        visited = [False] * (N + 1)\n        dist = [10 ** 6] * (N + 1)\n        total = [0]\n\n        def DFS(node):\n            visited[node] = True\n            found = False\n            for nie in Graph[node]:\n                if not visited[nie]:\n                    dist[nie] = min(dist[nie], dist[node] + 1)\n                    good = DFS(nie)\n                    if good:\n                        total[0] = total[0] + 2\n                    found = found or good\n            if node in Nodes:\n                return True\n            else:\n                return found\n        dist[X] = 0\n        DFS(X)\n        print(total[0] - dist[Y])\nthreading.Thread(target=main).start()", "import sys\n\ndef solve(n, k, x, y, a, graph):\n    a.add(x)\n    a.add(y)\n    stack = [(x, 0)]\n    parent = (n + 1) * [-1]\n    y_height = None\n    while stack:\n        (node, height) = stack.pop()\n        if node == y:\n            y_height = height\n        for child in graph[node]:\n            if child != parent[node]:\n                parent[child] = node\n                stack.append((child, height + 1))\n    lst = list(a)\n    edge_ct = 0\n    for node in lst:\n        if node != x and parent[node] not in a:\n            a.add(parent[node])\n            lst.append(parent[node])\n        if node != x:\n            edge_ct += 2\n    return edge_ct - y_height\nt = int(input())\nfor case in range(t):\n    input()\n    (n, k) = map(int, input().split())\n    (x, y) = map(int, input().split())\n    a = set(map(int, input().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    print(solve(n, k, x, y, a, graph))", "from collections import defaultdict, Counter\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\n\ndef main():\n    for test in range(ri()):\n        rs()\n        (n, k) = rl()\n        (x, y) = rl()\n        a = rl()\n        g = defaultdict(list)\n        for e in range(n - 1):\n            (u, v) = rl()\n            g[u].append(v)\n            g[v].append(u)\n        to_vis = set([x, y])\n        for i in a:\n            to_vis.add(i)\n        st = [(x, 0)]\n        to_y = None\n        par = [-1] * (n + 1)\n        while st:\n            (cn, cd) = st.pop()\n            if cn == y:\n                to_y = cd\n            for nn in g[cn]:\n                if nn != par[cn]:\n                    par[nn] = cn\n                    st.append((nn, cd + 1))\n        ls = list(to_vis)\n        res = 0\n        for cn in ls:\n            if cn != x and par[cn] not in to_vis:\n                to_vis.add(par[cn])\n                ls.append(par[cn])\n            if cn != x:\n                res += 2\n        print(res - to_y)\n    pass\nmain()", "import sys\ninput = sys.stdin.readline\nimport math\nsys.setrecursionlimit(200020)\nimport threading\nthreading.stack_size(2 ** 27)\n\ndef main():\n    for _ in range(int(input())):\n        input()\n        (n, k) = map(int, input().split())\n        (x, y) = map(int, input().split())\n        z = list(map(int, input().split()))\n        g = [[] for i in range(n)]\n        x -= 1\n        y -= 1\n        for i in range(n - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            g[a].append(b)\n            g[b].append(a)\n        a = [False] * n\n        for i in z:\n            a[i - 1] = True\n        depth = [0] * n\n        found = [False] * n\n\n        def Dfs(v, p):\n            if a[v] or y == v:\n                found[v] = True\n            for to in g[v]:\n                if to == p:\n                    continue\n                depth[to] = depth[v] + 1\n                Dfs(to, v)\n                if found[to]:\n                    found[v] = True\n        Dfs(x, -1)\n        ans = 0\n        for i in range(n):\n            if i != x and found[i]:\n                ans += 2\n        ans -= depth[y]\n        print(ans)\nthreading.Thread(target=main).start()", "t = int(input())\nfor case in range(t):\n    input()\n    (n, k) = list(map(int, input().split()))\n    (x, y) = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    things = list(map(int, input().split()))\n    things = set([i - 1 for i in things])\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    pre = [-1] * n\n    qu = [x]\n    vis_node = set()\n    vis_node.add(x)\n    while qu:\n        nq = []\n        for i in qu:\n            vis_node.add(i)\n            for u in adj[i]:\n                if u not in vis_node:\n                    nq.append(u)\n                    pre[u] = i\n        qu = nq\n    res = 0\n    vis_node = set()\n    vis_node.add(x)\n    tmp = y\n    while tmp not in vis_node:\n        vis_node.add(tmp)\n        tmp = pre[tmp]\n        res += 1\n    for i in things:\n        tmp = i\n        while tmp not in vis_node:\n            vis_node.add(tmp)\n            tmp = pre[tmp]\n            res += 2\n    print(res)", "def solve(N, K, vlad, nast, to_do, g):\n    to_do.add(vlad)\n    to_do.add(nast)\n    S = [(vlad, 0)]\n    prnt = (N + 1) * [-1]\n    time = None\n    while S:\n        (cur, t) = S.pop()\n        if cur == nast:\n            time = t\n        for nxt in g[cur]:\n            if nxt != prnt[cur]:\n                prnt[nxt] = cur\n                S.append((nxt, t + 1))\n    hwss = list(to_do)\n    edge_ct = 0\n    for hws in hwss:\n        if hws != vlad and prnt[hws] not in to_do:\n            to_do.add(prnt[hws])\n            hwss.append(prnt[hws])\n        if hws != vlad:\n            edge_ct += 2\n    return edge_ct - time\n\ndef get_input():\n    input()\n    (N, K) = map(int, input().split())\n    (vlad, nast) = map(lambda x: int(x) - 1, input().split())\n    todo = set(map(lambda x: int(x) - 1, input().split()))\n    g = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (frm, to) = map(lambda x: int(x) - 1, input().split())\n        g[frm].append(to)\n        g[to].append(frm)\n    return (N, K, vlad, nast, todo, g)\nfor _ in range(int(input())):\n    (N, K, vlad, nast, todo, g) = get_input()\n    ans = solve(N, K, vlad, nast, todo, g)\n    print(ans)", "t = int(input())\nfor case in range(t):\n    input()\n    (n, k) = list(map(int, input().split()))\n    (x, y) = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    things = list(map(int, input().split()))\n    things = set([i - 1 for i in things])\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    pre = [-1] * n\n    qu = [x]\n    vis_node = set()\n    vis_node.add(x)\n    while qu:\n        nq = []\n        for i in qu:\n            vis_node.add(i)\n            for u in adj[i]:\n                if u not in vis_node:\n                    nq.append(u)\n                    pre[u] = i\n        qu = nq\n    res = 0\n    vis_node = set()\n    vis_node.add(x)\n    tmp = y\n    while tmp not in vis_node:\n        vis_node.add(tmp)\n        tmp = pre[tmp]\n        res += 1\n    for i in things:\n        tmp = i\n        while tmp not in vis_node:\n            vis_node.add(tmp)\n            tmp = pre[tmp]\n            res += 2\n    print(res)", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        input()\n        (n, k) = map(int, input().split())\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        arr = list(map(int, input().split()))\n        arr = set([el - 1 for el in arr])\n        graph = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            graph[a].append(b)\n            graph[b].append(a)\n        d = [[False, False] for _ in range(n)]\n\n        def helper(node, par):\n            if node in arr:\n                d[node][0] = True\n            if node == y:\n                d[node][1] = True\n            for nie in graph[node]:\n                if nie != par:\n                    (a, b) = helper(nie, node)\n                    d[node][0] |= a\n                    d[node][1] |= b\n            return (d[node][0], d[node][1])\n        helper(x, -1)\n\n        def dfs(node, par):\n            temp = 0\n            for nie in graph[node]:\n                if nie != par:\n                    if not d[nie][0] and (not d[nie][1]):\n                        pass\n                    elif d[nie][1]:\n                        temp += 1 + dfs(nie, node)\n                    elif d[nie][0]:\n                        temp += 2 + dfs(nie, node)\n            return temp\n        print(dfs(x, -1))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()"]