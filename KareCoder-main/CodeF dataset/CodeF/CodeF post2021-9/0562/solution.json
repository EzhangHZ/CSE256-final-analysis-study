["import sys\nfrom sys import stdin\nfrom collections import deque\nsys.setrecursionlimit(10 ** 9)\ninf = float('inf')\ninput = sys.stdin.readline\nstack = []\nstartset = set()\nres = []\nt = int(input())\nfor _ in range(t):\n    (n, st, fi) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b, w) = map(int, input().split())\n        g[a].append((b, w))\n        g[b].append((a, w))\n    startset.clear()\n    used = [False] * (n + 1)\n    used[fi] = True\n    stack.append((st, 0))\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack.append((fi, 0))\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != fi and wei in startset:\n            stack.clear()\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    res.append('YES' if found else 'NO')\nprint(*res, sep='\\n')", "import sys\nfrom sys import stdin\nfrom collections import deque\nsys.setrecursionlimit(10 ** 9)\ninf = float('inf')\ninput = sys.stdin.readline\nstack = []\nstartset = set()\nres = []\nt = int(input())\nfor _ in range(t):\n    (n, st, fi) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b, w) = map(int, input().split())\n        g[a].append((b, w))\n        g[b].append((a, w))\n    startset.clear()\n    used = [False] * (n + 1)\n    used[fi] = True\n    stack.append((st, 0))\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack.append((fi, 0))\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != fi and wei in startset:\n            stack.clear()\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    res.append('YES' if found else 'NO')\nprint(*res, sep='\\n')", "t = int(input())\nfor _ in range(t):\n\n    def sol():\n        (n, a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        edges = [[] for i in range(n)]\n        for i in range(n - 1):\n            (v1, v2, w) = map(int, input().split())\n            v1 -= 1\n            v2 -= 1\n            edges[v1].append((v2, w))\n            edges[v2].append((v1, w))\n        from_a = set([0])\n        from_b = set()\n        visited = [False for _ in range(n)]\n        hack = [False]\n\n        def dfs(vc, ccur, from_arr):\n            stack = [(vc, ccur)]\n            while stack:\n                (v, cur) = stack.pop()\n                visited[v] = True\n                for (to, we) in edges[v]:\n                    if not visited[to] and to == b and (cur ^ we == 0):\n                        hack[0] = True\n                    if not visited[to] and to != b:\n                        from_arr.add(cur ^ we)\n                        stack.append((to, cur ^ we))\n        dfs(a, 0, from_a)\n        if hack[0]:\n            return 'YES'\n        visited = [False for _ in range(n)]\n        dfs(b, 0, from_b)\n        p = set(from_a).intersection(set(from_b))\n        if p:\n            return 'YES'\n        else:\n            return 'NO'\n    print(sol())", "stack = []\nhashesSt = set()\nt = int(input())\nfor _ in range(t):\n    (n, st, fi) = map(int, input().split())\n    st -= 1\n    fi -= 1\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b, w) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].append((b, w))\n        g[b].append((a, w))\n    hashesSt.clear()\n    used = [False] * n\n    used[fi] = True\n    stack.append((st, 0))\n    while stack:\n        (ver, hsh) = stack.pop()\n        used[ver] = True\n        hashesSt.add(hsh)\n        for (to, w) in g[ver]:\n            if not used[to]:\n                stack.append((to, hsh ^ w))\n    used = [False] * n\n    stack.append((fi, 0))\n    found = False\n    while stack:\n        (ver, hsh) = stack.pop()\n        used[ver] = True\n        if ver != fi and hsh in hashesSt:\n            stack.clear()\n            found = True\n            break\n        for (to, w) in g[ver]:\n            if not used[to]:\n                stack.append((to, hsh ^ w))\n    print('YES' if found else 'NO')", "from collections import Counter\nimport sys, threading\ninput = lambda : sys.stdin.readline().strip()\n\ndef main():\n    for _ in range(int(input())):\n        (n, a, b) = map(int, input().split())\n        adj = [[] for _ in range(n + 1)]\n        for _ in range(n - 1):\n            (u, v, w) = map(int, input().split())\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n        (ok, cnt) = (False, Counter())\n\n        def dfs1(u, p, xor):\n            cnt[xor] += 1\n            for (v, w) in adj[u]:\n                if v == p:\n                    continue\n                dfs1(v, u, xor ^ w)\n        for (v, w) in adj[b]:\n            dfs1(v, b, w)\n\n        def dfs2(u, p, xor):\n            nonlocal ok\n            if u == b:\n                return\n            if cnt[xor]:\n                ok = True\n                return\n            for (v, w) in adj[u]:\n                if v == p:\n                    continue\n                dfs2(v, u, xor ^ w)\n        dfs2(a, -1, 0)\n        print('YES' if ok else 'NO')\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "t = int(input())\n\ndef dfs(graph, src, terminate=None):\n    visited = set()\n    xor = [-1 for i in range(len(graph))]\n    xor[src] = 0\n    stack = [src]\n    visited.add(src)\n    while stack:\n        u = stack.pop()\n        if u == terminate:\n            continue\n        for (v, w) in graph[u]:\n            if v not in visited:\n                if xor[v] ^ w == 0 or v != terminate:\n                    xor[v] = xor[u] ^ w\n                    visited.add(v)\n                    stack.append(v)\n    return xor\n\ndef solve():\n    (n, a, b) = map(int, input().split())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u - 1].append((v - 1, w))\n        adj[v - 1].append((u - 1, w))\n    x1 = dfs(adj, a - 1, terminate=b - 1)\n    x2 = dfs(adj, b - 1)\n    aa = set()\n    for (i, xx) in enumerate(x1):\n        if i == b - 1 and xx == 0:\n            print('YES')\n            return\n        else:\n            aa.add(xx)\n    bb = set()\n    for (i, xx) in enumerate(x2):\n        if i != b - 1:\n            bb.add(xx)\n    for x in aa:\n        if x in bb and x != -1:\n            print('YES')\n            return\n    print('NO')\nfor _ in range(t):\n    solve()", "def main():\n    for _ in range(int(input())):\n        (n, a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (x, y, w) = map(int, input().split())\n            x -= 1\n            y -= 1\n            graph[x].append((y, w))\n            graph[y].append((x, w))\n        xors = set()\n\n        def dfs(node, parent, xor):\n            if node == a and xor == 0:\n                return True\n            for (v, w) in graph[node]:\n                if v == parent:\n                    continue\n                if dfs(v, node, xor ^ w):\n                    return True\n                xors.add(xor ^ w)\n            return False\n        if dfs(b, -1, 0):\n            print('YES')\n            continue\n\n        def dfs(node, parent, xor):\n            if node == b:\n                return xor == 0\n            if xor in xors:\n                return True\n            for (v, w) in graph[node]:\n                if v == parent:\n                    continue\n                if dfs(v, node, xor ^ w):\n                    return True\n            return False\n        path = [a]\n        print('YES' if dfs(a, -1, 0) else 'NO')\nimport sys, threading\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\n\ndef solve(g, a, b):\n\n    def bfs1(start):\n        q = [(start, 0)]\n        visited = {start}\n        ans = set()\n        while q:\n            newQ = []\n            for (u, x) in q:\n                if u != b:\n                    ans.add(x)\n                for v in g[u]:\n                    if v not in visited:\n                        newQ.append([v, x ^ g[u][v]])\n                        visited.add(v)\n            q = newQ\n        return ans\n    target = bfs1(b)\n    if 0 in target:\n        return 'YES'\n    q = [(a, 0)]\n    visited = {a}\n    while q:\n        newQ = []\n        for (u, x) in q:\n            if x in target:\n                return 'YES'\n            for v in g[u]:\n                if v != b and v not in visited:\n                    newQ.append([v, x ^ g[u][v]])\n                    visited.add(v)\n        q = newQ\n    return 'NO'\nt = int(input())\nfor _ in range(t):\n    (n, a, b) = map(int, input().split())\n    g = {i: collections.defaultdict(int) for i in range(n)}\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        g[u - 1][v - 1] = w\n        g[v - 1][u - 1] = w\n    print(solve(g, a - 1, b - 1))", "testcase = int(input())\nfor _ in range(testcase):\n    (n, a, b) = [int(num) for num in input().split()]\n    graph = {i: set() for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        (v0, v1, w) = [int(num) for num in input().split()]\n        graph[v0].add((v1, w))\n        graph[v1].add((v0, w))\n    seen = set()\n    seen.add(a)\n    ha = [(a, 0)]\n    ass = set()\n    ass.add(0)\n    while ha:\n        (q, xor) = ha.pop()\n        for (adj, w) in graph[q]:\n            if adj not in seen:\n                if adj == b:\n                    continue\n                seen.add(adj)\n                k = xor ^ w\n                ha.append((adj, k))\n                ass.add(k)\n    seen = set()\n    seen.add(b)\n    hb = [(b, 0)]\n    bss = set()\n    while hb:\n        (q, xor) = hb.pop()\n        for (adj, w) in graph[q]:\n            if adj not in seen:\n                seen.add(adj)\n                k = xor ^ w\n                hb.append((adj, k))\n                bss.add(k)\n    bss = list(bss)\n    bss = [num in ass for num in bss]\n    print('YES' if any(bss) else 'NO')", "testcase = int(input())\nfor _ in range(testcase):\n    (n, a, b) = [int(num) for num in input().split()]\n    graph = {i: set() for i in range(1, n + 1)}\n    for _ in range(n - 1):\n        (v0, v1, w) = [int(num) for num in input().split()]\n        graph[v0].add((v1, w))\n        graph[v1].add((v0, w))\n    seen = set()\n    seen.add(a)\n    ha = [(a, 0)]\n    ass = set()\n    ass.add(0)\n    while ha:\n        (q, xor) = ha.pop()\n        for (adj, w) in graph[q]:\n            if adj not in seen:\n                if adj == b:\n                    continue\n                seen.add(adj)\n                k = xor ^ w\n                ha.append((adj, k))\n                ass.add(k)\n    seen = set()\n    seen.add(b)\n    hb = [(b, 0)]\n    bss = set()\n    while hb:\n        (q, xor) = hb.pop()\n        for (adj, w) in graph[q]:\n            if adj not in seen:\n                seen.add(adj)\n                k = xor ^ w\n                hb.append((adj, k))\n                bss.add(k)\n    bss = list(bss)\n    bss = [num in ass for num in bss]\n    print('YES' if any(bss) else 'NO')", "from collections import defaultdict, deque\nt = int(input())\n\ndef bfs(graph, x):\n    q = deque([(x, 0)])\n    v = {x}\n    xor = {}\n    while len(q) > 0:\n        (curr, xorval) = q.pop()\n        xor[curr] = xorval\n        for (j, w) in graph[curr]:\n            if j not in v:\n                v.add(j)\n                q.appendleft((j, xorval ^ w))\n    return xor\nfor _ in range(t):\n    (n, a, b) = map(int, input().split())\n    graph = defaultdict(set)\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        graph[u].add((v, w))\n        graph[v].add((u, w))\n    xor = bfs(graph, b)\n    bvals = set()\n    for i in graph:\n        if i != b:\n            bvals.add(xor[i])\n    pos = xor[a] == 0\n    q = deque([(a, 0)])\n    v = {a, b}\n    while len(q) > 0:\n        (curr, xorval) = q.pop()\n        if xorval in bvals:\n            pos = True\n            break\n        for (j, w) in graph[curr]:\n            if j not in v:\n                v.add(j)\n                q.appendleft((j, xorval ^ w))\n    print('YES' if pos else 'NO')", "from bisect import bisect\nfrom collections import deque\nfor tcase in range(int(input())):\n    (n, a, b) = map(int, input().split())\n    adj = [[] for u in range(n + 1)]\n    for i in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    (xa, xb) = ([-1] * (n + 1), [-1] * (n + 1))\n    q = deque()\n    xb[b] = 0\n    q.append(b)\n    while len(q) > 0:\n        u = q.popleft()\n        for (v, w) in adj[u]:\n            if xb[v] == -1:\n                xb[v] = xb[u] ^ w\n                q.append(v)\n    q = deque()\n    xa[a] = 0\n    xa[b] = -2\n    q.append(a)\n    while len(q) > 0:\n        u = q.popleft()\n        for (v, w) in adj[u]:\n            if xa[v] == -1:\n                xa[v] = xa[u] ^ w\n                q.append(v)\n    s = [xb[u] for u in range(1, n + 1) if u != b]\n    s.sort()\n    ans = False\n    for u in range(1, n + 1):\n        x = xa[u]\n        i = bisect(s, x) - 1\n        ans = ans or (i >= 0 and s[i] == x)\n    print('YES' if ans else 'NO')", "def solve():\n    (n, a, b) = tuple(map(int, input().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v, w) = tuple(map(int, input().split()))\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    tfb = {}\n    queue = [(b, 0)]\n    visited = [False] * (n + 1)\n    while len(queue) > 0:\n        (cur, w) = queue.pop(0)\n        visited[cur] = True\n        for (node, wn) in graph[cur]:\n            if not visited[node]:\n                wn ^= w\n                tfb[wn] = True\n                queue.append((node, wn))\n    queue = [(a, 0)]\n    visited = [False] * (n + 1)\n    while len(queue) > 0:\n        (cur, w) = queue.pop(0)\n        if tfb.get(w) is not None:\n            print('YES')\n            return\n        visited[cur] = True\n        for (node, wn) in graph[cur]:\n            if node == b and w ^ wn == 0:\n                print('YES')\n                return\n            if node != b and (not visited[node]):\n                wn ^= w\n                queue.append((node, wn))\n    print('NO')\nt = int(input())\nfor _ in range(t):\n    solve()", "import queue\nT = int(input())\nfor t in range(T):\n    (n, a, b) = [int(x) for x in input().split()]\n    a = a - 1\n    b = b - 1\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v, w) = [int(x) for x in input().split()]\n        g[u - 1].append((v - 1, w))\n        g[v - 1].append((u - 1, w))\n    sa = set()\n    sb = set()\n    q = queue.Queue()\n    vis = [False] * n\n    vis[a] = True\n    q.put((a, 0))\n    ans = False\n    while not q.empty():\n        (u, w1) = q.get()\n        for (v, w2) in g[u]:\n            if v == b and w1 ^ w2 == 0:\n                ans = True\n            if not vis[v] and v != b:\n                w = w1 ^ w2\n                sa.add(w)\n                vis[v] = True\n                q.put((v, w))\n    vis = [False] * n\n    vis[b] = True\n    q.put((b, 0))\n    while not q.empty():\n        (u, w1) = q.get()\n        for (v, w2) in g[u]:\n            if not vis[v]:\n                w = w1 ^ w2\n                if w == 0:\n                    ans = True\n                sb.add(w)\n                vis[v] = True\n                q.put((v, w))\n    for w in sa:\n        if w in sb:\n            ans = True\n    if ans:\n        print('YES')\n    else:\n        print('NO')"]