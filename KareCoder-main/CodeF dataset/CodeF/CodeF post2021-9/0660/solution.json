["import heapq\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    (kvs, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    cnt = {}\n    for num in arr:\n        if num not in cnt:\n            cnt[num] = 0\n        cnt[num] += 1\n    K = k\n    x = kvs\n    for i in range(kvs + 1):\n        if i not in cnt:\n            if K:\n                K -= 1\n            else:\n                x = i\n                break\n    if x == kvs:\n        return 0\n    v = []\n    for key in cnt:\n        if key >= x:\n            heapq.heappush(v, cnt[key])\n    cost = len(v)\n    while v:\n        if v[0] <= k:\n            k -= v[0]\n            heapq.heappop(v)\n            cost -= 1\n        else:\n            break\n    return cost\nfor _ in range(int(input())):\n    print(solve())", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    (n, k) = M()\n    a = L()\n    d = {}\n    mx = 0\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    while mx in d:\n        mx += 1\n    for i in range(k):\n        mx += 1\n        while mx in d:\n            mx += 1\n    l = sorted([i for i in set(a) if i > mx], key=lambda x: d[x])\n    ans = len(l)\n    for i in l:\n        if k >= d[i]:\n            k -= d[i]\n            ans -= 1\n    print(ans)", "import heapq\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    cnt = {}\n    for num in arr:\n        if num not in cnt:\n            cnt[num] = 0\n        cnt[num] += 1\n    K = k\n    x = n\n    for i in range(n + 1):\n        if i not in cnt:\n            if K:\n                K -= 1\n            else:\n                x = i\n                break\n    if x == n:\n        return 0\n    v = []\n    for key in cnt:\n        if key >= x:\n            heapq.heappush(v, cnt[key])\n    cost = len(v)\n    while v:\n        if v[0] <= k:\n            k -= v[0]\n            heapq.heappop(v)\n            cost -= 1\n        else:\n            break\n    return cost\nt = int(input())\nfor i in range(t):\n    print(solve())", "import heapq\nfrom collections import Counter\n\ndef fuck(a, k):\n    n = len(a)\n    a.sort()\n    (mex, last, i) = (0, k, 0)\n    while i < n:\n        if a[i] >= mex:\n            gap = a[i] - mex\n            if gap <= last:\n                mex = a[i] + 1\n                last -= gap\n            else:\n                mex += last\n                break\n        i += 1\n    mp = Counter(a[i:])\n    q = [mp[i] for i in mp]\n    heapq.heapify(q)\n    while len(q) > 0 and k > 0:\n        t = heapq.heappop(q)\n        if t > k:\n            heapq.heappush(q, t - k)\n            break\n        else:\n            k -= t\n    return len(q)\n\ndef solve():\n    T = int(input())\n    for ii in range(T):\n        (n, k) = map(int, input().split())\n        line = input().split()\n        a = []\n        for s in line:\n            a.append(int(s))\n        print(fuck(a, k))\nsolve()", "import heapq\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    cnt = {}\n    for num in arr:\n        if num not in cnt:\n            cnt[num] = 0\n        cnt[num] += 1\n    K = k\n    x = n\n    for i in range(n + 1):\n        if i not in cnt:\n            if K:\n                K -= 1\n            else:\n                x = i\n                break\n    if x == n:\n        return 0\n    v = []\n    for key in cnt:\n        if key >= x:\n            heapq.heappush(v, cnt[key])\n    cost = len(v)\n    while v:\n        if v[0] <= k:\n            k -= v[0]\n            heapq.heappop(v)\n            cost -= 1\n        else:\n            break\n    return cost\nfor _ in range(int(input())):\n    print(solve())", "import heapq\nfrom collections import Counter\n\ndef fuck(a, k):\n    n = len(a)\n    a.sort()\n    (mex, last, i) = (0, k, 0)\n    while i < n:\n        if a[i] >= mex:\n            gap = a[i] - mex\n            if gap <= last:\n                mex = a[i] + 1\n                last -= gap\n            else:\n                mex += last\n                break\n        i += 1\n    mp = Counter(a[i:])\n    q = []\n    for v in mp:\n        heapq.heappush(q, mp[v])\n    while len(q) > 0 and k > 0:\n        t = heapq.heappop(q)\n        if t > k:\n            heapq.heappush(q, t - k)\n            break\n        else:\n            k -= t\n    return len(q)\n\ndef solve():\n    T = int(input())\n    for ii in range(T):\n        (n, k) = map(int, input().split())\n        line = input().split()\n        a = []\n        for s in line:\n            a.append(int(s))\n        print(fuck(a, k))\nsolve()", "I = input\nR = lambda : map(int, I().split())\nfor _ in range(int(I())):\n    (n, k) = R()\n    a = [*R()]\n    c = {}\n    mx = 0\n    for v in a:\n        c[v] = c.get(v, 0) + 1\n    while mx in c:\n        mx += 1\n    for _ in range(k):\n        mx += 1\n        while mx in c:\n            mx += 1\n    b = sorted([v for v in set(a) if v > mx], key=lambda x: c[x])\n    res = len(b)\n    for v in b:\n        if k >= c[v]:\n            k -= c[v]\n            res -= 1\n        else:\n            break\n    print(res)", "I = input\nR = lambda : map(int, I().split())\nfor _ in range(int(I())):\n    (n, k) = R()\n    a = [*R()]\n    c = {}\n    mx = 0\n    for v in a:\n        c[v] = c.get(v, 0) + 1\n    while mx in c:\n        mx += 1\n    for _ in range(k):\n        mx += 1\n        while mx in c:\n            mx += 1\n    b = sorted([v for v in set(a) if v > mx], key=lambda x: c[x])\n    res = len(b)\n    for v in b:\n        if k >= c[v]:\n            k -= c[v]\n            res -= 1\n        else:\n            break\n    print(res)", "import heapq\nfrom collections import Counter\n\ndef fuck(a, k):\n    n = len(a)\n    a.sort()\n    (mex, suf, i) = (0, k, 0)\n    while i < n:\n        if a[i] < mex:\n            i += 1\n            continue\n        gap = a[i] - mex\n        if gap <= k:\n            mex = a[i] + 1\n            k -= gap\n        else:\n            mex += k\n            break\n        i += 1\n    mp = Counter(a[i:])\n    q = []\n    for v in mp:\n        heapq.heappush(q, mp[v])\n    while len(q) > 0 and suf > 0:\n        t = heapq.heappop(q)\n        if t > suf:\n            heapq.heappush(q, t - suf)\n            break\n        else:\n            suf -= t\n    return len(q)\n\ndef solve():\n    T = int(input())\n    for ii in range(T):\n        (n, k) = map(int, input().split())\n        line = input().split()\n        a = []\n        for s in line:\n            a.append(int(s))\n        print(fuck(a, k))\nsolve()", "import heapq\nfrom collections import Counter\n\ndef fuck(a, k):\n    n = len(a)\n    a.sort()\n    (mex, suf, i) = (0, k, 0)\n    while i < n:\n        if a[i] >= mex:\n            gap = a[i] - mex\n            if gap <= k:\n                mex = a[i] + 1\n                k -= gap\n            else:\n                mex += k\n                break\n        i += 1\n    mp = Counter(a[i:])\n    q = []\n    for v in mp:\n        heapq.heappush(q, mp[v])\n    while len(q) > 0 and suf > 0:\n        t = heapq.heappop(q)\n        if t > suf:\n            heapq.heappush(q, t - suf)\n            break\n        else:\n            suf -= t\n    return len(q)\n\ndef solve():\n    T = int(input())\n    for ii in range(T):\n        (n, k) = map(int, input().split())\n        line = input().split()\n        a = []\n        for s in line:\n            a.append(int(s))\n        print(fuck(a, k))\nsolve()", "import sys, math\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    aux_list = [0] * n\n    for i in a:\n        if i < n:\n            aux_list[i] += 1\n    mex = None\n    for i in range(n):\n        if aux_list[i] == 0:\n            mex = i\n            break\n    if mex is None:\n        print('0')\n        continue\n    left = k\n    max_mex = None\n    for i in range(n):\n        if aux_list[i] == 0:\n            if left > 0:\n                left -= 1\n            elif max_mex is None:\n                max_mex = i\n    if max_mex is None:\n        max_mex = n\n    s = dict({})\n    for x in a:\n        if x >= max_mex:\n            if x not in s:\n                s[x] = 0\n            s[x] += 1\n    L = []\n    for x in s:\n        L.append([s[x], x])\n    L.sort()\n    ans = len(L)\n    for i in range(len(L)):\n        if L[i][0] <= k:\n            k -= L[i][0]\n            ans -= 1\n    print(ans)"]