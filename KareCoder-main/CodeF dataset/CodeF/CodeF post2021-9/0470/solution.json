["from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(float, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        ans = float('inf')\n        for i in range(n):\n            ht = {}\n            for j in range(i + 1, n):\n                d = (arr[i] - arr[j]) / (i - j)\n                if d in ht:\n                    ht[d] += 1\n                else:\n                    ht[d] = 1\n            if ht:\n                ans = min(ans, n - 1 - max(ht.values()))\n        print(ans)", "from collections import defaultdict\nmydict = defaultdict(lambda : 0)\ncases = int(input())\nfor _ in range(cases):\n    n = int(input())\n    line = input().split()\n    L = []\n    for elem in line:\n        L.append(int(elem))\n    if n <= 2:\n        print(0)\n        continue\n    consider = []\n    for l in range(n - 1):\n        mydict = defaultdict(lambda : 0)\n        for r in range(l + 1, n):\n            d = (L[r] - L[l]) / (r - l)\n            mydict[d] += 1\n        z = max(mydict.values())\n        consider.append(z)\n    z = max(consider)\n    print(n - z - 1)", "x = int(input())\nfor i in range(x):\n    y = int(input())\n    A = input().split()\n    B = [0] * y\n    maxi = 0\n    if y == 1:\n        print('0')\n    else:\n        for j in range(y):\n            B[j] = int(A[j])\n        for j in range(y - 1):\n            C = []\n            D = []\n            for k in range(j + 1, y):\n                a = (B[k] - B[j]) / (k - j)\n                C.append(float(a))\n            C.sort()\n            max_count = 1\n            curr_count = 1\n            for i in range(1, len(C)):\n                if C[i] == C[i - 1]:\n                    curr_count += 1\n                else:\n                    curr_count = 1\n                if curr_count > max_count:\n                    max_count = curr_count\n            if max_count + 1 > maxi:\n                maxi = max_count + 1\n        print(len(A) - maxi)", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl, bisect_right as br\nsys.setrecursionlimit(100000000)\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    temp = 0\n    ans = 0\n    for i in range(n - 1):\n        temp = 0\n        d = dict()\n        for j in range(i + 1, n):\n            k = (arr[j] - arr[i]) * 1.0 / (i - j)\n            d[k] = d.get(k, 0) + 1\n            temp = max(temp, d[k])\n        ans = max(ans, temp)\n    return n - ans - 1\n\ndef main():\n    t = int(input())\n    while t:\n        print(solve())\n        t -= 1\nmain()", "q = int(input())\nfor _ in range(q):\n    n = int(input())\n    a = [int(a) for a in input().split()]\n    len_prog = 0\n    for i in range(n):\n        dct = {}\n        for j in range(i + 1, n):\n            name = (a[i] - a[j]) / (i - j)\n            if name not in dct:\n                dct[name] = {i, j}\n            else:\n                dct[name].add(j)\n        for (k, v) in dct.items():\n            if len_prog < len(v):\n                len_prog = len(v)\n    if n > 1:\n        print(n - len_prog)\n    else:\n        print(0)", "for iii in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    q1 = {}\n    maxx = 0\n    for i in range(n):\n        q1 = {}\n        for j in range(i + 1, n):\n            x = (q[j] - q[i]) / (j - i)\n            if x in q1:\n                q1[x] += 1\n            else:\n                q1[x] = 1\n        for i in q1:\n            maxx = max(maxx, q1[i])\n    print(n - 1 - maxx)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    best = 0\n    for j in range(n - 1):\n        s = {}\n        for k in range(j + 1, n):\n            if (l[k] - l[j]) * 10 ** 6 // (k - j) in s.keys():\n                s[(l[k] - l[j]) * 10 ** 6 // (k - j)] += 1\n            else:\n                s[(l[k] - l[j]) * 10 ** 6 // (k - j)] = 1\n        best = max(best, max(s.values()))\n    print(n - 1 - best)", "import sys\nfrom math import sqrt, gcd\nfrom collections import deque\nsys.setrecursionlimit(10 ** 8)\nI = lambda : int(input())\nS = lambda : input().strip()\nM = lambda : map(int, input().strip().split())\nL = lambda : list(map(float, input().strip().split()))\nmod = 1000000007\nfor _ in range(I()):\n    n = I()\n    arr = L()\n    t = 0\n    ans = 0\n    for i in range(n - 1):\n        t = 0\n        di = {}\n        for j in range(i + 1, n):\n            d = (arr[j] - arr[i]) / (i - j)\n            if d in di:\n                di[d] += 1\n            else:\n                di[d] = 1\n            t = max(t, di[d])\n        ans = max(ans, t)\n    print(n - 1 - ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    t = 0\n    ans = 0\n    for i in range(0, n - 1):\n        t = 0\n        d = {}\n        for j in range(i + 1, n):\n            k = (a[j] - a[i]) * 1.0 / (i - j)\n            if k not in d:\n                d[k] = 1\n            else:\n                d[k] += 1\n            ans = max(ans, d[k])\n    print(n - ans - 1)", "class codeforce:\n\n    def solve(self, n, a):\n        t = 0\n        result = 0\n        for i in range(n - 1):\n            t = 0\n            di = {}\n            for j in range(i + 1, n):\n                if (a[j] - a[i]) * 1.0 / (i - j) in di:\n                    di[(a[j] - a[i]) * 1.0 / (i - j)] += 1\n                else:\n                    di[(a[j] - a[i]) * 1.0 / (i - j)] = 1\n                t = max(t, di[(a[j] - a[i]) * 1.0 / (i - j)])\n            result = max(result, t)\n        return n - result - 1\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    arr = list(map(int, input().split()))\n    res = codeforce()\n    print(res.solve(n, arr))\n    t -= 1", "from collections import Counter\nimport sys\nfin = sys.stdin\n\ndef solve(a, n):\n    if n == 1:\n        return 0\n    count = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            delta = a[j] - a[i]\n            steps = j - i\n            d = delta / steps\n            a0 = a[i] - d * i\n            count.append((int(a0 * 1000000000), int(d * 1000000000)))\n    count = Counter(count)\n    (_, count) = count.most_common(1)[0]\n    for i in range(1, n):\n        if count <= i * (i + 1) // 2:\n            return n - i - 1\nt = int(fin.readline())\nfor test in range(t):\n    n = int(fin.readline())\n    a = list(map(int, fin.readline().split()))\n    print(solve(a, n))", "from collections import defaultdict\nfrom collections import defaultdict, Counter\nn = int(input())\nresults = []\nfor i in range(n):\n    m = int(input())\n    a = [int(x) for x in input().strip().split(' ')]\n    if m == 1:\n        results.append(0)\n    else:\n        tmp_res = m\n        for j in range(m):\n            line = []\n            for k in range(m):\n                if j != k:\n                    m1 = (a[k] - a[j]) / (k - j)\n                else:\n                    m1 = 0\n                line.append(m1)\n            counter = Counter(line)\n            maxi = max(counter, key=counter.get)\n            if abs(maxi) == 0.0:\n                tmp_res = min(tmp_res, m - counter[maxi])\n            else:\n                tmp_res = min(tmp_res, m - counter[maxi] - 1)\n        results.append(tmp_res)\nfor line in results:\n    print(line)", "from collections import Counter\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 2 or n == 1:\n        print(0)\n        continue\n    mx = 0\n    for j in range(n):\n        l = []\n        for k in range(n):\n            if j < k:\n                l.append((a[k] - a[j]) / (k - j))\n            elif j > k:\n                l.append((a[j] - a[k]) / (j - k))\n        c = Counter(l)\n        if max(c.values()) > mx:\n            mx = max(c.values())\n    print(n - mx - 1)", "from collections import defaultdict\n\ndef answer(n, arr):\n    if n == 1 or n == 2:\n        return 0\n    maximum = 0\n    for i in range(len(arr)):\n        d = defaultdict(int)\n        for j in range(len(arr)):\n            if j != i:\n                d[(arr[i] - arr[j]) / (i - j)] += 1\n        if max(d.values()) > maximum:\n            maximum = max(d.values())\n    return n - maximum - 1\nt = int(input())\nfor k in range(t):\n    n = int(input())\n    inp = input().split()\n    arr = []\n    for i in inp:\n        arr.append(int(i))\n    print(answer(n, arr))", "from collections import Counter\nimport sys\nfin = sys.stdin\n\ndef solve(a, n):\n    if n == 1:\n        return 0\n    count = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            delta = a[j] - a[i]\n            steps = j - i\n            d = delta / steps\n            a0 = a[i] - d * i\n            count.append((int(a0 * 1000000000), int(d * 1000000000)))\n    count = Counter(count)\n    (_, count) = count.most_common(1)[0]\n    for i in range(1, n):\n        if count <= i * (i + 1) // 2:\n            return n - i - 1\nt = int(fin.readline())\nfor test in range(t):\n    n = int(fin.readline())\n    a = list(map(int, fin.readline().split()))\n    print(solve(a, n))", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dif = []\n    for i in range(1, n):\n        dif.append(arr[i] - arr[i - 1])\n    s = set(dif)\n    if n <= 2 or len(s) == 1:\n        print(0)\n        continue\n    res = 0\n    for i in range(n - 1):\n        ans = {}\n        ans1 = 0\n        for j in range(i + 1, n):\n            slope = (arr[j] - arr[i]) / (j - i)\n            if slope not in ans:\n                ans[slope] = 1\n            else:\n                ans[slope] += 1\n            ans1 = max(ans.values())\n        res = max(res, ans1)\n    print(n - res - 1)", "import os, sys\nfrom collections import Counter\nMAXN = 100000000\nMAXN = 1000000000\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef solve(a, N):\n    if N <= 2:\n        return 0\n    counter = Counter()\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            d = (a[j] - a[i]) / (j - i)\n            a0 = a[i] - i * d\n            counter[int(a0 * MAXN), int(d * MAXN)] += 1\n    (_, largest_count) = counter.most_common(1)[0]\n    ans = -1\n    for n in range(2, N + 1):\n        if n * (n - 1) // 2 >= largest_count:\n            ans = N - n\n            break\n    return ans\nT = read_int()\nwhile T > 0:\n    N = read_int()\n    a = read_arr()\n    print(solve(a, N))\n    T -= 1", "import os, sys\nfrom collections import Counter\nMAXN = 100000000\nMAXN = 1000000000\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef solve(a, N):\n    if N <= 2:\n        return 0\n    counter = Counter()\n\n    def get_a0_d(a, i, j):\n        d = (a[j] - a[i]) / (j - i)\n        a0 = a[i] - i * d\n        return (int(a0 * MAXN), int(d * MAXN))\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            counter[get_a0_d(a, i, j)] += 1\n    (_, largest_count) = counter.most_common(1)[0]\n    ans = -1\n    for n in range(2, N + 1):\n        if n * (n - 1) / 2 >= largest_count:\n            ans = N - n\n            break\n    return ans\nT = read_int()\nwhile T > 0:\n    N = read_int()\n    a = read_arr()\n    print(solve(a, N))\n    T -= 1", "import math as mt\nfor _ in range(int(input())):\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    if n == 1:\n        print(0)\n        continue\n    mn = 10 ** 7\n    ans = []\n    for i in range(n):\n        d = []\n        for j in range(n):\n            if i == j:\n                continue\n            d1 = (l[j] - l[i]) / (j - i)\n            d += [d1]\n        d.sort()\n        mx = -10 ** 9\n        cnt = 1\n        for j in range(1, len(d)):\n            if d[j] == d[j - 1]:\n                cnt += 1\n            else:\n                if cnt > mx:\n                    mx = cnt\n                cnt = 1\n        if cnt > mx:\n            mx = cnt\n        ans += [mx]\n    print(n - max(ans) - 1)", "import collections\nepsilon = 10 ** (-6)\nt = int(input())\nfor k in range(t):\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    res = 1\n    if n <= 2:\n        res = n - 1\n    else:\n        for i in range(n):\n            diff = collections.defaultdict(int)\n            for j in range(n):\n                if i != j:\n                    diff[(l[j] - l[i]) / (j - i)] += 1\n            res = max(res, max(diff.values()))\n    print(n - res - 1)", "from math import *\nfrom collections import *\nfrom itertools import *\nfrom functools import *\nfrom bisect import *\nfrom heapq import *\nfrom operator import *\nfrom sys import *\nsetrecursionlimit(100000000)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = 1\n    if n <= 2:\n        print(0)\n        continue\n    for i in range(n):\n        d = defaultdict(int)\n        for j in range(n):\n            if i != j:\n                d[(l[j] - l[i]) / (j - i)] += 1\n        if d:\n            ans = max(ans, max(d.values()))\n    print(n - 1 - ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1 or n == 2:\n        print(0)\n    else:\n        best = 0\n        for i in range(n):\n            c = {}\n            for j in range(n):\n                if i != j:\n                    if (a[i] - a[j]) / (i - j) in c:\n                        c[(a[i] - a[j]) / (i - j)] += 1\n                    else:\n                        c[(a[i] - a[j]) / (i - j)] = 1\n            best = max(best, max(c.values()))\n        print(n - 1 - best)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    s = [int(x) for x in input().split()]\n    score = []\n    for i in range(n):\n        slopes = dict()\n        for j in range(n):\n            if j != i:\n                slope = (s[i] - s[j]) / (i - j)\n                if slope not in slopes:\n                    slopes[slope] = 1\n                else:\n                    slopes[slope] += 1\n        Max = 0\n        for i in slopes:\n            if slopes[i] > Max:\n                Max = slopes[i]\n        score.append(n - Max - 1)\n    print(min(score))", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    count = 0\n    if n == 1:\n        print(0)\n    elif n == 2:\n        print(0)\n    else:\n        not_to_change = 0\n        for i in range(n):\n            d = Counter()\n            for j in range(n):\n                if i != j:\n                    temp_diff = (arr[i] - arr[j]) / (i - j)\n                    d[temp_diff] += 1\n            temp_max = max(d.values())\n            if temp_max > not_to_change:\n                not_to_change = temp_max\n        to_change = n - 1 - not_to_change\n        print(to_change)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    li = list(map(int, input().split()))\n    max_R = 0\n    for i in range(n):\n        diff_arr = {}\n        for j in range(n):\n            if i != j:\n                temp = (li[i] - li[j]) / (i - j)\n                if temp not in diff_arr:\n                    diff_arr[temp] = 0\n                diff_arr[temp] += 1\n        max_r = 0\n        for k in diff_arr.values():\n            if k > max_r:\n                max_r = k\n        if max_r > max_R:\n            max_R = max_r\n    print(n - max_R - 1)", "def mp(p):\n    n = len(p)\n    if n < 3:\n        return n\n    max_val = 0\n    for i in p:\n        d = {}\n        dups = 0\n        cur_max = 0\n        for j in p:\n            if i != j:\n                if j[0] == i[0]:\n                    s = 'inf'\n                else:\n                    s = float(j[1] - i[1]) / float(j[0] - i[0])\n                d[s] = d.get(s, 0) + 1\n                cur_max = max(cur_max, d[s])\n            else:\n                dups += 1\n        max_val = max(max_val, cur_max + dups)\n    return max_val\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    points = []\n    for i in range(n):\n        points.append([i, a[i]])\n    print(n - mp(points))", "for i in range(int(input())):\n    n = int(input())\n    arr = (*map(int, input().split()),)\n    if n == 1:\n        print(0)\n    else:\n        ans = float('inf')\n        for j in range(n):\n            freq = {}\n            for i in range(n):\n                if i != j:\n                    d = round((arr[i] - arr[j]) / (i - j), 10)\n                    freq[d] = freq.get(d, 0) + 1\n            ans = min(ans, n - 1 - max(freq.values()))\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = (*map(int, input().split()),)\n    if n == 1:\n        print(0)\n    else:\n        ans = float('inf')\n        for j in range(n):\n            freq = {}\n            for i in range(n):\n                if i != j:\n                    d = round((arr[i] - arr[j]) / (i - j), 10)\n                    freq[d] = freq.get(d, 0) + 1\n            ans = min(ans, n - 1 - max(freq.values()))\n        print(ans)", "def res():\n    t = int(input())\n    st = list(map(int, input().split()))\n    if t <= 2:\n        return 0\n    best_res = t\n    for i in range(t):\n        for j in range(i + 1, t):\n            res = t - 2\n            d = (st[i] - st[j]) / (j - i)\n            cur = st[j]\n            cur_j = j\n            for k in range(j + 1, t):\n                if (cur - st[k]) / (k - cur_j) == d:\n                    res -= 1\n                    cur = st[k]\n                    cur_j = k\n            if res < best_res:\n                best_res = res\n    return best_res\nn = int(input())\nfor _ in range(n):\n    i = res()\n    print(i)"]