["import sys\ninput = sys.stdin.readline\n\ndef readList():\n    return list(map(int, input().split()))\n\ndef readInt():\n    return int(input())\n\ndef readInts():\n    return map(int, input().split())\n\ndef readStr():\n    return input().strip()\n\ndef solve():\n    (n, m, k) = readInts()\n    arr = readList()\n    isPresent = [False] * (k + 1)\n    curr = k\n    cnt = 0\n    for i in range(k):\n        if arr[i] == curr:\n            if cnt < n * m - 3:\n                curr -= 1\n                continue\n            return 'TIDAK'\n        else:\n            while isPresent[curr] and curr > 0 and (cnt <= n * m - 3):\n                isPresent[curr] = False\n                cnt -= 1\n                curr -= 1\n            isPresent[arr[i]] = True\n            cnt += 1\n            if cnt > n * m - 2:\n                return 'TIDAK'\n    return 'YA'\nfor _ in range(int(input())):\n    print(solve())", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().strip().split())\n    l = list(map(int, input().strip().split()))\n    lk = [i for i in range(k, 0, -1)]\n    p = n * m - 3\n    ans = ''\n    if p >= k:\n        ans = 'YA'\n    else:\n        co = 0\n        for i in range(k):\n            if l[i] > lk[i]:\n                co = max(co, l[i] - lk[i])\n        if p > co:\n            ans = 'YA'\n        else:\n            ans = 'TIDAK'\n    print(ans)", "import sys\nimport heapq\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    chk = n * m - 4\n    s = 0\n    d = {}\n    c = 0\n    for i in range(k):\n        if k in d:\n            c -= 1\n            k -= 1\n        if l[i] == k:\n            k -= 1\n        else:\n            d[l[i]] = 1\n            c += 1\n        if c > chk:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "import collections\nimport heapq\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom io import BytesIO, IOBase\nimport os\n\ndef values():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef inlsts():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef instr():\n    return sys.stdin.readline().strip()\n\ndef words():\n    return [i for i in sys.stdin.readline().strip().split()]\n\ndef chars():\n    return [i for i in sys.stdin.readline().strip()]\n\ndef solve():\n    (n, m, k) = values()\n    l = values()\n    mx = m * n - 4\n    h = []\n    req = k\n    for i in l:\n        heapq.heappush(h, -i)\n        while h and req == -h[0]:\n            heapq.heappop(h)\n            req -= 1\n        if len(h) > mx:\n            return 'TIDAK'\n    return 'YA'\nfor i in range(inp()):\n    print(solve())", "def my_function(ms, sz, k):\n    if sz - k >= 3:\n        print('YA')\n        return\n    my_dic = {}\n    for index in range(k):\n        my_dic[ms[index]] = index + 1\n    cnt = sz\n    for index in range(k, 0, -1):\n        if cnt - my_dic[index] < 3:\n            print('TIDAK')\n            return\n        else:\n            cnt += 1\n    print('YA')\n\ndef alg(mass):\n    for arr in mass:\n        ms = arr['arr']\n        sz = arr['sz']\n        k = arr['k']\n        my_function(ms, sz, k)\n\ndef parsing():\n    cnt = int(input())\n    mass = []\n    while cnt > 0:\n        st = input().split(' ')\n        (n, m, k) = (int(st[0]), int(st[1]), int(st[2]))\n        arr = list(map(int, input().split(' ')))\n        mass.append({'sz': n * m, 'k': k, 'arr': arr})\n        cnt -= 1\n    return mass\nres = parsing()\nalg(res)", "import sys\n\ndef read():\n    return [int(x) for x in sys.stdin.readline().split(' ')]\n[t] = read()\nfor _ in range(t):\n    [n, m, k] = read()\n    A = read()\n    for i in range(len(A)):\n        A[i] -= 1\n    l = n * m - 3\n    done = k * [0]\n    acc = 0\n    next = k - 1\n    ok = True\n    for a in A:\n        acc += 1\n        done[a] = 1\n        if a != next:\n            continue\n        if acc > l:\n            ok = False\n            break\n        while next and done[next]:\n            acc -= 1\n            next -= 1\n    print('YA' if ok else 'TIDAK')", "t = int(input())\nfor _ in range(t):\n    (n, m, k) = [int(x) for x in input().split()]\n    lst = [int(x) for x in input().split()]\n    empty = n * m - 3\n    if k <= empty:\n        print('YA')\n    else:\n        i = 0\n        count = 0\n        mp = {}\n        ans = True\n        while empty < k and count <= empty:\n            if k in mp:\n                del mp[k]\n                count = count - 1\n                k = k - 1\n            else:\n                mp[lst[i]] = 1\n                i = i + 1\n                count = count + 1\n                if count == empty + 1:\n                    ans = False\n                    break\n        if ans == True:\n            print('YA')\n        else:\n            print('TIDAK')", "t = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n * m - 2 > k:\n        print('YA')\n        continue\n    pos = n * m - 3\n    isPosib = True\n    while pos < len(a):\n        if a[pos] >= k:\n            isPosib = False\n            break\n        k -= 1\n        pos += 1\n    if not isPosib:\n        print('TIDAK')\n        continue\n    print('YA')", "def solve() -> None:\n    (n, m, k) = map(int, input().split())\n    cards = list(map(int, input().split()))\n    have = [False] * (k + 1)\n    need_card = k\n    occupied = 0\n    for card in cards:\n        if card == need_card:\n            if occupied == n * m - 3:\n                print('TIDAK')\n                return\n            need_card -= 1\n            while need_card >= 1 and have[need_card]:\n                occupied -= 1\n                need_card -= 1\n        else:\n            occupied += 1\n            have[card] = True\n            if occupied > n * m - 3:\n                print('TIDAK')\n                return\n    print('YA')\ntt = int(input())\nfor _ in range(tt):\n    solve()", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    freeCells = n * m - (n + m - 1)\n    buffers = n * m - freeCells - 4\n    for i in range(k):\n        if i - k + a[i] > freeCells + buffers:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "import heapq\n\ndef sol(lst, n, m, k):\n    heap = []\n    counter = 0\n    k_star = k\n    for num in lst:\n        counter += 1\n        heapq.heappush(heap, -num)\n        while heap and -heap[0] == k_star:\n            counter -= 1\n            heapq.heappop(heap)\n            k_star -= 1\n        if counter == n * m - 3:\n            return 'TIDAK'\n    return 'YA'\nT = int(input())\nfor test_case in range(1, T + 1):\n    (n, m, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    s = sol(lst, n, m, k)\n    print(s)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    freeCells = n * m - (n + m - 1)\n    buffers = n * m - freeCells - 4\n    for i in range(k):\n        if i - k + a[i] > freeCells + buffers:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "t = int(input())\nfor _ in range(t):\n    (n, m, k) = [int(x) for x in input().split()]\n    lst = [int(x) for x in input().split()]\n    empty = n * m - 3\n    if k <= empty:\n        print('YA')\n    else:\n        i = 0\n        count = 0\n        mp = {}\n        ans = True\n        while empty < k and count <= empty:\n            if k in mp:\n                count = count - 1\n                k = k - 1\n            else:\n                mp[lst[i]] = 1\n                i = i + 1\n                count = count + 1\n                if count == empty + 1:\n                    ans = False\n                    break\n        if ans == True:\n            print('YA')\n        else:\n            print('TIDAK')", "t = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    cap = m * n - 4\n    d = {}\n    need = k\n    i = 0\n    flag = False\n    while need > 0:\n        if need in d:\n            need -= 1\n            cap += 1\n        elif a[i] == need:\n            need -= 1\n            i += 1\n        else:\n            if cap == 0:\n                flag = True\n                break\n            cap -= 1\n            d[a[i]] = 1\n            i += 1\n    if flag:\n        print('TIDAK')\n    else:\n        print('YA')", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\nfrom collections import deque\n\ndef solve(q, m, n, k):\n    visited = set()\n    for y in range(k, 0, -1):\n        if y in visited:\n            visited.remove(y)\n            continue\n        while q and q[0] != y:\n            visited.add(q.popleft())\n        q.popleft()\n        if len(visited) > m * n - 4:\n            return 'TIDAK'\n    return 'YA'\nt = int(input())\nfor _ in range(t):\n    (m, n, k) = map(int, input().split())\n    if m > n:\n        (m, n) = (n, m)\n    a = deque(map(int, input().split()))\n    res = solve(a, m, n, k)\n    print(res)", "import os\nimport math\nimport collections\nimport bisect\nimport functools\nimport itertools\nimport heapq\nfrom collections import deque\n\ndef solve(q, m, n, k):\n    visited = set()\n    for y in range(k, 0, -1):\n        if y in visited:\n            visited.remove(y)\n            continue\n        while len(q) > 0 and q[0] != y:\n            visited.add(q.popleft())\n        q.popleft()\n        if len(visited) > m * n - 4:\n            return 'TIDAK'\n    return 'YA'\nt = int(input())\nfor _ in range(t):\n    (m, n, k) = map(int, input().split())\n    if m > n:\n        (m, n) = (n, m)\n    a = deque(map(int, input().split()))\n    res = solve(a, m, n, k)\n    print(res)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    idx = [i for i in range(k, 0, -1)]\n    ans = 'YA'\n    if n * m - 3 < k:\n        mx = 0\n        for i in range(k):\n            if arr[i] > idx[i]:\n                mx = max(mx, arr[i] - idx[i])\n        if n * m - 4 < mx:\n            ans = 'TIDAK'\n    print(ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    covered = {x: i for (i, x) in enumerate(a)}\n    avail = n * m - 4\n    for i in range(k, 0, -1):\n        o = k - i\n        if covered[i] - o > avail:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "t = int(input())\nwhile t > 0:\n    (n, m, k) = map(int, input().split())\n    cards = list(map(int, input().split()))\n    onBoard = {}\n    freeSpots = n * m - 2\n    cardNo = 0\n    reqd = k\n    freeSpotmin = 2\n    if m == 2 and n == 2:\n        freeSpotmin = 1\n    while freeSpots >= freeSpotmin and cardNo < k:\n        card = cards[cardNo]\n        if card != reqd:\n            onBoard[card] = 1\n            freeSpots -= 1\n        else:\n            reqd -= 1\n            while reqd in onBoard:\n                del onBoard[reqd]\n                reqd -= 1\n                freeSpots += 1\n        cardNo += 1\n    if freeSpots < freeSpotmin:\n        print('TIDAK')\n    else:\n        print('YA')\n    t -= 1", "def main():\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ind = [0] * (k + 1)\n    for i in range(k):\n        ind[arr[i]] = i\n    aux = n * m - 4\n    card = k\n    curr = 0\n    while card > 0:\n        index = ind[card]\n        if curr > index:\n            aux += 1\n            card -= 1\n            continue\n        elif curr == index:\n            card -= 1\n            curr += 1\n            continue\n        else:\n            req = index - curr\n            if req <= aux:\n                aux -= req\n                curr = index + 1\n                card -= 1\n            else:\n                return 'TIDAK'\n    return 'YA'\nfor _ in range(int(input())):\n    print(main())", "import math\nimport collections\nimport bisect\nimport heapq\nfrom collections import deque\nfrom math import sqrt, ceil, floor\n\ndef inp_arr():\n    return list(map(int, input().strip().split(' ')))\n\ndef inp_str_arr():\n    return list(input().strip().split(' '))\n\ndef inp_str():\n    return input()\n\ndef solve():\n    (n, m, k) = inp_arr()\n    a = inp_arr()\n    hp = []\n    heapq.heapify(hp)\n    cap = n * m - 4\n    need = k\n    for x in a:\n        while len(hp) > 0 and abs(hp[0]) == need:\n            heapq.heappop(hp)\n            need -= 1\n        if x == need:\n            need -= 1\n        elif len(hp) == cap:\n            print('TIDAK')\n            return\n        else:\n            heapq.heappush(hp, -x)\n    print('YA')\n(tt,) = inp_arr()\nfor t in range(tt):\n    solve()", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    idx = [i for i in range(k, 0, -1)]\n    ans = 'YA'\n    if n * m - 3 < k:\n        mx = 0\n        for i in range(k):\n            if arr[i] > idx[i]:\n                mx = max(mx, arr[i] - idx[i])\n        if n * m - 3 <= mx:\n            ans = 'TIDAK'\n    print(ans)", "I = lambda : int(input())\nIs = lambda : map(int, input().split())\nLi = lambda : list(map(int, input().split()))\n\ndef solve():\n    (n, m, k) = Is()\n    a = Li()\n    s = n * m - 2\n    seen = set()\n    cur = k\n    po = 0\n    for i in a:\n        seen.add(i)\n        po += 1\n        if po == s:\n            print('TIDAK')\n            return\n        if i == k:\n            po -= 1\n            seen.remove(i)\n            cur -= 1\n        while cur in seen:\n            po -= 1\n            seen.remove(cur)\n            cur -= 1\n    print('YA')\n    return 1\nt = I()\nwhile t:\n    solve()\n    t -= 1", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    freeCells = n * m - (n + m - 1)\n    buffers = n * m - freeCells - 4\n    for i in range(k):\n        if i - k + a[i] > freeCells + buffers:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "import heapq\nimport sys\n\ndef solution(row, col, target, order):\n    max_heap = []\n    limit = row * col - 2\n    for element in order:\n        heapq.heappush(max_heap, (-element, element))\n        if len(max_heap) == limit:\n            break\n        while len(max_heap) != 0 and max_heap[0][1] == target:\n            target -= 1\n            heapq.heappop(max_heap)\n    if len(max_heap) != 0:\n        return 'TIDAK'\n    else:\n        return 'YA'\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = tuple(map(int, input().split()))\n    order = list(map(int, input().split()))\n    print(solution(n, m, k, order))", "t = int(input())\nwhile t > 0:\n    ip = [int(x) for x in input().split()]\n    n = ip[0]\n    m = ip[1]\n    k = ip[2]\n    a = [int(x) for x in input().split()]\n    freq = []\n    val = k\n    count = n * m - 4\n    for i in range(k + 1):\n        freq.append(0)\n    flag = True\n    for i in a:\n        if i == k:\n            k -= 1\n            while freq[k] > 0:\n                freq[k] -= 1\n                count += 1\n                k -= 1\n        elif count > 0:\n            freq[i] += 1\n            count -= 1\n        else:\n            flag = False\n            break\n    if flag:\n        print('YA')\n    else:\n        print('TIDAK')\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    (m, n, p) = [int(x) for x in input().split()]\n    permut = [int(x) for x in input().split()]\n    s = set()\n    i = 0\n    flag = 0\n    for need in range(p, 0, -1):\n        while True:\n            if flag == 1:\n                break\n            if need in s:\n                s.remove(need)\n                break\n            elif len(s) == m * n - 3:\n                print('TIDAK')\n                flag = 1\n            else:\n                s.add(permut[i])\n                i += 1\n        if flag == 1:\n            break\n    if flag != 1:\n        print('YA')", "def f(n, m, arr):\n    k = len(arr)\n    on_board = set()\n    max_size = n * m - 2\n    for i in range(k, 0, -1):\n        if i in on_board:\n            on_board.remove(i)\n            continue\n        while arr[-1] != i and len(on_board) < max_size:\n            top_value = arr.pop()\n            on_board.add(top_value)\n        if len(on_board) >= max_size - 1:\n            return False\n        arr.pop()\n    return True\nt = int(input())\nfor i in range(t):\n    (n, m, k) = [int(el) for el in input().split(' ')]\n    arr = [int(el) for el in input().split(' ')]\n    r_arr = list(reversed(arr))\n    if f(n, m, r_arr):\n        print('YA')\n    else:\n        print('TIDAK')", "t = int(input())\nfor x in range(t):\n    S = list(map(int, input().split()))\n    (n, m, k) = (S[0], S[1], S[2])\n    stack = list(map(int, input().split()))\n    count = 0\n    d = dict()\n    for i in range(k):\n        d[stack[i]] = i\n    for i in range(k, 0, -1):\n        if d[i] > m * n - 4 + k - i:\n            count = 1\n            print('TIDAK')\n            break\n    if count == 0:\n        print('YA')", "def solve(n, m, k, a):\n    d = {}\n    val = n * m - 4\n    nxt = k\n    p1 = 0\n    while p1 < k:\n        if a[p1] == nxt:\n            nxt -= 1\n            while True:\n                try:\n                    d[nxt] -= 1\n                    nxt -= 1\n                    val += 1\n                except:\n                    break\n        else:\n            try:\n                d[nxt] -= 1\n                val += 1\n                nxt -= 1\n            except:\n                d[a[p1]] = 1\n                val -= 1\n        if val < 0:\n            return 'TIDAK'\n        p1 += 1\n    return 'YA'\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(m, n, k, a))", "import heapq\n\ndef sol(lst, n, m, k):\n    counter = 0\n    h = []\n    to_insert = k\n    maxi = n * m - 3\n    for num in lst:\n        counter += 1\n        heapq.heappush(h, -num)\n        while h and -h[0] == to_insert:\n            counter -= 1\n            heapq.heappop(h)\n            to_insert -= 1\n        if counter == maxi:\n            return 'TIDAK'\n    return 'YA'\nT = int(input())\nfor test_case in range(1, T + 1):\n    (n, m, k) = [int(s) for s in input().split(' ')]\n    lst = [int(s) for s in input().split(' ')]\n    s = sol(lst, n, m, k)\n    print(s)", "t = int(input())\nfor _ in range(t):\n    (n, m, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    wait_set = set([])\n    wait_len = 0\n    max_len = n * m - 4\n    answer = 'YA'\n    M = k\n    i = 0\n    while M > 0:\n        if M not in wait_set:\n            x = a[i]\n            if x != M:\n                wait_set.add(x)\n                wait_len += 1\n                i += 1\n            else:\n                M = M - 1\n                i += 1\n        else:\n            wait_set.remove(M)\n            wait_len -= 1\n            M = M - 1\n        if wait_len > max_len:\n            answer = 'TIDAK'\n            break\n    print(answer)", "t = int(input(''))\nfor j in range(t):\n    l = list(map(int, input('').split()))\n    n = l[0]\n    m = l[1]\n    k = l[2]\n    s = [0] * (k + 1)\n    s[0] = 0\n    c = 0\n    l = list(map(int, input('').split()))\n    a = n * m - 4\n    if a >= k - 1:\n        print('YA')\n        continue\n    for i in l:\n        if i != k:\n            s[i] = 1\n            c += 1\n        else:\n            k = k - 1\n            while s[k] == 1:\n                c -= 1\n                s[k] = 0\n                k -= 1\n        if c >= a + 1:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "import heapq\n\ndef solution(row, col, target, order):\n    max_heap = []\n    limit = row * col - 2\n    for element in order:\n        heapq.heappush(max_heap, (-element, element))\n        if len(max_heap) == limit:\n            return 'TIDAK'\n        while len(max_heap) != 0 and max_heap[0][1] == target:\n            target -= 1\n            heapq.heappop(max_heap)\n    if len(max_heap) != 0:\n        return 'TIDAK'\n    else:\n        return 'YA'\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = tuple(map(int, input().split()))\n    order = list(map(int, input().split()))\n    print(solution(n, m, k, order))", "import heapq\n\ndef solution(row, col, target, order):\n    max_heap = []\n    limit = row * col - 2\n    for element in order:\n        heapq.heappush(max_heap, (-element, element))\n        if len(max_heap) == limit:\n            break\n        while len(max_heap) != 0 and max_heap[0][1] == target:\n            target -= 1\n            heapq.heappop(max_heap)\n    if len(max_heap) != 0:\n        return 'TIDAK'\n    else:\n        return 'YA'\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = tuple(map(int, input().split()))\n    order = list(map(int, input().split()))\n    print(solution(n, m, k, order))", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [x - 1 for x in list(map(int, input().split()))]\n    (kosong, sekarang) = (n * m - 2, k - 1)\n    (ok, bisa) = ([0] * k, True)\n    for i in range(k):\n        ok[a[i]] = 1\n        kosong -= 1\n        if kosong <= 0:\n            print('TIDAK')\n            bisa = False\n            break\n        while sekarang >= 0 and ok[sekarang]:\n            sekarang -= 1\n            kosong += 1\n    if bisa:\n        print('YA')", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [x - 1 for x in list(map(int, input().split()))]\n    (kosong, sekarang) = (n * m - 2, k - 1)\n    (ok, bisa) = ([0] * k, True)\n    for i in range(k):\n        ok[a[i]] = 1\n        kosong -= 1\n        bisa &= kosong > 0\n        while sekarang >= 0 and ok[sekarang]:\n            sekarang -= 1\n            kosong += 1\n    print('YA' if bisa else 'TIDAK')", "t = int(input())\nfor i in range(t):\n    (n, m, k) = [int(v) for v in input().split()]\n    w = [int(v) for v in input().split()][::-1]\n    rho = n * m - 4\n    zeta = k\n    eta = 0\n    res = set()\n    while zeta > 0:\n        if w:\n            if eta <= rho:\n                eta += 1\n                res.add(w.pop())\n            else:\n                print('TIDAK')\n                break\n        else:\n            zeta = 0\n            continue\n        while zeta in res:\n            res.remove(zeta)\n            zeta -= 1\n            eta -= 1\n    else:\n        print('YA')", "import heapq\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    cur_element = max(arr)\n    max_heap_size = n * m - 4\n    max_heap = []\n    invalid = False\n    for i in range(k):\n        if arr[i] == cur_element:\n            cur_element -= 1\n            while max_heap and -max_heap[0] == cur_element:\n                heapq.heappop(max_heap)\n                cur_element -= 1\n        else:\n            heapq.heappush(max_heap, -arr[i])\n            if len(max_heap) > max_heap_size:\n                invalid = True\n                break\n    if invalid:\n        print('TIDAK')\n    else:\n        print('YA')", "from collections import defaultdict\nfor _ in range(int(input())):\n    a0 = [int(x) for x in input().split()]\n    (n, m, k) = (a0[0], a0[1], a0[2])\n    (cur, cnt, ans, target) = (k, 0, 0, n * m - 3)\n    d = defaultdict(int)\n    a = [int(x) for x in input().split()]\n    for i in range(k):\n        flag = 0\n        while d[cur] == 0 and cnt < k:\n            idx = cnt\n            d[a[idx]] = d[a[idx]] + 1\n            cnt += 1\n            ans += 1\n        if target < ans:\n            flag = 1\n            print('TIDAK')\n            break\n        if flag == 1:\n            continue\n        ans -= 1\n        cur -= 1\n    if flag == 0:\n        print('YA')", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    f = [0] * (k + 5)\n\n    def get(i):\n        ans = 0\n        while i > 0:\n            ans += f[i]\n            i -= -i & i\n        return ans\n\n    def up(i):\n        while i <= k:\n            f[i] += 1\n            i += -i & i\n    ok = True\n    for e in a:\n        if get(e) > m * n - 4:\n            print('TIDAK')\n            ok = False\n            break\n        else:\n            up(e)\n    if ok:\n        print('YA')", "import sys\ninput = sys.stdin.readline\nimport queue\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    res = []\n    pq = queue.PriorityQueue()\n    for i in lst[:n * m - 4]:\n        pq.put(-i)\n    for i in lst[n * m - 4:]:\n        pq.put(-i)\n        res.append(-pq.get())\n    while not pq.empty():\n        res.append(-pq.get())\n    res = res[::-1]\n    for i in range(len(res) - 1):\n        if res[i + 1] < res[i]:\n            print('TIDAK')\n            break\n    else:\n        print('YA')", "class FenwickTree:\n\n    def __init__(self, n):\n        self.bit = [0] * n\n        self.size = n\n\n    def update(self, idx, x):\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def __call__(self, start, end):\n        return self.__getitem__(end) - self.__getitem__(start)\n\n    def __getitem__(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def find_kth(self, k):\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return (idx + 1, k)\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [k - x for x in list(map(int, input().split()))]\n    pos = [0] * k\n    for i in range(k):\n        pos[a[i]] = i\n    F = FenwickTree(k)\n    for i in range(k):\n        F.update(i, 1)\n    ok = True\n    for i in range(k):\n        now = pos[i]\n        num = F(0, now)\n        if num > n * m - 4:\n            print('TIDAK')\n            ok = False\n            break\n        F.update(now, -1)\n    if ok:\n        print('YA')"]