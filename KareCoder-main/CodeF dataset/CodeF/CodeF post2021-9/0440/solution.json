["def solve():\n    n = int(input())\n    T = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        T[u].append((v, i))\n        T[v].append((u, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return '-1'\n        if len(edges) == 1:\n            start = idx\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ' '.join([str(x) for x in ret])\nt = int(input())\nfor _ in range(t):\n    print(solve())", "import sys\ninput = sys.stdin.readline\n\ndef solve(n, adj):\n    node = -1\n    for v in range(n):\n        if len(adj[v]) > 2:\n            return [-1]\n        if len(adj[v]) == 1:\n            node = v\n    vis = [False for _ in range(n)]\n    ans = [0 for _ in range(n - 1)]\n    ans[adj[node][0][1]] = 2\n    prev = node\n    node = adj[node][0][0]\n    flag = True\n    while len(adj[node]) > 1:\n        (nxt, pos) = (0, 0)\n        if adj[node][0][0] == prev:\n            (nxt, pos) = adj[node][1]\n        else:\n            (nxt, pos) = adj[node][0]\n        if flag:\n            ans[pos] = 3\n        else:\n            ans[pos] = 2\n        flag = not flag\n        prev = node\n        node = nxt\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append((v - 1, i))\n        adj[v - 1].append((u - 1, i))\n    print(*solve(n, adj))", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfor _ in range(int(input())):\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    edges = [-1] * (n - 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append((v, i))\n        graph[v].append((u, i))\n    if max([len(neighbors) for neighbors in graph]) > 2:\n        print(-1)\n        continue\n    (prev, cur) = (None, 1)\n    while len(graph[cur]) != 1:\n        cur += 1\n    for r in range(n - 1):\n        for (x, i) in graph[cur]:\n            if x != prev:\n                edges[i] = [2, 3][r % 2]\n                (prev, cur) = (cur, x)\n                break\n    print(*edges)", "for _ in range(int(input())):\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    edges = [-1] * (n - 1)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append((v, i))\n        graph[v].append((u, i))\n    if max([len(neighbors) for neighbors in graph]) > 2:\n        print(-1)\n        continue\n    (prev, cur) = (None, 1)\n    while len(graph[cur]) != 1:\n        cur += 1\n    for r in range(n - 1):\n        for (x, i) in graph[cur]:\n            if x != prev:\n                edges[i] = [2, 3][r % 2]\n                (prev, cur) = (cur, x)\n                break\n    print(*edges)", "import math, re\n\ndef fastlist():\n    return list(map(int, input().split()))\n\ndef fastint():\n    return int(input())\n\ndef solve():\n    n = fastint()\n    res = [0] * (n - 1)\n    ver = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (u, v) = fastlist()\n        ver[u - 1] += [(v - 1, i)]\n        ver[v - 1] += [(u - 1, i)]\n    for i in range(n):\n        if len(ver[i]) == 1:\n            start = i\n            break\n    (cur, prev) = (start, -1)\n    for i in range(n - 1):\n        if len(ver[cur]) > 2:\n            print(-1)\n            return\n        for (j, x) in ver[cur]:\n            if j != prev:\n                res[x] = ['2', '3'][i % 2]\n                (cur, prev) = (j, cur)\n                break\n    print(*res)\nt = int(input())\nfor _ in range(t):\n    solve()", "from platform import node\nfrom sys import intern\n\ndef solve():\n    n = int(input())\n    node___neighs = [[] for _ in range(n)]\n    edges = []\n    for _ in range(n - 1):\n        (u, v) = (int(x) - 1 for x in input().split())\n        if v < u:\n            (u, v) = (v, u)\n        edges.append((u, v))\n        node___neighs[u].append(v)\n        node___neighs[v].append(u)\n    start_node = None\n    for node in range(n):\n        if len(node___neighs[node]) > 2:\n            print(-1)\n            return\n        if len(node___neighs[node]) == 1:\n            start_node = node\n    node___is_visited = [False for _ in range(n)]\n    edge___weight = {}\n    const_prime = 5\n    curr_weight = 2\n    stack = [start_node]\n    while stack:\n        curr_node = stack.pop()\n        node___is_visited[curr_node] = True\n        for neigh in node___neighs[curr_node]:\n            if not node___is_visited[neigh]:\n                edge = (curr_node, neigh)\n                if neigh < curr_node:\n                    edge = (neigh, curr_node)\n                edge___weight[edge] = curr_weight\n                stack.append(neigh)\n        curr_weight = const_prime - curr_weight\n    ans = [edge___weight[edge] for edge in edges]\n    print(*ans, sep=' ', end='\\n')\nfor _ in range(int(input())):\n    solve()", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    to = [[] for _ in range(n)]\n    a = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        a[u] += 1\n        a[v] += 1\n        to[u].append((v, i))\n        to[v].append((u, i))\n    if max(a) > 2:\n        print(-1)\n        continue\n    cur = a.index(1)\n    last = -1\n    res = [0] * (n - 1)\n    for i in range(n - 1):\n        for (v, ind) in to[cur]:\n            if v != last:\n                res[ind] = 2 if i % 2 == 0 else 3\n                last = cur\n                cur = v\n                break\n    print(*res)", "for _ in range(int(input())):\n    n = int(input())\n    cnt = [0] * (n + 1)\n    graph = [[] for i in range(n + 1)]\n    edges = [list(map(int, input().split())) for i in range(n - 1)]\n    w = [0] * (n - 1)\n    for i in range(n - 1):\n        edge = edges[i]\n        cnt[edge[0]] += 1\n        cnt[edge[1]] += 1\n        graph[edge[0]].append((edge[1], i))\n        graph[edge[1]].append((edge[0], i))\n    if max(cnt) > 2:\n        print(-1)\n        continue\n    v = cnt.index(1)\n    curr = 2\n    used = [0] * (n + 1)\n    used[v] = 1\n    for i in range(n - 1):\n        u = graph[v][0][0]\n        k = 0\n        if used[u]:\n            u = graph[v][1][0]\n            k = 1\n        w[graph[v][k][1]] = curr\n        curr = 5 - curr\n        v = u\n        used[v] = 1\n    print(*w)", "import sys\ninput = sys.stdin.readline\nt = int(input())\nout = []\nfor _ in range(t):\n    n = int(input())\n    cons = [[] for _ in range(n)]\n    isGood = True\n    for i in range(n - 1):\n        (a, b) = [int(x) - 1 for x in input().split()]\n        cons[a].append([b, i])\n        cons[b].append([a, i])\n        if len(cons[a]) == 3 or len(cons[b]) == 3:\n            isGood = False\n    if not isGood:\n        out.append('-1\\n')\n        continue\n    for i in range(len(cons)):\n        if len(cons[i]) == 1:\n            start = i\n            break\n    weights = [0] * (n - 1)\n    next_ = 2\n    search = [start]\n    while len(search) > 0:\n        node = search.pop(-1)\n        for (child, ind) in cons[node]:\n            if weights[ind] == 0:\n                weights[ind] = next_\n                search.append(child)\n                next_ = 5 - next_\n    strWeights = ''\n    for x in weights:\n        strWeights += str(x) + ' '\n    out.append(strWeights + '\\n')\nprint(''.join(out))", "import sys, collections\n\ndef solve(n, loc, conn):\n    for u in conn:\n        if len(conn[u]) > 2:\n            return []\n    res = [-1] * (n - 1)\n    level = {[u for u in conn if len(conn[u]) == 1][0]}\n    visit = level.copy()\n    value = 2\n    while level:\n        nextlevel = set()\n        for prev in level:\n            for curr in conn[prev]:\n                if curr not in visit:\n                    if (prev, curr) in loc:\n                        res[loc[prev, curr]] = value\n                    else:\n                        res[loc[curr, prev]] = value\n                    nextlevel.add(curr)\n                    visit.add(curr)\n        level = nextlevel\n        value = 5 - value\n    return res\ninput = sys.stdin.readline\nt = int(input()[:-1])\nfor _ in range(t):\n    n = int(input()[:-1])\n    loc = {}\n    conn = collections.defaultdict(set)\n    for i in range(n - 1):\n        (u, v) = [int(s) for s in input()[:-1].split()]\n        loc[u, v] = i\n        conn[u].add(v)\n        conn[v].add(u)\n    res = solve(n, loc, conn)\n    if res == []:\n        print(-1)\n    else:\n        print(*res)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    possible = True\n    al = [[] for i in range(n)]\n    edgenum = {}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        al[a].append(b)\n        al[b].append(a)\n        edgenum[a, b] = i\n        edgenum[b, a] = i\n    for i in range(n):\n        if len(al[i]) > 2:\n            possible = False\n            break\n    if not possible:\n        print(-1)\n    else:\n        startnode = 0\n        for i in range(n - 1):\n            if len(al[i]) < 2:\n                startnode = i\n                break\n        l = [0 for i in range(n - 1)]\n        done = set()\n        for x in range(n - 1):\n            nextnode = al[startnode][0]\n            if nextnode in done:\n                nextnode = al[startnode][1]\n            i = edgenum[startnode, nextnode]\n            l[i] = 2 + x % 2\n            done.add(startnode)\n            startnode = nextnode\n        print(*l)", "import sys\ninput = sys.stdin.readline\nnum_test_cases = int(input())\nfor test_case_ittr in range(num_test_cases):\n    num_vertices = int(input())\n    edges = []\n    possible = True\n    neighbors = dict()\n    for i in range(num_vertices - 1):\n        (a, b) = [int(x) for x in input().split()]\n        edges += [(a, b)]\n        if a not in neighbors:\n            neighbors[a] = {b}\n        else:\n            neighbors[a].add(b)\n        if len(neighbors[a]) > 2:\n            possible = False\n        if b not in neighbors:\n            neighbors[b] = {a}\n        else:\n            neighbors[b].add(a)\n        if len(neighbors[b]) > 2:\n            possible = False\n    if not possible:\n        print(-1)\n        continue\n    leaf = None\n    for node in neighbors:\n        if len(neighbors[node]) == 1:\n            leaf = node\n            break\n    edge_weights = dict()\n    node = leaf\n    prev = None\n    weight = 2\n    for j in range(num_vertices - 1):\n        next_node = list(neighbors[node] - {prev})[0]\n        edge_weights[node, next_node] = edge_weights[next_node, node] = weight\n        (prev, node) = (node, next_node)\n        if j & 1:\n            weight -= 1\n        else:\n            weight += 1\n    print(*[edge_weights[edge] for edge in edges])", "import sys\nimport collections\n\ndef solve(n, loc, conn):\n    for u in conn:\n        if len(conn[u]) > 2:\n            return []\n    res = [-1] * (n - 1)\n    level = {[u for u in conn if len(conn[u]) == 1][0]}\n    visit = level.copy()\n    value = 2\n    while level:\n        nextlevel = set()\n        for prev in level:\n            for curr in conn[prev]:\n                if curr not in visit:\n                    if (prev, curr) in loc:\n                        res[loc[prev, curr]] = value\n                    else:\n                        res[loc[curr, prev]] = value\n                    nextlevel.add(curr)\n                    visit.add(curr)\n        level = nextlevel\n        value = 5 - value\n    return res\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    loc = {}\n    conn = collections.defaultdict(set)\n    for i in range(n - 1):\n        (u, v) = [int(s) for s in input().split()]\n        loc[u, v] = i\n        conn[u].add(v)\n        conn[v].add(u)\n    res = solve(n, loc, conn)\n    if res == []:\n        print(-1)\n    else:\n        print(*res)", "import sys, collections\n\ndef solve(n, loc, conn, su, sv):\n    for u in conn:\n        if len(conn[u]) > 2:\n            return [-1]\n    res = [-1] * (n - 1)\n    res[loc[su, sv]] = 2\n    level = {su, sv}\n    value = 2\n    while level:\n        nextlevel = set()\n        value = 5 - value\n        for prev in level:\n            for curr in conn[prev]:\n                if (prev, curr) in loc:\n                    if res[loc[prev, curr]] != -1:\n                        continue\n                    res[loc[prev, curr]] = value\n                    nextlevel.add(curr)\n                else:\n                    if res[loc[curr, prev]] != -1:\n                        continue\n                    res[loc[curr, prev]] = value\n                    nextlevel.add(curr)\n        level = nextlevel\n    return res\ninput = sys.stdin.readline\nt = int(input()[:-1])\nfor _ in range(t):\n    n = int(input()[:-1])\n    loc = {}\n    conn = collections.defaultdict(set)\n    for i in range(n - 1):\n        (u, v) = [int(part) for part in input()[:-1].split()]\n        loc[u, v] = i\n        conn[u].add(v)\n        conn[v].add(u)\n    res = solve(n, loc, conn, u, v)\n    if res[0] == -1:\n        print(-1)\n    else:\n        for val in res:\n            print(val, end=' ')\n        print('\\n', end='')", "for _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].append([b - 1, i])\n        g[b - 1].append([a - 1, i])\n    for i in range(n):\n        if len(g[i]) > 2:\n            print(-1)\n            break\n    else:\n        l = [0] * (n - 1)\n        ord = []\n        for i in range(n):\n            if len(g[i]) == 1:\n                ord.append(g[i][0][1])\n                start = g[g[i][0][0]]\n                break\n        while len(start) == 2:\n            for j in start:\n                if j[1] != ord[-1]:\n                    ord.append(j[1])\n                    start = g[j[0]]\n                    break\n        for i in range(len(ord)):\n            if i % 2 == 0:\n                l[ord[i]] = 2\n            else:\n                l[ord[i]] = 3\n        print(*l)", "for _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a - 1].append([b - 1, i])\n        g[b - 1].append([a - 1, i])\n    for i in range(n):\n        if len(g[i]) > 2:\n            print(-1)\n            break\n    else:\n        l = [0] * (n - 1)\n        ord = []\n        for i in range(n):\n            if len(g[i]) == 1:\n                ord.append(g[i][0][1])\n                start = g[g[i][0][0]]\n                break\n        while len(start) == 2:\n            for j in start:\n                if j[1] != ord[-1]:\n                    ord.append(j[1])\n                    start = g[j[0]]\n                    break\n        for i in range(len(ord)):\n            if i % 2 == 0:\n                l[ord[i]] = 2\n            else:\n                l[ord[i]] = 3\n        print(*l)", "for _ in range(int(input())):\n    n = int(input())\n    cnt = [0] * (n + 1)\n    graph = [[] for i in range(n + 1)]\n    edges = [list(map(int, input().split())) for i in range(n - 1)]\n    w = [0] * (n - 1)\n    for i in range(n - 1):\n        edge = edges[i]\n        cnt[edge[0]] += 1\n        cnt[edge[1]] += 1\n        graph[edge[0]].append((edge[1], i))\n        graph[edge[1]].append((edge[0], i))\n    if max(cnt) > 2:\n        print(-1)\n        continue\n    v = cnt.index(1)\n    curr = 2\n    used = [0] * (n + 1)\n    used[v] = 1\n    for i in range(n - 1):\n        u = graph[v][0][0]\n        k = 0\n        if used[u]:\n            u = graph[v][1][0]\n            k = 1\n        w[graph[v][k][1]] = curr\n        curr = 5 - curr\n        v = u\n        used[v] = 1\n    print(*w)", "import sys, bisect, math\nfrom collections import deque, Counter\ninput = lambda : sys.stdin.readline().strip()\nceil = lambda x: math.ceil(x)\nmod = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    three = [True] * (n + 1)\n    two = [True] * (n + 1)\n    visited = [False] * (n + 1)\n    edges = []\n    graph = {i: set() for i in range(1, n + 1)}\n    index = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        edges.append([u, v])\n        graph[u].add(v)\n        graph[v].add(u)\n        (u, v) = (min(u, v), max(u, v))\n        index[u, v] = i\n    ans = [0] * (n - 1)\n    queue = deque()\n    queue.append(1)\n    visited[1] = True\n    while len(queue) != 0:\n        x = queue.popleft()\n        for i in graph[x]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n                if two[i] and two[x]:\n                    ans[index[min(i, x), max(i, x)]] = '2'\n                    two[i] = two[x] = False\n                elif three[i] and three[x]:\n                    ans[index[min(i, x), max(i, x)]] = '3'\n                    three[i] = three[x] = False\n                else:\n                    return -1\n    return ' '.join(ans)\nt = 1\nt = int(input())\nfor _ in range(t):\n    print(solve())", "for _ in range(int(input())):\n    n = int(input())\n    q = {}\n    for i in range(1, n + 1):\n        q[i] = set()\n    l = []\n    r = {}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        l += [(a, b)]\n        r[a, b] = 0\n        q[a].add(b)\n        q[b].add(a)\n    t = 1\n    k = 0\n    for i in q:\n        if len(q[i]) > 2:\n            print(-1)\n            t = 0\n            break\n        elif len(q[i]) == 1:\n            k = i\n    if t:\n        v = {}\n        j = 0\n        for i in range(1, n + 1):\n            v[i] = 1\n        v[k] = 0\n        for _ in range(n - 1):\n            for i in q[k]:\n                if v[i]:\n                    v[i] = 0\n                    if (i, k) in r:\n                        r[i, k] = j + 2\n                    else:\n                        r[k, i] = j + 2\n                    k = i\n            j = 1 - j\n        a = [0] * (n - 1)\n        for i in range(n - 1):\n            a[i] = r[l[i]]\n        print(*a)", "def dfs(graph, start):\n    result = dict()\n    value = 2\n    for el in graph[start]:\n        visited = {start, el}\n        result[tuple(sorted([start, el]))] = value\n        last = el\n        while True:\n            value = 3 if value == 2 else 2\n            neighbours = graph[last] - visited\n            if len(neighbours) == 0:\n                break\n            elem = neighbours.pop()\n            result[tuple(sorted([last, elem]))] = value\n            visited.add(elem)\n            last = elem\n        value = 3\n    return result\n\ndef solve():\n    for i in range(int(input())):\n        count = dict()\n        pairs = []\n        graph = dict()\n        br = 0\n        for j in range(int(input()) - 1):\n            (a, b) = list(sorted(map(int, input().split())))\n            pairs.append((a, b))\n            graph[a] = graph.get(a, set())\n            graph[a].add(b)\n            graph[b] = graph.get(b, set())\n            graph[b].add(a)\n            count[a] = count.get(a, 0) + 1\n            count[b] = count.get(b, 0) + 1\n            if count[a] == 3 or count[b] == 3:\n                br = -1\n        if br == -1:\n            print(br)\n            continue\n        result = dfs(graph, pairs[0][0])\n        for pair in pairs:\n            print(result[pair], end=' ')\n        print()\nsolve()", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    d = {}\n    ans = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u not in d:\n            d[u] = []\n        if v not in d:\n            d[v] = []\n        d[u].append(v)\n        d[v].append(u)\n        ans[u, v] = 0\n    r = 0\n    key = 1\n    for i in d:\n        if len(d[i]) == 1:\n            key = i\n        if len(d[i]) >= 3:\n            r = 1\n            break\n    if r == 1:\n        print(-1)\n        continue\n    visited = [0 for i in range(n + 1)]\n    st = []\n    st.append((0, key))\n    f = -1\n    while st:\n        key = st[-1]\n        i = st[-1][1]\n        st.pop()\n        if visited[i] == 1:\n            continue\n        if visited[i] == 0 and f != -1:\n            if f == 0:\n                f = 1\n                if key not in ans:\n                    ans[key[1], key[0]] = 2\n                else:\n                    ans[key] = 2\n            else:\n                f = 0\n                if key not in ans:\n                    ans[key[1], key[0]] = 3\n                else:\n                    ans[key] = 3\n        if f == -1:\n            f = 0\n        for e in d[i]:\n            if visited[e] == 0:\n                st.append((i, e))\n        visited[i] = 1\n    for i in ans:\n        if ans[i] > 0:\n            print(ans[i], end=' ')\n    print()", "for t in range(int(input())):\n    n = int(input())\n    S = [[int(i) for i in input().split()] for j in range(n - 1)]\n    d = dict()\n    for i in range(n - 1):\n        d[tuple(S[i])] = 0\n    if len(S) == 1:\n        print(2)\n    else:\n        A = [[] for i in range(n)]\n        flag = 1\n        for i in range(n - 1):\n            (a, b) = S[i]\n            A[a - 1].append(b - 1)\n            A[b - 1].append(a - 1)\n            if len(A[a - 1]) > 2 or len(A[b - 1]) > 2:\n                flag = 0\n                break\n        if flag == 0:\n            print(-1)\n        else:\n            B = list()\n            for i in range(n):\n                if len(A[i]) == 1:\n                    B.append(i)\n            start = B[0]\n            end = B[1]\n            C = [2, 3]\n            flag = 0\n            e1 = start\n            e2 = A[start][0]\n            for i in range(n - 1):\n                if (e1 + 1, e2 + 1) in d:\n                    d[tuple([e1 + 1, e2 + 1])] = C[flag]\n                elif (e2 + 1, e1 + 1) in d:\n                    d[tuple([e2 + 1, e1 + 1])] = C[flag]\n                if i != n - 2:\n                    A[e2].remove(e1)\n                    e1 = e2\n                    e2 = A[e1][0]\n                flag = 0 if flag else 1\n            ans = list()\n            for i in range(n - 1):\n                ans.append(d[tuple(S[i])])\n            print(*ans)", "from collections import deque\nfrom functools import partial\nfrom typing import Deque, List, Literal, Optional, Set, TYPE_CHECKING\n\nclass Edge:\n    __slots__ = ('points', 'weight')\n    if TYPE_CHECKING:\n        points: Set[int]\n        weight: Optional[int]\n\n    def __init__(self, points: Set[int]) -> None:\n        self.points = points\n        self.weight = None\n\ndef set_weight(edge: Edge, value: Literal[2, 3]) -> None:\n    if edge.weight is not None:\n        return\n    edge.weight = value\n    for point in edge.points:\n        for e in nodes[point]:\n            functions.append(partial(set_weight, e, 5 - edge.weight))\nfor _ in range(int(input())):\n    n = int(input())\n    nodes: List[Set[Edge]] = [set() for _ in range(n)]\n    edges: List[Edge] = []\n    for index in range(n - 1):\n        (u, v) = [int(i) - 1 for i in input().split()]\n        edge = Edge({u, v})\n        nodes[u].add(edge)\n        nodes[v].add(edge)\n        edges.append(edge)\n    if any(map(lambda node: len(node) > 2, nodes)):\n        print(-1)\n    else:\n        functions: Deque[partial] = deque([partial(set_weight, edges[0], 2)])\n        while functions:\n            func = functions.popleft()\n            func()\n        print(*[edge.weight for edge in edges])", "from collections import defaultdict, deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    edge = []\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        ab = input().split(' ')\n        graph[int(ab[0])].append([int(ab[1]), i])\n        graph[int(ab[1])].append([int(ab[0]), i])\n        edge.append([int(ab[0]), int(ab[1]), i])\n    finded = False\n    for i in graph:\n        if len(graph[i]) > 2:\n            print(-1)\n            finded = True\n            break\n    if finded:\n        continue\n    edge_graph = defaultdict(list)\n    for i in graph:\n        if len(graph[i]) < 2:\n            continue\n        edge1 = graph[i][0][1]\n        edge2 = graph[i][1][1]\n        if edge2 not in edge_graph[edge1]:\n            edge_graph[edge1].append(edge2)\n        if edge1 not in edge_graph[edge2]:\n            edge_graph[edge2].append(edge1)\n    ans = [0] * (n - 1)\n    ans[0] = 2\n    q = deque()\n    q.append((0, 2))\n    visited = defaultdict(int)\n    while q:\n        ele = q.popleft()\n        if visited[ele[0]] == 1:\n            continue\n        visited[ele[0]] = 1\n        ansput = 2\n        if ele[1] == 2:\n            ansput = 3\n        for i in edge_graph[ele[0]]:\n            if visited[i] == 1:\n                continue\n            q.append((i, ansput))\n            ans[i] = ansput\n    for i in range(len(ans)):\n        ans[i] = str(ans[i])\n    print(' '.join(ans))"]