["from math import inf, gcd, log, log2, floor, ceil, sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nfrom functools import lru_cache\nfrom itertools import accumulate\nimport bisect\nimport sys\nDIRS = [[1, 0], [0, 1], [0, -1], [-1, 0], [-1, -1], [1, 1], [-1, 1], [1, -1]]\nMOD = 10 ** 9 + 7\ninput = sys.stdin.readline\nt = int(input())\n\ndef solve():\n    (n, q) = [int(x) for x in input().split(' ')]\n    a = [int(x) for x in input().split(' ')]\n    qa = []\n    for _ in range(q):\n        qa.append(int(input()))\n    a.sort(reverse=True)\n    pfs = list(accumulate(a, initial=0))\n    ans = []\n    for x in qa:\n        idx = bisect.bisect_left(pfs, x)\n        ans.append(idx)\n    for x in ans:\n        if x <= n:\n            print(x)\n        else:\n            print(-1)\nwhile t:\n    solve()\n    t -= 1", "import bisect, sys\nfrom itertools import accumulate\ninput = sys.stdin.readline\nfor g in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    s = sorted(list(map(int, input().split())), reverse=True)\n    p = [0] * len(s)\n    p = list(accumulate(s))\n    for _ in range(q):\n        test = int(input())\n        if p[-1] < test:\n            print(-1)\n        else:\n            k = bisect.bisect_left(p, test)\n            print(k + 1)", "import bisect\nfrom itertools import accumulate\n\ndef solve() -> str:\n    (n, q) = map(int, input().split())\n    candies = list(map(int, input().split()))\n    candies.sort(reverse=True)\n    sums = [0]\n    sums.extend(accumulate(candies))\n    results = []\n    for _ in range(q):\n        target = int(input())\n        if target > sums[-1]:\n            results.append('-1')\n            continue\n        results.append(str(bisect.bisect_left(sums, target)))\n    return '\\n'.join(results)\nresults = []\nfor _ in range(int(input())):\n    results.append(solve())\nprint('\\n'.join(results))", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    for i in range(1, n):\n        arr[i] = arr[i] + arr[i - 1]\n    for _ in range(m):\n        q = int(input())\n        left = bisect_left(arr, q) + 1\n        if left > n:\n            print(-1)\n        else:\n            print(left)", "import sys\nimport bisect\n\ndef solve():\n    inp = sys.stdin.readline\n    (n, q) = map(int, inp().split())\n    a = list(map(int, inp().split()))\n    a.sort(reverse=True)\n    p = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n    for i in range(q):\n        x = int(inp())\n        ans = bisect.bisect_left(p, x)\n        if ans > n:\n            print(-1)\n        else:\n            print(ans)\n\ndef main():\n    for i in range(int(sys.stdin.readline())):\n        solve()\nmain()", "import sys\ninput = sys.stdin.readline\nimport bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = sorted(map(int, input().split()), reverse=True)\n    d = [0] * n\n    s = 0\n    for i in range(n):\n        s += a[i]\n        d[i] = s\n    for i in range(q):\n        s = int(input())\n        if s > d[-1]:\n            print(-1)\n        else:\n            print(bisect.bisect_left(d, s) + 1)", "import itertools as a\nimport bisect as b\n(x, y) = (int, input)\nfor i in range(x(y())):\n    ((n, q), p) = (map(x, y().split()), list(a.accumulate(sorted(map(x, y().split()))[::-1])))\n    print('\\n'.join([str((b.bisect_left(p, x(y())) - n or -n - 2) + n + 1) for j in range(q)]))", "import sys\nimport bisect\nT = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    A.sort()\n    B = [0] * N\n    B[-1] = A[-1]\n    for i in range(N - 2, -1, -1):\n        B[i] = B[i + 1] + A[i]\n    B.reverse()\n    for _ in range(Q):\n        x = int(sys.stdin.readline())\n        i = bisect.bisect_left(B, x)\n        ans = i + 1\n        print(ans if ans <= N else -1)", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    for i in range(1, n):\n        arr[i] = arr[i] + arr[i - 1]\n    for _ in range(m):\n        q = int(input())\n        left = bisect_left(arr, q) + 1\n        if left > n:\n            print(-1)\n        else:\n            print(left)", "from sys import stdin\nfrom bisect import bisect_left\nt = int(stdin.readline())\nwhile t > 0:\n    t -= 1\n    (n, q) = map(int, stdin.readline().split())\n    a = sorted(map(int, stdin.readline().split()), reverse=True)\n    b = [0] * n\n    b[0] = a[0]\n    for j in range(1, n):\n        b[j] = b[j - 1] + a[j]\n    for i in range(q):\n        x = int(stdin.readline())\n        y = bisect_left(b, x)\n        if y > n - 1:\n            print(-1)\n        else:\n            print(y + 1)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nfrom bisect import bisect_left\nINF = float('INF')\n\ndef solve():\n    (N, Q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    A = sorted(A, reverse=True)\n    V = [INF] * (N + 1)\n    V[0] = 0\n    for j in range(N):\n        V[j + 1] = V[j] + A[j]\n    V[0] = -1\n    for _ in range(Q):\n        q = int(input())\n        res = bisect_left(V, q)\n        if res == N + 1:\n            print(-1)\n        else:\n            print(res)\n    return\nT = int(input())\nfor _ in range(T):\n    solve()", "import sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\nreadline = sys.stdin.readline\nfor _ in range(int(readline())):\n    (n, q) = map(int, readline().split())\n    ns = list(accumulate(sorted(map(int, readline().split()), reverse=True)))\n    for _ in range(q):\n        x = int(readline())\n        index = bisect_left(ns, x, lo=0, hi=n)\n        if index == n:\n            print(-1)\n        else:\n            print(index + 1)", "from collections import Counter\nfrom functools import lru_cache\nfrom bisect import bisect, bisect_left\nt = int(input())\nresult = []\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    array = list(map(int, input().split()))\n    queries = []\n    for i in range(q):\n        queries.append(int(input()))\n    prefixSum = []\n    array.sort(reverse=True)\n    currentSum = 0\n    for num in array:\n        currentSum += num\n        prefixSum.append(currentSum)\n    ans = []\n    for query in queries:\n        currentIdx = bisect_left(prefixSum, query)\n        if currentIdx >= len(prefixSum):\n            ans.append(-1)\n        else:\n            ans.append(currentIdx + 1)\n    for an in ans:\n        print(an)", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import bisect_left\n\ndef solve(lst, queries):\n    lst.sort(key=lambda x: -x)\n    lst = pref_sum(lst)\n    for q in queries:\n        id = bisect_left(lst, q) + 1\n        if id > len(lst):\n            print(-1)\n        else:\n            print(id)\n\ndef pref_sum(lst):\n    s = 0\n    ans = []\n    for i in lst:\n        s += i\n        ans.append(s)\n    return ans\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        (n, q) = list(map(int, input().split()))\n        lst = list(map(int, input().split()))\n        qs = []\n        for i in range(q):\n            qs.append(int(input()))\n        solve(lst, qs)\nmain()", "from bisect import bisect_left\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\n\ndef exe():\n    a = []\n    count = []\n    c = 0\n    for i in lst:\n        c += i\n        count.append(c)\n    maxi = max(count)\n    for i in l:\n        if i > maxi:\n            print(-1)\n            continue\n        min_val = bisect_left(count, i)\n        print(min_val + 1)\nfor i in range(int(input())):\n    (n, q) = ma()\n    lst = lis()\n    lst.sort(reverse=True)\n    l = [int(input()) for i in range(q)]\n    exe()", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import bisect_left\nt = int(input())\nwhile t > 0:\n    (n, q) = list(map(int, input().split(' ')))\n    a = list(map(int, input().split(' ')))\n    total = sum(a)\n    queries = []\n    for _ in range(q):\n        queries.append(int(input()))\n    a.sort(reverse=True)\n    p = a[:]\n    for i in range(1, n):\n        p[i] = p[i - 1] + a[i]\n    for x in queries:\n        ans = bisect_left(p, x, 0, n)\n        if ans <= n - 1:\n            print(ans + 1)\n        else:\n            print(-1)\n    t -= 1", "from array import array\nimport collections\nimport sys\nfrom collections import Counter, deque\nimport heapq\nimport bisect\nimport copy\nMOD = 1000000007\nNO = lambda : print('NO')\nYES = lambda : print('YES')\n_1 = lambda : print(-1)\nari = lambda : [int(_) for _ in input().split()]\ncin = lambda : int(input())\ncis = lambda : input()\nshow = lambda x: print(x)\nfast = lambda : sys.stdin.readline()\ntest_case = 1\ntest_case = int(input())\nsys.setrecursionlimit(10 ** 6)\ndito = {}\nidx = 0\nfor i in 'abcdefghijklmnopqrstuvwxyz':\n    idx += 1\n    dito[i] = idx\n\ndef ans():\n    (n, q) = ari()\n    arr = ari()\n    query = []\n    for i in range(q):\n        query.append(cin())\n    arr.sort(reverse=True)\n    for i in range(1, n):\n        arr[i] += arr[i - 1]\n    for i in query:\n        if arr[-1] < i:\n            print(-1)\n        else:\n            idx = bisect.bisect_left(arr, i)\n            print(idx + 1)\n    return\nfor _ in range(test_case):\n    ans()", "import bisect\n\ndef method(arr, limit):\n    if arr[-1] < limit:\n        return -1\n    index = bisect.bisect_left(preList, limit)\n    return index + 1\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    pre = 0\n    n = len(arr)\n    preList = [0 for i in range(n)]\n    for i in range(n):\n        pre += arr[i]\n        preList[i] = pre\n    qs = []\n    for _ in range(q):\n        qs.append(int(input()))\n    for q in qs:\n        print(method(preList, q))", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "import bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    queries = []\n    for i in range(q):\n        queries.append(int(input()))\n    a = sorted(a, reverse=True)\n    b = a[:]\n    for i in range(1, len(b)):\n        b[i] = b[i - 1] + b[i]\n    for i in range(q):\n        ans = bisect.bisect_left(b, queries[i]) + 1\n        if ans == len(b) + 1:\n            print(-1)\n        else:\n            print(ans)", "from bisect import *\nfrom itertools import *\nkvs = lambda : map(int, input().split())\nfor _ in range(*kvs()):\n    (n, q) = kvs()\n    x = [*accumulate(reversed(sorted(kvs())))]\n    print(*(-1 if (a := bisect_left(x, *kvs())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "def task(n, a, q, qs):\n    a.sort(reverse=True)\n    sorted_qs = sorted(qs)\n    sugar = 0\n    j = 0\n    results = dict()\n    for i in range(q):\n        if sugar >= sorted_qs[i]:\n            results[sorted_qs[i]] = j\n        else:\n            while sugar < sorted_qs[i]:\n                if j == n:\n                    results[sorted_qs[i]] = -1\n                    break\n                sugar += a[j]\n                j += 1\n                if sugar >= sorted_qs[i]:\n                    results[sorted_qs[i]] = j\n    for i in range(q):\n        print(results[qs[i]])\nt = int(input())\nfor i in range(0, t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    qs = []\n    for i in range(q):\n        qs.append(int(input()))\n    task(n, a, q, qs)", "from bisect import *\nfrom itertools import *\ni = lambda : map(int, input().split())\nfor d in range(*i()):\n    (n, q) = i()\n    x = [*accumulate(reversed(sorted(i())))]\n    print(*(-1 if (a := bisect_left(x, *i())) == len(x) else a + 1 for f in range(q)), sep='\\n')", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dict = {}\n    k = []\n    for i in range(q):\n        p = int(input())\n        dict[p] = 0\n        k.append(p)\n    lst = list(dict.keys())\n    count = 0\n    j = 0\n    lst.sort()\n    a.sort(reverse=True)\n    p = len(lst)\n    for i in range(n):\n        count += a[i]\n        while j < p:\n            if lst[j] <= count:\n                dict[lst[j]] = i + 1\n                j += 1\n            else:\n                break\n    for i in k:\n        if dict[i] == 0:\n            print(-1)\n        else:\n            print(dict[i])", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from bisect import *\nfrom itertools import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, q) = I()\n    x = [*accumulate(reversed(sorted(I())))]\n    print(*(-1 if (a := bisect_left(x, *I())) == len(x) else a + 1 for _ in range(q)), sep='\\n')", "from collections import defaultdict as dfd\n\ndef solve(quan, quer):\n    quan.sort(reverse=True)\n    S = sum(quan)\n    book = dfd(list)\n    for (i, q) in enumerate(quer):\n        book[q].append(i)\n    arr_q = sorted(list(book.keys()))\n    ans = [-1] * len(quer)\n    (cnt, agg) = (0, 0)\n    for q in arr_q:\n        if q > S:\n            break\n        while agg < q:\n            agg += quan[cnt]\n            cnt += 1\n        for idx in book[q]:\n            ans[idx] = cnt\n    return ans\nT = int(input())\nfor _ in range(T):\n    (N, Q) = list(map(int, input().split()))\n    quan = list(map(int, input().split()))\n    quer = []\n    for _ in range(Q):\n        quer.append(int(input()))\n    ans = solve(quan, quer)\n    for a in ans:\n        print(a)", "from bisect import bisect_left, bisect_right\n\ndef BinarySearch(a, x):\n    i = bisect_left(a, x)\n    if i < len(a) and a[i] >= x:\n        return i + 1\n    else:\n        return -1\nfor t in range(int(input())):\n    (n, q) = [int(i) for i in input().split()]\n    d = [int(i) for i in input().split()]\n    queries = []\n    for i in range(q):\n        queries.append(int(input()))\n    d.sort(reverse=True)\n    for i in range(1, n):\n        d[i] += d[i - 1]\n    t = True\n    for i in range(q):\n        res = BinarySearch(d, queries[i])\n        print(res)", "import sys\nfor _ in range(int(sys.stdin.readline())):\n    (n, q) = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort()\n    f = [0] * q\n    a.reverse()\n    all_x = []\n    for i in range(q):\n        x = int(sys.stdin.readline())\n        all_x.append((x, i))\n    all_x.sort()\n    ukaz1 = 1\n    weight = a[0]\n    for i in all_x:\n        while ukaz1 <= n and weight < i[0]:\n            ukaz1 += 1\n            if ukaz1 < n + 1:\n                weight += a[ukaz1 - 1]\n        if ukaz1 == n + 1:\n            f[i[1]] = -1\n        else:\n            f[i[1]] = ukaz1\n    print(*f, sep='\\n')", "t = int(input())\nfor _ in range(t):\n    (n, q) = list(map(int, input().split()))\n    a = sorted(map(int, input().split()), reverse=True)\n    s = []\n    for i in range(q):\n        s += [[int(input()), i]]\n    sm = 0\n    s = sorted(s)\n    k = 0\n    ans = [-1 for _ in range(q)]\n    for i in range(n):\n        sm += a[i]\n        while k < q and sm >= s[k][0]:\n            ans[s[k][1]] = i + 1\n            k += 1\n    print('\\n'.join(map(str, ans)))", "import bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    queries = []\n    for i in range(q):\n        queries.append(int(input()))\n    a = sorted(a, reverse=True)\n    b = a[:]\n    for i in range(1, len(b)):\n        b[i] = b[i - 1] + b[i]\n    for i in range(q):\n        ans = bisect.bisect_left(b, queries[i]) + 1\n        if ans == len(b) + 1:\n            print(-1)\n        else:\n            print(ans)", "from bisect import *\nfrom itertools import *\ni = lambda : map(int, input().split())\nfor d in range(*i()):\n    (n, q) = i()\n    x = [*accumulate(reversed(sorted(i())))]\n    print(*(-1 if (a := bisect_left(x, *i())) == len(x) else a + 1 for f in range(q)), sep='\\n')", "for _ in range(int(input())):\n    requests = []\n    (mysor, num_of_requests) = map(int, input().split())\n    sugar = sorted(list(map(int, input().split())), reverse=True)\n    answers = [-1] * num_of_requests\n    summ = 0\n    for i in range(num_of_requests):\n        requests.append((int(input()), i))\n    requests.sort()\n    cur_request = 0\n    for j in range(mysor):\n        summ += sugar[j]\n        while cur_request < num_of_requests and requests[cur_request][0] <= summ:\n            answers[requests[cur_request][1]] = j + 1\n            cur_request += 1\n    print(*answers, sep='\\n')", "from pickle import FALSE\nt = int(input())\nfor e in range(t):\n    (n, q) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    que = []\n    for i in range(q):\n        que.append([int(input()), i])\n    arr.sort(reverse=True)\n    que.sort(key=lambda x: x[0])\n    d = 0\n    ans = 0\n    ti = 0\n    ee = {}\n    for i in range(q):\n        done = False\n        if d >= que[i][0]:\n            ee[que[i][1]] = ans\n            continue\n        while True:\n            if ti >= n:\n                break\n            d += arr[ti]\n            ti += 1\n            ans += 1\n            if d >= que[i][0]:\n                done = True\n                break\n        if not done:\n            ee[que[i][1]] = -1\n        else:\n            ee[que[i][1]] = ans\n    for i in range(q):\n        print(ee[i])", "t = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    candies = list(map(int, input().split()))\n    candies.sort(reverse=True)\n    total = sum(candies)\n    sugar = []\n    current = 0\n    for candy in candies:\n        current += candy\n        sugar.append(current)\n    queries = []\n    for i in range(q):\n        target = int(input())\n        queries.append((i, target))\n    queries.sort(key=lambda x: x[1])\n    output = []\n    i = 0\n    for (ind, target) in queries:\n        if target > sugar[-1]:\n            output.append((ind, -1))\n        else:\n            while sugar[i] < target:\n                i += 1\n            if i == n - 1 and sugar[i] < target:\n                output.append((ind, -1))\n            else:\n                output.append((ind, i + 1))\n    output.sort(key=lambda x: x[0])\n    for item in output:\n        print(item[1])", "from bisect import bisect_left\nT = []\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = sorted(list(map(int, input().split())), reverse=True)\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for j in range(q):\n        x = int(input())\n        if x > a[-1]:\n            T.append(-1)\n        else:\n            T.append(bisect_left(a, x) + 1)\nfor i in T:\n    print(i)", "from bisect import bisect_left\nfrom itertools import accumulate\nfor i in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    l.reverse()\n    l = list(accumulate(l))\n    for j in range(q):\n        x = int(input())\n        ans = bisect_left(l, x) + 1\n        if ans > n:\n            ans = -1\n        print(ans)", "t = int(input())\n\ndef bs(ps, x):\n    (l, r) = (0, len(ps) - 1)\n    while l < r:\n        mid = (r + l) // 2\n        if ps[mid] < x:\n            l = mid + 1\n        else:\n            r = mid\n    return l if ps[l] >= x else -1\nfor _ in range(t):\n    (n, q) = (int(x) for x in input().split())\n    a = [int(x) for x in input().split()]\n    a.sort(reverse=True)\n    ps = []\n    for i in a:\n        ps.append(i + (ps[-1] if ps else 0))\n    x = [int(input()) for _ in range(q)]\n    for i in x:\n        val = bs(ps, i)\n        print(val + (1 if val != -1 else 0))", "from collections import Counter, deque\nfrom collections import OrderedDict\nimport math\nfrom random import randint\nfrom bisect import bisect, bisect_left\nimport sys\nimport re\nMOD = 10 ** 9 + 7\nMAX = -sys.maxsize\nMIN = sys.maxsize\n\nclass get:\n\n    def int():\n        return list(map(int, input().split()))\n\n    def str():\n        return input().split()\n\n    def float():\n        return list(map(float, input().split()))\n\n    def map():\n        return map(int, input().split())\n\ndef sqrt(x):\n    return int(math.sqrt(x)) + 1\n\ndef gcd(*args):\n    result = args[0]\n    for item in args:\n        result = math.gcd(result, item)\n    return result\n\ndef LCM(a, b):\n    return a * b // math.gcd(a, b)\n\ndef isPrime(n):\n    if n == 1:\n        return False\n    for i in range(2, sqrt(n)):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    (n, q) = get.map()\n    a = get.int()\n    a.sort(reverse=True)\n    c = 0\n    sum_ = sum(a)\n    for i in range(n):\n        c += a[i]\n        a[i] = c\n    for _ in range(q):\n        x = int(input())\n        if x > sum_:\n            print(-1)\n            continue\n        kk = bisect_left(a, x)\n        print(kk + 1)\nt = int(input())\nfor tt in range(t):\n    solve()", "import sys\nimport threading\nfrom math import inf\nfrom bisect import bisect_left\nfrom collections import defaultdict, deque\n\ndef li():\n    return list(map(int, input().split()))\n\ndef nn():\n    return int(input().split())\n\ndef w():\n    return input()\n\ndef solve():\n    (n, q) = li()\n    arr = li()\n    arr.sort(reverse=True)\n    tot = sum(arr)\n    for i in range(1, n):\n        arr[i] += arr[i - 1]\n    for i in range(q):\n        qr = int(input())\n        if qr > tot:\n            idx = -1\n        else:\n            idx = bisect_left(arr, qr)\n        print(idx + 1) if idx != -1 else print(idx)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        solve()\nmain()", "from itertools import accumulate\nfrom bisect import bisect_left\n\ndef solve():\n    (n, q) = map(int, input().split())\n    arr = list(accumulate(sorted(list(map(int, input().split())), reverse=True)))\n    for i in range(q):\n        a = int(input())\n        x = bisect_left(arr, a)\n        if x < n:\n            print(x + 1)\n        else:\n            print(-1)\nt = int(input())\nfor _ in range(t):\n    solve()", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    a.sort(reverse=True)\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for i in range(q):\n        x = int(input())\n        mark = bisect.bisect_left(a, x)\n        if mark == n:\n            print(-1)\n        else:\n            print(mark + 1)", "from bisect import bisect_left\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    pre = [0]\n    for num in a:\n        pre.append(pre[-1] + num)\n    mx = pre[-1]\n    for _ in range(q):\n        x = int(input())\n        if x > mx:\n            print(-1)\n        else:\n            ans = bisect_left(pre, x)\n            print(ans)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    arr.reverse()\n    for i in range(n - 1):\n        arr[i + 1] += arr[i]\n    for i in range(q):\n        i = bisect_left(arr, int(input()))\n        if i >= n:\n            print(-1)\n        else:\n            print(i + 1)", "import bisect\n\ndef main():\n    (n, q) = map(int, input().split())\n    sweets = [int(x) for x in input().split()]\n    sweets.sort(reverse=True)\n    prefix_sum = [sweets[0]] * n\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i - 1] + sweets[i]\n    for _ in range(q):\n        x = int(input())\n        result = bisect.bisect_left(prefix_sum, x)\n        if result == n:\n            print(-1)\n        else:\n            print(result + 1)\nt = int(input())\nfor _ in range(t):\n    main()", "import bisect\n\ndef solve(n, q, A):\n    A.sort(reverse=True)\n    A_accum = [A[0]]\n    for a in A[1:]:\n        A_accum.append(a + A_accum[-1])\n    for _ in range(q):\n        x = int(input())\n        i = bisect.bisect_left(A_accum, x)\n        if i >= n:\n            print(-1)\n        else:\n            print(i + 1)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    A = list(map(int, input().split()))\n    solve(n, q, A)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().strip().split()))\n    a.sort(reverse=True)\n    p = [a[0]]\n    for i in range(1, n):\n        p.append(p[-1] + a[i])\n    for j in range(q):\n        x = int(input())\n        idx = bisect.bisect_left(p, x)\n        if idx <= n - 1:\n            print(idx + 1)\n        else:\n            print(-1)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a = a[::-1]\n    adds = [a[0]]\n    for i in range(1, n):\n        adds.append(adds[-1] + a[i])\n    for i in range(q):\n        x = int(input())\n        ans = bisect_left(adds, x)\n        if ans == n:\n            print(-1)\n        else:\n            print(ans + 1)", "from itertools import accumulate\nfrom bisect import bisect, bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    a = list(accumulate(a))\n    for _ in range(q):\n        x = int(input())\n        if a[-1] < x:\n            print(-1)\n        else:\n            print(bisect_left(a, x) + 1)", "from bisect import *\nfrom itertools import *\nfor s in range(int(input())):\n    (n, q) = map(int, input().split())\n    c = list(map(int, input().split()))\n    c.sort()\n    c.reverse()\n    c = list(accumulate(c))\n    for i in range(q):\n        num = int(input())\n        xb = bisect_left(c, num)\n        print('-1' if xb == n else xb + 1)", "from itertools import accumulate\nimport bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = sorted(map(int, input().split()), reverse=True)\n    prefix = list(accumulate(a))\n    for i in range(q):\n        res = bisect.bisect_left(prefix, int(input()))\n        print(res + 1 if res != n else -1)", "def solve(n, q, arr, query):\n    su = sum(arr)\n    arr.sort()\n    arr.reverse()\n    for i in range(1, n):\n        arr[i] += arr[i - 1]\n    res = []\n    for x in query:\n        l = 0\n        h = n - 1\n        temp = 0\n        if x > su:\n            res.append(-1)\n            continue\n        while l <= h:\n            mid = (l + h) // 2\n            if arr[mid] == x:\n                res.append(mid + 1)\n                temp = 1\n                break\n            elif arr[mid] > x:\n                h = mid - 1\n            else:\n                l = mid + 1\n        if temp == 0:\n            res.append(l + 1)\n    return res\nt = int(input())\nfor _ in range(t):\n    (n, q) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    query = []\n    for _ in range(q):\n        x = int(input())\n        query.append(x)\n    res = solve(n, q, arr, query)\n    for x in res:\n        print(x)\n    print()", "import bisect\nfor t in range(int(input())):\n    (n, q) = map(int, input().split())\n    items = sorted(list(map(int, input().split())), reverse=True)\n    add = [0] * (n + 1)\n    for i in range(1, n + 1):\n        add[i] = add[i - 1] + items[i - 1]\n    for i in range(q):\n        x = int(input())\n        if x > add[n]:\n            print(-1)\n        else:\n            print(bisect.bisect_left(add, x))", "from itertools import accumulate\nfrom bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    candy = list(accumulate(sorted(list(map(int, input().split())), reverse=True)))\n    for i in range(q):\n        req = int(input())\n        t = bisect_left(candy, req)\n        print(t + 1 if n > t else -1)", "from itertools import accumulate\nfrom bisect import bisect_left\n\ndef solve():\n    (n, q) = (int(x) for x in input().split())\n    a = [int(x) for x in input().split()]\n    a.sort(reverse=True)\n    p = list(accumulate(a))\n    for _ in range(q):\n        x = int(input())\n        i = bisect_left(p, x) + 1\n        print(i if i <= n else -1)\nfor _ in range(int(input())):\n    solve()", "import bisect\nR = lambda : map(int, input().split())\nfor _ in range(int(input())):\n    (n, q) = R()\n    L = list(R())\n    L = sorted(L, reverse=True)\n    for i in range(1, n):\n        L[i] += L[i - 1]\n    for i in range(q):\n        p = int(input())\n        res = bisect.bisect_left(L, p)\n        if res == n:\n            print(-1)\n        else:\n            print(res + 1)", "import bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    a = sorted(a, reverse=True)\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for i in range(q):\n        x_i = int(input())\n        j = bisect.bisect_left(a, x_i)\n        if j == n:\n            print(-1)\n        else:\n            print(j + 1)", "import bisect\nfor j in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    ls = [l[0]]\n    for x in range(1, n):\n        ls.append(l[x] + ls[x - 1])\n    for z in range(0, k):\n        n1 = int(input())\n        a = bisect.bisect_left(ls, n1)\n        if a == n:\n            print(-1)\n        else:\n            print(a + 1)", "import bisect\nfor j in range(0, int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    ls = [l[0]]\n    for x in range(1, n):\n        ls.append(l[x] + ls[x - 1])\n    for z in range(0, k):\n        n1 = int(input())\n        a = bisect.bisect_left(ls, n1)\n        if a == n:\n            print(-1)\n        else:\n            print(a + 1)", "from bisect import bisect_left\nfor i in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = [int(x) for x in input().split()]\n    l.sort(reverse=True)\n    s = 0\n    for i in range(1, n):\n        l[i] += l[i - 1]\n    for k in range(q):\n        a = int(input())\n        ans = bisect_left(l, a) + 1\n        print(ans if ans <= n else -1)", "import sys\ninput = sys.stdin.readline\n\ndef bin(a, n):\n    l = 0\n    h = len(a) - 1\n    while l <= h:\n        m = (h + l) // 2\n        if a[m] == n:\n            return m\n        if a[m] < n:\n            l = m + 1\n        else:\n            h = m - 1\n    return l\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = b[i - 1] + a[i]\n    for i in range(m):\n        q = int(input())\n        if q > b[-1]:\n            print(-1)\n            continue\n        ans = bin(b, q)\n        print(ans + 1)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    a = sorted(a, reverse=True)\n    for i in range(1, n):\n        a[i] = a[i] + a[i - 1]\n    for i in range(q):\n        qi = int(input())\n        left = bisect_left(a, qi) + 1\n        if left > n:\n            print(-1)\n        else:\n            print(left)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    inp = input().split()\n    (n, m) = (int(inp[0]), int(inp[1]))\n    arr = list(map(int, input().split()))\n    sumi = sum(arr)\n    arr = sorted(arr, key=lambda x: -x)\n    prefix = arr[:]\n    for i in range(1, len(arr)):\n        prefix[i] += prefix[i - 1]\n    for i in range(m):\n        val = int(input())\n        if sumi < val:\n            print(-1)\n        elif sumi == val:\n            print(n)\n        else:\n            print(bisect_left(prefix, val) + 1)", "import bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    for i in range(1, n):\n        l[i] += l[i - 1]\n    for i in range(q):\n        a = int(input())\n        index = bisect.bisect_left(l, a)\n        index += 1\n        if index > n:\n            index = -1\n        print(index)", "from itertools import accumulate\n\ndef binary_search(arr, x):\n    res = -1\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] >= x:\n            high = mid - 1\n            res = mid\n    return res if res == -1 else res + 1\ncases = int(input())\nfor _ in range(cases):\n    (candies_count, queries_count) = map(int, input().split(' '))\n    sugar_content = sorted(list(map(int, input().split(' '))), reverse=True)\n    prefix_sums = list(accumulate(sugar_content))\n    queries = []\n    for _ in range(queries_count):\n        queries.append(int(input()))\n    for target in queries:\n        print(binary_search(prefix_sums, target))", "import itertools, bisect\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    sums = list(itertools.accumulate(a))\n    for _ in range(q):\n        x = int(input())\n        idx = bisect.bisect_left(sums, x)\n        if idx == n:\n            print(-1)\n        else:\n            print(idx + 1)", "from bisect import bisect_left as bl\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    can = sorted(list(map(int, input().split())), reverse=1)\n    adds = [can[0]]\n    for i in range(1, n):\n        adds.append(adds[i - 1] + can[i])\n    for i in range(q):\n        chahiye = int(input())\n        ans = bl(adds, chahiye)\n        if ans == n:\n            print(-1)\n        else:\n            print(ans + 1)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    x = list(map(int, input().split()))\n    x.sort(reverse=True)\n    for i in range(n - 1):\n        x[i + 1] += x[i]\n    ans = x[-1]\n    for _ in range(q):\n        s = int(input())\n        if s > ans:\n            print(-1)\n        elif s == ans:\n            print(len(x))\n        else:\n            l = bisect_left(x, s)\n            print(l + 1)", "from itertools import accumulate\nfrom bisect import bisect_left\nfor t in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = sorted(map(int, input().split()), reverse=True)\n    val = [*accumulate(l)]\n    for i in range(q):\n        x = int(input())\n        print([bisect_left(val, x) + 1, -1][x > val[-1]])", "from bisect import bisect_left\ntests = int(input())\nfor test in range(tests):\n    (candy, query) = tuple(map(int, input().split(' ')))\n    sg = list(map(int, input().split(' ')))\n    sg.sort(key=lambda x: -x)\n    for i in range(1, candy):\n        sg[i] += sg[i - 1]\n    for q in range(query):\n        target = int(input())\n        ind = bisect_left(sg, target)\n        if ind >= candy:\n            print(-1)\n        else:\n            print(ind + 1)", "from bisect import bisect_left\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    arr = sorted(list(map(int, input().split())), reverse=True)\n    prev = 0\n    l = []\n    for e in arr:\n        l.append(e + prev)\n        prev += e\n    for _ in range(q):\n        x = int(input())\n        if l[-1] < x:\n            print(-1)\n        else:\n            print(bisect_left(l, x) + 1)", "from sys import stdin, stdout\nimport collections\nimport math\n\ndef solve(l, q):\n    n = len(l)\n    if q > l[-1]:\n        return -1\n    (s, e) = (0, n - 1)\n    while s <= e:\n        m = (s + e) // 2\n        if q < l[m]:\n            e = m - 1\n        elif q > l[m]:\n            s = m + 1\n        else:\n            return m\n    return s\n\ndef main():\n    for _ in range(int(input())):\n        (n, q) = map(int, input().split())\n        l = list(map(int, input().split()))\n        l.sort(reverse=True)\n        for i in range(1, n):\n            l[i] += l[i - 1]\n        for i in range(q):\n            x = int(input())\n            ans = solve(l, x)\n            if ans == -1:\n                ans = -2\n            print(ans + 1)\n    return\ninput = stdin.readline\nmain()", "from bisect import bisect_left\nn = int(input())\nfor i in range(n):\n    (x, y) = map(int, input().split())\n    l = [int(x) for x in input().split()]\n    l.sort(reverse=True)\n    s = 0\n    for i in range(1, x):\n        l[i] += l[i - 1]\n    for k in range(y):\n        a = int(input())\n        ans = bisect_left(l, a) + 1\n        print(ans if ans <= x else -1)", "from bisect import bisect_left\nwhile True:\n    try:\n        test = int(input())\n    except EOFError:\n        break\n    for i in range(test):\n        (n, q) = map(int, input().split(' '))\n        arr = sorted(map(int, input().split(' ')), reverse=True)\n        for i in range(1, len(arr)):\n            arr[i] += arr[i - 1]\n        for i in range(q):\n            a = int(input())\n            ans = bisect_left(arr, a) + 1\n            if ans > n:\n                print(-1)\n            else:\n                print(ans)", "import bisect\nx = int(input())\nfor jj in range(x):\n    (n, m) = [int(i) for i in input().split(' ')]\n    a = [int(i) for i in input().split(' ')]\n    a.sort(reverse=True)\n    t = [0] * n\n    for i in range(n):\n        t[i] = t[i - 1] + a[i]\n    for i in range(m):\n        q = int(input())\n        if q > t[-1]:\n            print(-1)\n        else:\n            print(bisect.bisect_left(t, q) + 1)", "from itertools import accumulate\nfrom bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    can = list(map(int, input().split()))\n    can.sort(reverse=True)\n    p = list(accumulate(can))\n    for _ in range(q):\n        idx = bisect_left(p, int(input()))\n        if idx == n:\n            print(-1)\n        else:\n            print(idx + 1)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef find(sums, query):\n    left = 0\n    right = len(sums) - 1\n    answer = -1\n    while left <= right:\n        middle = left + (right - left) // 2\n        if sums[middle] >= query:\n            answer = middle + 1\n            right = middle - 1\n        else:\n            left = middle + 1\n    return answer\nt = inp()\nanswer = []\nfor i in range(t):\n    (n, m) = inlt()\n    candies = inlt()\n    candies.sort(reverse=True)\n    sums = []\n    su_m = 0\n    for i in range(n):\n        su_m += candies[i]\n        sums.append(su_m)\n    for i in range(m):\n        query = inp()\n        answer.append(find(sums, query))\nfor ans in answer:\n    print(ans)", "from bisect import bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = sorted(map(int, input().split()), reverse=True)\n    sumA = [0] * (n + 1)\n    for i in range(n):\n        sumA[i + 1] = a[i] + sumA[i]\n    while q != 0:\n        x = int(input())\n        num = bisect(sumA, x - 1)\n        print(num if num <= n else -1)\n        q = q - 1", "from bisect import bisect_left\nx = int(input())\nfor _ in range(x):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    (s, suffix_sum) = (0, [])\n    for a_i in a[::-1]:\n        s += a_i\n        suffix_sum.append(s)\n    for j in range(q):\n        x_j = int(input())\n        res = bisect_left(suffix_sum, x_j) + 1\n        if res > n:\n            res = -1\n        print(res)", "from itertools import accumulate\nimport bisect\nI = input\nfor _ in range(int(I())):\n    (n, q) = map(int, I().split())\n    lst = list(map(int, I().split()))\n    presum = list(accumulate(sorted(lst, reverse=True)))\n    for _ in range(q):\n        i = int(I().strip())\n        idx = bisect.bisect_left(presum, i)\n        print(-1 if idx == len(presum) else idx + 1)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = sorted(list(map(int, input().split())), reverse=True)\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for j in range(q):\n        x = int(input())\n        if x > a[-1]:\n            print(-1)\n        else:\n            print(bisect_left(a, x) + 1)", "from bisect import bisect_left\nfor t in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = sorted(list(map(int, input().split())), reverse=True)\n    sm = 0\n    num_list = []\n    for i in a:\n        num_list.append(sm + i)\n        sm += i\n    for i in range(q):\n        x = int(input())\n        if num_list[-1] >= x:\n            print(bisect_left(num_list, x) + 1)\n        else:\n            print(-1)", "import bisect\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    ax = []\n    curr = 0\n    for i in range(len(a) - 1, -1, -1):\n        curr += a[i]\n        ax.append(curr)\n    for i in range(m):\n        q = int(input())\n        if q > ax[-1]:\n            print(-1)\n        else:\n            x = bisect.bisect_right(ax, q)\n            if ax[x - 1] == q:\n                print(x)\n            else:\n                print(x + 1)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, q) = [int(x) for x in input().split()]\n    l = [int(x) for x in input().split()]\n    l = sorted(l)[::-1]\n    temp = []\n    sum = 0\n    for x in l:\n        sum += x\n        temp.append(sum)\n    for i in range(q):\n        t = int(input())\n        if t < temp[0]:\n            print(1)\n            continue\n        if t > temp[-1]:\n            print(-1)\n            continue\n        mid = bisect_left(temp, t)\n        print(mid + 1)", "from bisect import bisect_right\n_ = int(input())\nfor __ in range(_):\n    (n, q) = map(int, input().split())\n    candies = sorted(list(map(int, input().split())))\n    candies_sum = [candies[0]]\n    for z in range(1, n):\n        candies_sum.append(candies[z] + candies_sum[-1])\n    for x in range(q):\n        query = int(input())\n        if query > candies_sum[-1]:\n            print(-1)\n            continue\n        search_for = candies_sum[-1] - query\n        pos = bisect_right(candies_sum, search_for)\n        print(n - pos)", "import bisect\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    cans = list(map(int, input().split()))\n    cans.sort(reverse=True)\n    s = cans[0]\n    pcans = [s]\n    for i in range(1, len(cans)):\n        s += cans[i]\n        pcans.append(s)\n    for i in range(q):\n        query = int(input())\n        ansx = bisect.bisect_left(pcans, query)\n        if ansx + 1 > n:\n            print(-1)\n        else:\n            print(ansx + 1)", "import bisect\nimport itertools\nfor _ in range(int(input())):\n    (_, q) = map(int, input().split())\n    a = list(itertools.accumulate(sorted(map(int, input().split()), reverse=True)))\n    for _ in range(q):\n        print(bisect.bisect_left(a, x) + 1 if (x := int(input())) <= a[-1] else -1)", "import bisect\nfor pratyush in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    p = [l[0]]\n    for x in range(1, n):\n        p.append(l[x] + p[x - 1])\n    for i in range(0, k):\n        m = int(input())\n        a = bisect.bisect_left(p, m)\n        if a == n:\n            print(-1)\n        else:\n            print(a + 1)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    sug = sorted([int(x) for x in input().split()])[::-1]\n    pr = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pr[i] = pr[i - 1] + sug[i - 1]\n    for _ in range(q):\n        x = int(input())\n        res = bisect.bisect_left(pr, x)\n        if res > n:\n            print('-1')\n        else:\n            print(res)", "from bisect import bisect_left\nfor i in range(int(input())):\n    (n, q) = map(int, input().split())\n    sweets = sorted(list(map(int, input().split())), reverse=True)\n    data = []\n    summ = 0\n    for i in sweets:\n        summ += i\n        data.append(summ)\n    for i in range(q):\n        x = int(input())\n        answer = bisect_left(data, x)\n        if answer == len(data):\n            print(-1)\n        else:\n            print(answer + 1)", "from bisect import bisect, bisect_left, bisect_right\n\ndef busquedaBinaria(lista, abuscar):\n    inicio = 0\n    final = len(lista) - 1\n    res = -1\n    while inicio <= final and res == -1:\n        m = (inicio + final) // 2\n        if lista[m] == abuscar:\n            res = m\n        elif abuscar < lista[m]:\n            final = m - 1\n        else:\n            inicio = m + 1\n    return res\nt = int(input())\nfor _ in range(t):\n    (n, q) = list(map(int, input().split()))\n    lista = list(map(int, input().split()))\n    lista.sort(reverse=True)\n    res = [lista[0]]\n    for i in range(1, len(lista)):\n        res.append(lista[i] + res[-1])\n    for i in range(q):\n        c = int(input())\n        if c > res[-1]:\n            print(-1)\n        else:\n            found = bisect_left(res, c)\n            print(found + 1)", "from bisect import bisect_left\nimport sys\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = sorted(a)[::-1]\n    l = sum(a)\n    prefix = []\n    for (i, item) in enumerate(a):\n        k = item\n        if i:\n            k += prefix[-1]\n        prefix.append(k)\n    for _ in range(q):\n        o = int(input())\n        if o > l:\n            print(-1)\n            continue\n        index = bisect_left(prefix, o)\n        print(index + 1)"]