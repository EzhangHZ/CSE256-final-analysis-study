["n = int(input())\ns = input()\nfirst1 = n\nfor i in range(len(s)):\n    if s[i] == '1':\n        first1 = i\n        break\ns = s[first1:]\nif s == '':\n    print(0)\nelse:\n    first0 = n\n    for i in range(len(s)):\n        if s[i] == '0':\n            first0 = i\n            break\n    if first0 == n:\n        print(s)\n    else:\n        n = int(s, 2)\n        best = n\n        for i in range(first0 + 1):\n            best = max(best, n | n >> i)\n        print(bin(best)[2:])\nprint()", "n = int(input())\ns = int(input(), 2)\nans = 0\nfor i in range(20):\n    ans = max(ans, s | s >> i)\nans = bin(ans)\nans = ans[2:]\nprint(ans)", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "n = int(input())\ns = input()\nb = int(s, 2)\na = b\nmx = a | b\nfor i in range(0, 7):\n    a = a >> 1\n    m = a | b\n    if m > mx:\n        mx = m\nst = format(mx, 'b')\nprint(st)", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "lenght = input()\nn = int(input(), 2)\nrez = 0\nfor i in range(10):\n    rez = max(rez, n | n >> i)\nprint(bin(rez)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "n = int(input())\ns = int(input(), 2)\nt = s\nans = 0\nfor i in range(20):\n    ans = max(ans, s | s >> i)\nans = bin(ans)\nans = ans[2:]\nprint(ans)", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "n = int(input())\ns = input()\nb = int(s, 2)\na = b\nmx = a | b\nfor i in range(0, 30):\n    a = a >> 1\n    m = a | b\n    if m > mx:\n        mx = m\nst = format(mx, 'b')\nprint(st)", "n = int(input())\ns = input()\nb = int(s, 2)\na = b\nmx = a | b\nfor i in range(0, 10):\n    a = a >> 1\n    m = a | b\n    if m > mx:\n        mx = m\nst = format(mx, 'b')\nprint(st)", "n = int(input())\na = int(input(), 2)\ntemp = a\nmx = a | temp\nfor i in range(7):\n    temp = temp >> 1\n    m = a | temp\n    if mx < m:\n        mx = m\nprint(bin(mx).replace('0b', ''))", "input()\nK = int(input(), 2)\nm = K\nfor i in range(1, 9):\n    m = max(m, K | K >> i)\nprint(bin(m)[2:])", "input()\nnv = int(input(), 2)\nm = nv\nfor i in range(1, 9):\n    m = max(m, nv | nv >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "n = input()\ns = x = int(input(), 2)\nfor i in range(8):\n    x = max(x, s | s >> i)\nprint(bin(x)[2:])", "n = int(input())\ns = input()\nif s.count('0') == n:\n    print('0')\nelif s.count('1') == n:\n    print(s)\nelse:\n    s = s.lstrip('0')\n    n = len(s)\n    a = int(s, 2)\n    p = s.index('0')\n    k = n - p\n    ans = 0\n    for i in range(n - k):\n        sk = s[i:i + k]\n        b = int(sk, 2)\n        ans = max(a | b, ans)\n    ans = bin(ans)\n    ans = ans[2:]\n    ans = ans.lstrip('0')\n    print(ans)", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 50):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 26):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 15):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nK = int(input(), 2)\nm = K\nfor i in range(1, 9):\n    m = max(m, K | K >> i)\nprint(bin(m)[2:])", "n = int(input())\ns = input()\nb = int(s, 2)\na = b\nmx = a | b\nfor i in range(0, 30):\n    a = a >> 1\n    m = a | b\n    if m > mx:\n        mx = m\nst = format(mx, 'b')\nprint(st)", "n = int(input())\ns = input()\nb = int(s, 2)\na = b\nmx = a | b\nfor i in range(0, 20):\n    a = a >> 1\n    m = a | b\n    if m > mx:\n        mx = m\nst = format(mx, 'b')\nprint(st)", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "from sys import exit\nn = int(input())\ns = input()\nf1 = s.find('1')\nif f1 == -1:\n    print(0)\n    exit()\nln = 0\nfor i in range(f1, n):\n    if s[i] == '1':\n        ln += 1\n    else:\n        break\nsb = int(s, 2)\nres = sb\nfor i in range(ln):\n    res = max(res, sb | int(s[:-(i + 1)], 2))\nprint(bin(res)[2:])", "l = int(input())\nn = int(input(), 2)\nm = n\nfor i in range(1, 50):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nmaks = n\nfor i in range(1, 20):\n    maks = max(maks, n | n >> i)\nprint(bin(maks)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "len_1 = int(input())\nstr_1 = input()\nmsb = -1\nflag = 0\nfor t in range(len_1):\n    if str_1[t] == '0':\n        msb = t\n        if flag == 1:\n            break\n    if str_1[t] == '1':\n        flag = 1\nseg_len = len_1 - msb\nlst_val = []\nu = 0\nwhile seg_len + u <= len_1:\n    lst_val.append(int(str_1[u:seg_len + u], 2))\n    u += 1\nval = int(str_1, 2)\nmax = val\nfor t in lst_val:\n    if val | t > max:\n        max = t | val\nbin_2 = bin(max)\nprint(bin_2[2:])", "input()\nash = int(input(), 2)\nm = ash\nfor i in range(1, 100):\n    m = max(m, ash | ash >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 8):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "l = int(input())\nn = int(input(), 2)\nm = n\nfor i in range(1, 9):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    S = input().strip()\n    if S == '1' * n:\n        return S\n    elif S == '0' * n:\n        return '0'\n    m = st1 = 0\n    ans = 0\n    for i in range(n - 1):\n        if st1 == 0 and S[i] == '1':\n            st1 = S[i:]\n            st1 = int(st1, 2)\n        if S[i] == '1' and S[i + 1] == '0':\n            k = n - (i + 1)\n            for j in range(i, -1, -1):\n                if S[j] == '0':\n                    continue\n                st2 = S[j:]\n                st2 = st2[:k]\n                ans = max(ans, st1 | int(st2, 2))\n            return bin(ans)[2:]\nprint(solve())", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "len_1 = int(input())\nstr_1 = input()\nmsb = -1\nflag = 0\nfor t in range(len_1):\n    if str_1[t] == '0':\n        msb = t\n        if flag == 1:\n            break\n    if str_1[t] == '1':\n        flag = 1\nseg_len = len_1 - msb\nlst_val = []\nu = 1\nval_2 = int(str_1[u - 1:seg_len], 2)\nstore = 2 ** seg_len\nlst_val.append(val_2)\nwhile seg_len + u <= len_1:\n    val_2 = 2 * val_2 - int(str_1[u - 1]) * store + int(str_1[seg_len + u - 1])\n    lst_val.append(val_2)\n    u += 1\nval = int(str_1, 2)\nmax = val\nfor t in lst_val:\n    if val | t > max:\n        max = t | val\nbin_2 = bin(max)\nprint(bin_2[2:])", "def valOf(inp):\n    return int(inp, base=2)\n\ndef mainFunc():\n    n = int(input())\n    s = input()\n    s = s.lstrip('0')\n    if not s:\n        print(0)\n        return\n    zeroPos = -1\n    for (index, value) in enumerate(s):\n        if value == '0':\n            zeroPos = index\n            break\n    if zeroPos == -1:\n        print(s)\n        return\n    expectedS2Size = len(s) - zeroPos\n    maxOrPossible = valOf(s)\n    for i in range(0, len(s) - expectedS2Size):\n        maxOrPossible = max(maxOrPossible, valOf(s[i:i + expectedS2Size]) | valOf(s))\n    print(bin(maxOrPossible).replace('0b', ''))\n    return\nt = 1\nfor testcase in range(t):\n    mainFunc()", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 101):\n    m = max(m, n | n >> i)\nprint(bin(m)[2:])", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 100):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "import math\nn = int(input())\ns = input()\nans = int(s, 2)\nfor i in range(1, 11):\n    ps = s[0:n - i]\n    if len(ps) == 0:\n        break\n    pans = int(ps, 2) | int(s, 2)\n    ans = max(ans, pans)\nprint(bin(ans)[2:])", "from sys import stdin, stdout\n\ndef ss(n, s):\n    if s.count('0') == n:\n        return '0'\n    y = int(s, 2)\n    s = bin(y)[2:]\n    l = ''\n    if y == 0:\n        return '0'\n    for t in range(len(s)):\n        i = s[t]\n        if i == '0':\n            l += '1'\n        elif l != '':\n            l += '0'\n    mx = 0\n    m = len(l)\n    if l:\n        for j in range(n - m):\n            mx = max(mx, y | int(s[j:j + m], 2))\n    else:\n        mx = y or int(s[-1], 2)\n    return bin(mx)[2:]\nn = int(input())\ns = input()\nprint(ss(n, s))", "input()\nn = int(input(), 2)\nm = n\nfor i in range(1, 1000):\n    m = max(m, n | n >> i)\nprint('{0:b}'.format(m))", "import sys\nfrom collections import *\nsys.setrecursionlimit(10 ** 5)\nitr = (line for line in sys.stdin.read().strip().split('\\n'))\nINP = lambda : next(itr)\n\ndef ni():\n    return int(INP())\n\ndef nl():\n    return [int(_) for _ in INP().split()]\nn = ni()\na = INP()\nif a.count('1') == 0:\n    print(0)\nelse:\n    f = False\n    f0 = False\n    first = 0\n    f0i = 0\n    for i in range(n):\n        if a[i] == '1':\n            if not f:\n                f = True\n                first = i\n        if f:\n            if a[i] == '0':\n                if not f0:\n                    f0 = True\n                    f0i = i\n    l = n - f0i\n    org = int(a[first:], 2)\n    best = int(a[first:], 2)\n    for i in range(n - l + 1):\n        best = max(best, org | int(a[i:i + l], 2))\n    print(bin(best)[2:])", "n = int(input())\ns = input()\ny = int(s, 2)\ns = bin(y)[2:]\nl = ''\nif y == 0:\n    print('0')\nelse:\n    for i in s:\n        if i == '0':\n            l += '1'\n        elif l != '':\n            l += '0'\n    mx = 0\n    m = len(l)\n    if m == 0:\n        mx = y or int(s[-1], 2)\n    else:\n        for j in range(n - m):\n            mx = max(mx, y | int(s[j:j + m], 2))\n    print(bin(mx)[2:])", "n = int(input())\ns = input()\ns = list(s)\ni = 0\nwhile s[i] == '0':\n    i += 1\n    if i == n:\n        break\nif i == n:\n    print(0)\nelse:\n    s = s[i:]\n    n = len(s)\n    ans = [i for i in s]\n    i = 0\n    o = 0\n    while s[i] == '1':\n        o += 1\n        i += 1\n    if o == 0:\n        print('0')\n    else:\n        ones = [j for j in range(1, o + 1)]\n        while i < n and len(ones) > 0:\n            if s[i] == '0':\n                tmp = []\n                for j in ones:\n                    if s[i - j] == '1':\n                        tmp.append(j)\n                if len(tmp) > 0:\n                    ans[i] = '1'\n                    ones = tmp\n            i += 1\n        anss = ''\n        for i in ans:\n            anss += i\n        print(anss)", "n = int(input())\ns = input()\ni = s.find('1')\nif i == -1:\n    print(0)\nelse:\n    s1 = s[i:]\n    j = s1.find('0')\n    if j == -1:\n        print(s1)\n    else:\n        s2 = s1[j:]\n        s3 = s1[:j] + ''.join((str(int(a) or int(b)) for (a, b) in zip(s1, s2)))\n        s2 = s1[1:]\n        s4 = s1[:1] + ''.join((str(int(a) or int(b)) for (a, b) in zip(s1, s2)))\n        print(max(s3, s4))", "import itertools\nfrom math import floor, log, log2, ceil, sqrt\nfrom itertools import groupby\nfrom decimal import Decimal, getcontext\nfrom posixpath import split\nimport sys\nfrom collections import deque\nprimes = set()\nmaxN = 1000001\n\ndef generatePrimes():\n    used = [False] * maxN\n    for i in range(2, maxN):\n        if not used[i]:\n            primes.add(i)\n            for j in range(i, maxN, i):\n                used[j] = True\n\ndef isPrime(n):\n    if n < 2:\n        return True\n    x = 2\n    while x * x <= n:\n        if n % x == 0:\n            return False\n        x += 1\n    return True\n\ndef gcd(x, y):\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\n\ndef solve():\n    n = int(input())\n    s = input()\n    index = 0\n    while index < n and s[index] == '0':\n        index += 1\n    if index == n:\n        print(0)\n        return\n    s = s[index:]\n    n -= index\n    k = 0\n    while k < n and s[k] == '1':\n        k += 1\n    if k == n:\n        print(s)\n        return\n    res = s\n    for i in range(k):\n        temp = list(s)\n        for j in range(k, n):\n            if temp[j] == '0':\n                temp[j] = '1' if s[j - k + i] == '1' else '0'\n        res = max(res, ''.join(temp))\n    print(res)\nsolve()", "n = int(input())\nbinary = input()\nbinary = binary.lstrip('0')\nn = len(binary)\np_zero = []\np_one = []\nfor i in range(n):\n    if binary[i] == '0':\n        p_zero.append(i)\n    else:\n        p_one.append(i)\nif len(p_one) == 0:\n    print(0)\nelif len(p_zero) == 0:\n    print(binary)\nelse:\n    size = n - p_zero[0]\n    max_sub = ''\n    seq = ''\n    for i in p_one:\n        if n - i < size:\n            break\n        sub = binary[i:i + size]\n        if i == p_one[0]:\n            for j in p_zero:\n                if sub[j - p_zero[0]] == '1':\n                    seq += '1'\n                else:\n                    seq += '0'\n            max_sub = sub\n        else:\n            p = 0\n            c_seq = ''\n            flag = True\n            for j in p_zero:\n                if sub[j - p_zero[0]] == '1':\n                    c_seq += '1'\n                else:\n                    c_seq += '0'\n                if seq[p] < c_seq[-1]:\n                    break\n                if seq[p] > c_seq[-1]:\n                    flag = False\n                    break\n                p += 1\n            if flag:\n                seq = c_seq\n                max_sub = sub\n    max_sub = '0' * (n - size) + max_sub\n    for i in range(n):\n        print('1' if binary[i] == '1' or max_sub[i] == '1' else '0', end='')\n    print()", "def sor(s1: str, s2: str):\n    a1 = list(max(s1, s2))\n    a2 = min(s1, s2)\n    for i in range(len(a2)):\n        if a2[i] == '1':\n            a1[len(a1) - len(a2) + i] = '1'\n    return ''.join(a1).lstrip('0')\nn = int(input())\ns = input().lstrip('0')\nn = len(s)\nans = '0'\na1 = s.find('1')\nif a1 != -1:\n    a2 = s.find('0')\n    if a2 != -1:\n        for i in range(a1, a2):\n            l = n - a2\n            s2 = s[i:i + l]\n            ans = max(ans, sor(s, s2))\nprint(ans)", "import sys\nimport threading\nfrom functools import lru_cache\nfrom bisect import bisect_left\nfrom collections import defaultdict, deque\nfrom heapq import *\n\ndef main():\n    n = int(input())\n    s = input()\n    s = list(s)\n    while s and s[0] == '0':\n        del s[0]\n    ans = [i for i in s]\n    firstZero = -1\n    firstOne = -1\n    for index in range(len(s)):\n        if s[index] == '1' and firstOne == -1:\n            firstOne = index\n        if s[index] == '0' and firstZero == -1:\n            firstZero = index\n    if firstOne == -1 or firstZero == -1:\n        print(''.join(ans) if ans else '0')\n        exit(0)\n    for index in range(0, firstZero):\n        curr = list(s[:firstZero])\n        current_index = index\n        for j in range(firstZero, len(s)):\n            if s[current_index] == '1':\n                curr.append('1')\n            else:\n                curr.append(s[j])\n            current_index += 1\n        rep = False\n        for m in range(len(s)):\n            if curr[m] == '1' and ans[m] == '0':\n                rep = True\n                break\n            if curr[m] == '0' and ans[m] == '1':\n                break\n        if rep:\n            ans = curr\n    print(''.join(ans))\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "n = int(input())\ns = input()\nind = []\nindex = 0\nflag = 0\nlen_index = 0\ned = 0\nfor i in range(n):\n    if flag:\n        index += 1\n    if s[i] == '1':\n        ed = 1\n    if s[i] == '0' and ed != 0:\n        ind.append(index)\n        flag = 1\n        len_index += 1\nif flag == 0:\n    print(0)\n    exit(0)\nln = index\nmx_s = ''\nfor i in range(ln, n):\n    new_s = ''\n    for j in ind:\n        new_s += s[i - (ln - j)]\n    if new_s > mx_s:\n        mx_s = new_s\nans = ['0'] * (ln + 1)\nfor i in range(len_index):\n    ans[ind[i]] = mx_s[i]\nans = ''.join(ans)\nans = int(ans, 2) | int(s, 2)\nprint(bin(ans)[2:])", "n = int(input())\nss = input()\n\ndef cal(s):\n    if '1' not in s:\n        return '0'\n    s = s[s.index('1'):]\n    if '0' not in s:\n        return s[:-1] + '0'\n    t = s[s.index('0'):]\n    k = len(t)\n    re = t\n    for i in range(len(s) - k + 1):\n        if s[i] != '1':\n            continue\n        p = s[i:i + k]\n        c = [max(p[j], t[j]) for j in range(k)]\n        ck = ''.join(c)\n        if ck == '1' * k:\n            return '1' * len(s)\n        re = max(re, ck)\n    return s[:-k] + re\nprint(cal(ss))", "n = int(input())\ns = [int(x) for x in list(input())]\nif sum(s) == 0:\n    print(0)\nelse:\n    leadingOnes = 0\n    s1 = []\n    stop = False\n    for i in range(n):\n        if not stop:\n            if s[i] == 1:\n                leadingOnes += 1\n            if s[i] == 0 and leadingOnes > 0:\n                stop = True\n        if leadingOnes > 0:\n            s1.append(s[i])\n    best = s1\n    for i in range(leadingOnes + 1):\n        s2 = [0 for _ in range(i + 1)] + s1[:len(s1) - i + 1]\n        isBetter = False\n        new = []\n        for i in range(len(s1)):\n            if not (s2[i] == 1 or s1[i] == 1) and (best[i] == 1 or s1[i] == 1) and (not isBetter):\n                break\n            if s2[i] == 1 or s1[i] == 1:\n                if best[i] == 0:\n                    isBetter = True\n                new.append(1)\n            else:\n                new.append(0)\n        if isBetter:\n            best = new\n    print(''.join(map(str, best)))", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nimport heapq\nrd = lambda : map(lambda s: int(s), input().strip().split())\nrdone = lambda : map(lambda s: int(s) - 1, input().strip().split())\nri = lambda : int(input())\nrs = lambda : input().strip()\nfrom collections import defaultdict as unsafedict, deque, Counter as unsafecounter\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom random import randint\nfrom math import gcd, floor, log2, factorial, radians, sin, cos, ceil\nn = ri()\ns = rs()\nz = []\no = []\nfor i in range(len(s)):\n    if s[i] == '0':\n        z.append(i)\n    else:\n        o.append(i)\nr = []\nval = -1\nfor i in z:\n    if o and o[0] < i:\n        while o and o[0] < i:\n            r.append(o.pop(0))\n        val = i\n        break\nif val == -1:\n    s = s.lstrip('0')\n    if s == '':\n        s = '0'\n    print(s)\n    exit()\nl = n - val\npp = []\nmx = s\nfor i in r:\n    res = s[i:i + l]\n    st = list(s)\n    base = 0\n    for ind in range(val, n):\n        if s[ind] == '0' and res[base] == '1':\n            st[ind] = '1'\n        base += 1\n    mx = max(mx, ''.join(st))\nprint(mx.lstrip('0'))", "def main():\n    n = int(input())\n    s = list(input())\n    i = 0\n    while i < n and s[i] == '0':\n        i += 1\n    if i == n:\n        s = '0'\n    else:\n        s = s[i:]\n    n = len(s)\n    pos = -1\n    for i in range(n):\n        if s[i] == '0':\n            pos = i\n            break\n    if pos == -1:\n        print(''.join(s))\n        return\n    if pos == 0:\n        print(0)\n        return\n    ans = []\n    for i in range(pos):\n        t = s[i:i + (n - pos)]\n        (j, k) = (len(s) - 1, len(t) - 1)\n        res = []\n        while j >= 0 and k >= 0:\n            res.append('1' if s[j] == '1' or t[k] == '1' else '0')\n            j -= 1\n            k -= 1\n        while j >= 0:\n            res.append(s[j])\n            j -= 1\n        res.reverse()\n        ans.append(''.join(res))\n    ans.sort(reverse=True)\n    i = 0\n    while i < n and ans[0][i] == '0':\n        i += 1\n    if i == n:\n        print(0)\n        return\n    print(ans[0][i:])\nmain()", "from copy import deepcopy\nn = int(input())\ns = input()\nfirst_one = 0\nwhile first_one < n and s[first_one] == '0':\n    first_one += 1\ns = s[first_one:]\nn -= first_one\ncnt_of_ones = 0\nwhile cnt_of_ones < n and s[cnt_of_ones] != '0':\n    cnt_of_ones += 1\ns_max = ''\nfor i in range(cnt_of_ones + 1):\n    s_ = ''\n    si = ''\n    for j in range(i):\n        s_ += '0'\n    s_ += s[0:n - i]\n    for j in range(n):\n        if s[j] == '1' or s_[j] == '1':\n            si += '1'\n        else:\n            si += '0'\n    s_max = max(s_max, si)\nif s_max != '':\n    print(s_max)\nelse:\n    print('0')", "def getStr(i, k):\n    ans = ''\n    while i < n:\n        if s[i] == '1' or s[k] == '1':\n            ans += '1'\n        else:\n            ans += '0'\n        i += 1\n        k += 1\n    return ans\nn = int(input())\ns = input()\ni = 0\nwhile i < n and s[i] == '0':\n    i += 1\nif i == n:\n    print(0)\n    exit()\nj = i\nwhile i < n and s[i] == '1':\n    i += 1\nans = '0' * (n - i - j)\nfor k in range(i, j - 1, -1):\n    t = getStr(i, k)\n    ans = max(ans, t)\nprint(s[j:i] + ans)", "def getStr(i, k):\n    ans = ''\n    while i < n:\n        if s[i] == '1' or s[k] == '1':\n            ans += '1'\n        else:\n            ans += '0'\n        i += 1\n        k += 1\n    return ans\nn = int(input())\ns = input()\ni = 0\nwhile i < n and s[i] == '0':\n    i += 1\nif i == n:\n    print(0)\n    exit()\nj = i\nwhile i < n and s[i] == '1':\n    i += 1\nans = '0' * (n - i - j)\nfor k in range(i, j - 1, -1):\n    t = getStr(i, k)\n    ans = max(ans, t)\nprint(s[j:i] + ans)", "def solve1(n, o, s):\n    p = ''\n    flag = False\n    for i in range(0, n):\n        if s[i] == '1' or flag:\n            flag = True\n            p += s[i]\n    if len(p) == 0:\n        print(0)\n        exit(0)\n    s = p\n    n = len(s)\n    p = ''\n    for i in range(2, n + 1):\n        x = n - o + 1\n        y = n - i + 1\n        for j in range(min(x, y), n + 1):\n            if s[j - 1] == '0':\n                if j >= x:\n                    a = s[j - x] == '1'\n                else:\n                    a = 0\n                if j >= y:\n                    b = s[j - y] == '1'\n                else:\n                    b = 0\n                if a < b:\n                    o = i\n                if a != b:\n                    break\n    for i in range(1, n + 1):\n        p += str(((i >= n - o + 1 and s[i - n + o - 1] == '1') | int(s[i - 1]) - 48) + 48)\n    print(p)\n(n, o) = [int(input()), 1]\ns = input()\nsolve1(n, o, s)\nwhile None:\n    pass\nwhile 1:\n    break", "import sys\ninput = sys.stdin.readline\n\ndef pobit(s, s2):\n    i = len(s) - 1\n    l = len(s2) - 1\n    ans = []\n    while l >= 0:\n        if s[i] == '1' or s2[l] == '1':\n            ans.append('1')\n        else:\n            ans.append('0')\n        i -= 1\n        l -= 1\n    while i >= 0:\n        ans.append(str(s[i]))\n        i -= 1\n    stroka = ''\n    i = len(s) - 1\n    while ans[i] == '0':\n        i -= 1\n        if i == 0:\n            break\n    while i >= 0:\n        stroka += ans[i]\n        i -= 1\n    return stroka\n\ndef solve():\n    n = int(input())\n    s = input()\n    s = s[0:n]\n    x = 0\n    i = 0\n    while s[i] == '0':\n        i += 1\n        if i == n:\n            return '0'\n    while i < n:\n        if s[i] == '1':\n            x += 1\n        else:\n            break\n        i += 1\n    ans = '0'\n    for i in range(n - x, n):\n        y = pobit(s, s[0:i])\n        if y > ans:\n            ans = y\n    return ans\nans = solve()\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\ndef pobit(S, S1):\n    i = len(S) - 1\n    l = len(S1) - 1\n    answer = []\n    while l >= 0:\n        if S[i] == '1' or S1[l] == '1':\n            answer.append('1')\n        else:\n            answer.append('0')\n        i -= 1\n        l -= 1\n    while i >= 0:\n        answer.append(str(S[i]))\n        i -= 1\n    stroka = ''\n    i = len(S) - 1\n    while answer[i] == '0':\n        i -= 1\n        if i == 0:\n            break\n    while i >= 0:\n        stroka += answer[i]\n        i -= 1\n    return stroka\n\ndef solve():\n    n = int(input())\n    S = input()\n    S = S[0:n]\n    x = 0\n    i = 0\n    while S[i] == '0':\n        i += 1\n        if i == n:\n            return '0'\n    while i < n:\n        if S[i] == '1':\n            x += 1\n        else:\n            break\n        i += 1\n    answer = '0'\n    for i in range(n - x, n):\n        y = pobit(S, S[0:i])\n        if y > answer:\n            answer = y\n    return answer\nanswer = solve()\nprint(answer)", "def update(s, i, j, n, mx):\n    while j >= i:\n        s[n - 1] |= s[j]\n        j -= 1\n        n -= 1\n    mx = max(mx, s)\n    return mx\n\ndef solve():\n    n = int(input())\n    s = input().strip()\n    s = [int(el) for el in s]\n    i = 0\n    while i < n and s[i] == 0:\n        i += 1\n    if i == n:\n        print(0)\n        return\n    s = s[i:]\n    n = len(s)\n    i = 0\n    while i < n and s[i] == 1:\n        i += 1\n    if i == n:\n        print(*s, sep='')\n        return\n    nt = n - i\n    i = 0\n    mx = [0] * nt\n    while i + nt <= n:\n        j = i + nt - 1\n        mx = update(s.copy(), i, j, n, mx)\n        i += 1\n    i = 0\n    while i < len(mx) - 1 and mx[i] == 0:\n        i += 1\n    print(*mx[i:], sep='')\nsolve()", "def solve1(n, o, s):\n    p = ''\n    flag = False\n    for i in range(0, n):\n        if s[i] == '1' or flag:\n            flag = True\n            p += s[i]\n    if len(p) == 0:\n        print(0)\n        exit(0)\n    s = p\n    n = len(s)\n    p = ''\n    for i in range(2, n + 1):\n        x = n - o + 1\n        y = n - i + 1\n        for j in range(min(x, y), n + 1):\n            if s[j - 1] == '0':\n                if j >= x:\n                    a = s[j - x] == '1'\n                else:\n                    a = 0\n                if j >= y:\n                    b = s[j - y] == '1'\n                else:\n                    b = 0\n                if a < b:\n                    o = i\n                if a != b:\n                    break\n    for i in range(1, n + 1):\n        p += str(((i >= n - o + 1 and s[i - n + o - 1] == '1') | int(s[i - 1]) - 48) + 48)\n    print(p)\n(n, o) = [int(input()), 1]\ns = input()\nsolve1(n, o, s)\nwhile None:\n    pass\nwhile 1:\n    break", "import sys\ninput = sys.stdin.readline\n\ndef pobit(S, S1):\n    i = len(S) - 1\n    l = len(S1) - 1\n    answers = []\n    while l >= 0:\n        if S[i] == '1' or S1[l] == '1':\n            answers.append('1')\n        else:\n            answers.append('0')\n        i -= 1\n        l -= 1\n    while i >= 0:\n        answers.append(str(S[i]))\n        i -= 1\n    stroka = ''\n    i = len(S) - 1\n    while answers[i] == '0':\n        i -= 1\n        if i == 0:\n            break\n    while i >= 0:\n        stroka += answers[i]\n        i -= 1\n    return stroka\n\ndef solve():\n    n = int(input())\n    S = input()\n    S = S[0:n]\n    x = 0\n    i = 0\n    while S[i] == '0':\n        i += 1\n        if i == n:\n            return '0'\n    while i < n:\n        if S[i] == '1':\n            x += 1\n        else:\n            break\n        i += 1\n    answers = '0'\n    for i in range(n - x, n):\n        y = pobit(S, S[0:i])\n        if y > answers:\n            answers = y\n    return answers\nanswers = solve()\nprint(answers)", "import sys\ninput = sys.stdin.readline\n\ndef pobit(s, s2):\n    i = len(s) - 1\n    l = len(s2) - 1\n    ans = []\n    while l >= 0:\n        if s[i] == '1' or s2[l] == '1':\n            ans.append('1')\n        else:\n            ans.append('0')\n        i -= 1\n        l -= 1\n    while i >= 0:\n        ans.append(str(s[i]))\n        i -= 1\n    stroka = ''\n    i = len(s) - 1\n    while ans[i] == '0':\n        i -= 1\n        if i == 0:\n            break\n    while i >= 0:\n        stroka += ans[i]\n        i -= 1\n    return stroka\n\ndef solve():\n    n = int(input())\n    s = input()\n    s = s[0:n]\n    x = 0\n    i = 0\n    while s[i] == '0':\n        i += 1\n        if i == n:\n            return '0'\n    while i < n:\n        if s[i] == '1':\n            x += 1\n        else:\n            break\n        i += 1\n    ans = '0'\n    for i in range(n - x, n):\n        y = pobit(s, s[0:i])\n        if y > ans:\n            ans = y\n    return ans\nans = solve()\nprint(ans)", "def solve1(n, o, s):\n    p = ''\n    flag = False\n    for i in range(0, n):\n        if s[i] == '1' or flag:\n            flag = True\n            p += s[i]\n    if len(p) == 0:\n        print(0)\n        exit(0)\n    s = p\n    n = len(s)\n    p = ''\n    for i in range(2, n + 1):\n        x = n - o + 1\n        y = n - i + 1\n        for j in range(min(x, y), n + 1):\n            if s[j - 1] == '0':\n                if j >= x:\n                    a = s[j - x] == '1'\n                else:\n                    a = 0\n                if j >= y:\n                    b = s[j - y] == '1'\n                else:\n                    b = 0\n                if a < b:\n                    o = i\n                if a != b:\n                    break\n    for i in range(1, n + 1):\n        p += str(((i >= n - o + 1 and s[i - n + o - 1] == '1') | int(s[i - 1]) - 48) + 48)\n    print(p)\n(n, o) = [int(input()), 1]\ns = input()\nsolve1(n, o, s)\nwhile None:\n    pass\nwhile 1:\n    break", "def solve1(n, o, s):\n    p = ''\n    flag = False\n    for i in range(0, n):\n        if s[i] == '1' or flag:\n            flag = True\n            p += s[i]\n    if len(p) == 0:\n        print(0)\n        exit(0)\n    s = p\n    n = len(s)\n    p = ''\n    for i in range(2, n + 1):\n        x = n - o + 1\n        y = n - i + 1\n        for j in range(min(x, y), n + 1):\n            if s[j - 1] == '0':\n                if j >= x:\n                    a = s[j - x] == '1'\n                else:\n                    a = 0\n                if j >= y:\n                    b = s[j - y] == '1'\n                else:\n                    b = 0\n                if a < b:\n                    o = i\n                if a != b:\n                    break\n    for i in range(1, n + 1):\n        p += str(((i >= n - o + 1 and s[i - n + o - 1] == '1') | int(s[i - 1]) - 48) + 48)\n    print(p)\n(n, o) = [int(input()), 1]\ns = input()\nsolve1(n, o, s)\nwhile None:\n    pass\nwhile 1:\n    break"]