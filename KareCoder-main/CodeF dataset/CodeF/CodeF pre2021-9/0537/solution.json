["import sys\nimport math, bisect, operator\n(inf, m) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\nfor _ in range(I()):\n    (n, q) = neo()\n    A = [0] + Neo()\n    A.sort()\n    pre = list(accumulate(A))\n    d = defaultdict(int)\n    d[sum(A)] += 1\n\n    def hello(i, j):\n        if i == j:\n            d[A[i]] += 1\n            return\n        elif i > j:\n            return\n        k = bisect.bisect_right(A, (A[i] + A[j]) // 2) - 1\n        d[sum(A[i:k + 1])] += 1\n        d[sum(A[k + 1:j + 1])] += 1\n        if k != j:\n            hello(i, k)\n        hello(k + 1, j)\n    hello(1, n)\n    for i in range(q):\n        t = I()\n        if d[t]:\n            print('Yes')\n        else:\n            print('No')", "import sys\nfrom bisect import bisect_right\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nt = int(input())\n\ndef dfs(arr, canset):\n    if len(set(arr)) <= 1:\n        return\n    mid = (min(arr) + max(arr)) // 2\n    midi = bisect_right(arr, mid)\n    l_arr = arr[:midi]\n    canset.add(sum(l_arr))\n    r_arr = arr[midi:]\n    canset.add(sum(r_arr))\n    dfs(l_arr, canset)\n    dfs(r_arr, canset)\n\ndef solve():\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    s = sum(a)\n    can_set = set()\n    can_set.add(s)\n    dfs(a, can_set)\n    for _ in range(q):\n        s = int(input())\n        if s in can_set:\n            print('Yes')\n        else:\n            print('No')\nfor _ in range(t):\n    solve()", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef check(a, mid):\n    d[sum(a)] = 'Yes'\n    for i in range(len(a)):\n        if a[i] > mid:\n            return i\n    return len(a)\n\ndef breaker(a):\n    ele = a[0]\n    for i in a:\n        if i != ele:\n            return True\n    return False\n\ndef answer(a):\n    if breaker(a):\n        mid = (max(a) + min(a)) // 2\n        m = check(a, mid)\n        answer(a[:m])\n        answer(a[m:])\n    else:\n        check(a, 0)\nfor T in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    quaries = []\n    for i in range(q):\n        quaries.append(int(input()))\n    a.sort()\n    d = {}\n    answer(a)\n    for i in quaries:\n        try:\n            print(d[i])\n        except:\n            print('No')", "import bisect\n\ndef sol(a):\n    suma.add(sum(a))\n    mid = (a[0] + a[-1]) // 2\n    i = bisect.bisect(a, mid)\n    if i == len(a):\n        return\n    left = a[:i]\n    right = a[i:]\n    sol(left)\n    sol(right)\nt = int(input())\nfor j in range(t):\n    (n, q) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    suma = set()\n    sol(sorted(a))\n    for i in range(q):\n        s = int(input())\n        if s in suma:\n            print('Yes')\n        else:\n            print('No')", "from bisect import *\n\ndef chidori(arr, l, r, ans, prefix):\n    if l == 0:\n        tot = prefix[r]\n    else:\n        tot = prefix[r] - prefix[l - 1]\n    if tot not in ans:\n        ans[tot] = True\n    if arr[l] == arr[r]:\n        return\n    val = (arr[l] + arr[r]) // 2\n    mid = bisect_right(arr, val)\n    x = chidori(arr, l, mid - 1, ans, prefix)\n    y = chidori(arr, mid, r, ans, prefix)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    tot = sum(a)\n    prefix = [a[0]]\n    for i in range(1, n):\n        prefix.append(prefix[-1] + a[i])\n    ans = {tot: True}\n    chidori(a, 0, n - 1, ans, prefix)\n    for queries in range(q):\n        x = int(input())\n        if x not in ans:\n            print('No')\n        else:\n            print('Yes')", "t = int(input())\nwhile t > 0:\n    t -= 1\n    (n, q) = input().split()\n    (n, q) = (int(n), int(q))\n    ar = [int(op) for op in input().split()]\n    sr = []\n    for i in range(q):\n        sr.append(int(input()))\n    dt = {}\n\n    def fun(ar):\n        if len(ar) == 0:\n            return 0\n        else:\n            avg = int((max(ar) + min(ar)) / 2)\n            la = []\n            ra = []\n            for i in range(len(ar)):\n                if ar[i] > avg:\n                    ra.append(ar[i])\n                else:\n                    la.append(ar[i])\n            ans = 0\n            if not (len(la) == 0 or len(ra) == 0):\n                ans = fun(la) + fun(ra)\n                dt[ans] = 1\n            else:\n                ans = sum(la) + sum(ra)\n            dt[ans] = 1\n            return ans\n    dt[fun(ar)] = 1\n    for i in range(q):\n        if dt.get(sr[i], -1) == 1:\n            print('Yes')\n        else:\n            print('No')", "from bisect import *\n\ndef chidori(arr, l, r, ans):\n    tot = sum(arr[l:r + 1])\n    if tot not in ans:\n        ans[tot] = True\n    if arr[l] == arr[r]:\n        return\n    val = (arr[l] + arr[r]) // 2\n    mid = bisect_right(arr, val)\n    x = chidori(arr, l, mid - 1, ans)\n    y = chidori(arr, mid, r, ans)\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    tot = sum(a)\n    ans = {tot: True}\n    chidori(a, 0, n - 1, ans)\n    for queries in range(q):\n        x = int(input())\n        if x not in ans:\n            print('No')\n        else:\n            print('Yes')", "import copy\nt = int(input())\n\ndef fun(l, r, data, comsum, res):\n    if l == r:\n        res.add(data[l])\n        return\n    if data[l] == data[r]:\n        res.add(comsum[r] - comsum[l] + data[l])\n        return\n    if r == l + 1:\n        res.add(data[l])\n        res.add(data[r])\n        res.add(data[l] + data[r])\n        return\n    mid = (data[l] + data[r]) // 2\n    (l1, r1) = (l, r)\n    m = (r1 + l1) // 2\n    while l1 < r1:\n        if data[m] <= mid:\n            l1 = m + 1\n        elif data[m] > mid:\n            r1 = m\n        m = (r1 + l1) // 2\n    if m - 1 == r:\n        res.add(comsum[r] - comsum[l] + data[l])\n        return\n    res.add(comsum[r] - comsum[l] + data[l])\n    fun(l, m - 1, data, comsum, res)\n    fun(m, r, data, comsum, res)\n    return\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    data = sorted(map(int, input().split()))\n    comsum = copy.copy(data)\n    for i in range(1, n):\n        comsum[i] += comsum[i - 1]\n    res = set()\n    fun(0, n - 1, data, comsum, res)\n    for k in range(q):\n        q = int(input())\n        if q in res:\n            print('Yes')\n        else:\n            print('No')", "sums = {}\n\ndef find_sum(array, begin, end):\n    sums[sum(array[begin:end + 1])] = True\n\ndef process_sums(array, begin, end):\n    find_sum(array, begin, end)\n    mid = (array[begin] + array[end]) // 2\n    pos = None\n    for p in range(begin, end + 1):\n        if array[p] > mid:\n            pos = p - 1\n            break\n    if pos is None or pos == end:\n        return\n    process_sums(array, begin, pos)\n    process_sums(array, pos + 1, end)\n\ndef get_q():\n    return int(input().split()[1])\n\ndef get_numbers():\n    nums = list(map(int, input().split()))\n    nums.sort()\n    return nums\nfor _ in range(int(input())):\n    q = get_q()\n    numbers = get_numbers()\n    sums.clear()\n    process_sums(numbers, 0, len(numbers) - 1)\n    for i in range(q):\n        print('Yes') if int(input()) in sums else print('No')", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    nums = sorted(map(int, input().split()))\n    sp = [0]\n    cur = 0\n    for i in nums:\n        cur += i\n        sp.append(cur)\n    ans = {sp[-1]}\n\n    def run(pl, pr):\n        if pl == pr:\n            ans.add(nums[pl])\n            return\n        mid = (nums[pl] + nums[pr]) // 2\n        (left, right) = (pl, pr + 1)\n        while left < right:\n            mi = (left + right) // 2\n            if nums[mi] <= mid:\n                left = mi + 1\n            else:\n                right = mi\n        ans.add(sp[left] - sp[pl])\n        ans.add(sp[pr + 1] - sp[left])\n        if left == pr + 1 or left == pl:\n            return\n        run(pl, left - 1)\n        run(left, pr)\n    run(0, n - 1)\n    for i in range(m):\n        a = int(input())\n        if a in ans:\n            print('Yes')\n        else:\n            print('No')", "from bisect import bisect_right\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    cumsum = l.copy()\n    for i in range(1, n):\n        cumsum[i] += cumsum[i - 1]\n    possible_sums = set()\n\n    def recurse(nums, sums):\n        if not nums:\n            return\n        possible_sums.add(sums[-1] - (sums[0] - nums[0]))\n        if len(nums) < 2 or nums[0] == nums[-1]:\n            return\n        mid = (nums[0] + nums[-1]) / 2\n        mid_ind = bisect_right(nums, mid)\n        if nums[mid_ind] == mid:\n            mid_ind += 1\n        recurse(nums[:mid_ind], sums[:mid_ind])\n        recurse(nums[mid_ind:], sums[mid_ind:])\n    recurse(l, cumsum)\n    for _ in range(q):\n        p = int(input())\n        print('Yes' if p in possible_sums else 'No')", "import math\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    (n, q) = [int(i) for i in input().split()]\n    arr = [int(i) for i in input().split()]\n    arr.sort()\n    Dict = defaultdict(int)\n\n    def bin_search(l, r, val):\n        while l < r:\n            mid = (l + r + 1) // 2\n            if arr[mid] <= val:\n                l = mid\n            else:\n                r = mid - 1\n        return l\n\n    def split(i, j):\n        Dict[sum(arr[i:j + 1])] += 1\n        if i == j:\n            return\n        if arr[i] == arr[j]:\n            return\n        mid = (arr[i] + arr[j]) // 2\n        ind = bin_search(i, j, mid)\n        split(i, ind)\n        split(ind + 1, j)\n        return\n    split(0, n - 1)\n    for i in range(q):\n        if Dict[int(input())] >= 1:\n            print('Yes')\n        else:\n            print('No')", "import math, sys, bisect\np = []\n\ndef pretty(arr):\n    if arr.count(arr[0]) == len(arr):\n        p.append(sum(arr))\n        return\n    else:\n        arr.sort()\n        mid = math.floor((arr[0] + arr[-1]) / 2)\n        point = bisect.bisect(arr, mid)\n        left = arr[0:point]\n        right = arr[point:]\n        p.append(sum(right))\n        p.append(sum(left))\n        pretty(right)\n        pretty(left)\nt = int(input())\nwhile t != 0:\n    t -= 1\n    (n, q) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    p = []\n    arr.sort()\n    pretty(arr)\n    p.append(sum(arr))\n    p = set(p)\n    while q != 0:\n        q -= 1\n        x = int(input())\n        print('Yes' if x in p else 'No')"]