["from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nn = int(input())\nc = [0 for i in range(n + 1)]\na = [0 for i in range(n + 1)]\ng = [[] for i in range(n + 1)]\n\ndef dfs(x):\n    List = []\n    for i in g[x]:\n        List += dfs(i)\n    if c[x] > len(List):\n        raise ValueError\n    List.insert(c[x], x)\n    return List\nfor i in range(1, n + 1):\n    (pi, ci) = list(map(int, input().split(' ')))\n    c[i] = ci\n    g[pi].append(i)\ntry:\n    ans = dfs(0)\n    print('YES')\n    for i in range(0, n + 1):\n        a[ans[i]] = i\n    for i in range(1, n + 1):\n        print(a[i], end=' ')\nexcept ValueError:\n    print('NO')", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nn = int(input())\nc = [0 for i in range(n + 1)]\na = [0 for i in range(n + 1)]\ng = [[] for i in range(n + 1)]\n\ndef dfs(x):\n    List = []\n    for i in g[x]:\n        List += dfs(i)\n    if c[x] > len(List):\n        raise ValueError\n    List.insert(c[x], x)\n    return List\nfor i in range(1, n + 1):\n    (pi, ci) = list(map(int, input().split(' ')))\n    c[i] = ci\n    g[pi].append(i)\ntry:\n    ans = dfs(0)\n    print('YES')\n    for i in range(0, n + 1):\n        a[ans[i]] = i\n    for i in range(1, n + 1):\n        print(a[i], end=' ')\nexcept ValueError:\n    print('NO')", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nci = [0]\n\ndef solve(x):\n    rst = []\n    for s in graph[x]:\n        rst.extend(solve(s))\n    if len(rst) < ci[x]:\n        raise ValueError\n    rst.insert(ci[x], x)\n    return rst\nfor i in range(1, n + 1):\n    (p, c) = map(int, input().split())\n    graph[p].append(i)\n    ci.append(c)\ntry:\n    ans = solve(graph[0][0])\nexcept ValueError:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(1, n + 1):\n        print(ans.index(i) + 1, end=' ')", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nci = [0]\n\ndef solve(x):\n    rlt = []\n    for v in graph[x]:\n        rlt.extend(solve(v))\n    if len(rlt) < ci[x]:\n        raise ValueError\n    rlt.insert(ci[x], x)\n    return rlt\nfor i in range(1, n + 1):\n    (p, c) = map(int, input().split())\n    graph[p].append(i)\n    ci.append(c)\ntry:\n    ans = solve(graph[0][0])\nexcept ValueError:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(1, n + 1):\n        print(ans.index(i) + 1, end=' ')", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nci = [0]\n\ndef solve(x):\n    rst = []\n    for s in graph[x]:\n        rst.extend(solve(s))\n    if len(rst) < ci[x]:\n        raise ValueError\n    rst.insert(ci[x], x)\n    return rst\nfor i in range(1, n + 1):\n    (p, c) = map(int, input().split())\n    graph[p].append(i)\n    ci.append(c)\ntry:\n    ans = solve(graph[0][0])\nexcept ValueError:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(1, n + 1):\n        print(ans.index(i) + 1, end=' ')", "import sys\nsys.setrecursionlimit(2500)\nfrom collections import defaultdict\nchildren = defaultdict(set)\nnum_bigger = dict()\nans = dict()\nn = int(input())\nroot = None\nfor me in range(1, n + 1):\n    (parent, b) = input().split(' ')\n    (parent, b) = (int(parent), int(b))\n    num_bigger[me] = b\n    if parent == 0:\n        root = me\n    else:\n        children[parent].add(me)\nassert root\n\ndef sorted_of(elem):\n    ret = []\n    for child in children[elem]:\n        ret += sorted_of(child)\n    if num_bigger[elem] <= len(ret):\n        ret.insert(num_bigger[elem], elem)\n    else:\n        print('NO')\n        sys.exit()\n    return ret\ntry:\n    s = sorted_of(root)\nexcept Exception as e:\n    print('exception', str(e))\n    sys.exit()\nfor i in range(n):\n    ans[s[i]] = i + 1\nprint('YES')\nprint(' '.join((str(ans[i]) for i in range(1, n + 1))))", "import sys\nsys.setrecursionlimit(2500)\nfrom collections import defaultdict\nchildren = defaultdict(set)\nnum_bigger = dict()\nans = dict()\nn = int(input())\nroot = None\nfor me in range(1, n + 1):\n    (parent, b) = input().split(' ')\n    (parent, b) = (int(parent), int(b))\n    num_bigger[me] = b\n    if parent == 0:\n        root = me\n    else:\n        children[parent].add(me)\nassert root\n\ndef sorted_of(elem):\n    ret = []\n    for child in children[elem]:\n        ret += sorted_of(child)\n    if num_bigger[elem] <= len(ret):\n        ret.insert(num_bigger[elem], elem)\n    else:\n        print('NO')\n        sys.exit()\n    return ret\ns = sorted_of(root)\nfor i in range(n):\n    ans[s[i]] = i + 1\nprint('YES')\nprint(' '.join((str(ans[i]) for i in range(1, n + 1))))", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nci = [0]\n\ndef solve(x):\n    rlt = []\n    for v in graph[x]:\n        rlt.extend(solve(v))\n    if len(rlt) < ci[x]:\n        raise ValueError\n    rlt.insert(ci[x], x)\n    return rlt\nfor i in range(1, n + 1):\n    (p, c) = map(int, input().split())\n    graph[p].append(i)\n    ci.append(c)\ntry:\n    ans = solve(graph[0][0])\nexcept ValueError:\n    print('NO')\nelse:\n    print('YES')\n    for i in range(1, n + 1):\n        print(ans.index(i) + 1, end=' ')"]