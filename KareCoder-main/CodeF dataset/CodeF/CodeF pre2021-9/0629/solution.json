["import sys\n\ndef load_sys():\n    return sys.stdin.readlines()\n\ndef load_local():\n    with open('input.txt', 'r') as f:\n        input = f.readlines()\n    return input\n\ndef f(n, m, k, edges):\n    edges.sort(key=lambda x: x[-1])\n    UF = {x: x for x in range(1, n + 1)}\n\n    def find(x):\n        if UF[x] != x:\n            UF[x] = find(UF[x])\n        return UF[x]\n\n    def union(x, y):\n        UF[find(y)] = find(x)\n        return\n    edges_cnt = 0\n    ans = 0\n    for (idx, (i, j, w)) in enumerate(edges):\n        if w < k:\n            if find(i) != find(j):\n                union(i, j)\n                edges_cnt += 1\n        else:\n            if edges_cnt >= n - 1:\n                return min(w - k, k - edges[idx - 1][-1])\n            if find(i) != find(j):\n                union(i, j)\n                edges_cnt += 1\n                ans += w - k\n            if edges_cnt >= n - 1:\n                return ans\n    return k - w\ninput = load_sys()\ni = 1\nwhile i < len(input):\n    (n, m, k) = map(int, input[i].split())\n    edges = []\n    for _ in range(m):\n        i += 1\n        (x, y, w) = map(int, input[i].split())\n        edges.append((x, y, w))\n    i += 1\n    print(f(n, m, k, edges))", "import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nimport itertools\nfrom functools import lru_cache\nfrom typing import List\nMAXN = 2 * 10 ** 5 + 5\nparent = [i for i in range(MAXN)]\n\ndef find(u):\n    pu = parent[u]\n    if pu == u:\n        return pu\n    pu = find(pu)\n    parent[u] = pu\n    return pu\n\ndef merge(u, v):\n    (pu, pv) = (find(u), find(v))\n    parent[pu] = pv\n    return pu != pv\n\ndef solve(n, m, k, edges):\n    edges.sort()\n    for i in range(n + 1):\n        parent[i] = i\n    groups = n\n    ans = 0\n    for (i, (s, u, v)) in enumerate(edges):\n        if s <= k:\n            if merge(u, v):\n                groups -= 1\n        else:\n            if groups == 1:\n                return min(k - edges[i - 1][0], s - k)\n            if merge(u, v):\n                groups -= 1\n                ans += s - k\n            if groups == 1:\n                return ans\n    return k - edges[-1][0]\nT = int(input())\nans = []\nfor ti in range(T):\n    (n, m, k) = map(int, input().strip().split())\n    edges = []\n    for _ in range(m):\n        (u, v, s) = map(int, input().split())\n        edges.append((s, u, v))\n    ans.append(solve(n, m, k, edges))\nprint('\\n'.join(map(str, ans)))", "def uf_find(n, p):\n    ufl = []\n    while p[n] != n:\n        ufl.append(n)\n        n = p[n]\n    for i in ufl:\n        p[i] = n\n    return n\n\ndef uf_union(a, b, p, rank):\n    ap = uf_find(a, p)\n    bp = uf_find(b, p)\n    if ap == bp:\n        return True\n    else:\n        if rank[ap] > rank[bp]:\n            p[bp] = ap\n        elif rank[ap] < rank[bp]:\n            p[ap] = bp\n        else:\n            p[bp] = ap\n            rank[ap] += 1\n        return False\nfor loop in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    under = []\n    over = []\n    for i in range(m):\n        (x, y, s) = map(int, input().split())\n        x -= 1\n        y -= 1\n        if s <= k:\n            under.append((s, x, y))\n        else:\n            over.append((s, x, y))\n    under.sort()\n    over.sort()\n    ans = float('inf')\n    cnt = 0\n    p = [i for i in range(n)]\n    rank = [0] * n\n    for (c, x, y) in under:\n        if not uf_union(x, y, p, rank):\n            cnt += 1\n    if cnt == n - 1 and len(under) > 0:\n        ans = min(ans, k - under[-1][0])\n    if cnt != n - 1:\n        tmpsum = 0\n        for (c, x, y) in over:\n            if not uf_union(x, y, p, rank):\n                cnt += 1\n                tmpsum += c - k\n                if cnt == n - 1:\n                    ans = min(ans, tmpsum)\n    elif len(over) > 0:\n        ans = min(ans, over[0][0] - k)\n    print(ans)"]