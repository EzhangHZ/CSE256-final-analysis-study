["import sys\ninput = sys.stdin.readline\nget_int = lambda : int(input().rstrip())\nget_arr = lambda : [int(w) for w in input().split()]\nget_str = lambda : input().rstrip()\n(n, m) = get_arr()\nd = [get_arr() for _ in range(n)]\nmod = 998244353\ninv = 1\nfor t in range(1, n + 1):\n    inv *= pow(t, -1, mod)\n    inv %= mod\nans = 0\nfor j in range(m):\n    arr = sorted((d[i][j] - 1 for i in range(n)))\n    p = 1\n    for k in range(n):\n        val = arr[k] - k\n        if val <= 0:\n            p = 0\n            break\n        p *= val\n    ans += (1 - p * inv) % mod\n    ans %= mod\nprint(ans)", "from math import factorial\nfrom fractions import Fraction\n(n, m) = map(int, input().split())\ndji = [[] for _ in range(m)]\nfor i in range(n):\n    for (j, x) in enumerate(map(int, input().split())):\n        dji[j].append(x)\nout = 0\nfor dj in dji:\n    dj.sort()\n    p = 1\n    for (i, d) in enumerate(dj):\n        if i + 1 >= d:\n            p = 0\n            break\n        p *= d - i - 1\n    out += p\nf = m - Fraction(out, factorial(n))\nprint(f.numerator * pow(f.denominator, -1, 998244353) % 998244353)", "import sys\nimport math\nfrom math import factorial, inf, gcd, sqrt\nfrom heapq import *\nfrom functools import *\nfrom itertools import *\nfrom collections import *\nfrom typing import *\nfrom bisect import *\nimport random\nsys.setrecursionlimit(10 ** 5)\n\ndef rarray():\n    return [int(i) for i in input().split()]\n(n, m) = rarray()\nmod = 998244353\na = [rarray() for i in range(n)]\na = list(zip(*a))\nans = 0\nfac = 1\nfor i in range(1, n + 1):\n    fac = fac * i % mod\nfor i in range(m):\n    c = [0] * (n + 1)\n    for j in a[i]:\n        c[j - 1] += 1\n    s = 0\n    res = 1\n    for j in reversed(range(1, n + 1)):\n        s += c[j]\n        res = res * s % mod\n        s -= 1\n    ans = (ans + fac - res + mod) % mod\nprint(ans * pow(fac, mod - 2, mod) % mod)", "import sys\nfrom sys import stdin\nans = 0\n(n, m) = map(int, stdin.readline().split())\nmod = 998244353\na = [list(map(int, stdin.readline().split())) for i in range(n)]\nfac = 1\nfor i in range(1, n + 1):\n    fac *= i\ninv = pow(fac, mod - 2, mod)\nfor j in range(m):\n    na = [a[i][j] for i in range(n)]\n    na.sort()\n    now = 1\n    able = 0\n    for i in range(n):\n        while len(na) > 0 and na[-1] > n - i:\n            del na[-1]\n            able += 1\n        now *= able\n        able -= 1\n    ans += now * inv\n    ans %= mod\nprint((m - ans) % mod)", "ans = 0\n(n, m) = map(int, input().split())\nmod = 998244353\na = [list(map(int, input().split())) for i in range(n)]\nfac = 1\nfor i in range(1, n + 1):\n    fac *= i\ninv = pow(fac, mod - 2, mod)\nfor j in range(m):\n    na = sorted([a[i][j] for i in range(n)])\n    now = 1\n    able = 0\n    for i in range(n):\n        while len(na) > 0 and na[-1] > n - i:\n            del na[-1]\n            able += 1\n        now *= able\n        able -= 1\n    ans += now * inv\n    ans %= mod\nprint((m - ans) % mod)", "ans = 0\n(n, m) = map(int, input().split())\nmod = 998244353\na = [list(map(int, input().split())) for i in range(n)]\nfac = 1\nfor i in range(1, n + 1):\n    fac *= i\ninv = pow(fac, mod - 2, mod)\nfor j in range(m):\n    na = sorted([a[i][j] for i in range(n)])\n    now = 1\n    able = 0\n    for i in range(n):\n        while len(na) > 0 and na[-1] > n - i:\n            del na[-1]\n            able += 1\n        now *= able\n        able -= 1\n    ans += now * inv\n    ans %= mod\nprint((m - ans) % mod)", "ans = 0\n(n, m) = map(int, input().split())\nmod = 998244353\na = [list(map(int, input().split())) for i in range(n)]\nfac = 1\nfor i in range(1, n + 1):\n    fac *= i\ninv = pow(fac, mod - 2, mod)\nfor j in range(m):\n    na = sorted([a[i][j] for i in range(n)])\n    now = 1\n    able = 0\n    for i in range(n):\n        while len(na) > 0 and na[-1] > n - i:\n            del na[-1]\n            able += 1\n        now *= able\n        able -= 1\n    ans += now * inv\n    ans %= mod\nprint((m - ans) % mod)", "ans = 0\n(n, m) = map(int, input().split())\nmod = 998244353\na = [list(map(int, input().split())) for i in range(n)]\nfac = 1\nfor i in range(1, n + 1):\n    fac *= i\ninv = pow(fac, mod - 2, mod)\nfor j in range(m):\n    na = sorted([a[i][j] for i in range(n)])\n    now = 1\n    able = 0\n    for i in range(n):\n        while len(na) > 0 and na[-1] > n - i:\n            del na[-1]\n            able += 1\n        now *= able\n        able -= 1\n    ans += now * inv\n    ans %= mod\nprint((m - ans) % mod)", "ans = 0\n(n, m) = map(int, input().split())\nmod = 998244353\na = [list(map(int, input().split())) for i in range(n)]\nfac = 1\nfor i in range(1, n + 1):\n    fac *= i\ninv = pow(fac, mod - 2, mod)\nfor j in range(m):\n    na = sorted([a[i][j] for i in range(n)])\n    now = 1\n    able = 0\n    for i in range(n):\n        while len(na) > 0 and na[-1] > n - i:\n            del na[-1]\n            able += 1\n        now *= able\n        able -= 1\n    ans += now * inv\n    ans %= mod\nprint((m - ans) % mod)", "import sys\nimport math\nfrom math import factorial, inf, gcd, sqrt\nfrom heapq import *\nfrom functools import *\nfrom itertools import *\nfrom collections import *\nfrom typing import *\nfrom bisect import *\nimport random\nsys.setrecursionlimit(10 ** 5)\n\ndef rarray():\n    return [int(i) for i in input().split()]\n(n, m) = rarray()\nmod = 998244353\na = [rarray() for i in range(n)]\na = list(zip(*a))\nfac = [[0] * (n + 1) for i in range(n + 1)]\nfac[0][0] = 1\nfor i in range(1, n + 1):\n    fac[i][0] = 1\n    for j in range(1, i + 1):\n        fac[i][j] = fac[i][j - 1] * (i - j + 1) % mod\nans = 0\nfor i in range(m):\n    a[i] = sorted(a[i])\n    j = 0\n    res = 1\n    while j < n:\n        k = j\n        while j < n and a[i][j] == a[i][k]:\n            j += 1\n        t = j - k\n        res = res * fac[a[i][k] - 1 - k][t] % mod\n    ans = (ans + fac[n][n] - res + mod) % mod\nprint(ans * pow(fac[n][n], mod - 2, mod) % mod)", "MOD = 998244353\n\ndef inv_f(x):\n    return pow(x, MOD - 2, MOD)\ninv = [0] * 50\nfor i in range(1, 50):\n    inv[i] = inv_f(i)\n(n, m) = map(int, input().split())\nboard = []\nfor i in range(n):\n    board.append(list(map(int, input().split())))\nout = 0\nfor j in range(m):\n    count = [0] * (n + 1)\n    for i in range(n):\n        count[board[i][j] - 1] += 1\n    p = 0\n    tot = n\n    for i in range(n):\n        tot -= count[~i]\n        pp = tot * inv[n - i] % MOD\n        p = (p + (1 - p) * pp) % MOD\n    out += p\n    out %= MOD\nprint(out)"]