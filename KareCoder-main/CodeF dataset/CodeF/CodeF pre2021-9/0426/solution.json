["n = int(input())\nfirst = []\nlast = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\nfirst.sort()\nlast.sort()\nans = n * n\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "import bisect\nfrom sys import stdin, stdout\nread = lambda : map(int, stdin.readline().split())\nI = lambda : stdin.readline()\n(mins, maxs) = ([], [])\nn = int(I())\nfor _ in range(n):\n    (l, *arr) = read()\n    ascent = False\n    minn = 10 ** 7\n    maxx = -1\n    for i in arr:\n        if minn < i:\n            ascent = True\n        else:\n            minn = i\n        if maxx < i:\n            maxx = i\n    if not ascent:\n        mins.append(minn)\n        maxs.append(maxx)\nmaxs.sort()\nprint(n * n - sum((bisect.bisect_right(maxs, i) for i in mins)))", "import sys\ninput = sys.stdin.readline\nimport bisect\n\ndef main():\n    N = int(input())\n    mi = []\n    ma = []\n    for _ in range(N):\n        l = [int(x) for x in input().split()]\n        ll = l.pop(0)\n        is_asc = False\n        for i in range(ll - 1):\n            if l[i + 1] > l[i]:\n                is_asc = True\n                break\n        if is_asc:\n            ma.append(float('inf'))\n            mi.append(-float('inf'))\n        else:\n            mi.append(min(l))\n            ma.append(max(l))\n    mi.sort()\n    ma.sort()\n    ans = 0\n    for v in mi:\n        x = bisect.bisect_right(ma, v)\n        ans += N - x\n    print(ans)\nmain()", "import bisect\na = []\nb = []\ncount = 0\ns = 0\nn = int(input())\nfor i in range(n):\n    l = list(map(int, input().split()))\n    l = l[1:]\n    if sorted(l, reverse=True) == l:\n        a.append(l[0])\n        b.append(l[-1])\n    else:\n        s += 1\na.sort()\nb.sort()\nfor end in b:\n    ans = bisect.bisect(a, end)\n    count += n - ans\nprint(count + s * n)", "n = int(input())\nfirst = []\nlast = []\nsuc = []\nalready = 0\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\n    else:\n        already += 1\nfirst.sort()\nlast.sort()\nans = n * n\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "from bisect import *\na = []\nb = []\nn = int(input())\nfor _ in range(n):\n    (l, *s) = map(int, input().split())\n    if sorted(s) == s[::-1]:\n        a.append(s[0])\n        b.append(s[-1])\na.sort()\nprint(n * n - sum((bisect(a, x) for x in b)))", "from bisect import *\nl1 = []\nl2 = []\nn = int(input())\nfor _ in range(n):\n    (l, *s) = map(int, input().split())\n    if sorted(s) == s[::-1]:\n        l1.append(s[0])\n        l2.append(s[-1])\nl1.sort()\nprint(n ** 2 - sum((bisect(l1, x) for x in l2)))", "n = int(input())\nmaxi = []\nmini = []\nfor i in range(n):\n    s = list(map(int, input().split()))[1:]\n    if s == sorted(s, key=lambda x: -x):\n        maxi.append(s[0])\n        mini.append(s[-1])\nmini.sort()\nmaxi.sort()\ntotal = n * n\naux = 0\nfor i in range(len(mini)):\n    while aux < len(maxi) and mini[i] >= maxi[aux]:\n        aux += 1\n    total -= aux\nprint(total)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nfor _ in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "n = int(input())\nfirst = []\nlast = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\nfirst.sort()\nlast.sort()\nans = n * n\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "from bisect import *\n(a, b) = ([], [])\nn = int(input())\nfor _ in range(n):\n    (l, *s) = map(int, input().split())\n    if sorted(s) == s[::-1]:\n        a += (s[0],)\n        b += (s[-1],)\na.sort()\nnum = 0\nfor x in b:\n    num += bisect(a, x)\nprint(n * n - num)", "import bisect\nn = int(input())\n(a, b) = ([], [])\nfor _ in range(n):\n    (l, *s) = map(int, input().split())\n    if sorted(s) == s[::-1]:\n        a.append(s[0])\n        b.append(s[-1])\na.sort()\ncount = 0\nfor val in b:\n    count += bisect.bisect(a, val)\nprint(n ** 2 - count)", "n = int(input())\nM = []\nm = []\ngood = 0\nfor i in range(n):\n    (l, *s) = map(int, input().split())\n    if s == sorted(s)[::-1]:\n        M.append(s[0])\n        m.append(s[-1])\n    else:\n        good += 1\nans = good ** 2 + good * (n - good) * 2\nM.sort(reverse=True)\nm.sort(reverse=True)\nc = n - good\np = 0\nfor k in M:\n    while k <= m[p] and c >= 1:\n        c -= 1\n        p += 1\n        if c == 0:\n            break\n    if c == 0:\n        break\n    ans += c\nprint(ans)", "import bisect\nn = int(input())\n(count, k) = (0, 0)\n(p, l) = ([], [])\nfor i in range(n):\n    (m, *a) = map(int, input().split())\n    if sorted(a) == a[::-1]:\n        l.append(a[0])\n        p.append(a[-1])\nl.sort()\nprint(n * n - sum((bisect.bisect(l, x) for x in p)))", "n = int(input())\n(menores, maiores, asc, nasc) = ([], [], 0, 0)\nfor i in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            menores.append(min(s))\n            maiores.append(max(s))\nresposta = asc * asc + 2 * asc * nasc\nmenores.sort()\nmaiores.sort()\ni = 0\nfor x in maiores:\n    while i < nasc and menores[i] < x:\n        i += 1\n    resposta += i\nprint(resposta)", "n = int(input())\n(menores, maiores, asc, nasc) = ([], [], 0, 0)\nfor i in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            menores.append(min(s))\n            maiores.append(max(s))\nresposta = asc * asc + 2 * asc * nasc\nmenores.sort()\nmaiores.sort()\ni = 0\nfor x in maiores:\n    while i < nasc and menores[i] < x:\n        i += 1\n    resposta += i\nprint(resposta)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\nn = int(input())\ns = []\nl = []\nans = n ** 2\nfor i in range(n):\n    a = list(map(int, input().split()))[1:]\n    if sorted(a)[::-1] == a:\n        s.append(min(a))\n        l.append(max(a))\ns.sort()\nl.sort()\nc = 0\nfor i in range(len(s)):\n    while c < len(l) and l[c] <= s[i]:\n        c += 1\n    ans -= c\nprint(ans)", "n = int(input())\nM = []\nm = []\ngood = 0\nfor i in range(n):\n    (l, *s) = map(int, input().split())\n    if s == sorted(s)[::-1]:\n        M.append(s[0])\n        m.append(s[-1])\n    else:\n        good += 1\nans = good ** 2 + good * (n - good) * 2\nM.sort(reverse=True)\nm.sort(reverse=True)\nc = n - good\np = 0\nfor k in M:\n    while k <= m[p] and c >= 1:\n        c -= 1\n        p += 1\n        if c == 0:\n            break\n    if c == 0:\n        break\n    ans += c\nprint(ans)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nfor _ in range(n):\n    s = list(map(int, input().split()))[1:]\n    i = 0\n    while i < len(s):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\n        i += 1\nanswer = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor m in maxi:\n    while i < nasc and mini[i] < m:\n        i += 1\n    answer += i\nprint(answer)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nfor _ in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "from bisect import *\nn = int(input())\n(a, b) = ([], [])\nfor _ in [0] * n:\n    (l, *s) = map(int, input().split())\n    if sorted(s) == s[::-1]:\n        a += (s[0],)\n        b += (s[-1],)\na.sort()\nprint(n * n - sum((bisect(a, x) for x in b)))", "n = int(input())\nfirst = []\nlast = []\nalready = 0\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\nfirst.sort()\nlast.sort()\nans = n * n\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "n = int(input())\nfirst = []\nlast = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\nfirst.sort()\nlast.sort()\nans = n * n\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "n = int(input())\nsmall = []\nlarge = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        small.append(line[0])\n        large.append(line[-1])\nsmall.sort()\nlarge.sort()\nans = n * n\nptr = 0\nfor i in range(len(large)):\n    while ptr < len(small) and large[i] >= small[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "n = int(input())\nsmall = []\nlarge = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        small.append(line[0])\n        large.append(line[-1])\nsmall.sort()\nlarge.sort()\nans = n * n\nptr = 0\nfor i in range(len(large)):\n    while ptr < len(small) and large[i] >= small[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "n = int(input())\ns = []\nl = []\nans = n ** 2\nfor i in range(n):\n    a = list(map(int, input().split()))[1:]\n    if sorted(a)[::-1] == a:\n        s.append(min(a))\n        l.append(max(a))\ns.sort()\nl.sort()\nc = 0\nfor i in range(len(s)):\n    while c < len(l) and l[c] <= s[i]:\n        c += 1\n    ans -= c\nprint(ans)", "import bisect\nn = int(input())\no = n * n\nmi = []\nma = []\nl = []\nfor i in range(n):\n    (m, *q) = [*map(int, input().split())]\n    w = sorted(q, reverse=1)\n    if q == w:\n        mi += [w[-1]]\n        ma += [w[0]]\n        l += [[w[-1], w[0]]]\nmi.sort()\nma.sort()\nr = len(ma)\nfor i in ma:\n    o -= r - bisect.bisect_left(mi, i)\nprint(o)", "num = int(input())\nminimo = []\nmaximo = []\ncresc = 0\ndecr = 0\nfor a in range(num):\n    seq = list(map(int, input().split()))\n    seq.reverse()\n    seq.pop()\n    seq.reverse()\n    for b in range(len(seq)):\n        if b > 0 and seq[b] > seq[b - 1]:\n            cresc += 1\n            break\n        elif b == len(seq) - 1:\n            decr += 1\n            minimo.append(min(seq))\n            maximo.append(max(seq))\nres = cresc * cresc + 2 * (cresc * decr)\nminimo.sort()\nmaximo.sort()\ni = 0\nfor c in maximo:\n    while i < decr and minimo[i] < c:\n        i += 1\n    res += i\nprint(res)", "n = int(input())\n(minimos, maximos) = ([], [])\n(asc, nasc) = (0, 0)\nfor i in range(n):\n    sequencia = list(map(int, input().split(' ')))[1:]\n    for j in range(len(sequencia)):\n        if j > 0 and sequencia[j] > sequencia[j - 1]:\n            asc += 1\n            break\n        elif j == len(sequencia) - 1:\n            nasc += 1\n            minimos.append(min(sequencia))\n            maximos.append(max(sequencia))\ntotal = asc * asc + 2 * asc * nasc\nminimos.sort()\nmaximos.sort()\ni = 0\nfor k in maximos:\n    while i < nasc and minimos[i] < k:\n        i += 1\n    total += i\nprint(total)", "n = int(input())\nL = []\nS = []\ngood = 0\nM = []\nm = []\nfor i in range(n):\n    (l, *s) = map(int, input().split())\n    if s == sorted(s)[::-1]:\n        M.append(s[0])\n        m.append(s[-1])\n    else:\n        good += 1\nans = good ** 2 + good * (n - good) * 2\nM.sort(reverse=True)\nm.sort(reverse=True)\nc = n - good\np = 0\nfor k in M:\n    while k <= m[p] and c >= 1:\n        c -= 1\n        p += 1\n        if c == 0:\n            break\n    if c == 0:\n        break\n    ans += c\nprint(ans)", "import bisect\n\ndef possible(arr):\n    max_val = 0\n    arr.reverse()\n    for i in arr:\n        if i < max_val:\n            return True\n        max_val = max(max_val, i)\n    return False\n\ndef main():\n    n = int(input())\n    min_vals = []\n    max_vals = []\n    pairs = 0\n    already = 0\n    for i in range(n):\n        nums = list(map(int, input().split()))\n        nums.pop(0)\n        min_val = min(nums)\n        max_val = max(nums)\n        if possible(nums):\n            pairs += n\n            already += 1\n        else:\n            min_vals.append(min_val)\n            max_vals.append(max_val)\n    max_vals.sort()\n    for i in min_vals:\n        index = bisect.bisect(max_vals, i)\n        pairs += len(max_vals) - index\n        pairs += already\n    print(pairs)\nmain()", "n = int(input())\nfirst = []\nlast = []\nsuc = []\nalready = 0\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\n    else:\n        already += 1\nfirst.sort()\nlast.sort()\nans = max(0, already * (n - already) * 2 + already * already)\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans += len(first) - ptr\nprint(ans)", "n = int(input())\nfirst = []\nlast = []\nsuc = []\nalready = 0\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        first.append(line[0])\n        last.append(line[-1])\n    else:\n        already += 1\nfirst.sort()\nlast.sort()\nans = n * n\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "n = int(input())\nsmall = []\nlarge = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        small.append(line[0])\n        large.append(line[-1])\nsmall.sort()\nlarge.sort()\nans = n * n\nptr = 0\nfor i in range(len(large)):\n    while ptr < len(small) and large[i] >= small[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "import bisect\nn = int(input())\nfirsts = []\nlasts = []\nans = n ** 2\nfor i in range(n):\n    a = list(map(int, input().split()))\n    is_ascent = False\n    cur_min = a[1]\n    for j in range(2, a[0] + 1):\n        if a[j] > cur_min:\n            is_ascent = True\n            break\n        elif a[j] < cur_min:\n            cur_min = a[j]\n    if not is_ascent:\n        firsts.append(a[1])\n        lasts.append(a[-1])\nfirsts.sort()\nminus = 0\nfor i in lasts:\n    minus += bisect.bisect(firsts, i)\nprint(ans - minus)", "n = int(input())\nsmall = []\nlarge = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        small.append(line[0])\n        large.append(line[-1])\nsmall.sort()\nlarge.sort()\nans = n * n\nptr = 0\nfor i in range(len(large)):\n    while ptr < len(small) and large[i] >= small[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "import bisect\nn = int(input())\ns = []\nl = []\nans = 0\nans = n ** 2\nfor i in range(n):\n    a = list(map(int, input().split()))[1:]\n    if sorted(a)[::-1] == a:\n        s.append(min(a))\n        l.append(max(a))\ns.sort()\nl.sort()\nfor x in s:\n    k = bisect.bisect(l, x)\n    ans -= k\nprint(ans)", "n = int(input())\nminimos = []\nmaximos = []\ntotal = 0\nascent = 0\nnasc = 0\nfor i in range(n):\n    sequencia = list(map(int, input().split()))[1:]\n    for i in range(len(sequencia)):\n        if i > 0 and sequencia[i] > sequencia[i - 1]:\n            ascent += 1\n            break\n        elif i == len(sequencia) - 1:\n            nasc += 1\n            minimos.append(min(sequencia))\n            maximos.append(max(sequencia))\ntotal += ascent ** 2 + 2 * ascent * nasc\nminimos = sorted(minimos)\nmaximos = sorted(maximos)\nmi = 0\nfor maior in maximos:\n    while mi < n - ascent and minimos[mi] < maior:\n        mi += 1\n    total += mi\nprint(int(total))", "n = int(input())\nminimos = []\nmaximos = []\ntotal = 0\nascent = 0\nnasc = 0\nfor i in range(n):\n    sequencia = list(map(int, input().split()))[1:]\n    for i in range(len(sequencia)):\n        if i > 0 and sequencia[i] > sequencia[i - 1]:\n            ascent += 1\n            break\n        elif i == len(sequencia) - 1:\n            nasc += 1\n            minimos.append(min(sequencia))\n            maximos.append(max(sequencia))\ntotal += ascent ** 2 + 2 * ascent * nasc\nminimos = sorted(minimos)\nmaximos = sorted(maximos)\nmi = 0\nfor maior in maximos:\n    while mi < n - ascent and minimos[mi] < maior:\n        mi += 1\n    total += mi\nprint(int(total))", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nwhile n > 0:\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\n    n -= 1\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nwhile n > 0:\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\n    n -= 1\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "num = int(input())\nminimo = []\nmaximo = []\ncresc = 0\ndecr = 0\nfor a in range(num):\n    seq = list(map(int, input().split()))\n    seq.reverse()\n    seq.pop()\n    seq.reverse()\n    for b in range(len(seq)):\n        if b > 0 and seq[b] > seq[b - 1]:\n            cresc += 1\n            break\n        elif b == len(seq) - 1:\n            decr += 1\n            minimo.append(min(seq))\n            maximo.append(max(seq))\nres = cresc * cresc + 2 * (cresc * decr)\nminimo.sort()\nmaximo.sort()\ni = 0\nfor c in maximo:\n    while i < decr and minimo[i] < c:\n        i += 1\n    res += i\nprint(res)", "import bisect\n\ndef ascent(a):\n    n = len(a)\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            return 1\n    return 0\nn = int(input())\na = []\nfirst = []\nlast = []\nfor _ in range(n):\n    arr = [int(i) for i in input().split()]\n    arr = arr[1:]\n    a.append(arr)\n    if not ascent(arr):\n        first.append(arr[0])\n        last.append(arr[-1])\nfirst.sort()\ncount = n ** 2\nfor x in last:\n    count -= bisect.bisect(first, x)\nprint(count)", "n = int(input())\nlarge = []\nsmall = []\nfor i in range(n):\n    line = [int(i) for i in input().split()[1:]]\n    if line == sorted(line, key=lambda x: -x):\n        large.append(line[0])\n        small.append(line[-1])\nsmall.sort()\nlarge.sort()\nans = n * n\nptr = 0\nfor i in range(len(small)):\n    while ptr < len(large) and small[i] >= large[ptr]:\n        ptr += 1\n    ans -= ptr\nprint(ans)", "import io\nfrom bisect import *\nnim = int(input())\n(array1, array2) = ([], [])\nfor _ in [0] * nim:\n    (l, *s) = map(int, input().split())\n    if all((x >= y for (x, y) in zip(s, s[1:]))):\n        array1 += (s[0],)\n        array2 += (s[-1],)\narray1.sort()\nprint(nim * nim - sum((bisect(array1, x) for x in array2)))", "n = int(input())\nmini = []\nmaxi = []\nasc = 0\nnasc = 0\nfor index in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "import bisect as b\nimport sys\ninput = sys.stdin.readline\nn = int(input())\nl = [list(map(int, input().split())) for i in range(n)]\ncl = [False] * n\nocnt = 0\nfor i in range(n):\n    for j in range(l[i][0] - 1):\n        if l[i][j + 1] < l[i][j + 2]:\n            cl[i] = True\n            ocnt += 1\n            break\nM = [max(l[i][1:]) if not cl[i] else -1 for i in range(n)]\nm = [min(l[i][1:]) for i in range(n)]\nM.sort()\nans = 0\nfor i in range(n):\n    if cl[i]:\n        ans += n\n        continue\n    ans += n - b.bisect_right(M, m[i])\nprint(ans + n * ocnt - ocnt ** 2)", "from bisect import bisect_right as bi\nb = []\nc = []\nn = int(input())\nans = n ** 2\nfor _ in range(n):\n    a = list(map(int, input().split()))\n    f = 1\n    for i in range(1, len(a) - 1):\n        if a[i] < a[i + 1]:\n            f = 0\n            break\n    if f or len(a) == 2:\n        b.append(a[1])\n        c.append(a[-1])\nb.sort()\nc.sort()\nfor i in range(len(c)):\n    ans -= bi(b, c[i])\nprint(ans)", "from bisect import bisect\nuna = []\nb = int(input())\nfor ii in range(b):\n    a = [int(j) for j in input().split()]\n    a = a[1:]\n    flag = False\n    for i in range(len(a) - 1):\n        if a[i + 1] > a[i]:\n            flag = True\n            break\n    if flag == False:\n        una.append((a[0], a[-1]))\ncount = 0\nl = []\nchi = []\nfor i in una:\n    l.append(i[0])\n    chi.append(i[1])\nl = sorted(l)\nfor k in chi:\n    count += len(l) - bisect(l, k)\nn = len(una)\nprint(b ** 2 - n ** 2 + count)", "from bisect import *\nn = int(input())\n(f, l) = ([], [])\nk = 0\nfor j in range(n):\n    s = []\n    (t, *s) = list(map(int, input().split()))\n    if s[::-1] == sorted(s):\n        f += [s[0]]\n        l += [s[t - 1]]\nf.sort()\nfor x in l:\n    k += bisect(f, x)\nprint(n * n - k)", "from bisect import bisect_right as bi\nn = int(input())\nmn_a = []\nmx_a = []\nans = n ** 2\nfor i in range(n):\n    inp = list(map(int, input().split()))\n    l = inp[0]\n    ss = inp[1:]\n    not_asc = True\n    for j in range(l - 1):\n        if ss[j] < ss[j + 1]:\n            not_asc = False\n            break\n    if not_asc or l == 1:\n        mn_a.append(ss[-1])\n        mx_a.append(ss[0])\nmn_a.sort()\nmx_a.sort()\nfor i in range(len(mn_a)):\n    ans -= bi(mx_a, mn_a[i])\nprint(ans)", "n = int(input())\nmini = []\nmaxi = []\nasc = 0\nnasc = 0\nfor indice in range(n):\n    s = input().split(' ')[1:]\n    s = [int(x) for x in s]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "import bisect\nn = int(input())\ns = []\nl = []\nans = 0\nans = 0\nn1 = n\nfor i in range(n):\n    a = list(map(int, input().split()))[1:]\n    if sorted(a)[::-1] == a:\n        s.append(min(a))\n        l.append(max(a))\n    else:\n        ans += n1 * 2 - 1\n        n1 -= 1\ns.sort()\nl.sort()\nj = 0\nfor i in range(len(s)):\n    while j < len(l) and s[i] >= l[j]:\n        j += 1\n    ans += len(l) - j\nprint(ans)", "sequencias = int(input())\ncont = 0\ncresc = 0\nncresc = 0\nmaxi = []\nmini = []\nfor x in range(sequencias):\n    sequencia = str(input()).split()\n    s = sequencia[1:]\n    sint = [int(p) for p in s]\n    for y in range(len(sint)):\n        if y > 0 and sint[y] > sint[y - 1]:\n            cresc += 1\n            break\n        elif y == len(sint) - 1:\n            maxi.append(max(sint))\n            mini.append(min(sint))\n            ncresc += 1\ncont = cresc * cresc + cresc * ncresc * 2\nmini.sort()\nmaxi.sort()\nh = 0\nfor g in range(len(maxi)):\n    while h < ncresc and int(mini[h]) < int(maxi[g]):\n        h += 1\n    cont += h\nprint(cont)", "sequencias = int(input())\ncont = 0\ncresc = 0\nncresc = 0\nmaxi = []\nmini = []\nfor x in range(sequencias):\n    sequencia = str(input()).split()\n    s = sequencia[1:]\n    sint = [int(p) for p in s]\n    for y in range(len(sint)):\n        if y > 0 and sint[y] > sint[y - 1]:\n            cresc += 1\n            break\n        elif y == len(sint) - 1:\n            maxi.append(max(sint))\n            mini.append(min(sint))\n            ncresc += 1\ncont = cresc * cresc + cresc * ncresc * 2\nmini.sort()\nmaxi.sort()\nh = 0\nfor g in range(len(maxi)):\n    while h < ncresc and int(mini[h]) < int(maxi[g]):\n        h += 1\n    cont += h\nprint(cont)", "import sys\nfrom collections import deque\nfrom bisect import bisect_right\ninput = sys.stdin.readline\nn = int(input())\nmin_s = deque([])\nmax_s = deque([])\ngood_s = 0\nfor _ in range(n):\n    s = [int(x) for x in input().strip().split()][1:]\n    ss_ = float('inf')\n    isgood = False\n    for ss in s:\n        if ss > ss_:\n            good_s += 1\n            isgood = True\n            break\n        elif ss < ss_:\n            ss_ = ss\n    if isgood:\n        continue\n    min_s.append(min(s))\n    max_s.append(max(s))\nmax_s = sorted(list(max_s))\nans = good_s * n + (n - good_s) * good_s\nlen_bad_s = len(max_s)\nfor (i, s) in enumerate(min_s):\n    ind = bisect_right(max_s, s)\n    ans += len_bad_s - ind\nprint(ans)", "from bisect import *\nn = int(input())\n(a, b) = ([], [])\nfor _ in [0] * n:\n    (l, *s) = map(int, input().split())\n    if all((x >= y for (x, y) in zip(s, s[1:]))):\n        a += (s[0],)\n        b += (s[-1],)\na.sort()\nprint(n * n - sum((bisect(a, x) for x in b)))", "n = int(input())\ns = []\nfor i in range(n):\n    s.append(list(map(int, input().split()))[1:])\nf = sorted([e for e in s if e == sorted(e, reverse=True)], key=lambda x: -x[0])\nl = sorted(f[:], key=lambda x: -x[-1])\nq = ans = 0\nfor e in l:\n    while q < len(f) and e[-1] < f[q][0]:\n        q += 1\n    ans += len(f) - q\nprint(n * n - ans)", "import bisect\na = []\nb = []\ncount = 0\ns = 0\nn = int(input())\nfor i in range(n):\n    l = list(map(int, input().split()))\n    l = l[1:]\n    if sorted(l, reverse=True) == l:\n        a.append(l[0])\n        b.append(l[-1])\n    else:\n        s += 1\na.sort()\nb.sort()\nfor end in b:\n    ans = bisect.bisect(a, end)\n    count += n - ans\nprint(count + s * n)", "from bisect import bisect_right as bi\nb = []\nc = []\nn = int(input())\nans = n ** 2\nfor _ in range(n):\n    a = list(map(int, input().split()))\n    f = 1\n    for i in range(1, len(a) - 1):\n        if a[i] < a[i + 1]:\n            f = 0\n            break\n    if f or len(a) == 2:\n        b.append(a[1])\n        c.append(a[-1])\nb.sort()\nc.sort()\nfor i in range(len(c)):\n    ans -= bi(b, c[i])\nprint(ans)", "import bisect\nn = int(input())\nm = []\nmm = []\nfor i in range(n):\n    x = list(map(int, input().split()))\n    s = x[1:]\n    if sorted(s) == s[::-1]:\n        m.append(s[0])\n        mm.append(s[-1])\nm.sort()\nmm.sort()\nans = 0\nfor i in range(len(m)):\n    j = bisect.bisect_right(m, mm[i])\n    ans = ans + j\nprint(n * n - ans)", "import bisect\nn = int(input())\ns = []\nl = []\nans = 0\nans = 0\nn1 = n\nfor i in range(n):\n    a = list(map(int, input().split()))[1:]\n    if sorted(a)[::-1] == a:\n        s.append(min(a))\n        l.append(max(a))\n    else:\n        ans += n1 * 2 - 1\n        n1 -= 1\ns.sort()\nl.sort()\nfor i in s:\n    j = bisect.bisect(l, i)\n    ans += len(l) - j\nprint(ans)", "n = int(input())\nmx = []\nmn = []\nsize = 0\nfor _ in range(n):\n    l = list(map(int, input().split()))\n    (maxValue, minValue) = (l[1], l[1])\n    flag = True\n    for j in range(1, l[0] + 1):\n        maxValue = max(maxValue, l[j])\n        minValue = min(minValue, l[j])\n        if minValue < l[j]:\n            flag = False\n    if flag:\n        mx.append(maxValue)\n        mn.append(minValue)\n        size += 1\nmx = sorted(mx)\nmn = sorted(mn)\nres = (n * size - size * size) * 2 + (n - size) ** 2\n(i, count) = (0, 0)\nwhile i < size and count < size:\n    if mx[count] <= mn[i]:\n        count += 1\n        res += i\n    else:\n        i += 1\nres += (size - count) * i\nprint(res)", "n = int(input())\nnomin = []\nnomax = []\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    num = temp.pop(0)\n    flag = 1\n    for j in range(num - 1):\n        if temp[j] < temp[j + 1]:\n            flag = 0\n            continue\n    if flag == 1:\n        nomin.append(temp[-1])\n        nomax.append(temp[0])\nnomax.sort()\nwa = 0\nimport bisect\nfor i in nomin:\n    a = bisect.bisect_right(nomax, i)\n    wa += a\nprint(n ** 2 - wa)", "n = int(input())\nm = []\nmm = []\nc = 0\nfor l in range(0, n):\n    line = list(map(int, input().split()))\n    line.pop(0)\n    blool = False\n    for l in range(0, len(line) - 1):\n        if line[l] < line[l + 1]:\n            blool = True\n    if blool:\n        c += 1\n    else:\n        m.append(line[len(line) - 1])\n        mm.append(line[0])\nm.sort()\nmm.sort()\nl = 0\nj = 0\ntotal = 2 * c * (n - c) + c ** 2\nn -= c\nwhile l < n and j < n:\n    if mm[l] > m[j]:\n        j += 1\n    else:\n        total = total + j\n        l += 1\nwhile l < n:\n    total += n\n    l += 1\nprint(total)", "numberSequences = int(input())\n(mini, maxi, numberSequencesWithAscention, numberSequencesWithoutAscention) = ([], [], 0, 0)\nfor i in range(numberSequences):\n    currentSequenceString = input().split()[1:]\n    currentSequence = []\n    for e in currentSequenceString:\n        currentSequence.append(int(e))\n    for j in range(len(currentSequence)):\n        if j > 0 and currentSequence[j] > currentSequence[j - 1]:\n            numberSequencesWithAscention += 1\n            break\n        elif j == len(currentSequence) - 1:\n            numberSequencesWithoutAscention += 1\n            mini.append(min(currentSequence))\n            maxi.append(max(currentSequence))\nanswer = numberSequencesWithAscention * numberSequencesWithAscention + 2 * numberSequencesWithAscention * numberSequencesWithoutAscention\nmini.sort()\nmaxi.sort()\nj = 0\nfor i in range(len(maxi)):\n    while j < numberSequencesWithoutAscention and mini[j] < maxi[i]:\n        j += 1\n    answer += j\nprint(answer)", "n = int(input())\nx = []\ny = []\nk = 0\ng = 0\nfor i in range(n):\n    l = list(map(int, input().split()))[1:]\n    for j in range(len(l)):\n        if j > 0 and l[j] > l[j - 1]:\n            k += 1\n            break\n        elif j == len(l) - 1:\n            g += 1\n            y.append(min(l))\n            x.append(max(l))\ncount = k * k + 2 * k * g\nx.sort()\ny.sort()\nj = 0\nfor k in x:\n    while j < g and y[j] < k:\n        j += 1\n    count += j\nprint(count)", "n = int(input())\nmx = []\nmn = []\nsize = 0\nfor _ in range(n):\n    l = list(map(int, input().split()))\n    (maxValue, minValue) = (l[1], l[1])\n    flag = True\n    for j in range(1, l[0] + 1):\n        maxValue = max(maxValue, l[j])\n        minValue = min(minValue, l[j])\n        if minValue < l[j]:\n            flag = False\n    if flag:\n        mx.append(maxValue)\n        mn.append(minValue)\n        size += 1\nmx = sorted(mx)\nmn = sorted(mn)\nres = (n * size - size * size) * 2 + (n - size) ** 2\n(i, count) = (0, 0)\nwhile i < size and count < size:\n    if mx[count] <= mn[i]:\n        count += 1\n        res += i\n    else:\n        i += 1\nres += (size - count) * i\nprint(res)", "import bisect\nn = int(input())\nminis = []\nmaxis = []\nself_test_cnt = 0\nfor N in range(n):\n    l = list(map(int, input().split()))\n    sz = l[0]\n    curr = l[1:]\n    mini = 987654321\n    maxi = -1\n    self_test = 0\n    for i in curr:\n        if i > maxi:\n            maxi = i\n        if i > mini:\n            self_test = 1\n        if i < mini:\n            mini = i\n    self_test_cnt += self_test\n    if self_test == 0:\n        minis.append(mini)\n        maxis.append(maxi)\nans = 2 * self_test_cnt * (n - self_test_cnt) + self_test_cnt * self_test_cnt\nminis = sorted(minis)\nmaxis = sorted(maxis)\nfor i in maxis:\n    ans += bisect.bisect_left(minis, i)\nprint(ans)", "n = int(input())\ntemp = 0\nfirst = []\nlast = []\nimport bisect\nfor i in range(n):\n    l1 = list(map(int, input().split()))[1:]\n    curr = l1[0]\n    flag = 0\n    for x in l1:\n        if x <= curr:\n            curr = x\n        else:\n            flag = 1\n            break\n    if flag == 1:\n        temp += 1\n    else:\n        first.append(l1[0])\n        last.append(l1[-1])\ncount = 0\nfirst.sort()\nfor item in last:\n    count += len(first) - bisect.bisect_right(first, item)\nprint(count + temp * temp + 2 * len(first) * temp)", "n = int(input())\na = [list(map(int, input().split()))[1:] for _ in range(n)]\ns = sorted([q for q in a if q == sorted(q, reverse=True)], key=lambda x: -x[0])\nd = sorted(s[:], key=lambda x: -x[-1])\nq1 = ans = 0\nfor q in d:\n    while q1 < len(s) and q[-1] < s[q1][0]:\n        q1 += 1\n    ans += len(s) - q1\nprint(n ** 2 - ans)", "def has_inc(l):\n    for i in range(len(l) - 1):\n        if l[i] < l[i + 1]:\n            return True\n    return False\nn = int(input())\n(mins, maxs) = ([], [])\nhas_incr = 0\nfor i in range(n):\n    s = list(map(int, input().split(' ')))[1:]\n    decres = has_inc(s)\n    has_incr += decres\n    if not decres:\n        mins.append(s[-1])\n        maxs.append(s[0])\nmins = sorted(mins)\nmaxs = sorted(maxs)\nleft = 0\nans = 0\nfor elem in maxs:\n    while left < len(maxs) and mins[left] < elem:\n        left += 1\n    ans += left\nprint(ans + (2 * n - has_incr) * has_incr)", "def haveAsc(s):\n    min = s[1]\n    l = s[0]\n    for i in range(2, l + 1):\n        if s[i] > min:\n            return True\n        min = s[i]\n    return False\nn = int(input())\nmins = []\nmaxs = []\nblocks = []\nfree = 0\nfor i in range(n):\n    b = [int(s) for s in input().split()]\n    if haveAsc(b):\n        free += 1\n    else:\n        mins.append(b[-1])\n        maxs.append(b[1])\nnotFree = n - free\nans = free * free + notFree * free * 2\nmins.sort()\nmaxs.sort()\nend = len(mins)\ni = 0\nj = 0\nwhile i < end:\n    if mins[i] >= maxs[j]:\n        if j == end - 1:\n            break\n        j += 1\n    else:\n        ans += end - j\n        i += 1\nprint(ans)", "def check(l):\n    mini = 1000000\n    for i in l:\n        if mini >= i:\n            mini = i\n        else:\n            return 1\n    return 0\nn = int(input())\ncnt = 0\nfmin = []\nfmax = []\nm = n\nfor test in range(n):\n    l = list(map(int, input().split()))\n    if check(l[1:]):\n        cnt = cnt + (2 * (m - 1) + 1)\n        m = m - 1\n    else:\n        fmin.append(min(l[1:]))\n        fmax.append(max(l[1:]))\nfmin.sort()\nfmax.sort()\nr = len(fmin) - 1\nfor i in range(len(fmin) - 1, -1, -1):\n    while r >= 0 and fmin[i] < fmax[r]:\n        r -= 1\n    cnt += len(fmin) - r - 1\nprint(cnt)", "n = int(input())\nlo = []\nhi = []\nfor _ in range(n):\n    l = 1000010000\n    h = -1000010000\n    a = 0\n    for (i, x) in enumerate(map(int, input().split())):\n        if i:\n            if x > l:\n                a = 1\n            l = min(l, x)\n            h = max(h, x)\n    if not a:\n        lo += (l,)\n        hi += (h,)\nh = sorted(hi)\nans = n * n\nimport bisect\nfor l in lo:\n    j = bisect.bisect(h, l)\n    ans -= j\nprint(ans)", "import sys\nn = int(input())\nm = []\nmm = []\nc = 0\nfor i in range(0, n):\n    line = list(map(int, input().split()))\n    line.pop(0)\n    blool = False\n    for i in range(0, len(line) - 1):\n        if line[i] < line[i + 1]:\n            blool = True\n    if blool:\n        c += 1\n    else:\n        m.append(line[len(line) - 1])\n        mm.append(line[0])\nm.sort()\nmm.sort()\ni = 0\nj = 0\ntotal = 2 * c * (n - c) + c ** 2\nn -= c\nwhile i < n and j < n:\n    if mm[i] > m[j]:\n        j += 1\n    else:\n        total = total + j\n        i += 1\nwhile i < n:\n    total += n\n    i += 1\nprint(total)", "from bisect import bisect\nuna = []\nb = int(input())\nfor ii in range(b):\n    a = [int(j) for j in input().split()]\n    a = a[1:]\n    flag = False\n    for i in range(len(a) - 1):\n        if a[i + 1] > a[i]:\n            flag = True\n            break\n    if flag == False:\n        una.append((a[0], a[-1]))\ncount = 0\nl = []\nchi = []\nfor i in una:\n    l.append(i[0])\n    chi.append(i[1])\nl = sorted(l)\nfor k in chi:\n    count += len(l) - bisect(l, k)\nn = len(una)\nprint(b ** 2 - n ** 2 + count)", "n = int(input())\nasc = 0\nnasc = 0\nminimos = []\nmaximos = []\nfor i in range(n):\n    s = input().split()\n    s = [int(e) for e in s]\n    s.pop(0)\n    for j in range(len(s)):\n        if j > 0 and s[j] > s[j - 1]:\n            asc += 1\n            break\n        elif j == len(s) - 1:\n            nasc += 1\n            minimos.append(min(s))\n            maximos.append(max(s))\nr = asc * asc + 2 * (asc * nasc)\nminimos.sort()\nmaximos.sort()\ni = 0\nfor k in maximos:\n    while i < nasc and minimos[i] < k:\n        i += 1\n    r += i\nprint(r)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nfor _ in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "n = int(input())\nl = []\nans = 0\nminn = []\nmaxx = []\nc = 0\nfor _ in range(n):\n    ar = [int(x) for x in input().split()]\n    ar = ar[1:]\n    m = 10 ** 10\n    f = 0\n    for i in ar:\n        if i <= m:\n            m = i\n        else:\n            f = 1\n            break\n    if f == 1:\n        continue\n    else:\n        minn.append(min(ar))\n        maxx.append(max(ar))\nmaxx.sort()\nminn.sort()\ntemp = len(maxx)\nfrom bisect import bisect_left\nfor i in maxx:\n    ind = bisect_left(minn, i)\n    ans += temp - ind\nprint(n ** 2 - ans)", "from bisect import bisect_right as br\nn = int(input())\ns = [list(map(int, input().split())) for i in range(n)]\na = []\nb = []\nc = 0\nfor i in s:\n    i = i[1:]\n    if list(reversed(sorted(i))) == i:\n        a.append(min(i))\n        b.append(max(i))\n    else:\n        c += 1\na = sorted(a)\nb = sorted(b)\np = 0\nt = len(b)\nfor i in a:\n    p += len(b) - br(b, i)\nprint(n ** 2 - (n - c) ** 2 + p)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nfor _ in range(n):\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "import bisect\n\ndef hasAscent(l):\n    for i in range(1, len(l) - 1):\n        if l[i] < l[i + 1]:\n            return 1\n    return 0\nn = int(input())\nnon_ascent = []\nascent = 0\nminimas = []\nmaximas = []\nfor j in range(n):\n    l1 = list(map(int, input().split()))\n    if hasAscent(l1):\n        ascent += 1\n    else:\n        minimas.append(min(l1[1:]))\n        maximas.append(max(l1[1:]))\nmaximas.sort()\nans = int(2 * n * ascent - ascent ** 2)\nfor num in minimas:\n    ind = bisect.bisect_right(maximas, num)\n    ans += len(maximas) - ind\nprint(ans)", "def get_int():\n    from sys import stdin\n    return int(stdin.readline().replace('\\n', ''))\n\ndef get_int_list():\n    from sys import stdin\n    return [int(x) for x in stdin.readline().replace('\\n', '').split(' ')]\n\ndef get_str():\n    from sys import stdin\n    return stdin.readline().replace('\\n', '')\n\ndef ascent(_list):\n    for i in range(len(_list)):\n        if i > 0 and _list[i] > _list[i - 1]:\n            return True\n    return False\n\ndef question():\n    (maxs, mins) = ([], [])\n    (asc, nasc) = (0, 0)\n    n = get_int()\n    _lists = []\n    while n > 0:\n        _list = get_int_list()[1:]\n        n -= 1\n        if ascent(_list):\n            asc += 1\n        else:\n            nasc += 1\n            maxs += [max(_list)]\n            mins += [min(_list)]\n    total = asc * asc + 2 * asc * nasc\n    mins.sort()\n    maxs.sort()\n    i = 0\n    for mx in maxs:\n        while i < nasc and mins[i] < mx:\n            i += 1\n        total += i\n    return total\nprint(question())", "n = int(input())\n(minis, maxis, casc, cdes) = ([], [], 0, 0)\nfor i in range(n):\n    s = list(map(int, input().split()))\n    s.pop(0)\n    for j in range(len(s)):\n        if j > 0 and s[j] > s[j - 1]:\n            casc += 1\n            break\n        elif j == len(s) - 1:\n            cdes += 1\n            minis.append(min(s))\n            maxis.append(max(s))\ntotal = casc * casc + 2 * casc * cdes\nminis.sort()\nmaxis.sort()\ni = 0\nfor j in maxis:\n    while i < cdes and minis[i] < j:\n        i += 1\n    total += i\nprint(total)", "n = int(input())\n(mini, maxi, asc, nasc) = ([], [], 0, 0)\nwhile n > 0:\n    s = list(map(int, input().split()))[1:]\n    for i in range(len(s)):\n        if i > 0 and s[i] > s[i - 1]:\n            asc += 1\n            break\n        elif i == len(s) - 1:\n            nasc += 1\n            mini.append(min(s))\n            maxi.append(max(s))\n    n -= 1\ntotal = asc * asc + 2 * asc * nasc\nmini.sort()\nmaxi.sort()\ni = 0\nfor x in maxi:\n    while i < nasc and mini[i] < x:\n        i += 1\n    total += i\nprint(total)", "import sys\nfrom bisect import bisect_left\n\ndef readline():\n    return sys.stdin.readline().strip().split(' ')\n\ndef has_ascent(seq):\n    m = 1000001\n    for x in seq:\n        if x > m:\n            return True\n        else:\n            m = x\n    return False\n\ndef main():\n    [n] = list(map(int, readline()))\n    seqs = [list(map(int, readline()[1:])) for i in range(n)]\n    seqs_false = [x for x in seqs if not has_ascent(x)]\n    mins = list(map(min, seqs_false))\n    maxs = list(map(max, seqs_false))\n    maxs.sort()\n    print(n * n - sum([bisect_left(maxs, x + 0.1) for x in mins]))\nmain()", "n = int(input())\nfrom bisect import bisect_left\nMs = []\nms = []\nascend = []\ncnt = 0\nfor i in range(n):\n    As = list(map(int, input().split()))\n    l = As[0]\n    As = As[1:]\n    flg = False\n    if l > 1:\n        for i in range(1, l):\n            if As[i - 1] < As[i]:\n                flg = True\n                break\n    if flg:\n        ascend.append(True)\n        cnt += 1\n    else:\n        Ms.append(max(As))\n        ms.append(min(As))\n        ascend.append(False)\nans1 = (n - cnt) * cnt * 2 + cnt ** 2\nMs.sort()\nans = 0\nfor m in ms:\n    ind = bisect_left(Ms, m + 1)\n    ans += n - ind - cnt\nprint(ans + ans1)", "import bisect\nn = int(input())\nlu = []\nmim = []\nmam = []\nlu = 0\nfor i in range(n):\n    t = list(map(int, input().split()))[1:]\n    ma = 0\n    mi = 10 ** 6\n    l = 0\n    for j in t:\n        if ma < j:\n            ma = j\n        if mi > j:\n            mi = j\n        if j > mi:\n            l += 1\n            break\n    if l == 0:\n        mim.append(mi)\n        mam.append(ma)\n    else:\n        lu += 1\ns = 0\nmim.sort()\nmam.sort()\nfor i in range(len(mim)):\n    s += n - bisect.bisect_right(mam, mim[i])\nprint(s + lu * n)", "from bisect import bisect_right as br\nmaxx = []\nminn = []\nc = 0\nn = int(input())\nfor _ in range(n):\n    t = list(map(int, input().split()))\n    t = t[1:]\n    flag = False\n    for k in range(len(t) - 1):\n        if t[k] < t[k + 1]:\n            flag = True\n            break\n    if not flag:\n        maxx.append(max(t))\n        minn.append(min(t))\n    else:\n        c += 1\nans = 0\nmaxx.sort()\nminn.sort()\nfor k in minn:\n    ans += len(maxx) - br(maxx, k)\nprint(pow(n, 2) - pow(n - c, 2) + ans)", "n = int(input())\nmi = []\nma = []\ni = j = cnt = 0\nfor _ in range(n):\n    a = list(map(int, input().split()))\n    flag = False\n    for k in range(1, a[0]):\n        if a[k] < a[k + 1]:\n            flag = True\n    if flag:\n        cnt += 1\n        continue\n    a.pop(0)\n    mi.append(min(a))\n    ma.append(max(a))\nmi.sort()\nma.sort()\nans = cnt * ((2 * n - 1 + (2 * n - cnt * 2 + 1)) // 2)\nn = len(mi)\nwhile i < n:\n    while j < n and ma[j] <= mi[i]:\n        j += 1\n    ans += n - j\n    i += 1\nprint(ans)", "num_de_sequencias = int(input())\npequenos = []\ngrandes = []\naux1 = 0\nfor i in range(num_de_sequencias):\n    sequencia = list(map(int, input().split()))\n    tamanho = sequencia[0]\n    pequeno = 10000000\n    grande = 0\n    flag = False\n    for j in range(1, tamanho + 1):\n        if j > 1 and sequencia[j] > pequeno and (not flag):\n            aux1 += 1\n            flag = True\n        pequeno = min(pequeno, sequencia[j])\n        grande = max(grande, sequencia[j])\n    if not flag:\n        pequenos.append(pequeno)\n        grandes.append(grande)\npequenos.append(10000000)\npequenos.sort()\ngrandes.sort()\ncont = 0\naux2 = 0\nfor i in range(len(grandes)):\n    while pequenos[aux2] < grandes[i] and aux2 < len(pequenos):\n        aux2 += 1\n    cont += aux2\nprint(aux1 * aux1 + 2 * (num_de_sequencias - aux1) * aux1 + cont)", "n = int(input())\nfirst = []\nlast = []\nsuc = []\nalready = 0\nfor i in range(n):\n    lst = list(map(int, input().split()))\n    fl = False\n    for j in range(1, len(lst) - 1):\n        if lst[j + 1] > lst[j]:\n            already += 1\n            fl = True\n            break\n    if fl:\n        continue\n    if len(lst) == 2:\n        first.append(lst[1])\n        last.append(lst[1])\n    else:\n        first.append(lst[1])\n        last.append(lst[-1])\nfirst.sort()\nlast.sort()\nans = max(0, already * (n - already) * 2 + already * already)\nptr = 0\nfor i in range(len(last)):\n    while ptr < len(first) and last[i] >= first[ptr]:\n        ptr += 1\n    ans += len(first) - ptr\nprint(ans)", "import operator\nfrom bisect import *\nn = int(input())\nMaMi = []\nres = 0\nB = []\nfor i in range(n):\n    (nA, *A) = [*map(int, input().split())]\n    for j in range(1, nA):\n        if A[j] > A[j - 1]:\n            break\n    else:\n        MaMi.append([A[0], A[-1]])\nm = n\nn = len(MaMi)\nMaMi = sorted(MaMi, key=operator.itemgetter(1, 0))\nfor i in range(n):\n    B.append(MaMi[i][1])\nfor i in range(n):\n    res += n - bisect_left(B, MaMi[i][0])\nprint(m * m - res)", "n = int(input())\ne = []\nb = []\nok = 0\nrs = 0\nfor _ in range(n):\n    c = list(map(int, input().split()))\n    l = c[1:]\n    if all((l[i] >= l[i + 1] for i in range(len(l) - 1))):\n        rs += 1\n        b.append(l[0])\n        e.append(l[len(l) - 1])\n    else:\n        ok += 1\nans = 0\nans += ok * n\nans += rs * ok\ne.sort()\nb.sort()\nl = len(e)\nib = 0\nie = 0\nf = True\nwhile ie < l and f:\n    while e[ie] >= b[ib]:\n        ib += 1\n        if ib == l:\n            f = False\n            print(ans)\n            break\n    ans += l - ib\n    ie += 1\nif f:\n    print(ans)", "n = int(input())\nfirst_elements = list()\nlast_elements = list()\npairs = 0\n\ndef has_ascent(ll):\n    min_ll = ll[0]\n    for i in range(1, len(ll)):\n        if min_ll < ll[i]:\n            return True\n        if ll[i] < min_ll:\n            min_ll = ll[i]\nfor _ in range(n):\n    l = list(map(int, input().split()))[1:]\n    if has_ascent(l):\n        pairs += n * 2 - 1\n        n -= 1\n    else:\n        first_elements.append(l[0])\n        last_elements.append(l[-1])\nfirst_elements = sorted(first_elements)\nlast_elements = sorted(last_elements)\nfound_index = 0\nfor element in last_elements:\n    min_index = found_index\n    found_index = len(first_elements)\n    for index in range(min_index, len(first_elements)):\n        if first_elements[index] > element:\n            found_index = index\n            break\n    pairs += len(first_elements) - found_index\nprint(pairs)", "from bisect import bisect_right as br\nn = int(input())\ns = [list(map(int, input().split())) for i in range(n)]\na = []\nb = []\nc = 0\nfor i in s:\n    i = i[1:]\n    if list(reversed(sorted(i))) == i:\n        a.append(min(i))\n        b.append(max(i))\n    else:\n        c += 1\na = sorted(a)\nb = sorted(b)\np = 0\nt = len(b)\nfor i in a:\n    p += len(b) - br(b, i)\nprint(n ** 2 - (n - c) ** 2 + p)"]