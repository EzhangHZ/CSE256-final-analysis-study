["def solve(N, K, A):\n    tok_size = 1\n    ti = 0\n    i = 1\n    while i < N:\n        if A[ti] > A[i]:\n            ti = 0\n            tok_size = i + 1\n        elif A[ti] == A[i]:\n            ti = (ti + 1) % tok_size\n        else:\n            break\n        i += 1\n    tok = A[:tok_size]\n    if len(tok) >= K:\n        return tok[:K]\n    else:\n        d = K // len(tok)\n        m = K % len(tok)\n        return tok * d + tok[:m]\n(N, K) = tuple(map(int, input().split()))\nA = input()\nprint(solve(N, K, A))", "import math\nimport random\nfrom collections import Counter, deque\nfrom sys import stdout\nimport time\nfrom math import factorial, log, gcd\nimport sys\nfrom decimal import Decimal\nimport heapq\n\ndef S():\n    return sys.stdin.readline().split()\n\ndef I():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef IS():\n    return sys.stdin.readline().replace('\\n', '')\n\ndef main():\n    (n, k) = I()\n    s = IS()\n    o = s[0]\n    if n == 1:\n        print(o * k)\n        return\n    mn = min(n, k)\n    idx = 1\n    ans_string = o\n    while idx < mn:\n        el = s[idx]\n        if el < o:\n            ans_string += el\n            idx += 1\n        elif el > o:\n            break\n        else:\n            new_idx_1 = 0\n            new_idx_2 = idx\n            flag = False\n            while new_idx_2 < mn - 1:\n                new_idx_2 += 1\n                new_idx_1 += 1\n                if s[new_idx_2] < s[new_idx_1]:\n                    flag = True\n                    ans_string += s[idx:new_idx_2]\n                    idx = new_idx_2\n                    break\n                elif s[new_idx_2] > s[new_idx_1]:\n                    break\n            if not flag:\n                break\n    _len = idx\n    print((ans_string * (k // _len + 1))[:k])\nmain()", "from math import ceil\n(n, k) = [int(s) for s in input().split(' ')]\ns = input()\nprefix_idx = 0\nidx = n - 1\nfor i in range(1, n):\n    if s[i] == s[prefix_idx]:\n        if idx == n - 1:\n            idx = i - 1\n        prefix_idx += 1\n    elif s[i] < s[prefix_idx]:\n        prefix_idx = 0\n        idx = n - 1\n    else:\n        if idx == n - 1:\n            idx = i - 1\n        break\nmultiply = ceil(k / (idx + 1))\nprint((s[:idx + 1] * multiply)[:k])", "from math import ceil\n(n, k) = [int(s) for s in input().split(' ')]\ns = input()\nprefix_idx = 0\nidx = n - 1\nfor i in range(1, n):\n    if s[i] == s[prefix_idx]:\n        if idx == n - 1:\n            idx = i - 1\n        prefix_idx += 1\n    elif s[i] < s[prefix_idx]:\n        prefix_idx = 0\n        idx = n - 1\n    else:\n        if idx == n - 1:\n            idx = i - 1\n        break\nmultiply = ceil(k / (idx + 1))\nprint((s[:idx + 1] * multiply)[:k])", "(n, k) = map(int, input().split())\ns = input()\nans = 1\nfor i in range(n):\n    if s[i] < s[i % ans]:\n        ans = i + 1\n    elif s[i] > s[i % ans]:\n        break\nprint((s[:ans] * (k // ans + 1))[:k])", "def readline():\n    return map(int, input().split())\n\ndef main():\n    (n, k) = readline()\n    s = list(map(ord, input()))\n    if len(s) > k:\n        s = s[:k]\n    prefix = 0\n    i = 0\n    for i in range(1, len(s)):\n        if s[i] > s[prefix]:\n            s = s[:i]\n            break\n        elif s[i] == s[prefix]:\n            prefix += 1\n        else:\n            prefix = 0\n    if prefix:\n        s = s[:-prefix]\n    s *= (k - 1) // len(s) + 1\n    print(''.join(map(chr, s[:k])))\nmain()", "(n, k) = map(int, input().split())\ns = input()\nres = 1\nfor i in range(n):\n    if s[i] < s[i % res]:\n        res = i + 1\n    elif s[i] > s[i % res]:\n        break\nprint((s[:res] * (k // res + 1))[:k])", "(n, k) = map(int, input().split())\ns = input()\nans = 1\nfor i in range(n):\n    if s[i] < s[i % ans]:\n        ans = i + 1\n    elif s[i] > s[i % ans]:\n        break\nprint((s[:ans] * (k // ans + 1))[:k])", "(n, k) = map(int, input().split())\ns = input()\nl = 0\npos = 1\nn = len(s)\nwhile l < n:\n    index = l % pos\n    if s[l] < s[index]:\n        pos = l + 1\n        l += 1\n    elif s[l] == s[index]:\n        l += 1\n    else:\n        break\nres = s[:pos] * (k // pos + 1)\nprint(res[:k])", "(n, k) = map(int, input().split())\ns = input()\nans = 1\nfor i in range(n):\n    if s[i] < s[i % ans]:\n        ans = i + 1\n    elif s[i] > s[i % ans]:\n        break\nprint((s[:ans] * (k // ans + 1))[:k])", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ns = str(input())\np = 1\nfor i in range(1, n):\n    if s[i % p] < s[i]:\n        break\n    if s[i % p] > s[i]:\n        p = i + 1\nx = m // p\ny = m - x * p\nprint(s[0:p] * x + s[0:y])", "(n, k) = map(int, input().split())\ns = input()\nbest_len = 1\nfor i in range(n):\n    if s[i] < s[i % best_len]:\n        best_len = i + 1\n    elif s[i] > s[i % best_len]:\n        break\ns = (s[:best_len] * (k // best_len + 1))[:k]\nprint(s)", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ns = str(input())\np = 1\nfor i in range(1, n):\n    if s[i % p] < s[i]:\n        break\n    if s[i % p] > s[i]:\n        p = i + 1\nx = m // p\ny = m - x * p\nprint(s[0:p] * x + s[0:y])", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ns = str(input())\np = 1\nfor i in range(1, n):\n    if s[i % p] < s[i]:\n        break\n    if s[i % p] > s[i]:\n        p = i + 1\nx = m // p\ny = m - x * p\nprint(s[0:p] * x + s[0:y])", "(n, q) = map(int, input().split())\nstring = input()\np = 0\ni = 1\nwhile i < len(string):\n    if string[i] < string[p]:\n        i += 1\n        p = 0\n    elif string[i] == string[p]:\n        i += 1\n        p += 1\n    else:\n        break\nst = string[:i - p]\nl = len(st)\nprint(st * (q // l) + st[:q % l])", "(n, k) = map(int, input().split())\ns = input()\np = -1\ni = 0\nwhile i < n:\n    if s[i] > s[0]:\n        p = i\n        break\n    elif s[i] == s[0]:\n        j = i + 1\n        z = 1\n        while j < n and z < i and (s[j] == s[z]):\n            j += 1\n            z += 1\n        if j < n and z < i and (s[j] > s[z]):\n            p = i\n            break\n        i = j - 1\n    i += 1\nif p != -1:\n    s = s[:p]\ni = len(s) - 1\nwhile i > 0 and s[i] == s[0]:\n    i -= 1\ns = s[:i + 1]\nprint(s * (k // len(s)) + s[:k % len(s)])", "import itertools\n\ndef validate_prefix(s, prefix):\n    n = len(s)\n    source = 0\n    for i in range(prefix, n):\n        if s[i] > s[source]:\n            return prefix\n        elif s[i] == s[source]:\n            source += 1\n            if source == prefix:\n                source = 0\n            continue\n        assert s[i] < s[source]\n        prefix = i + 1\n        source = 0\n    return prefix\n\ndef determine_initial_prefix(s):\n    prefix = 1\n    while True:\n        new_prefix = validate_prefix(s, prefix)\n        if new_prefix == prefix:\n            break\n        prefix = new_prefix\n    return prefix\n\ndef solve():\n    (n, k) = [int(x) for x in input().split()]\n    s = list(input())\n    pref = determine_initial_prefix(s)\n    return ''.join(itertools.islice(itertools.cycle(s[:pref]), k))\nprint(solve())", "import math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n(n, k) = get_ints()\ns = get_string()\n(i, j, x) = (1, 0, 1)\nwhile i < n and i < k:\n    if s[i] > s[0]:\n        break\n    while i < n and s[i] == s[j]:\n        i += 1\n        j += 1\n    if i >= n or (i < n and s[i] > s[j]):\n        break\n    i += 1\n    j = 0\n    x = i\nans = s[:x]\nwhile len(ans) < k:\n    ans += ans\nans = ans[:k]\nsys.stdout.write(ans + '\\n')", "from heapq import heapify, heappush, heappop, heappushpop\nfrom collections import defaultdict as dd, deque as dq, Counter as C\nfrom math import factorial as f, ceil, gcd, sqrt, log\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom itertools import combinations as c, permutations as p\nfrom math import factorial as f, ceil, gcd, sqrt, log\nfrom sys import stdin\ninput = stdin.readline\nmp = lambda : map(int, input().split())\nit = lambda : int(input())\nls = lambda : list(input().strip())\nmt = lambda r: [ls() for _ in range(r)]\nlcm = lambda a, b: a * b // gcd(a, b)\n\ndef fibo_n(n):\n    return ((1 + sqrt(5)) / 2) ** n / sqrt(5)\n(a, b) = mp()\ns = input().strip()\nstart = 0\nend = 1\nfinalend = 1\nwhile end != a:\n    if s[start] > s[end]:\n        finalend = end + 1\n        start = 0\n        end += 1\n    elif s[start] == s[end]:\n        start += 1\n        end += 1\n    else:\n        break\nst = s[:finalend]\nprint((st * ceil(b / len(st)))[:b])", "import sys\n(n, q) = map(int, sys.stdin.readline().split())\nstring = sys.stdin.readline().rstrip()\np = 0\ni = 1\nwhile i < len(string):\n    if string[i] < string[p]:\n        i += 1\n        p = 0\n    elif string[i] == string[p]:\n        i += 1\n        p += 1\n    else:\n        break\nst = string[:i - p]\nl = len(st)\nanswer = st * (q // l)\nanswer += st[:q % l]\nprint(answer)", "(n, k) = map(int, input().split())\ns = input()\np = 0\ni = 1\nwhile i < len(s):\n    if s[i] < s[p]:\n        i += 1\n        p = 0\n    elif s[i] == s[p]:\n        i += 1\n        p += 1\n    else:\n        break\nr = s[:i - p]\nl = len(r)\nprint(r * (k // l) + r[:k % l])", "def bestPrefix(S):\n    best = S[0]\n    for i in range(1, len(S)):\n        ch = i % len(best)\n        if best[ch] < S[i]:\n            break\n        elif best[ch] > S[i]:\n            while len(best) < i + 1:\n                best += S[len(best)]\n    return best\n\ndef solve(s, n, k):\n    pref = bestPrefix(s)\n    ans = ''\n    while len(ans) + len(pref) <= k:\n        ans += pref\n    ans += pref[:k - len(ans)]\n    return ans\n(n, k) = map(int, input().split())\ns = input()\nans = solve(s, n, k)\nprint(ans)", "(n, m) = list(map(int, input().strip().split()))\n(s, z, j) = (input(), '', 1)\nfor i in range(1, n):\n    if s[i] < s[i % j]:\n        j = i + 1\n    elif s[i] != s[i % j]:\n        break\nfor i in range(0, m):\n    z += s[i % j]\nprint(z)", "def bestPref(s):\n    pref = s[0]\n    for i in range(1, len(s)):\n        ind = i % len(pref)\n        if pref[ind] < s[i]:\n            break\n        elif pref[ind] > s[i]:\n            while len(pref) < i + 1:\n                pref += s[len(pref)]\n    return pref\n\ndef solve(n, k, s):\n    pref = bestPref(s)\n    cur = ''\n    while len(cur) + len(pref) <= k:\n        cur += pref\n    cur += pref[:k - len(cur)]\n    return cur\n(n, k) = list(map(int, input().split()))\nans = solve(n, k, input())\nprint(ans)", "import sys\nimport os\nif 'CP_LOCAL' in os.environ:\n    sys.stdin = open('codeforces/input.txt', 'r')\n    sys.stdout = open('codeforces/output.txt', 'w')\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n(n, k) = inlt()\nalp = insr()\nmc = 0\nct = 1\n(l, r) = (0, len(alp) - 1)\nfor i in range(1, len(alp)):\n    if alp[i] > alp[mc]:\n        break\n    ct += 1\n    if alp[i] == alp[mc]:\n        mc += 1\n    else:\n        mc = 0\nwhile mc:\n    ct -= 1\n    mc -= 1\nsub = ''.join(alp[:ct])\nres = sub[:k]\nwhile len(res) < k:\n    res += res\nprint(res[:k])", "(n, k) = map(int, input().split())\ns = input()\nl = ''\nl = l + s[0]\nj = 0\nfor i in range(1, n):\n    if s[i] > l[j]:\n        break\n    elif s[i] < l[j]:\n        l = l + s[i]\n        j = 0\n    elif s[i] == l[j]:\n        l = l + s[i]\n        j = j + 1\np = len(l)\nr = l[:p - j]\nm = len(r)\ns = r * (k // m)\nfor i in range(k % m):\n    s = s + r[i]\nprint(s)", "from io import BytesIO, IOBase\nimport math\nimport time\nimport sys\nimport os\nfrom math import gcd, floor, sqrt, log\nstart_time = time.time()\n\ndef iin():\n    return int(input())\n\ndef sin():\n    return input().strip()\n\ndef listin():\n    return list(map(int, input().strip().split()))\n\ndef liststr():\n    return list(map(str, input().strip().split()))\n\ndef ceill(x):\n    return int(x) if x == int(x) else int(x) + 1\n\ndef ceilldiv(x, d):\n    return x // d if x % d == 0 else x // d + 1\n\ndef LCM(a, b):\n    return a * b // gcd(a, b)\n(n, m) = listin()\ns = sin()\nz = ''\nj = 1\nfor i in range(1, n):\n    if s[i] < s[i % j]:\n        j = i + 1\n    elif s[i] != s[i % j]:\n        break\nfor i in range(0, m):\n    z += s[i % j]\nprint(z)", "import math, bisect\n(n, k) = map(int, input().split())\na = input()\nind1 = 0\nx = 0\nind2 = 1\nz = 1\nans = a\nwhile ind2 != n:\n    if a[ind1] == a[ind2]:\n        if x == 0:\n            z = ind2\n            x = 1\n        ind1 += 1\n    elif a[ind1] > a[ind2]:\n        x = 0\n        z = ind2 + 1\n        ind1 = 0\n    else:\n        break\n    ind2 += 1\nans = a[:z]\nb = ''\nl = len(ans)\nfor i in range(k):\n    b += ans[i % l]\nprint(b)", "from math import *\n(n, k) = [int(i) for i in input().split()]\na = input()\nb = (a * ceil(k / n))[:k]\nci = 0\nmb = -1\nind = -1\nfor i in range(1, k):\n    if ord(b[ci]) < ord(b[i]):\n        ind = i\n        if mb != -1:\n            ind = mb\n        break\n    elif ord(b[ci]) == ord(b[i]):\n        ci += 1\n        if mb == -1:\n            mb = i\n    elif ord(b[ci]) > ord(b[i]):\n        ci = 0\n        mb = -1\nans = ''\nif ind == -1:\n    ans = b\nelse:\n    c = b[:ind]\n    ans = (c * ceil(k / ind))[:k]\nprint(ans)", "import sys\nf = sys.stdin\n\ndef line():\n    return f.readline().strip().split()\n\ndef solve():\n    pos = 1\n    stop = False\n    i = 1\n    while i < len(W):\n        off = 0\n        for j in range(pos):\n            if i + j == len(W) or W[i + j] > W[j]:\n                stop = True\n                break\n            off += 1\n            if W[i + j] != W[j]:\n                break\n        if not stop:\n            pos += off\n        i = pos\n        if stop:\n            break\n    pref = W[:pos]\n    return pref\nT = 1\nfor test in range(1, T + 1):\n    (N, K) = map(int, line())\n    W = line()[0]\n    if K < N:\n        W = W[:K]\n    pref = solve()\n    sz = len(pref)\n    c = 0\n    m = K // sz\n    res = ''.join((pref for _ in range(m)))\n    res += pref[:K % sz]\n    sys.stdout.write(res)\n    sys.stdout.write('\\n')\nf.close()", "(n, k) = map(int, input().split())\ns = input()\np = ''\np += s[0]\nj = 1\nfor i in range(1, len(s)):\n    if s[i] > s[i % j]:\n        break\n    if s[i] < s[i % j]:\n        j = i + 1\nans = ''\nfor i in range(0, k):\n    ans += s[i % j]\nprint(ans)", "(n, k) = [int(d) for d in input().split()]\ns = input()\nif len(s) == 1:\n    print(s * k)\nelse:\n    x = s[0]\n    done = True\n    i = 1\n    get = False\n    idx = 0\n    curr = 0\n    while i < len(s) and done == True:\n        if s[i] < s[curr]:\n            x = x + s[i]\n            if curr != 0:\n                curr = 0\n                get = False\n            i = i + 1\n        elif s[i] == s[curr]:\n            x = x + s[i]\n            curr = curr + 1\n            if get == False:\n                idx = i\n                get = True\n            i = i + 1\n        else:\n            break\n    if get == True:\n        x = x[:idx]\n    full = k // len(x)\n    rem = k - full * len(x)\n    res = x * full + x[:rem]\n    print(res)", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfor _ in range(1):\n    (n, k) = [int(x) for x in input().split()]\n    s = input()\n    (l, r) = (0, 0)\n    ans = ''\n    for i in range(k):\n        if s[l] >= s[r]:\n            if ans and s[l] == s[r]:\n                l += 1\n            else:\n                l = 0\n            ans += s[r]\n        else:\n            ans += s[l]\n            r = l\n            l = 0\n        r += 1\n        r %= n\n        l %= n\n    print(ans)", "from cmath import log\n(n, k) = input().split()\nn = int(n)\nk = int(k)\ns = input()\nshortest_len = 0\ncurr_cmp = 0\nlast_char = '~'\nfirst = s[0]\nfor i in range(n):\n    if curr_cmp > 0 and s[curr_cmp] == s[i]:\n        curr_cmp += 1\n    elif curr_cmp and s[curr_cmp] > s[i]:\n        curr_cmp = 0\n    elif curr_cmp or (s[i] > last_char and s[i] > first):\n        break\n    elif s[i] > last_char and s[i] == first:\n        curr_cmp += 1\n    last_char = s[i]\n    shortest_len += 1\nshortest_len -= curr_cmp\ncut = s[0:shortest_len]\nfor i in range(int(k / shortest_len)):\n    print(cut, end='')\nprint(s[0:int(k % shortest_len)])", "(n, k) = map(int, input().split())\ns = input()\nunit = s[0]\nwhile True:\n    i = 0\n    test = s + unit\n    while i < len(s) and unit == test[i:i + len(unit)]:\n        i += len(unit)\n    while i < len(s) and unit > test[i:i + len(unit)]:\n        i += 1\n    if i == len(unit):\n        break\n    unit = test[:i]\nprint(unit * (k // len(unit)) + unit[:k % len(unit)])", "def sec(init, i, e, flag):\n    i1 = i\n    while i < n and ord(s[init]) == ord(s[i]) and (init < i1):\n        init += 1\n        i += 1\n        e += 1\n    if i == n or (i != n and ord(s[init]) < ord(s[i])):\n        flag = 1\n    return (e, flag, i)\n(n, k) = map(int, input().split())\ns = input()\ninit = 0\ne = 1\ni = 1\nflag = 0\nwhile i < n:\n    if ord(s[i]) > ord(s[init]):\n        break\n    elif s[i] == s[init]:\n        e1 = e\n        (e, flag, i) = sec(init, i, e, flag)\n        if flag == 1:\n            e = e1\n            break\n        else:\n            init = 0\n            continue\n    e += 1\n    i += 1\nt = k // e + 1\ns = s[:e]\nx = s\nfor i in range(t):\n    s += x\nprint(*s[:k], sep='')", "inp = input().split()\nlength = int(inp[0])\nrequired = int(inp[1])\ns = input()\ncount = 1\nfor i in range(1, length):\n    if s[i] > s[i % count]:\n        break\n    if s[i] < s[i % count]:\n        count = i + 1\nfor i in range(required):\n    print(s[i % count], end='')", "(n, desired) = map(int, input().split())\ns = list(input())\nstack = [s[0]]\nptr = 0\nfor i in range(1, n):\n    if ptr == len(stack):\n        ptr = 0\n    if s[i] < stack[ptr]:\n        stack.append(s[i])\n        ptr = 0\n    elif s[i] == stack[ptr]:\n        stack.append(s[i])\n        ptr += 1\n    else:\n        stack = stack[:len(stack) - ptr]\n        break\nwhile stack[-1] == stack[0] and len(stack) > 1:\n    stack.pop()\nans = []\nfor i in range(desired):\n    ptr = i % len(stack)\n    ans.append(stack[ptr])\nprint(*ans, sep='')", "def zfunction(s):\n    n = len(s)\n    z = [0] * n\n    z[0] = n\n    (R, L) = (0, 0)\n    for i in range(1, n):\n        if i > R:\n            L = i\n            R = i\n            while R < n and s[R - L] == s[R]:\n                R += 1\n            z[i] = R - L\n            R -= 1\n        else:\n            k = i - L\n            if z[k] < R - i + 1:\n                z[i] = z[k]\n            else:\n                L = i\n                while R < n and s[R - L] == s[R]:\n                    R += 1\n                z[i] = R - L\n                R -= 1\n    return z\n(n, k) = map(int, input().split())\ns = input()\nz = zfunction(s)\nbest = 0\nfor i in range(1, n):\n    comp = i - best - 1\n    if s[i] > s[comp]:\n        break\n    if s[i] < s[comp]:\n        best = i\n    elif comp + comp + 1 == i:\n        best = i\n    else:\n        check = z[comp + 1]\n        if check >= best + 1:\n            best = i\n        elif s[comp + 1 + check] > s[check]:\n            best = i\ns = s[:best + 1]\nwhile len(s) < k:\n    s = s + s\ns = s[:k]\nprint(s)", "(n, desired) = map(int, input().split())\ns = list(input())\nstack = [s[0]]\nptr = 0\nfor i in range(1, n):\n    if ptr == len(stack):\n        ptr = 0\n    if s[i] < stack[ptr]:\n        stack.append(s[i])\n        ptr = 0\n    elif s[i] == stack[ptr]:\n        stack.append(s[i])\n        ptr += 1\n    else:\n        stack = stack[:len(stack) - ptr]\n        break\nwhile stack[-1] == stack[0] and len(stack) > 1:\n    stack.pop()\nans = []\nfor i in range(desired):\n    ptr = i % len(stack)\n    ans.append(stack[ptr])\nprint(*ans, sep='')"]