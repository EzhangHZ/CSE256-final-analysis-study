["from decimal import Decimal\nfrom functools import lru_cache\none = Decimal(1)\n\n@lru_cache\ndef g(c, p, v):\n    if p == one:\n        return one\n    res = one\n    if c <= v:\n        res += c\n    else:\n        res += c * g(c - v, p + v, v)\n    return res\n\n@lru_cache\ndef f(c, m, p, v):\n    if p == 1:\n        return one\n    res = one\n    if m <= v:\n        res += m * g(c + m / 2, p + m / 2, v)\n    else:\n        res += m * f(c + v / 2, m - v, p + v / 2, v)\n    if c <= v:\n        res += c * g(m + c / 2, p + c / 2, v)\n    else:\n        res += c * f(c - v, m + v / 2, p + v / 2, v)\n    return res\n\ndef solve():\n    (c, m, p, v) = map(Decimal, input().split())\n    return f(c, m, p, v)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\nmain()", "from decimal import Decimal\nfrom functools import lru_cache\neps = Decimal(1e-06)\nprec = 6\n\n@lru_cache\ndef g(c, p, v):\n    if abs(p - 1) <= eps:\n        return Decimal(1)\n    res = Decimal(1)\n    if c <= v:\n        res += c\n    else:\n        res += c * g(c - v, p + v, v)\n    return res\n\n@lru_cache\ndef f(c, m, p, v):\n    if abs(p - 1) <= eps:\n        return Decimal(1)\n    res = Decimal(1)\n    if m <= v:\n        res += m * g(c + m / 2, p + m / 2, v)\n    else:\n        res += m * f(c + v / 2, m - v, p + v / 2, v)\n    if c <= v:\n        res += c * g(m + c / 2, p + c / 2, v)\n    else:\n        res += c * f(c - v, m + v / 2, p + v / 2, v)\n    return res\n\ndef solve():\n    (c, m, p, v) = map(Decimal, input().split())\n    return f(c, m, p, v)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\nmain()", "from decimal import Decimal\nfrom functools import lru_cache\neps = Decimal(1e-06)\nprec = 6\n\n@lru_cache\ndef g(c, p, v):\n    if abs(p - 1) <= eps:\n        return Decimal(1)\n    res = Decimal(1)\n    if c <= v:\n        res += c\n    else:\n        res += c * g(c - v, p + v, v)\n    res = round(res, prec)\n    return res\n\n@lru_cache\ndef f(c, m, p, v):\n    if abs(p - 1) <= eps:\n        return Decimal(1)\n    res = Decimal(1)\n    if m <= v:\n        res += m * g(c + m / 2, p + m / 2, v)\n    else:\n        res += m * f(c + v / 2, m - v, p + v / 2, v)\n    if c <= v:\n        res += c * g(m + c / 2, p + c / 2, v)\n    else:\n        res += c * f(c - v, m + v / 2, p + v / 2, v)\n    res = round(res, prec)\n    return res\n\ndef solve():\n    (c, m, p, v) = map(Decimal, input().split())\n    return f(c, m, p, v)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\nmain()", "def solve(c, m, p, v, cnt):\n    if 1 - p < 1e-05:\n        return cnt\n    ret = 0\n    if c >= 1e-05 and m >= 1e-05:\n        if c <= v:\n            ret += c * solve(0, m + c / 2, p + c / 2, v, cnt + 1)\n        else:\n            ret += c * solve(c - v, m + v / 2, p + v / 2, v, cnt + 1)\n        if m <= v:\n            ret += m * solve(c + m / 2, 0, p + m / 2, v, cnt + 1)\n        else:\n            ret += m * solve(c + v / 2, m - v, p + v / 2, v, cnt + 1)\n    elif c < 1e-05:\n        if m <= v:\n            ret += m * solve(0, 0, 1, v, cnt + 1)\n        else:\n            ret += m * solve(0, m - v, p + v, v, cnt + 1)\n    elif m < 1e-05:\n        if c <= v:\n            ret += c * solve(0, 0, 1, v, cnt + 1)\n        else:\n            ret += c * solve(c - v, 0, p + v, v, cnt + 1)\n    ret += p * cnt\n    return ret\nfor _ in range(int(input())):\n    (qc, qm, qp, qv) = map(float, input().split())\n    print(solve(qc, qm, qp, qv, 1))", "def f(c, m, p, v):\n    if abs(1 - p) < 10 ** (-7):\n        return 1\n    if c < 10 ** (-7):\n        ans = 0\n        if m - v > 0:\n            ans += m * (f(0, m - v, p + v, v) + 1)\n        else:\n            ans += m * 2\n        ans += p\n        return ans\n    elif m < 10 ** (-7):\n        ans = 0\n        if c > v:\n            ans += c * (f(c - v, 0, p + v, v) + 1)\n        else:\n            ans += c * 2\n        ans += p\n        return ans\n    else:\n        ans = 0\n        if c - v > 0:\n            ans += c * (f(c - v, m + v / 2, p + v / 2, v) + 1)\n        else:\n            ans += c * (f(0, m + c / 2, p + c / 2, v) + 1)\n        if m - v > 0:\n            ans += m * (f(c + v / 2, m - v, p + v / 2, v) + 1)\n        else:\n            ans += m * (f(c + m / 2, 0, p + m / 2, v) + 1)\n        ans += p\n        return ans\nfor __ in range(int(input())):\n    (c, m, p, v) = map(float, input().split())\n    print(f(c, m, p, v))", "import sys\ninput = sys.stdin.readline\nscale = 40000\nfor _ in range(int(input())):\n    (c, m, p, v) = map(float, input().split())\n    (c, m, p, v) = (c * scale, m * scale, p * scale, v * scale)\n\n    def dfs(c, m, p):\n        ans = 1\n        if c:\n            x = min(v, c)\n            if not m:\n                ans += c / scale * dfs(c - x, 0, p + x)\n            else:\n                ans += c / scale * dfs(c - x, m + x / 2, p + x / 2)\n        if m:\n            x = min(v, m)\n            if not c:\n                ans += m / scale * dfs(0, m - x, p + x)\n            else:\n                ans += m / scale * dfs(c + x / 2, m - x, p + x / 2)\n        return ans\n    print(dfs(c, m, p))", "scale = 10 ** 6\n\ndef calculate_expectation(c, m, p, v):\n    expectation = 1\n    if c != 0:\n        if c <= v:\n            if m != 0:\n                expectation += c / scale * calculate_expectation(0, m + c / 2, p + c / 2, v)\n            else:\n                expectation += c / scale\n        elif m != 0:\n            expectation += c / scale * calculate_expectation(c - v, m + v / 2, p + v / 2, v)\n        else:\n            expectation += c / scale * calculate_expectation(c - v, 0, p + v, v)\n    if m != 0:\n        if m <= v:\n            if c != 0:\n                expectation += m / scale * calculate_expectation(c + m / 2, 0, p + m / 2, v)\n            else:\n                expectation += m / scale\n        elif c != 0:\n            expectation += m / scale * calculate_expectation(c + v / 2, m - v, p + v / 2, v)\n        else:\n            expectation += m / scale * calculate_expectation(0, m - v, p + v, v)\n    return expectation\nt = int(input())\nresults = []\nfor i in range(t):\n    (c, m, p, v) = map(float, input().split())\n    c = c * scale\n    m = m * scale\n    p = p * scale\n    v = v * scale\n    results.append(calculate_expectation(c, m, p, v))\nfor i in range(t):\n    print(results[i])", "scale = 10 ** 6\n\ndef calculate_expectation(c, m, p, v):\n    expectation = 1\n    if c != 0:\n        if c <= v:\n            if m != 0:\n                expectation += c / scale * calculate_expectation(0, m + c / 2, p + c / 2, v)\n            else:\n                expectation += c / scale\n        elif m != 0:\n            expectation += c / scale * calculate_expectation(c - v, m + v / 2, p + v / 2, v)\n        else:\n            expectation += c / scale * calculate_expectation(c - v, 0, p + v, v)\n    if m != 0:\n        if m <= v:\n            if c != 0:\n                expectation += m / scale * calculate_expectation(c + m / 2, 0, p + m / 2, v)\n            else:\n                expectation += m / scale\n        elif c != 0:\n            expectation += m / scale * calculate_expectation(c + v / 2, m - v, p + v / 2, v)\n        else:\n            expectation += m / scale * calculate_expectation(0, m - v, p + v, v)\n    return expectation\nt = int(input())\nresults = []\nfor i in range(t):\n    (c, m, p, v) = map(float, input().split())\n    c = c * scale\n    m = m * scale\n    p = p * scale\n    v = v * scale\n    results.append(calculate_expectation(c, m, p, v))\nfor i in range(t):\n    print(results[i])", "def main():\n    t = int(input())\n    for i in range(t):\n        (c, m, p, v) = list(map(float, input().split()))\n        res = 0\n        cur = [[c, m, p, 1]]\n        i = 0\n        while cur != []:\n            nxt = []\n            for node in cur:\n                (c, m, p, q) = node\n                if c != 0:\n                    if c > v + 1e-06:\n                        if m != 0:\n                            nxt.append([c - v, m + v / 2, p + v / 2, q * c])\n                        else:\n                            nxt.append([c - v, 0, p + v, q * c])\n                    elif m != 0:\n                        nxt.append([0, m + c / 2, p + c / 2, q * c])\n                    else:\n                        nxt.append([0, 0, 1, q * c])\n                if m != 0:\n                    if m > v + 1e-06:\n                        if c != 0:\n                            nxt.append([c + v / 2, m - v, p + v / 2, q * m])\n                        else:\n                            nxt.append([0, m - v, p + v, q * m])\n                    elif c != 0:\n                        nxt.append([c + m / 2, 0, p + m / 2, q * m])\n                    else:\n                        nxt.append([0, 0, 1, q * m])\n                res += p * q * (i + 1)\n            cur = nxt\n            i += 1\n        print(res)\nwhile True:\n    try:\n        main()\n    except:\n        break", "from sys import stdin, setrecursionlimit, maxsize\nfrom collections import deque\nfrom math import exp, gcd\ninput = stdin.readline\nsetrecursionlimit(10 ** 9)\neps = 1e-09\nscale = 1000000.0\n\ndef expectedRaces(c, m, p, v):\n    res = p / scale\n    if c > 0:\n        if c > v:\n            if m > 0:\n                res += c / scale * (1 + expectedRaces(c - v, m + v // 2, p + v // 2, v))\n            else:\n                res += c / scale * (1 + expectedRaces(c - v, 0, p + v, v))\n        elif m > 0:\n            res += c / scale * (1 + expectedRaces(0, m + c // 2, p + c // 2, v))\n        else:\n            res += c / scale * (1 + expectedRaces(0, 0, p + c, v))\n    if m > 0:\n        if m > v:\n            if c > 0:\n                res += m / scale * (1 + expectedRaces(c + v // 2, m - v, p + v // 2, v))\n            else:\n                res += m / scale * (1 + expectedRaces(0, m - v, p + v, v))\n        elif c > 0:\n            res += m / scale * (1 + expectedRaces(c + m // 2, m - v, p + m // 2, v))\n        else:\n            res += m / scale * (1 + expectedRaces(0, 0, p + m, v))\n    return res\nfor _ in range(int(input())):\n    (cd, md, pd, vd) = map(float, input().split())\n    c = round(cd * scale)\n    m = round(md * scale)\n    p = round(pd * scale)\n    v = round(vd * scale)\n    res = expectedRaces(c, m, p, v)\n    print('%.12f' % res)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\n\ndef main():\n    (c, m, p, v) = map(float, input().split())\n    eps = 10 ** (-9)\n\n    def dfs(cnt, x, c, m, p):\n        cnt += 1\n        ret = 0\n        ret = x * p * cnt\n        if c != 0:\n            if c < v + eps:\n                if m == 0:\n                    ret += dfs(cnt, x * c, 0, 0, 1)\n                else:\n                    ret += dfs(cnt, x * c, 0, m + c / 2, p + c / 2)\n            elif m == 0:\n                ret += dfs(cnt, x * c, c - v, 0, p + v)\n            else:\n                ret += dfs(cnt, x * c, c - v, m + v / 2, p + v / 2)\n        if m != 0:\n            if m < v + eps:\n                if c == 0:\n                    ret += dfs(cnt, x * m, 0, 0, 1)\n                else:\n                    ret += dfs(cnt, x * m, c + m / 2, 0, p + m / 2)\n            elif c == 0:\n                ret += dfs(cnt, x * m, 0, m - v, p + v)\n            else:\n                ret += dfs(cnt, x * m, c + v / 2, m - v, p + v / 2)\n        return ret\n    print(dfs(0, 1, c, m, p))\nfor _ in range(int(input())):\n    main()", "r = 1000000000.0\n\ndef check(c, m, p, v, l):\n    ans = p / r * l\n    if c > 0:\n        if c > v:\n            if m > 0:\n                ans += c / r * check(c - v, m + v / 2, p + v / 2, v, l + 1)\n            else:\n                ans += c / r * check(c - v, 0, p + v, v, l + 1)\n        elif m > 0:\n            ans += c / r * check(0, m + c / 2, p + c / 2, v, l + 1)\n        else:\n            ans += c / r * check(0, 0, p + c, v, l + 1)\n    if m > 0:\n        if m > v:\n            if c > 0:\n                ans += m / r * check(c + v / 2, m - v, p + v / 2, v, l + 1)\n            else:\n                ans += m / r * check(0, m - v, p + v, v, l + 1)\n        elif c > 0:\n            ans += m / r * check(c + m / 2, 0, p + m / 2, v, l + 1)\n        else:\n            ans += m / r * check(0, 0, p + m, v, l + 1)\n    return ans\ntest = int(input())\nfor i in range(test):\n    lst = [float(i) for i in input().split()][:4]\n    (c, m, p, v) = (lst[0], lst[1], lst[2], lst[3])\n    c = c * r\n    m = m * r\n    p = p * r\n    v = v * r\n    ans = 0.0\n    ans = check(c, m, p, v, 1)\n    print(ans)", "def func(c, m, p, v, n):\n    ans = p * (n + 1)\n    if c > x:\n        a = min(c, v)\n        if m > x:\n            ans += c * func(c - a, m + a / 2, p + a / 2, v, n + 1)\n        else:\n            ans += c * func(c - a, m, p + a, v, n + 1)\n    if m > x:\n        a = min(m, v)\n        if c > x:\n            ans += m * func(c + a / 2, m - a, p + a / 2, v, n + 1)\n        else:\n            ans += m * func(c, m - a, p + a, v, n + 1)\n    return ans\nt = int(input())\nx = 1e-08\nfor _ in range(t):\n    (c, m, p, v) = map(float, input().split(' '))\n    ans = func(c, m, p, v, 0)\n    print('{:.12f}'.format(float(ans)))", "t = int(input())\n\ndef is_zero(x):\n    return abs(x) < 1e-09\n\ndef EV(x, y, z, v):\n    if is_zero(x) and is_zero(y):\n        return 1\n    elif is_zero(x):\n        step = min(y, v)\n        return 1 + y * EV(x, y - step, z + step, v)\n    elif is_zero(y):\n        step = min(x, v)\n        return 1 + x * EV(x - step, y, z + step, v)\n    else:\n        step1 = min(x, v)\n        step2 = min(y, v)\n        return 1 + x * EV(x - step1, y + step1 / 2, z + step1 / 2, v) + y * EV(x + step2 / 2, y - step2, z + step2 / 2, v)\nfor test in range(t):\n    (c, m, p, v) = [float(x) for x in input().split()]\n    print(EV(c, m, p, v))", "def func(c, m, p, v, n):\n    ans = p * (n + 1)\n    if c > x:\n        a = min(c, v)\n        if m > x:\n            ans += c * func(c - a, m + a / 2, p + a / 2, v, n + 1)\n        else:\n            ans += c * func(c - a, m, p + a, v, n + 1)\n    if m > x:\n        a = min(m, v)\n        if c > x:\n            ans += m * func(c + a / 2, m - a, p + a / 2, v, n + 1)\n        else:\n            ans += m * func(c, m - a, p + a, v, n + 1)\n    return ans\nt = int(input())\nx = 1e-08\nfor _ in range(t):\n    (c, m, p, v) = map(float, input().split(' '))\n    ans = func(c, m, p, v, 0)\n    print('{:.12f}'.format(float(ans)))", "t = int(input())\nfor _ in range(t):\n    (c, m, p, v) = map(float, input().split())\n\n    def dp(c, m, p):\n        ans = 1\n        if c > 1e-06:\n            ch = min(c, v)\n            nc = c - ch\n            nm = m + ch / 2\n            np = p + ch / 2\n            if m < 1e-06:\n                nm = m\n                np += ch / 2\n            ans += c * dp(nc, nm, np)\n        if m > 1e-06:\n            ch = min(m, v)\n            nm = m - ch\n            nc = c + ch / 2\n            np = p + ch / 2\n            if c < 1e-06:\n                nc = c\n                np += ch / 2\n            ans += m * dp(nc, nm, np)\n        return ans\n    print(dp(c, m, p))", "def solve():\n    (c, m, p, v) = map(float, input().split())\n\n    def rec1(a, p, cur, r):\n        cur += 1\n        ans = cur * p * r\n        if a > 1e-08:\n            if a >= v:\n                ans += rec1(a - v, p + v, cur, r * a)\n            else:\n                ans += rec1(0, p + a, cur, r * a)\n        return ans\n\n    def rec(c, m, p, cur, r):\n        cur += 1\n        ans = cur * p * r\n        if c > 1e-08:\n            if c > v + 1e-09:\n                ans += rec(c - v, m + v / 2, p + v / 2, cur, r * c)\n            else:\n                ans += rec1(m + c / 2, p + c / 2, cur, r * c)\n        if m > 1e-08:\n            if m > v + 1e-09:\n                ans += rec(c + v / 2, m - v, p + v / 2, cur, r * m)\n            else:\n                ans += rec1(c + m / 2, p + m / 2, cur, r * m)\n        return ans\n    print(f'{rec(c, m, p, 0, 1):.{9}f}')\nk = int(input())\nfor i in range(k):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 9)\nSCALE = 10 ** 6\n\ndef func(it):\n    return float(SCALE * float(it))\n\ndef solve(c, m, p, v):\n    ans = p / SCALE\n    if c > 0:\n        if c > v:\n            if m > 0:\n                ans += c / SCALE * (1 + solve(c - v, m + v / 2, p + v / 2, v))\n            else:\n                ans += c / SCALE * (1 + solve(c - v, 0, p + v, v))\n        elif m > 0:\n            ans += c / SCALE * (1 + solve(0, m + c / 2, p + c / 2, v))\n        else:\n            ans += c / SCALE * (1 + solve(0, 0, p + c, v))\n    if m > 0:\n        if m > v:\n            if c > 0:\n                ans += m / SCALE * (1 + solve(c + v / 2, m - v, p + v / 2, v))\n            else:\n                ans += m / SCALE * (1 + solve(0, m - v, p + v, v))\n        elif c > 0:\n            ans += m / SCALE * (1 + solve(c + m / 2, 0, p + m / 2, v))\n        else:\n            ans += m / SCALE * (1 + solve(0, 0, p + m, v))\n    return ans\nfor case in range(int(input())):\n    mp = map(func, input().split())\n    ans = solve(*mp)\n    print(round(ans, 12))", "from collections import deque\nimport sys\nsys.setrecursionlimit(10 ** 6)\nscale = 10 ** 6\n\ndef rec(c, m, p, v):\n    res = p / scale\n    if c > 0:\n        if c > v:\n            if m > 0:\n                res += c / scale * (1 + rec(c - v, m + v / 2, p + v / 2, v))\n            else:\n                res += c / scale * (1 + rec(c - v, 0, p + v, v))\n        elif m > 0:\n            res += c / scale * (1 + rec(0, m + c / 2, p + c / 2, v))\n        else:\n            res += c / scale * (1 + rec(0, 0, p + c, v))\n    if m > 0:\n        if m > v:\n            if c > 0:\n                res += m / scale * (1 + rec(c + v / 2, m - v, p + v / 2, v))\n            else:\n                res += m / scale * (1 + rec(0, m - v, p + v, v))\n        elif c > 0:\n            res += m / scale * (1 + rec(c + m / 2, 0, p + m / 2, v))\n        else:\n            res += m / scale * (1 + rec(0, 0, p + m, v))\n    return res\nt = int(input())\nfor i in range(t):\n    (cm, mm, pm, vv) = [float(i) for i in input().split()]\n    print(rec(cm * scale, mm * scale, pm * scale, vv * scale))", "from decimal import *\n\ndef numMoves(c, m, p, v):\n    ans = 1\n    if c != -1:\n        if c <= v:\n            if m != -1:\n                ans += c * numMoves(-1, m + c / 2, p + c / 2, v)\n            else:\n                ans += c * numMoves(-1, m, p + c, v)\n        elif m != -1:\n            ans += c * numMoves(c - v, m + v / 2, p + v / 2, v)\n        else:\n            ans += c * numMoves(c - v, m, p + v, v)\n    if m != -1:\n        if m <= v:\n            if c != -1:\n                ans += m * numMoves(c + m / 2, -1, p + m / 2, v)\n            else:\n                ans += m * numMoves(c, -1, p + m, v)\n        elif c != -1:\n            ans += m * numMoves(c + v / 2, m - v, p + v / 2, v)\n        else:\n            ans += m * numMoves(c, m - v, p + v, v)\n    return ans\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    abc = input().split()\n    c = Decimal(abc[0])\n    m = Decimal(abc[1])\n    p = Decimal(abc[2])\n    v = Decimal(abc[3])\n    print(numMoves(c, m, p, v))", "from decimal import Decimal\nfrom decimal import *\nv = 1\n\ndef f(a, b, l):\n    t1 = 1\n    t2 = 1\n    t3 = 1\n    if a == 0 and b == 0:\n        return l * t3\n    if a == 0:\n        if b <= v:\n            return l * (t3 - b) + (l + 1) * b\n        else:\n            return b * f(0, b - v, l + 1) + l * (t3 - b)\n    if b == 0:\n        if a <= v:\n            return l * (t3 - a) + (l + 1) * a\n        else:\n            return a * f(0, a - v, l + 1) + l * (t3 - a)\n    if a <= v:\n        t1 = f(0, b + a / 2, l + 1)\n    else:\n        t1 = f(a - v, b + v / 2, l + 1)\n    if b <= v:\n        t2 = f(a + b / 2, 0, l + 1)\n    else:\n        t2 = f(a + v / 2, b - v, l + 1)\n    return l * (t3 - a - b) + a * t1 + b * t2\nT = int(input())\nfor i in range(0, T):\n    (a, b, c, v) = map(Decimal, input().split())\n    print(f(a, b, 1))", "def expected(c, m, p, v):\n    E = 1.0\n    if c > 1e-07:\n        if m <= 1e-07:\n            E += c * expected(c - min(c, v), m, p + min(c, v), v)\n        else:\n            E += c * expected(c - min(c, v), m + min(c, v) / 2.0, p + min(c, v) / 2.0, v)\n    if m > 1e-07:\n        if c <= 1e-07:\n            E += m * expected(c, m - min(m, v), p + min(m, v), v)\n        else:\n            E += m * expected(c + min(m, v) / 2.0, m - min(m, v), p + min(m, v) / 2.0, v)\n    return E\nt = int(input())\nfor _ in range(t):\n    (c, m, p, v) = [float(x) for x in input().split()]\n    print(expected(c, m, p, v))", "from decimal import *\n\ndef f(a, b, v):\n    ans = 1\n    if a <= v:\n        ans += a\n    else:\n        ans += a * f(a - v, b + v, v)\n    return ans\n\ndef g(a, b, c, v):\n    ans = 1\n    if a <= v:\n        ans += a * f(b + a / 2, c + a / 2, v)\n    else:\n        ans += a * g(a - v, b + v / 2, c + v / 2, v)\n    if b <= v:\n        ans += b * f(a + b / 2, c + b / 2, v)\n    else:\n        ans += b * g(a + v / 2, b - v, c + v / 2, v)\n    return ans\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        ans = g(*map(Decimal, input().split()))\n        print(f'{ans:.12f}')\nmain()", "def calc(a, v):\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] > v + 1e-10:\n            b = a.copy()\n            b[i] -= v\n            if n == 2:\n                b[1 - i] += v / n\n            ans += (calc(b, v) + 1) * a[i]\n        elif n == 2:\n            ans += (calc([a[1 - i] + a[i] / 2], v) + 1) * a[i]\n        else:\n            ans += (1 + 1) * a[i]\n    ans += 1 * (1 - sum(a))\n    return ans\n\ndef solve_case():\n    a = list(map(float, input().split()))\n    print(f'{calc(a[:2], a[-1]):.12f}')\nn = int(input())\nfor i in range(n):\n    solve_case()", "cache = {}\n\ndef expected(P, v):\n    (c, m, p) = P\n    ans = p\n    if 0 < c:\n        P1 = [c, m, p]\n        if c <= v:\n            P1 = [0, 0, p + c] if m == 0 else [0, m + c / 2, p + c / 2]\n        if c > v:\n            P1 = [c - v, 0, p + v] if m == 0 else [c - v, m + v / 2, p + v / 2]\n        ans += c * (1 + expected(P1, v))\n    if 0 < m:\n        P2 = [c, m, p]\n        if m <= v:\n            P2 = [0, 0, p + m] if c == 0 else [c + m / 2, 0, p + m / 2]\n        if m > v:\n            P2 = [0, m - v, p + v] if c == 0 else [c + v / 2, m - v, p + v / 2]\n        ans += m * (1 + expected(P2, v))\n    return ans * 0.0001\nt = int(input())\nfor _ in range(t):\n    L = list(map(float, input().split()))\n    (P, v) = (L[:3], L[3])\n    P = [x * 10000 for x in P]\n    v = 10000 * v\n    print(expected(P, v))", "def dfs(c, m, p, v, steps, prob):\n    ans = 0\n    if c != -1:\n        if m != -1:\n            if c <= v:\n                ans += dfs(-1, m + c / 2, p + c / 2, v, steps + 1, prob * c / r)\n            else:\n                ans += dfs(c - v, m + v / 2, p + v / 2, v, steps + 1, prob * c / r)\n        elif c <= v:\n            ans += dfs(-1, -1, p + c, v, steps + 1, prob * c / r)\n        else:\n            ans += dfs(c - v, -1, p + v, v, steps + 1, prob * c / r)\n    if m != -1:\n        if c != -1:\n            if m <= v:\n                ans += dfs(c + m / 2, -1, p + m / 2, v, steps + 1, prob * m / r)\n            else:\n                ans += dfs(c + v / 2, m - v, p + v / 2, v, steps + 1, prob * m / r)\n        elif m <= v:\n            ans += dfs(-1, -1, p + m, v, steps + 1, prob * m / r)\n        else:\n            ans += dfs(-1, m - v, p + v, v, steps + 1, prob * m / r)\n    if p:\n        ans += steps * prob * p / r\n    return ans\nr = 10 ** 9\nT = int(input())\nfor case in range(T):\n    (c, m, p, v) = list(map(float, input().split()))\n    c *= r\n    m *= r\n    p *= r\n    v *= r\n    answer = dfs(c, m, p, v, 1, 1)\n    print(answer)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\ndef calc(a, b, c, v, s):\n    if a == 0 and b == 0:\n        return c * s\n    eps = 10 ** (-8)\n    res = 0\n    if a > eps:\n        l = min(a, v)\n        if b > eps:\n            res += a * calc(a - l, b + l / 2, c + l / 2, v, s + 1)\n        else:\n            res += a * calc(a - l, 0, c + l, v, s + 1)\n    if b > eps:\n        l = min(b, v)\n        if a > eps:\n            res += b * calc(a + l / 2, b - l, c + l / 2, v, s + 1)\n        else:\n            res += b * calc(0, b - l, c + l, v, s + 1)\n    return s * c + res\nt = int(input())\nfor _ in range(t):\n    (c, m, p, v) = map(float, input().split())\n    print(calc(c, m, p, v, 0) + 1)", "from decimal import *\n\ndef solve(c1, m1, p, v, n):\n    c = 0\n    m = 0\n    if c1 > m1:\n        c = m1\n        m = c1\n    else:\n        c = c1\n        m = m1\n    ans = n * p\n    if c == 0:\n        if m != 0:\n            if v >= m:\n                ans += (1 - p) * solve(0, 0, 1, v, n + 1)\n            else:\n                ans += (1 - p) * solve(0, m - v, p + v, v, n + 1)\n    elif v <= c:\n        ans += c * solve(c - v, m + v / 2, p + v / 2, v, n + 1)\n        ans += m * solve(c + v / 2, m - v, p + v / 2, v, n + 1)\n    elif v > m:\n        ans += c * solve(0, m + c / 2, p + c / 2, v, n + 1)\n        ans += m * solve(c + m / 2, 0, p + m / 2, v, n + 1)\n    else:\n        ans += c * solve(0, m + c / 2, p + c / 2, v, n + 1)\n        ans += m * solve(c + v / 2, m - v, p + v / 2, v, n + 1)\n    return ans\nt = int(input())\nwhile t > 0:\n    a = input().split(' ')\n    (c, m, p, v) = (Decimal(a[0]), Decimal(a[1]), Decimal(a[2]), Decimal(a[3]))\n    print(solve(c, m, p, v, 1))\n    t -= 1", "T = int(input())\nfor t in range(T):\n    [c, m, p, v] = list(map(float, input().split()))\n\n    def dp(c, m, p, k):\n        if c < 1e-06:\n            c = 0\n        if m < 1e-06:\n            m = 0\n        a = min(c, v)\n        b = min(m, v)\n        if c == 0 and m == 0:\n            return (k + 1) * p\n        if m == 0:\n            return c * dp(c - a, m, p + a, k + 1) + (k + 1) * p\n        if c == 0:\n            return m * dp(c, m - b, p + b, k + 1) + (k + 1) * p\n        return c * dp(c - a, m + a / 2.0, p + a / 2.0, k + 1) + m * dp(c + b / 2.0, m - b, p + b / 2.0, k + 1) + (k + 1) * p\n    print(dp(c, m, p, 0))", "def f(a, c):\n    if a <= 1e-06:\n        return 0\n    else:\n        return c / 2\n\ndef dfs(c, m, p, v, step, sum):\n    ans = p * step * sum\n    if c >= 1e-06:\n        if c < v:\n            ans = ans + dfs(c - c, m + f(m, c), p + c - f(m, c), v, step + 1, c * sum)\n        else:\n            ans = ans + dfs(c - v, m + f(m, v), p + v - f(m, v), v, step + 1, c * sum)\n    if m >= 1e-06:\n        if m < v:\n            ans = ans + dfs(c + f(c, m), m - m, p + m - f(c, m), v, step + 1, m * sum)\n        else:\n            ans = ans + dfs(c + f(c, v), m - v, p + v - f(c, v), v, step + 1, m * sum)\n    return ans / 1000000.0\nt = int(input())\nwhile t != 0:\n    t = t - 1\n    l = list(map(float, input().split()))\n    ans = dfs(l[0] * 1000000.0, l[1] * 1000000.0, l[2] * 1000000.0, l[3] * 1000000.0, 1, 1)\n    print(ans)", "from collections import Counter, deque, defaultdict\nfrom heapq import *\nfrom decimal import *\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef inp():\n    return int(input())\n\ndef mapInput():\n    return map(Decimal, input().split())\n\ndef arrInput():\n    return list(map(Decimal, input().split()))\ndiv = Decimal(2)\n\ndef rounds(c, m, p, v):\n    if c == 0 and m == 0:\n        return 1\n    res = 1\n    if c > 0:\n        (x, y, z) = (c, m, p)\n        reduced = -1\n        if x > v:\n            reduced = v / 2\n            x -= v\n        else:\n            reduced = x / 2\n            x = 0\n        z += reduced\n        if y > 0:\n            y += reduced\n        else:\n            z += reduced\n        res += c * rounds(x, y, z, v)\n    if m > 0:\n        (x, y, z) = (c, m, p)\n        reduced = -1\n        if y > v:\n            reduced = v / div\n            y -= v\n        else:\n            reduced = y / div\n            y = 0\n        z += reduced\n        if x > 0:\n            x += reduced\n        else:\n            z += reduced\n        res += m * rounds(x, y, z, v)\n    return res\n\ndef task():\n    (c, m, p, v) = mapInput()\n    print(rounds(c, m, p, v))\nfor _ in range(inp()):\n    task()", "for t in range(int(input())):\n    [c, m, p, v] = list(map(float, input().split()))\n\n    def dp(c, m, p, k):\n        if c < 1e-06:\n            c = 0\n        if m < 1e-06:\n            m = 0\n        a = min(c, v)\n        b = min(m, v)\n        if c == 0 and m == 0:\n            return (k + 1) * p\n        if m == 0:\n            return c * dp(c - a, m, p + a, k + 1) + (k + 1) * p\n        if c == 0:\n            return m * dp(c, m - b, p + b, k + 1) + (k + 1) * p\n        return c * dp(c - a, m + a / 2.0, p + a / 2.0, k + 1) + m * dp(c + b / 2.0, m - b, p + b / 2.0, k + 1) + (k + 1) * p\n    print(dp(c, m, p, 0))", "for t in range(int(input())):\n    [c, m, p, v] = list(map(float, input().split()))\n\n    def dp(c, m, p, k):\n        if c < 1e-06:\n            c = 0\n        if m < 1e-06:\n            m = 0\n        a = min(c, v)\n        b = min(m, v)\n        if c == 0 and m == 0:\n            return (k + 1) * p\n        if m == 0:\n            return c * dp(c - a, m, p + a, k + 1) + (k + 1) * p\n        if c == 0:\n            return m * dp(c, m - b, p + b, k + 1) + (k + 1) * p\n        return c * dp(c - a, m + a / 2.0, p + a / 2.0, k + 1) + m * dp(c + b / 2.0, m - b, p + b / 2.0, k + 1) + (k + 1) * p\n    print(dp(c, m, p, 0))", "from decimal import Decimal\n\ndef f(c, m, p, v):\n    if m == 0:\n        if c > v:\n            return c * (1 + f(c - v, 0, p + v, v)) + p\n        else:\n            return 2 * c + p\n    elif c == 0:\n        if m > v:\n            return m * (1 + f(0, m - v, p + v, v)) + p\n        else:\n            return 2 * m + p\n    if c <= v:\n        exp_if_c = f(0, m + c / 2, p + c / 2, v)\n    else:\n        exp_if_c = f(c - v, m + v / 2, p + v / 2, v)\n    if m <= v:\n        exp_if_m = f(c + m / 2, 0, p + m / 2, v)\n    else:\n        exp_if_m = f(c + v / 2, m - v, p + v / 2, v)\n    return c * (1 + exp_if_c) + m * (1 + exp_if_m) + p\nfor _ in range(int(input())):\n    (c, m, p, v) = map(Decimal, input().split())\n    print(f(c, m, p, v))", "from decimal import *\ngetcontext().prec = 20\n\ndef dfs(c, m, v):\n    ans = Decimal(1)\n    if c > 0:\n        if c <= v:\n            if m > 0:\n                ans += c * dfs(0, m + c / 2, v)\n            else:\n                ans += c * dfs(0, 0, v)\n        elif m > 0:\n            ans += c * dfs(c - v, m + v / 2, v)\n        else:\n            ans += c * dfs(c - v, 0, v)\n    if m > 0:\n        if m <= v:\n            if c > 0:\n                ans += m * dfs(c + m / 2, 0, v)\n            else:\n                ans += m * dfs(0, 0, v)\n        elif c > 0:\n            ans += m * dfs(c + v / 2, m - v, v)\n        else:\n            ans += m * dfs(0, m - v, v)\n    return ans\nt = int(input())\nfor i in range(t):\n    (c, m, p, v) = map(Decimal, input().split())\n    print(dfs(c, m, v))", "num_inp = lambda : int(input())\narr_inp = lambda : list(map(int, input().split()))\nsp_inp = lambda : map(int, input().split())\nstr_inp = lambda : input()\n\ndef calc(a, v):\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] > v + 1e-10:\n            b = a.copy()\n            b[i] -= v\n            if n == 2:\n                b[1 - i] += v / n\n            ans += (calc(b, v) + 1) * a[i]\n        elif n == 2:\n            ans += (calc([a[1 - i] + a[i] / 2], v) + 1) * a[i]\n        else:\n            ans += (1 + 1) * a[i]\n    ans += 1 * (1 - sum(a))\n    return ans\n\ndef solve_case():\n    a = list(map(float, input().split()))\n    print(f'{calc(a[:2], a[-1]):.12f}')\nn = int(input())\nfor i in range(n):\n    solve_case()", "from decimal import *\n\ndef numMoves(c, m, p, v):\n    ans = 1\n    if c != -1:\n        if c <= v:\n            if m != -1:\n                ans += c * numMoves(-1, m + c / 2, p + c / 2, v)\n            else:\n                ans += c * numMoves(-1, m, p + c, v)\n        elif m != -1:\n            ans += c * numMoves(c - v, m + v / 2, p + v / 2, v)\n        else:\n            ans += c * numMoves(c - v, m, p + v, v)\n    if m != -1:\n        if m <= v:\n            if c != -1:\n                ans += m * numMoves(c + m / 2, -1, p + m / 2, v)\n            else:\n                ans += m * numMoves(c, -1, p + m, v)\n        elif c != -1:\n            ans += m * numMoves(c + v / 2, m - v, p + v / 2, v)\n        else:\n            ans += m * numMoves(c, m - v, p + v, v)\n    return ans\nfor _ in range(int(input())):\n    lst = input().split()\n    c = Decimal(lst[0])\n    m = Decimal(lst[1])\n    p = Decimal(lst[2])\n    v = Decimal(lst[3])\n    print(numMoves(c, m, p, v))"]