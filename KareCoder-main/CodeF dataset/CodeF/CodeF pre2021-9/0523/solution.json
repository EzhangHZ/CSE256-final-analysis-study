["from math import factorial as f\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return f(n) // (f(k) * f(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + (2 * m - 1), 2 * m) % mod)", "from math import comb\n(n, m) = map(int, input().split())\nprint(comb(n + 2 * m - 1, 2 * m) % (10 ** 9 + 7))", "from math import factorial\n(n, m) = map(int, input().split())\nans = factorial(n + 2 * m - 1) // (factorial(2 * m) * factorial(n - 1))\nprint(ans % 1000000007)", "from math import comb\n(n, m) = map(int, input().split())\nprint(comb(n + 2 * m - 1, 2 * m) % (10 ** 9 + 7))", "import math\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef c(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n(a, b) = map(int, input().split())\nprint(c(a + 2 * b - 1, 2 * b) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "mod = 1000000007\ndp = [[0 for j in range(25)] for i in range(1005)]\n(n, m) = map(int, input().split())\nfor i in range(1, 2 * m + 1):\n    dp[1][i] = 1\nfor i in range(1, n + 1):\n    dp[i][1] = i\nfor i in range(2, n + 1):\n    for j in range(2, 2 * m + 1):\n        dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod\nprint(dp[n][2 * m])", "import sys\nfrom math import comb\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nprint(comb(n + 2 * m - 1, 2 * m) % 1000000007)", "(n, m) = map(int, input().split())\ndp = [[0] * 25 for i in range(1005)]\nmod = 1000000000.0 + 7\nfor i in range(1, 2 * m + 1):\n    dp[1][i] = 1\nfor i in range(1, n + 1):\n    dp[i][1] = i\nfor i in range(2, n + 1):\n    for j in range(2, 2 * m + 1):\n        dp[i][j] = int((dp[i - 1][j] + dp[i][j - 1]) % mod)\nprint(dp[n][2 * m])", "from math import comb\n(n, m) = map(int, input().split())\nprint(comb(n + 2 * m - 1, 2 * m) % (10 ** 9 + 7))", "import math\n\ndef ncr(n, r):\n    if r <= n:\n        return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\n    else:\n        return 0\n(n, m) = map(int, input().split())\nstars = 2 * m\nbars = n - 1\nprint(ncr(stars + bars, bars) % (10 ** 9 + 7))", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as f\n(n, m) = map(int, input().split())\nM = 10 ** 9 + 7\nprint(f(n + 2 * m - 1) // (f(2 * m) * f(n - 1)) % M)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nM = pow(10, 9) + 7\nans = 1\nfor i in range(n, 2 * m + n):\n    ans *= i\n    ans %= M\nr = 1\nfor i in range(1, 2 * m + 1):\n    r *= i\nans *= pow(r, M - 2, mod=M)\nans %= M\nprint(ans)", "from math import comb\n(n, m) = map(int, input().split())\nprint(comb(n + 2 * m - 1, 2 * m) % int(7 + 1000000000.0))", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import comb\nd = 1000000007\n(n, m) = map(int, input().split())\nsol = 0\nfor i in range(n):\n    sol += comb(i + m, m) * comb(n - i + m - 2, m - 1) % d\nprint(sol % d)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "import math\n\ndef ncr(n, r):\n    n = int(n)\n    r = int(r)\n    return math.factorial(n) // math.factorial(r) // math.factorial(n - r)\nM = 1000000007\n(n, m) = input().split()\nn = int(n)\nm = int(m)\nans = ncr(m + m + n - 1, n - 1)\nans %= M\nprint(ans)", "from math import factorial\nN = 10 ** 9 + 7\n\ndef ncr(n, r):\n    return factorial(n) // factorial(r) // factorial(n - r)\n(n, m) = map(int, input().split())\nprint(ncr(n + m + m - 1, m + m) % N)", "import math\nmod = pow(10, 9) + 7\n\ndef factori(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans = ans * i % mod\n    return ans\n\ndef tavan(n, m):\n    ans = 1\n    for i in range(m):\n        ans = ans * n % mod\n    return ans\n(n, m) = [int(i) for i in input().split()]\nprint(math.factorial(2 * m + n - 1) // math.factorial(2 * m) // math.factorial(n - 1) % mod)", "import math\n(n, m) = [int(_) for _ in input().split()]\nprint(math.comb(n + 2 * m - 1, 2 * m) % 1000000007)", "import math\n(n, m) = [int(i) for i in input().split()]\nmod = 10 ** 9 + 7\ntmp = math.comb(n + 2 * m - 1, 2 * m)\nprint(tmp % mod)", "import math\n(n, m) = list(map(int, input().split(' ')))\nprint(math.comb(n + 2 * m - 1, 2 * m) % (10 ** 9 + 7))", "(n, m) = map(int, input().split())\ndp_a = [[0] * n for _ in range(m)]\ndp_b = [[0] * n for _ in range(m)]\nfor i in range(n):\n    dp_a[0][i] = 1\nfor i in range(1, m):\n    for j in range(n):\n        dp_a[i][j] = (dp_a[i - 1][j] + dp_a[i][j - 1]) % (10 ** 9 + 7)\nfor i in range(m):\n    for j in range(n):\n        dp_b[i][j] = (dp_b[i][j - 1] + dp_a[i][j]) % (10 ** 9 + 7)\ncount = 0\nfor i in range(n):\n    try:\n        count += dp_a[m - 1][i] * dp_b[m - 1][n - i - 1]\n    except:\n        continue\nprint(count % 1000000007)", "from math import comb\n(n, m) = map(int, input().split())\nprint(comb(n + 2 * m - 1, 2 * m) % (10 ** 9 + 7))", "(n, m) = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\ndp_a = [[0 for _ in range(n)] for _ in range(m)]\ndp_b = [[0 for _ in range(n)] for _ in range(m)]\nfor j in range(0, n):\n    dp_a[0][j] = 1\nfor i in range(1, m):\n    for j in range(0, n):\n        dp_a[i][j] += dp_a[i][j - 1] + dp_a[i - 1][j]\n        dp_a[i][j] %= MOD\nfor i in range(0, m):\n    for j in range(0, n):\n        dp_b[i][j] += dp_b[i][j - 1] + dp_a[i][j]\n        dp_b[i][j] %= MOD\nans = 0\nfor j in range(0, n):\n    ans += dp_a[m - 1][j] * dp_b[m - 1][n - j - 1] % MOD\n    ans %= MOD\nprint(ans % MOD)", "from math import comb as c\n(n, m) = map(int, input().split())\nprint(c(n + 2 * m - 1, 2 * m) % 1000000007)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef nCr(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(nCr(n + 2 * m - 1, 2 * m) % mod)", "p = 10 ** 9 + 7\n\ndef power(x, y, p):\n    y = bin(y)[2:]\n    start = x\n    answer = 1\n    for i in range(len(y)):\n        if y[len(y) - i - 1] == '1':\n            answer = answer * start % p\n        start = start * start % p\n    return answer\n\ndef process(n, m):\n    num = 1\n    den = 1\n    for i in range(2 * m):\n        num *= 2 * m + n - 1 - i\n        den *= 2 * m - i\n    den2 = power(den, p - 2, p)\n    return num * den2 % p\n(n, m) = [int(x) for x in input().split()]\nprint(process(n, m))", "import sys\nfrom typing import List\nsys.setrecursionlimit(100000)\n_factorial_cache: List[int] = [1]\nMOD = 10 ** 9 + 7\n\ndef factorial(_x: int) -> int:\n    try:\n        return _factorial_cache[_x]\n    except IndexError:\n        _factorial_cache.append(_x * factorial(_x - 1))\n        return _factorial_cache[_x]\n(n, m) = [int(i) for i in input().split()]\nresult = factorial(n + 2 * m - 1) // (factorial(2 * m) * factorial(n - 1))\nprint(result % MOD)", "mod = 10 ** 9 + 7\n(n, m) = map(int, input().split())\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(n + 1):\n    dp[0][i] = 1\nfor cnt in range(1, m + 1):\n    for mx in range(1, n + 1):\n        dp[cnt][mx] = dp[cnt][mx - 1] + dp[cnt - 1][mx]\n\ndef dfs(mx, cnt):\n    return dp[cnt - 1][mx]\n\ndef dfs_r(mx, cnt):\n    return dp[cnt][mx]\ns = 0\nfor i in range(1, n + 1):\n    left = i\n    right = n - i + 1\n    s += dfs(left, m) * dfs_r(right, m)\n    s %= mod\nprint(s)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "(n, m) = list(map(int, input().split()))\n\ndef c(n, r):\n    res = 1\n    if r > n - r:\n        r = n - r\n    for i in range(0, r):\n        res = res * (n - i)\n        res = res // (i + 1)\n    return res\nans = c(n + 2 * m - 1, 2 * m) % 1000000007\nprint(ans)", "import math\nf = math.factorial\n(n, m) = map(int, input().split())\nprint(f(2 * m + n - 1) // f(2 * m) // f(n - 1) % (10 ** 9 + 7))", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "mod = 10 ** 9 + 7\n\ndef combination(n, r):\n    if r > n - r:\n        r = n - r\n    res = 1\n    for i in range(1, r + 1):\n        res *= n - i + 1\n        res //= i\n    return res\n(n, m) = map(int, input().split())\nprint(combination(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n(n, m) = map(int, input().split())\nsol = fact(n + 2 * m - 1) // (fact(2 * m) * fact(n - 1))\nprint(sol % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "mod = 10 ** 9 + 7\nfrom math import factorial\n\ndef func(n, c):\n    return factorial(n) // (factorial(n - c) * factorial(c))\n(a, b) = map(int, input().rstrip().split())\nprint(int(func(a + 2 * b - 1, 2 * b) % mod))", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "import math\nimport sys\n\ndef get_single_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n(n, m) = get_ints()\nprint(math.comb(n + 2 * m - 1, 2 * m) % (10 ** 9 + 7))", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "import math\nf = math.factorial\n(n, m) = map(int, input().split())\nprint(f(n + 2 * m - 1) // f(2 * m) // f(n - 1) % (10 ** 9 + 7))", "import os, sys\nfrom io import BytesIO, IOBase\n\ndef ii():\n    return int(input())\n\ndef si():\n    return input()\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\nimport math\nfor i in range(1):\n    (n, m) = mi()\n    ans = 1\n    for i in range(n, n + 2 * m):\n        ans *= i\n    ans //= math.factorial(2 * m)\n    print(ans % 1000000007)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n(n, m) = map(int, input().split())\nans = fact(n + 2 * m - 1) // (fact(2 * m) * fact(n - 1)) % mod\nprint(int(ans))", "from math import factorial as fact\n\ndef func(a, b):\n    return fact(a) // (fact(b) * fact(a - b))\n(n, m) = input().split()\nn = int(n)\nm = int(m)\nprint(func(n + 2 * m - 1, 2 * m) % 1000000007)", "def solve(n, m):\n    m *= 2\n    answer = 1\n    for i in range(m):\n        answer = answer * (n + i) // (i + 1)\n    print(answer % 1000000007)\n(n, m) = map(int, input().split())\nsolve(n, m)", "mo = 10 ** 9 + 7\nfrom math import factorial as fuck\n(n, m) = map(int, input().split())\na = fuck(n + 2 * m - 1)\na = a // fuck(n - 1)\na = a // fuck(2 * m)\nprint(a % mo)", "from math import factorial as fact\n(n, m) = map(int, input().split())\nmod = 1000000007\nn1 = n + 2 * m - 1\nr = 2 * m\nans = fact(n1) // (fact(r) * fact(n1 - r))\nprint(ans % mod)", "from math import factorial as fact\nmo = 10 ** 9 + 7\n(n, m) = map(int, input().split())\nf = fact(n + 2 * m - 1)\nf = f // (fact(2 * m) * fact(n - 1))\nprint(f % mo)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "import math\nf = math.factorial\n(n, m) = map(int, input().split())\nprint(f(n + 2 * m - 1) // f(2 * m) // f(n - 1) % (10 ** 9 + 7))", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\n\ndef comb(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = [int(x) for x in input().split()]\nM = 1000000007\nprint(comb(n + 2 * m - 1, 2 * m) % M)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef Ct(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(Ct(n + 2 * m - 1, 2 * m) % mod)", "import math\n(n, m) = map(int, input().split())\nprint(math.factorial(n + 2 * m - 1) // (math.factorial(2 * m) * math.factorial(n - 1)) % 1000000007)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return factorial(n) // (factorial(n - k) * factorial(k))\n(n, m) = list(map(int, input().split()))\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "def ncr(n, r):\n    if n == 1:\n        return n\n    end = max(r, n - r)\n    temp = 1\n    for i in range(n, end, -1):\n        temp *= i\n    return temp // math.factorial(min(r, n - r))\nmod = 1000000007\n(n, m) = map(int, input().split())\nimport math\nprint(ncr(2 * m + n - 1, n - 1) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "import math\nmod = 10 ** 9 + 7\n\ndef cbn(n, k):\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n(k, n) = map(int, input().split(' '))\nprint(cbn(2 * n + k - 1, 2 * n) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "import sys\nsys.setrecursionlimit(10 ** 5)\ninput = sys.stdin.readline\nMOD = 10 ** 9 + 7\nMAX_N = 2000\n\ndef single_mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    if r > n - r:\n        r = n - r\n    ret = 1\n    for i in range(r):\n        ret *= n - i\n        ret *= pow(i + 1, MOD - 2, MOD)\n        ret %= MOD\n    return ret\n(n, m) = [int(item) for item in input().split()]\nprint(single_mod_nCr(n + m * 2 - 1, m * 2))", "s = input().split()\nn = int(s[0])\nm = int(s[1])\nm *= 2\nf1 = 1\nfor i in range(2, n + m):\n    f1 *= i\nf2 = 1\nfor i in range(2, n):\n    f2 *= i\nf3 = 1\nfor i in range(2, m + 1):\n    f3 *= i\nmd = int(1000000000.0 + 7)\nans = f1 // (f2 * f3) % md\nprint(ans)", "(n, m) = [int(x) for x in input().split(' ')]\ntop = 2 * m + n - 1\nm *= 2\nans = 1\ndiv = 1\nwhile m:\n    ans *= top\n    div *= m\n    top -= 1\n    m -= 1\nprint(ans // div % (10 ** 9 + 7))", "mod = [10 ** 9 + 7]\n\ndef fact(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n        ans %= mod[0]\n    return ans\n(n, m) = map(int, input().split())\nval = fact(n + 2 * m - 1)\nval *= pow(fact(n - 1), mod[0] - 2, mod[0])\nval %= mod[0]\nval *= pow(fact(2 * m), mod[0] - 2, mod[0])\nval %= mod[0]\nprint(val)", "MOD = 10 ** 9 + 7\nf = [1]\nfor i in range(1020):\n    f.append(f[-1] * (i + 1) % MOD)\n\ndef nCr(n, r, mod=MOD):\n    return f[n] * pow(f[r], mod - 2, mod) * pow(f[n - r], mod - 2, mod) % mod\n(n, m) = map(int, input().split())\nans = nCr(n + 2 * m - 1, 2 * m)\nprint(ans)", "md = 10 ** 9 + 7\n(n, m) = map(int, input().split())\ndp = [0] + [1] * n\nfor _ in range(2 * m):\n    for i in range(1, n + 1):\n        a = dp[i]\n        b = dp[i - 1]\n        dp[i] = (a + b) % md\nprint(dp[n])", "(n, m) = map(int, input().split())\nmat = [[0] * m for i in range(n + 1)]\nfor i in range(1, n + 1):\n    mat[i][0] = i * (i + 1) // 2\n    for j in range(1, m):\n        mat[i][j] = mat[i][j - 1] + mat[i - 1][j] + mat[i - 1][j] - mat[i - 2][j]\nprint(mat[n][m - 1] % (10 ** 9 + 7))", "import itertools\n\ndef C(n, k):\n    if 0 <= k <= n:\n        nn = 1\n        kk = 1\n        for t in range(1, min(k, n - k) + 1):\n            nn *= n\n            kk *= t\n            n -= 1\n        return nn // kk\n    else:\n        return 0\nls = list(map(int, input().split()))\nn = ls[0]\nm = ls[1]\nprint(C(n + 2 * m - 1, 2 * m) % 1000000007)", "from math import factorial\n\ndef C(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\n(N, M) = [int(i) for i in input().split()]\nmodulo = 10 ** 9 + 7\nprint(C(N + 2 * M - 1, 2 * M) % modulo)", "import math\nMOD = 10 ** 9 + 7\n(n, m) = map(int, input().split(' '))\nans = math.factorial(n + 2 * m - 1) // (math.factorial(2 * m) * math.factorial(n - 1)) % MOD\nprint(ans)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef nCr(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n(n, m) = map(int, input().split())\nprint(nCr(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 1000000007\n\ndef ncr(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n(n, m) = map(int, input().split())\nprint(ncr(n + 2 * m - 1, 2 * m) % mod)", "from math import factorial as fact\nmod = 10 ** 9 + 7\n\ndef C(n, k):\n    return fact(n) // (fact(n - k) * fact(k))\n(n, m) = map(int, input().split())\nprint(C(n + 2 * m - 1, 2 * m) % mod)", "MOD = 10 ** 9 + 7\n\ndef pow_mod(n, k, mod):\n    if k == 0:\n        return 1\n    if k % 2 == 1:\n        return n * pow_mod(n, k - 1, mod) % mod\n    else:\n        r = pow_mod(n, k // 2, mod)\n        return r * r % mod\n\ndef mod_inverse(n, mod):\n    return pow_mod(n, mod - 2, mod)\n\ndef fact_mod(n, mod):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i % mod\n    return res\n\ndef choose_mod(n, k, mod):\n    return fact_mod(n, mod) * mod_inverse(fact_mod(k, mod), mod) * mod_inverse(fact_mod(n - k, mod), mod) % mod\n(n, m) = map(int, input().split())\nprint(choose_mod(n + 2 * m - 1, 2 * m, MOD))", "import math\nf = math.factorial\n(n, m) = map(int, input().split())\nprint(f(n + 2 * m - 1) // f(2 * m) // f(n - 1) % (10 ** 9 + 7))", "from math import factorial as fact\n\ndef C(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n(n, m) = map(int, input().split())\nmod = 10 ** 9 + 7\nprint(C(2 * m + n - 1, n - 1) % mod)", "mod = 10 ** 9 + 7\n(n, m) = list(map(int, input().split(' ')))\n\ndef fact(n):\n    res = 1\n    while n > 1:\n        res *= n\n        n -= 1\n    return res\n\ndef C(n, m):\n    return fact(n) // (fact(m) * fact(n - m))\n\ndef H(n, m):\n    return C(n + m - 1, m)\nprint(H(n, 2 * m) % mod)"]