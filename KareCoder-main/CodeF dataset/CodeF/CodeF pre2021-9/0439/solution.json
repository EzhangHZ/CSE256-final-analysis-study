["from operator import sub\n\ndef main():\n    n_tests = int(input())\n    return '\\n'.join((nMoves() for i in range(n_tests)))\nletters = 'abcdefghijklmnopqr'\nlog2 = {1: 0, 2: 1, 4: 2, 8: 3, 16: 4, 32: 5, 64: 6, 128: 7, 256: 8, 512: 9, 1024: 10, 2048: 11, 4096: 12, 8192: 13, 16384: 14, 32768: 15, 65536: 16, 131072: 17}\nmemo = {1: ((0, 1), (1, 0))}\n\ndef nMoves():\n    input()\n    badString = input()\n    if len(badString) == 1:\n        return '1' if badString != 'a' else '0'\n    return str(sub(len(badString), analyze(badString, 0, 0, i_l=len(badString))))\n\ndef analyze(string, n, i_f, i_l):\n    n_1 = n + 1\n    if i_f + 2 == i_l:\n        return max((string[i_f] == letters[n]) + (string[i_f + 1] == letters[n_1]), (string[i_f] == letters[n_1]) + (string[i_f + 1] == letters[n]))\n    i_m = (i_f + i_l) // 2\n    return max(string[i_f:i_m].count(letters[n]) + analyze(string, n_1, i_m, i_l), string[i_m:i_l].count(letters[n]) + analyze(string, n_1, i_f, i_m))\nprint(main())", "cache = {}\n\ndef foo(c, s):\n    if len(s) == 1:\n        if s == c:\n            return 0\n        return 1\n    if (c, s) in cache:\n        return cache[c, s]\n    n = len(s)\n    mid = n >> 1\n    first = s[:mid]\n    second = s[mid:]\n    val1 = mid - first.count(c) + foo(chr(ord(c) + 1), second)\n    val2 = mid - second.count(c) + foo(chr(ord(c) + 1), first)\n    val = min(val1, val2)\n    cache[c, s] = val\n    return val\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    print(foo('a', s))", "import sys\nimport math\nfrom bisect import bisect_right as br\nfrom statistics import mode\nfrom itertools import combinations as cb\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef check(st, ch):\n    n = len(st)\n    mid = n // 2\n    if n == 1:\n        if st == ch:\n            return 0\n        else:\n            return 1\n    return min(mid - st[:mid].count(ch) + check(st[mid:], chr(ord(ch) + 1)), mid - st[mid:].count(ch) + check(st[:mid], chr(ord(ch) + 1)))\nfor _ in range(int(input())):\n    n = int(input())\n    st = input()\n    print(check(st, 'a'))", "def create_cases(data1, data2):\n    cases = []\n    answers = []\n    data1 = data1.split('\\n')[1:]\n    data2 = data2.split('\\n')\n    for i in data1:\n        if len(i) == 1:\n            continue\n        x = list(map(int, i.split()))\n        cases.append(x)\n    for i in data2:\n        answers.append(list(map(int, i)))\n    return (cases, answers)\n\ndef f(cases):\n    answers = []\n    for case in cases:\n        answer = calc(case, 0)\n        answers.append(answer)\n    return answers\nletters = 'abcdefghijklmnopqrstuvwxyz'\n\ndef calc(s, i):\n    if len(s) == 1:\n        if s == letters[i]:\n            return 0\n        return 1\n    mid = len(s) // 2\n    cntl = mid - s[mid:].count(letters[i]) + calc(s[:mid], i + 1)\n    cntr = mid - s[:mid].count(letters[i]) + calc(s[mid:], i + 1)\n    return min(cntl, cntr)\nn = int(input())\ncases = []\nwhile n > 0:\n    input()\n    cases.append(input())\n    n -= 1\nanswers = f(cases)\nfor answer in answers:\n    print(answer)", "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time\nsys.setrecursionlimit(5 * 10 ** 5)\ninf = 10 ** 20\nmod = 10 ** 9 + 7\n\ndef LI():\n    return list(map(int, input().split()))\n\ndef II():\n    return int(input())\n\ndef LS():\n    return list(input().split())\n\ndef S():\n    return input()\n\ndef dfs(s, x):\n    if len(s) == 1:\n        return 0 if s == x else 1\n    n = len(s) // 2\n    s_first = s[:n]\n    s_second = s[n:]\n    nx = chr(ord('a') + (ord(x) - ord('a') + 1) % 26)\n    ans_first = n - s_first.count(x) + dfs(s_second, nx)\n    ans_second = n - s_second.count(x) + dfs(s_first, nx)\n    return min(ans_first, ans_second)\n\ndef solve():\n    n = II()\n    s = S()\n    return dfs(s, 'a')\n\ndef main():\n    t = II()\n    res = list()\n    for _ in range(t):\n        res.append(solve())\n    for ans in res:\n        print(ans)\n    return 0\nmain()", "import sys, math\nsys.setrecursionlimit(1000000)\nINF = 1 << 100\nmod = 1000000007\ninput = lambda : sys.stdin.readline().rstrip()\nli = lambda : list(map(int, input().split()))\n\ndef f(S, depth):\n    N = len(S)\n    l = chr(ord('a') + depth)\n    if N == 1:\n        if l == S:\n            return 0\n        return 1\n    x = N // 2 - S[N // 2:].count(l) + f(S[:N // 2], depth + 1)\n    y = N // 2 - S[:N // 2].count(l) + f(S[N // 2:], depth + 1)\n    return min(x, y)\nt = int(input())\noutput = []\nfor _ in range(t):\n    N = int(input())\n    S = input()\n    ans = f(S, 0)\n    output.append(ans)\nfor o in output:\n    print(o)", "from collections import defaultdict\nfrom sys import setrecursionlimit, stdin, stdout\nsetrecursionlimit(10 ** 5)\nel = list('abcdefghijklmnopqrstuvwxyz')\nfor _ in range(int(stdin.readline().strip())):\n    n = int(stdin.readline().strip())\n    s = list(stdin.readline().strip())\n\n    def getans(s, char):\n        n = len(s)\n        if n == 1:\n            if s[0] == el[char]:\n                return 0\n            else:\n                return 1\n        tot = n // 2\n        sl = s[:tot]\n        c1 = tot - sl.count(el[char])\n        sr = s[tot:]\n        c2 = tot - sr.count(el[char])\n        return min(c1 + getans(sr, char + 1), c2 + getans(sl, char + 1))\n    print(getans(s, 0))", "from sys import stdin, stdout\nfrom collections import Counter\nfrom itertools import permutations\nimport bisect\nimport math\nI = lambda : map(int, stdin.readline().split())\nI1 = lambda : stdin.readline()\n\ndef fun(s, l, i, n):\n    if n == 1:\n        if s == l[i]:\n            return 0\n        else:\n            return 1\n    x = s[:n // 2]\n    y = s[n // 2:]\n    c1 = x.count(l[i])\n    c2 = y.count(l[i])\n    a = n // 2 - c1 + fun(y, l, i + 1, n // 2)\n    b = n // 2 - c2 + fun(x, l, i + 1, n // 2)\n    return min(a, b)\nfor _ in range(int(I1())):\n    n = int(I1())\n    s = I1().strip()\n    l = 'abcdefghijklmnopqrstuvwxyz'\n    r = fun(s, l, 0, n)\n    print(r)", "CASES = []\n\ndef compute_min_cost(case, match='a'):\n    s = case\n    if len(s) != 1:\n        m = int(len(s) / 2)\n        l = compute_min_cost(s[:m], chr(ord(match) + 1))\n        l += m - s[m:].count(match)\n        r = compute_min_cost(s[m:], chr(ord(match) + 1))\n        r += m - s[:m].count(match)\n        return min(l, r)\n    else:\n        if s == match:\n            return 0\n        return 1\n\ndef process():\n    [print(compute_min_cost(case)) for case in CASES]\n\ndef entrypoint():\n    t = int(input())\n    for _ in range(t):\n        _ = int(input())\n        string = input()\n        CASES.append(string)\n\ndef main():\n    entrypoint()\n    process()\nmain()", "def agood(string, length, entry):\n    if length == 1:\n        if string == entry:\n            return 0\n        else:\n            return 1\n    center = length // 2\n    left = string[:center]\n    right = string[center:]\n    next_chr = chr(ord(entry) + 1)\n    count_left = len(left) - left.count(entry) + agood(right, center, next_chr)\n    count_right = len(right) - right.count(entry) + agood(left, center, next_chr)\n    return count_left if count_left < count_right else count_right\nentry = int(input())\ninitial_entry = 'a'\nfor _ in range(entry):\n    length = int(input())\n    string = input()\n    print(agood(string.strip(), length, initial_entry))", "def goodString(word, c):\n    size = len(word)\n    if size == 1:\n        return 1 if word != c else 0\n    nextC = chr(ord(c) + 1)\n    center = size // 2\n    one = word[:center]\n    two = word[center:]\n    countC1 = one.count(c)\n    countC2 = two.count(c)\n    stepOne = len(one) - countC1 + goodString(two, nextC)\n    stepTwo = len(two) - countC2 + goodString(one, nextC)\n    if stepOne < stepTwo:\n        return stepOne\n    else:\n        return stepTwo\nn = int(input())\nfor i in range(n):\n    size = int(input())\n    word = input()\n    print(goodString(word, 'a'))", "import sys\nsys.setrecursionlimit(2147483647)\ninput = sys.stdin.readline\nalpha = 'abcdefghijklmnopqrstuvwxyz'\n\ndef count_insert(arr, index):\n    length = len(arr)\n    char = alpha[index % 26]\n    if length == 1:\n        if arr == char:\n            return 0\n        else:\n            return 1\n    return min(count_insert(arr[0:length // 2], index + 1) + length // 2 - arr[length // 2:].count(char), count_insert(arr[length // 2:], index + 1) + length // 2 - arr[:length // 2].count(char))\n\ndef main():\n    n = int(input())\n    arr = []\n    for _ in range(n):\n        t = int(input())\n        arr.append(input().rstrip())\n    for i in range(n):\n        print(count_insert(arr[i], 0))\nmain()", "def main():\n    c = 'a'\n    number = int(input())\n    for i in range(number):\n        length = int(input())\n        string = input()\n        print(minimum_number(string, length, c))\n\ndef minimum_number(string, length, c):\n    if length == 1:\n        if string == c:\n            return 0\n        else:\n            return 1\n    else:\n        single = chr(1 + ord(c))\n        half = length // 2\n        first = string[:half]\n        last = string[half:]\n        single = chr(1 + ord(c))\n        valueA = len(first) - first.count(c) + minimum_number(last, len(last), single)\n        valueB = len(last) - last.count(c) + minimum_number(first, len(first), single)\n        if valueA < valueB:\n            return valueA\n        else:\n            return valueB\nmain()", "def goodString(word, size, single):\n    if size == 1:\n        return 1 if word != single else 0\n    single2 = chr(1 + ord(single))\n    mid = size // 2\n    firstWord = word[:mid]\n    lastWord = word[mid:]\n    single2 = chr(1 + ord(single))\n    calculoOne = len(firstWord) - firstWord.count(single) + goodString(lastWord, len(lastWord), single2)\n    calculoTwo = len(lastWord) - lastWord.count(single) + goodString(firstWord, len(firstWord), single2)\n    if calculoOne < calculoTwo:\n        return calculoOne\n    else:\n        return calculoTwo\nnumberIn = int(input())\nfor i in range(numberIn):\n    size = int(input())\n    word = input()\n    print(goodString(word, size, 'a'))", "def main():\n    c = 'a'\n    number = int(input())\n    for i in range(number):\n        length = int(input())\n        string = input()\n        print(minimum_number(string, length, c))\n\ndef minimum_number(string, length, c):\n    if length == 1:\n        if string == c:\n            return 0\n        else:\n            return 1\n    else:\n        half = length // 2\n        first = string[:half]\n        last = string[half:]\n        aux = chr(1 + ord(c))\n        valueA = len(first) - first.count(c) + minimum_number(last, len(last), aux)\n        valueB = len(last) - last.count(c) + minimum_number(first, len(first), aux)\n        if valueA < valueB:\n            return valueA\n        else:\n            return valueB\nmain()", "def main():\n    c = 'a'\n    number = int(input())\n    for i in range(number):\n        length = int(input())\n        string = input()\n        print(minimum_number(string, length, c))\n\ndef minimum_number(string, length, c):\n    if length == 1:\n        if string == c:\n            return 0\n        else:\n            return 1\n    else:\n        half = length // 2\n        first = string[:half]\n        last = string[half:]\n        aux = chr(1 + ord(c))\n        valueA = len(first) - first.count(c) + minimum_number(last, len(last), aux)\n        valueB = len(last) - last.count(c) + minimum_number(first, len(first), aux)\n        if valueA < valueB:\n            return valueA\n        else:\n            return valueB\nmain()", "def dfs(s, q, n):\n    o = chr(q)\n    if n == 1:\n        return 1 - (s == o)\n    return min(n // 2 - s[:n // 2].count(o) + dfs(s[n // 2:], q + 1, n // 2), n // 2 - s[n // 2:].count(o) + dfs(s[:n // 2], q + 1, n // 2))\nq = ord('a')\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(dfs(s, q, n))", "def good(l, c):\n    ch = chr(c)\n    if len(l) == 1:\n        return 1 if ch != l[0] else 0\n    x = len(l) // 2\n    lm = x - l[:x].count(ch) + good(l[x:], c + 1)\n    rm = x - l[x:].count(ch) + good(l[:x], c + 1)\n    return min(lm, rm)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    print(good(s, ord('a')))", "def ans(s, c):\n    n = len(s)\n    if n == 1:\n        return int(ord(s[0]) != c)\n    n = n // 2\n    return min(ans(s[:n], c + 1) + n - s[n:].count(chr(c)), ans(s[n:], c + 1) + n - s[:n].count(chr(c)))\nfor _ in range(int(input())):\n    input()\n    print(ans(input(), 97))", "def ans(s, c):\n    n = len(s)\n    if n == 1:\n        return int(ord(s[0]) != c)\n    n //= 2\n    return min(ans(s[:n], c + 1) + n - s[n:].count(chr(c)), ans(s[n:], c + 1) + n - s[:n].count(chr(c)))\nfor _ in range(int(input())):\n    input()\n    print(ans(input(), 97))", "def g(s, c):\n    n = len(s)\n    if n == 1:\n        return int(ord(s[0]) != c)\n    n //= 2\n    return min(g(s[:n], c + 1) + n - s[n:].count(chr(c)), g(s[n:], c + 1) + n - s[:n].count(chr(c)))\nfor _ in range(int(input())):\n    input()\n    print(g(input(), 97))", "T = int(input())\n\ndef f(x, z):\n    if len(x) == 0:\n        return 0\n    if len(x) == 1:\n        return int(x != z)\n    m = len(x) // 2\n    L = x[:m]\n    R = x[m:]\n    a = m - L.count(z) + f(R, chr(ord(z) + 1))\n    b = m - R.count(z) + f(L, chr(ord(z) + 1))\n    return min(a, b)\nwhile T:\n    n = int(input())\n    S = input()\n    print(f(S, 'a'))\n    T = T - 1", "def calc(s, n, c):\n    if n == 1:\n        if s[0] != c:\n            return 1\n        else:\n            return 0\n    mid = n // 2\n    s1 = s[:n // 2]\n    l1 = s1.count(c)\n    s2 = s[n // 2:]\n    r2 = s2.count(c)\n    cntl = mid - l1 + calc(s2, n // 2, chr(ord(c) + 1))\n    cntr = mid - r2 + calc(s1, n // 2, chr(ord(c) + 1))\n    return min(cntl, cntr)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(calc(s, n, 'a'))", "def goodstring(s, h, impind):\n    if len(s) == 1:\n        if s[0] != h[impind]:\n            return 1\n        else:\n            return 0\n    mid = len(s) // 2\n    p = goodstring(s[:mid], h, impind + 1) + mid - s[mid:].count(h[impind])\n    q = goodstring(s[mid:], h, impind + 1) + mid - s[:mid].count(h[impind])\n    return min(p, q)\nT = int(input())\nh = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h', 9: 'i', 10: 'j', 11: 'k', 12: 'l', 13: 'm', 14: 'n', 15: 'o', 16: 'p', 17: 'q', 18: 'r', 19: 's', 20: 't', 21: 'u', 22: 'v', 23: 'w', 24: 'x', 25: 'y', 26: 'z'}\nfor i in range(T):\n    n = int(input())\n    s = input()\n    print(goodstring(s, h, 1))", "def good(l, c):\n    ch = chr(c)\n    if len(l) == 1:\n        return int(ch != l[0])\n    k = len(l) // 2\n    lm = k - l[:k].count(ch) + good(l[k:], c + 1)\n    rm = k - l[k:].count(ch) + good(l[:k], c + 1)\n    return min(lm, rm)\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    print(good(a, ord('a')))", "from operator import le\n\ndef tinh(s, c):\n    if len(s) == 1:\n        if s[0] == c:\n            return 0\n        else:\n            return 1\n    mid = len(s) // 2\n    left = s[0:mid]\n    right = s[mid:len(s)]\n    cntl = left.count(c)\n    cntr = right.count(c)\n    l = mid - cntl + tinh(right, chr(ord(c) + 1))\n    r = mid - cntr + tinh(left, chr(ord(c) + 1))\n    return min(l, r)\nfor t in range(int(input())):\n    n = int(input())\n    s = input()\n    print(tinh(s, 'a'))", "def cgood(palavra, c):\n    tamanho = len(palavra)\n    if tamanho == 1:\n        return 1 if palavra != c else 0\n    proximo_c = chr(ord(c) + 1)\n    centro = tamanho // 2\n    parte1 = palavra[:centro]\n    parte2 = palavra[centro:]\n    countC1 = parte1.count(c)\n    countC2 = parte2.count(c)\n    passosParte1 = len(parte1) - countC1 + cgood(parte2, proximo_c)\n    passosParte2 = len(parte2) - countC2 + cgood(parte1, proximo_c)\n    if passosParte1 < passosParte2:\n        return passosParte1\n    else:\n        return passosParte2\nn = int(input())\nfor i in range(n):\n    tamanho = int(input())\n    palavra = input()\n    print(cgood(palavra, 'a'))", "def solve(array, letter):\n    if len(array) == 1:\n        if array[0] == letter:\n            return 0\n        else:\n            return 1\n    mid = len(array) // 2\n    l_side = array[:mid]\n    r_side = array[mid:]\n    l_occ = mid - l_side.count(letter) + solve(r_side, chr(ord(letter) + 1))\n    r_occ = mid - r_side.count(letter) + solve(l_side, chr(ord(letter) + 1))\n    return min(l_occ, r_occ)\nfor _ in range(int(input())):\n    n = int(input())\n    s = list(input())\n    print(solve(s, 'a'))", "def good_str(s, x, n):\n    if n == 1:\n        if s[0] == chr(x):\n            return 0\n        else:\n            return 1\n    else:\n        s1 = s[:n // 2]\n        s2 = s[n // 2:]\n        p = s1.count(chr(x))\n        q = s2.count(chr(x))\n        right = n // 2 - p + good_str(s2, x + 1, n // 2)\n        left = n // 2 - q + good_str(s1, x + 1, n // 2)\n        return min(right, left)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    result = good_str(s, 97, n)\n    print(result)", "def ans(s, n, c):\n    if n == 1:\n        return 0 if s[0] == c else 1\n    s1 = s[0:n // 2]\n    s2 = s[n // 2:]\n    x = s1.count(c)\n    sx1 = n // 2 - x + ans(s2, n // 2, chr(ord(c) + 1))\n    x = s2.count(c)\n    sx2 = n // 2 - x + ans(s1, n // 2, chr(ord(c) + 1))\n    return min(sx1, sx2)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    l = [i for i in input()]\n    print(ans(l, n, 'a'))\n    t -= 1", "def good(l, c):\n    ch = chr(c)\n    if len(l) == 1:\n        return 1 if ch != l[0] else 0\n    x = len(l) // 2\n    lm = x - l[:x].count(ch) + good(l[x:], c + 1)\n    rm = x - l[x:].count(ch) + good(l[:x], c + 1)\n    return min(lm, rm)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    print(good(s, ord('a')))", "def countGood(s, c):\n    curlen = len(s)\n    if curlen == 1:\n        if s[0] == c:\n            return 0\n        else:\n            return 1\n    else:\n        countL = 0\n        for letter in s[:curlen // 2]:\n            if letter != c:\n                countL += 1\n        countL += countGood(s[curlen // 2:], chr(ord(c) + 1))\n        countR = 0\n        for letter in s[curlen // 2:]:\n            if letter != c:\n                countR += 1\n        countR += countGood(s[:curlen // 2], chr(ord(c) + 1))\n        return countL if countL < countR else countR\nt = int(input())\nfor j in range(t):\n    n = int(input())\n    s = input()\n    print(countGood(s, 'a'))", "def good(s, letter):\n    if len(s) == 1:\n        if s == letter:\n            return 0\n        else:\n            return 1\n    half = len(s) // 2\n    first = s[:half]\n    second = s[half:]\n    return min(half - first.count(letter) + good(second, chr(ord(letter) + 1)), half - second.count(letter) + good(first, chr(ord(letter) + 1)))\ntotal = int(input())\nfor _ in range(total):\n    len_n = input()\n    original = input().strip()\n    print(good(original, 'a'))", "def goodString(word, size, single):\n    if size == 1:\n        return 1 if word != single else 0\n    single2 = chr(1 + ord(single))\n    mid = size // 2\n    firstWord = word[:mid]\n    lastWord = word[mid:]\n    single2 = chr(1 + ord(single))\n    calculoOne = len(firstWord) - firstWord.count(single) + goodString(lastWord, len(lastWord), single2)\n    calculoTwo = len(lastWord) - lastWord.count(single) + goodString(firstWord, len(firstWord), single2)\n    if calculoOne < calculoTwo:\n        return calculoOne\n    else:\n        return calculoTwo\nnumberIn = int(input())\nfor i in range(numberIn):\n    size = int(input())\n    word = input()\n    print(goodString(word, size, 'a'))", "def goodString(word, size, single):\n    if size == 1:\n        return 1 if word != single else 0\n    single2 = chr(1 + ord(single))\n    mid = size // 2\n    firstWord = word[:mid]\n    lastWord = word[mid:]\n    single2 = chr(1 + ord(single))\n    calculoOne = len(firstWord) - firstWord.count(single) + goodString(lastWord, len(lastWord), single2)\n    calculoTwo = len(lastWord) - lastWord.count(single) + goodString(firstWord, len(firstWord), single2)\n    if calculoOne < calculoTwo:\n        return calculoOne\n    else:\n        return calculoTwo\n\ndef main():\n    numberIn = int(input())\n    for i in range(numberIn):\n        size = int(input())\n        word = input()\n        print(goodString(word, size, 'a'))\nmain()", "def minimum_moves(s, c):\n    if len(s) == 1:\n        if s != c:\n            return 1\n        else:\n            return 0\n    middle = len(s) // 2\n    left_part = s[:middle]\n    right_part = s[middle:]\n    right_moves = len(right_part) - right_part.count(c) + minimum_moves(left_part, chr(ord(c) + 1))\n    left_moves = len(left_part) - left_part.count(c) + minimum_moves(right_part, chr(ord(c) + 1))\n    return min(left_moves, right_moves)\nn = int(input())\nfor i in range(n):\n    size = int(input())\n    s = input()\n    print(minimum_moves(s, 'a'))", "t = int(input())\n\ndef minimo(string, letra):\n    if len(string) == 1:\n        if string[0] == letra:\n            return 0\n        else:\n            return 1\n    primeira_metade = string[0:len(string) // 2]\n    segunda_metade = string[len(string) // 2:len(string)]\n    faltam_primeira_metade = len(primeira_metade) - primeira_metade.count(letra)\n    faltam_segunda_metade = len(segunda_metade) - segunda_metade.count(letra)\n    proxima_letra = chr(ord(letra) + 1)\n    total_primeira_condicao = faltam_primeira_metade + minimo(segunda_metade, proxima_letra)\n    total_segunda_condicao = faltam_segunda_metade + minimo(primeira_metade, proxima_letra)\n    return min(total_primeira_condicao, total_segunda_condicao)\nfor i in range(t):\n    n = int(input())\n    s = input()\n    print(minimo(s, 'a'))", "def calc(s, n, c):\n    if n == 1:\n        if s[0] != c:\n            return 1\n        else:\n            return 0\n    mid = n // 2\n    s1 = s[:n // 2]\n    l1 = s1.count(c)\n    s2 = s[n // 2:]\n    r2 = s2.count(c)\n    cntl = mid - l1 + calc(s2, n // 2, chr(ord(c) + 1))\n    cntr = mid - r2 + calc(s1, n // 2, chr(ord(c) + 1))\n    return min(cntl, cntr)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(calc(s, n, 'a'))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef rec(i, j, k):\n    if i == j:\n        if s[i] == chr(k):\n            return 0\n        return 1\n    else:\n        mid = (i + j) // 2\n        char = chr(k)\n        l = (j - i + 1) // 2\n        l1 = s[i:mid + 1].count(char)\n        l2 = s[mid + 1:j + 1].count(char)\n        return min(l - l1 + rec(mid + 1, j, k + 1), l - l2 + rec(i, mid, k + 1))\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(rec(0, n - 1, 97))", "def solve(s, ch):\n    if len(s) == 1:\n        if ch == s:\n            return 0\n        else:\n            return 1\n    first = s[:len(s) // 2]\n    second = s[len(s) // 2:]\n    cnt1 = len(first) - first.count(ch) + solve(second, chr(ord(ch) + 1))\n    cnt2 = len(second) - second.count(ch) + solve(first, chr(ord(ch) + 1))\n    return min(cnt1, cnt2)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        s = input()\n        print(solve(s, 'a'))\nmain()", "import sys\nimport bisect as bi\nimport math\nimport string\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef cin():\n    return map(int, sin().split())\n\ndef ain():\n    return list(map(int, sin().split()))\n\ndef sin():\n    return input()\n\ndef inin():\n    return int(input())\nd = 'abcdefghijklmnopqrstuvwxyz'\n\ndef solve(s, n, ans, c):\n    if n == 1:\n        if ord(s) - ord('a') == c:\n            return 0\n        else:\n            return 1\n    c1 = s[0:n // 2].count(d[c])\n    c2 = s[n // 2:n].count(d[c])\n    s1 = s[n // 2:n]\n    s2 = s[0:n // 2]\n    ans += min(solve(s1, n // 2, ans, c + 1) + n // 2 - c1, solve(s2, n // 2, ans, c + 1) + n // 2 - c2)\n    return ans\nfor _ in range(inin()):\n    n = inin()\n    s = sin().strip()\n    print(solve(s, n, 0, 0))", "def rec(ar, al, k):\n    if k == 1:\n        if ar[0] == al:\n            return 0\n        else:\n            return 1\n    k = k // 2\n    t = ar[:k].count(al)\n    t = k - t\n    m = ar[k:].count(al)\n    m = k - m\n    al = chr(ord(al) + 1)\n    return min(t + rec(ar[k:], al, k), m + rec(ar[:k], al, k))\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(input())\n    ch = 'a'\n    print(rec(arr, ch, n))", "def cost(lst, n, ch):\n    if n == 1:\n        if lst[0] == ch:\n            return 0\n        return 1\n    else:\n        a1 = lst[:n // 2]\n        a2 = lst[n // 2:]\n        return min(n // 2 - a1.count(ch) + cost(a2, n // 2, chr(ord(ch) + 1)), n // 2 - a2.count(ch) + cost(a1, n // 2, chr(ord(ch) + 1)))\nfor _ in range(int(input())):\n    m = int(input())\n    a = list(input())\n    print(cost(a, m, 'a'))", "def calc_steps_c_good(string: str, letter_code: int, length: int) -> int:\n    if length == 1:\n        if string == chr(letter_code):\n            return 0\n        return 1\n    mid = length >> 1\n    start_string = string[:mid]\n    end_string = string[mid:]\n    start_ct = start_string.count(chr(letter_code))\n    end_ct = end_string.count(chr(letter_code))\n    front_steps = calc_steps_c_good(start_string, letter_code + 1, mid)\n    end_steps = calc_steps_c_good(end_string, letter_code + 1, mid)\n    return min(front_steps + mid - end_ct, end_steps + mid - start_ct)\nfor _ in range(int(input())):\n    l = int(input())\n    value = input()\n    print(calc_steps_c_good(value, ord('a'), l))", "def solve(n, s, c):\n    if n == 1:\n        return int(s[0] != c)\n    mid = int(n / 2)\n    esq = s[:mid]\n    dir = s[mid:]\n    nxt = chr(ord(c) + 1)\n    cnt_esq = mid - esq.count(c) + solve(mid, dir, nxt)\n    cnt_dir = mid - dir.count(c) + solve(mid, esq, nxt)\n    return min(cnt_esq, cnt_dir)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        s = input()\n        print(solve(n, s, 'a'))\nmain()", "t = int(input())\n\ndef busca(s, c):\n    char = chr(97 + c)\n    if len(s) == 1:\n        if s[0] == char:\n            return 0\n        else:\n            return 1\n    else:\n        meio = len(s) // 2\n        esquerda = len(s) // 2 - s[:meio].count(char) + busca(s[meio:], c + 1)\n        direita = len(s) // 2 - s[meio:].count(char) + busca(s[:meio], c + 1)\n        return min(esquerda, direita)\nfor i in range(t):\n    n = int(input())\n    s = input()\n    print(busca(s, 0))", "def good_str(s, c, n):\n    if n == 1:\n        if s[0] == chr(c):\n            return 0\n        else:\n            return 1\n    else:\n        s1 = s[:n // 2]\n        s2 = s[n // 2:]\n        p = s1.count(chr(c))\n        q = s2.count(chr(c))\n        right = n // 2 - p + good_str(s2, c + 1, n // 2)\n        left = n // 2 - q + good_str(s1, c + 1, n // 2)\n        return min(right, left)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    c = ord('a')\n    result = good_str(s, c, n)\n    print(result)", "def good_str(s, c, n):\n    if n == 1:\n        if s[0] == chr(c):\n            return 0\n        else:\n            return 1\n    else:\n        s1 = s[:n // 2]\n        s2 = s[n // 2:]\n        p = s1.count(chr(c))\n        q = s2.count(chr(c))\n        right = n // 2 - p + good_str(s2, c + 1, n // 2)\n        left = n // 2 - q + good_str(s1, c + 1, n // 2)\n        return min(right, left)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    c = ord('a')\n    result = good_str(s, c, n)\n    print(result)", "def good(l, c):\n    ch = chr(c)\n    if len(l) == 1:\n        return 1 if ch != l[0] else 0\n    x = len(l) // 2\n    lm = x - l[:x].count(ch) + good(l[x:], c + 1)\n    rm = x - l[x:].count(ch) + good(l[:x], c + 1)\n    return min(lm, rm)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    print(good(s, ord('a')))", "def busca(palavra, aux):\n    if len(palavra) == 1:\n        if chr(aux) != palavra[0]:\n            return 1\n        else:\n            return 0\n    meio = len(palavra) // 2\n    min_esquerda = meio - palavra[:meio].count(chr(aux)) + busca(palavra[meio:], aux + 1)\n    min_direita = meio - palavra[meio:].count(chr(aux)) + busca(palavra[:meio], aux + 1)\n    return min(min_esquerda, min_direita)\nnum_casos_teste = int(input())\nfor i in range(num_casos_teste):\n    inutil = int(input())\n    palavra = input()\n    min_movimentos = busca(palavra, ord('a'))\n    print(min_movimentos)", "def check(list, c):\n    ch = chr(c)\n    if len(list) == 1:\n        return 1 if ch != list[0] else 0\n    x = len(list) // 2\n    leftm = x - list[:x].count(ch) + check(list[x:], c + 1)\n    rigthm = x - list[x:].count(ch) + check(list[:x], c + 1)\n    return min(leftm, rigthm)\nfor _ in range(int(input())):\n    n = int(input())\n    string = input()\n    print(check(string, ord('a')))", "def count(l, x):\n    c = 0\n    for k in l:\n        if k == x:\n            c += 1\n    return c\n\ndef calc(s, c):\n    if len(s) == 1:\n        return int(s != c)\n    mid = len(s) // 2\n    fps = s[:mid]\n    sps = s[mid:]\n    c1 = chr(ord(c) + 1)\n    first_part = calc(fps, c1)\n    first_part += len(s) // 2 - count(sps, c)\n    second_part = calc(sps, c1)\n    second_part += len(s) // 2 - count(fps, c)\n    return min(first_part, second_part)\nfor i in range(int(input())):\n    n = int(input())\n    ipt = input()\n    print(calc(ipt, 'a'))", "def get_next_char(char):\n    return chr(ord(char) + 1)\n\ndef solve(string, size, char='a'):\n    if len(string) == 1:\n        if string[0] == char:\n            return 0\n        return 1\n    half_size = size // 2\n    fst_half = string[0:half_size]\n    snd_half = string[half_size:]\n    moves_on_left = half_size - fst_half.count(char)\n    moves_on_right = half_size - snd_half.count(char)\n    left = moves_on_left + solve(snd_half, half_size, get_next_char(char))\n    right = moves_on_right + solve(fst_half, half_size, get_next_char(char))\n    return min(left, right)\nfor _ in range(int(input())):\n    size = int(input())\n    string = list(input())\n    print(solve(string, size))", "t = int(input())\n\ndef find(s, ch):\n    if len(s) == 1:\n        return 0 if s[0] == ch else 1\n    n = len(s)\n    a = s[0:n // 2]\n    b = s[n // 2:n]\n    acount = a.count(ch)\n    bcount = b.count(ch)\n    ch = chr(ord(ch) + 1)\n    return min(len(a) - acount + find(b, ch), len(b) - bcount + find(a, ch))\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    print(find(s, 'a'))", "def good_str(s, x, n):\n    if n == 1:\n        if s[0] == chr(x):\n            return 0\n        else:\n            return 1\n    else:\n        s1 = s[:n // 2]\n        s2 = s[n // 2:]\n        p = s1.count(chr(x))\n        q = s2.count(chr(x))\n        sum1 = n // 2 - p + good_str(s2, x + 1, n // 2)\n        sum2 = n // 2 - q + good_str(s1, x + 1, n // 2)\n        return min(sum1, sum2)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    result = good_str(s, 97, n)\n    print(result)", "from sys import stdin\n\ndef calc(s, c):\n    if len(s) == 1:\n        return int(s[0] != c)\n    m = len(s) // 2\n    cntl = calc(s[m:], chr(ord(c) + 1))\n    cntl += len(s) / 2 - s[0:m].count(c)\n    cntr = calc(s[0:m], chr(ord(c) + 1))\n    cntr += len(s) / 2 - s[m:].count(c)\n    return int(min(cntl, cntr))\nlines = stdin.readlines()\nt = int(lines[0])\nfor i in range(2, len(lines), 2):\n    s = lines[i].rstrip('\\r\\n')\n    print(calc(s, 'a'))", "def val(s, c):\n    n = len(s)\n    if n == 1:\n        return int(ord(s[0]) != c)\n    n = n // 2\n    return min(val(s[:n], c + 1) + n - s[n:].count(chr(c)), val(s[n:], c + 1) + n - s[:n].count(chr(c)))\nt = int(input())\nfor i in range(t):\n    input()\n    print(val(input(), 97))", "def goodString(word, size, unique):\n    if size == 1:\n        if word != unique:\n            return 1\n        else:\n            return 0\n    uniqueTwo = chr(1 + ord(unique))\n    mid = size // 2\n    firstWord = word[:mid]\n    lastWord = word[mid:]\n    uniqueTwo = chr(1 + ord(unique))\n    calculationOne = len(firstWord) - firstWord.count(unique) + goodString(lastWord, len(lastWord), uniqueTwo)\n    calculationTwo = len(lastWord) - lastWord.count(unique) + goodString(firstWord, len(firstWord), uniqueTwo)\n    if calculationOne < calculationTwo:\n        return calculationOne\n    else:\n        return calculationTwo\nn = int(input())\nfor i in range(n):\n    size = int(input())\n    word = input()\n    print(goodString(word, size, 'a'))", "def good_string(x, y):\n    ch = chr(y)\n    if len(x) == 1:\n        return 1 if ch != x[0] else 0\n    k = len(x) // 2\n    z = k - x[:k].count(ch) + good_string(x[k:], y + 1)\n    w = k - x[k:].count(ch) + good_string(x[:k], y + 1)\n    return min(z, w)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    print(good_string(a, ord('a')))", "def calc(s, c, n):\n    if n == 1:\n        if s[0] == chr(c):\n            return 0\n        else:\n            return 1\n    else:\n        s1 = s[:n // 2]\n        s2 = s[n // 2:]\n        p = s1.count(chr(c))\n        q = s2.count(chr(c))\n        left = n // 2 - q + calc(s1, c + 1, n // 2)\n        right = n // 2 - p + calc(s2, c + 1, n // 2)\n        return min(left, right)\nfor i in range(int(input())):\n    n = int(input())\n    s = input()\n    c = ord('a')\n    result = calc(s, c, n)\n    print(result)", "def busca(palavra, aux):\n    if len(palavra) == 1:\n        if chr(aux) != palavra[0]:\n            return 1\n        else:\n            return 0\n    meio = len(palavra) // 2\n    min_esquerda = meio - palavra[:meio].count(chr(aux)) + busca(palavra[meio:], aux + 1)\n    min_direita = meio - palavra[meio:].count(chr(aux)) + busca(palavra[:meio], aux + 1)\n    return min(min_esquerda, min_direita)\nnum_casos_teste = int(input())\nfor i in range(num_casos_teste):\n    inutil = int(input())\n    palavra = input()\n    min_movimentos = busca(palavra, ord('a'))\n    print(min_movimentos)", "def find_min_moves(s, aux):\n    if len(s) == 1:\n        if chr(aux) != s[0]:\n            return 1\n        else:\n            return 0\n    m = len(s) // 2\n    l = m - s[:m].count(chr(aux)) + find_min_moves(s[m:], aux + 1)\n    r = m - s[m:].count(chr(aux)) + find_min_moves(s[:m], aux + 1)\n    return min(l, r)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    min_moves = find_min_moves(s, ord('a'))\n    print(min_moves)", "def f(s, c):\n    if len(s) == 1:\n        return 0 if s == c else 1\n    (s, t) = (s[:len(s) // 2], s[len(s) // 2:])\n    return min(len(s) - t.count(c) + f(s, chr(ord(c) + 1)), len(t) - s.count(c) + f(t, chr(ord(c) + 1)))\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(f(s, 'a'))", "def good(l, c):\n    ch = chr(c)\n    if len(l) == 1:\n        return 1 if ch != l[0] else 0\n    k = len(l) // 2\n    lm = k - l[:k].count(ch) + good(l[k:], c + 1)\n    rm = k - l[k:].count(ch) + good(l[:k], c + 1)\n    return min(lm, rm)\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    print(good(a, ord('a')))", "def ans(s, n, c):\n    if n == 1:\n        if s[0] == c:\n            return 0\n        else:\n            return 1\n    str1 = s[:n // 2]\n    str2 = s[n // 2:]\n    c1 = str1.count(c)\n    s1 = n // 2 - c1 + ans(str2, n // 2, chr(ord(c) + 1))\n    c2 = str2.count(c)\n    s2 = n // 2 - c2 + ans(str1, n // 2, chr(ord(c) + 1))\n    return min(s1, s2)\nfor i in range(int(input())):\n    n = int(input())\n    x = input()\n    print(ans(x, n, 'a'))", "alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\ndef recursion(s, start, end, height):\n    if end - start == 1:\n        if s[start] == alphabet[height]:\n            return 0\n        else:\n            return 1\n    else:\n        middle = (start + end) // 2\n        return min(recursion(s, middle, end, height + 1) + (end - start) // 2 - s[start:middle].count(alphabet[height]), recursion(s, start, middle, height + 1) + (end - start) // 2 - s[middle:end].count(alphabet[height]))\n\ndef solve():\n    n = int(input())\n    s = input()\n    print(recursion(s, 0, n, 0))\nfor _ in range(int(input())):\n    solve()", "def two(n, r, s):\n    if n == 1:\n        return 1 - s.count(chr(r))\n    a = s[:n // 2]\n    b = s[n // 2:]\n    return min(n // 2 - a.count(chr(r)) + two(n // 2, r + 1, b), n // 2 - b.count(chr(r)) + two(n // 2, r + 1, a))\nfor _ in range(int(input())):\n    print(two(int(input()), 97, input()))", "def sol(s, n, c):\n    if n == 1:\n        if s[0] == c:\n            return 0\n        else:\n            return 1\n    s1 = s[0:n // 2]\n    s2 = s[n // 2:]\n    x = s1.count(c)\n    sx1 = n // 2 - x + sol(s2, n // 2, chr(ord(c) + 1))\n    x = s2.count(c)\n    sx2 = n // 2 - x + sol(s1, n // 2, chr(ord(c) + 1))\n    return min(sx1, sx2)\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    l = [i for i in input()]\n    print(sol(l, n, 'a'))\n    t -= 1", "t = int(input())\nf = int\n\ndef makgood(st, ch, n):\n    if n == 1:\n        if st == ch:\n            return 0\n        else:\n            return 1\n    k = f(n / 2)\n    a = st[:k].count(ch)\n    b = st[k:].count(ch)\n    nx = chr(ord(ch) + 1)\n    c = min(k - b + makgood(st[:k], nx, k), k - a + makgood(st[k:], nx, k))\n    return c\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    print(makgood(s, 'a', n))", "def f(s, c):\n    if len(s) == 1:\n        return 0 if s == c else 1\n    (s, t) = (s[:len(s) // 2], s[len(s) // 2:])\n    return min(len(s) - t.count(c) + f(s, chr(ord(c) + 1)), len(t) - s.count(c) + f(t, chr(ord(c) + 1)))\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(f(s, 'a'))", "def result(s, n, z):\n    a = z\n    b = chr(ord(a) + 1)\n    if n == 1:\n        if s[0] == a:\n            return 0\n        else:\n            return 1\n    x = s[:n // 2]\n    y = s[n // 2:]\n    cx = x.count(a)\n    cy = y.count(a)\n    out = min(n // 2 - cx + result(y, n // 2, b), n // 2 - cy + result(x, n // 2, b))\n    return out\nt = int(input())\ni = 0\nwhile i < t:\n    n = int(input())\n    s = input()\n    print(result(s, n, 'a'))\n    i = i + 1", "t = int(input())\n\ndef find(s, ch):\n    if len(s) == 1:\n        return 0 if s[0] == ch else 1\n    n = len(s)\n    a = s[0:n // 2]\n    b = s[n // 2:n]\n    acount = a.count(ch)\n    bcount = b.count(ch)\n    ch = chr(ord(ch) + 1)\n    return min(len(a) - acount + find(b, ch), len(b) - bcount + find(a, ch))\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    print(find(s, 'a'))", "def aux(input_s, const):\n    if len(input_s) == 1:\n        return int(input_s != const)\n    mid = len(input_s) // 2\n    fps = input_s[:mid]\n    sps = input_s[mid:]\n    const_1 = chr(ord(const) + 1)\n    first = aux(fps, const_1)\n    first_result = 0\n    for l in sps:\n        if l == const:\n            first_result += 1\n    first += len(input_s) // 2 - first_result\n    second = aux(sps, const_1)\n    second_result = 0\n    for l in fps:\n        if l == const:\n            second_result += 1\n    second += len(input_s) // 2 - second_result\n    return min(first, second)\ninput_n = int(input())\nfor i in range(input_n):\n    n = int(input())\n    input_s = input()\n    print(aux(input_s, 'a'))", "def DivideConquer(s, c):\n    n = len(s)\n    if n == 1:\n        if s[0] == c:\n            return 0\n        return 1\n    c1 = n // 2 - s[0:n // 2].count(c)\n    c2 = n // 2 - s[n // 2:n].count(c)\n    x = c1 + DivideConquer(s[n // 2:], chr(ord(c) + 1))\n    y = c2 + DivideConquer(s[0:n // 2], chr(ord(c) + 1))\n    return min(x, y)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    m = DivideConquer(s, 'a')\n    print(m)", "def change_count(num, st, cur):\n    if num == 1:\n        if st == cur:\n            return 0\n        else:\n            return 1\n    else:\n        mid = num // 2\n        left = mid - st[:mid].count(cur)\n        right = mid - st[mid:].count(cur)\n        return min(left + change_count(mid, st[mid:], chr(ord(cur) + 1)), right + change_count(mid, st[:mid], chr(ord(cur) + 1)))\nfor i in range(int(input())):\n    n = int(input())\n    s = input()\n    print(change_count(n, s, 'a'))", "def goodString(s, len, charCode):\n    (h, char) = (len // 2, chr(charCode))\n    if len == 1:\n        if s == char:\n            return 0\n        else:\n            return 1\n    (s1, s2) = (s[:h], s[h:])\n    a1 = h - s1.count(char) + goodString(s2, h, charCode + 1)\n    a2 = h - s2.count(char) + goodString(s1, h, charCode + 1)\n    return min(a1, a2)\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = input()\n    ans = goodString(A, N, 97)\n    print(ans)", "def func(s, c, l):\n    if len(s) == 1:\n        if s == c:\n            return 0\n        else:\n            return 1\n    else:\n        n = chr(ord(c) + 1)\n        return min(l - s[:l].count(c) + func(s[l:], n, l // 2), l - s[l:].count(c) + func(s[:l], n, l // 2))\nfor i in range(int(input())):\n    n = int(input())\n    s = input()\n    print(func(s, 'a', n // 2))", "def F(l, r, c):\n    if r - l == 1:\n        if s[l] == c:\n            return 0\n        else:\n            return 1\n    mid = (l + r) // 2\n    cntl = (r - l) // 2 - s.count(c, l, mid) + F(mid, r, chr(ord(c) + 1))\n    cntr = (r - l) // 2 - s.count(c, mid, r) + F(l, mid, chr(ord(c) + 1))\n    return min(cntl, cntr)\nfor z in range(int(input())):\n    n = int(input())\n    s = input()\n    print(F(0, n, 'a'))", "def f(s, c):\n    if len(s) == 1:\n        return 0 if s == c else 1\n    (s, t) = (s[:len(s) // 2], s[len(s) // 2:])\n    return min(len(s) - t.count(c) + f(s, chr(ord(c) + 1)), len(t) - s.count(c) + f(t, chr(ord(c) + 1)))\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(f(s, 'a'))", "def checkWord(word, c):\n    if len(word) == 1:\n        if word == c:\n            return 0\n        else:\n            return 1\n    mid = int(len(word) / 2)\n    left = checkWord(word[:mid], chr(ord(c) + 1))\n    left += mid - word[mid:].count(c)\n    right = checkWord(word[mid:], chr(ord(c) + 1))\n    right += mid - word[:mid].count(c)\n    return min(left, right)\ncases = int(input())\nfor _ in range(cases):\n    size = int(input())\n    word = input()\n    result = checkWord(word, 'a')\n    print(result)", "def hh1(x, m, c):\n    return m - x.count(c)\n\ndef hh2(x, m, c):\n    if m == 1:\n        if x[0] == c:\n            return 0\n        else:\n            return 1\n    else:\n        a = m // 2\n        d = chr(1 + ord(c))\n        return min(hh1(x[:a], a, c) + hh2(x[a:], a, d), hh1(x[a:], a, c) + hh2(x[:a], a, d))\nfor t in range(int(input())):\n    n = int(input())\n    s = list(input())\n    print(hh2(s, n, 'a'))", "def a_good(n, s, ch):\n    if n == 1:\n        if s == ch:\n            return 0\n        else:\n            return 1\n    mid = n // 2\n    left = s[:mid].count(ch)\n    right = s[mid:].count(ch)\n    return min(mid - left + a_good(mid, s[mid:], chr(ord(ch) + 1)), mid - right + a_good(mid, s[:mid], chr(ord(ch) + 1)))\ntt = int(input())\nfor _ in range(tt):\n    n = int(input())\n    s = input()\n    print(a_good(n, s, 'a'))", "def two(s, r, n):\n    if n == 1:\n        t = 1 - s.count(chr(r))\n        return t\n    a = s[:n // 2]\n    b = s[n // 2:]\n    t = n // 2 - a.count(chr(r)) + two(b, r + 1, n // 2)\n    m = n // 2 - b.count(chr(r)) + two(a, r + 1, n // 2)\n    return min(t, m)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    r = 97\n    print(two(s, r, n))", "def two(s, r, n):\n    if n == 1:\n        t = 1 - s.count(chr(r))\n        return t\n    a = s[:n // 2]\n    b = s[n // 2:]\n    t = n // 2 - a.count(chr(r)) + two(b, r + 1, n // 2)\n    m = n // 2 - b.count(chr(r)) + two(a, r + 1, n // 2)\n    return min(t, m)\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    r = 97\n    print(two(s, r, n))", "def f(s, c):\n    n = len(s)\n    if n == 1:\n        if s[0] == c:\n            return 0\n        else:\n            return 1\n    a = s[:n // 2].count(c)\n    b = s[n // 2:].count(c)\n    return min(n // 2 - a + f(s[n // 2:], c + 1), n // 2 - b + f(s[:n // 2], c + 1))\n\ndef f2(s):\n    arr = []\n    for i in s:\n        arr.append(ord(i) - 96)\n    return arr\nfor t in range(int(input())):\n    n = int(input())\n    s = str(input())\n    arr = f2(s)\n    print(f(arr, 1))", "t = int(input())\n\ndef get_mincost(arr, n, ch):\n    if n == 1:\n        if arr[0] == ch:\n            return 0\n        return 1\n    else:\n        a1 = arr[:n // 2]\n        a2 = arr[n // 2:]\n        mini = min(n // 2 - a1.count(ch) + get_mincost(a2, n // 2, chr(ord(ch) + 1)), n // 2 - a2.count(ch) + get_mincost(a1, n // 2, chr(ord(ch) + 1)))\n        return mini\nfor _ in range(t):\n    n = int(input())\n    a = list(input())\n    ch = 'a'\n    print(get_mincost(a, n, ch))", "def f(x, z):\n    if len(x) == 0:\n        return 0\n    if len(x) == 1:\n        return int(x != z)\n    m = len(x) // 2\n    L = x[:m]\n    R = x[m:]\n    a = m - L.count(z) + f(R, chr(ord(z) + 1))\n    b = m - R.count(z) + f(L, chr(ord(z) + 1))\n    return min(a, b)\nt = int(input())\nwhile t:\n    s = int(input())\n    word = input()\n    print(f(word, 'a'))\n    t -= 1", "def calc(string, c):\n    char = chr(c)\n    if len(string) == 1:\n        return 1 if string[0] != char else 0\n    tot_chars = len(string) // 2\n    cntl = tot_chars - string[0:tot_chars].count(char) + calc(string[tot_chars:], c + 1)\n    cntr = tot_chars - string[tot_chars:].count(char) + calc(string[:tot_chars], c + 1)\n    return min(cntl, cntr)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    print(calc(s, ord('a')))", "def think(A, mid, s):\n    if len(s) == 1:\n        if s[0] == A:\n            return 0\n        else:\n            return 1\n    f_half = think(A + 1, mid // 2, s[:mid])\n    f_half += mid - s[mid:].count(A)\n    s_half = think(A + 1, mid // 2, s[mid:])\n    s_half += mid - s[:mid].count(A)\n    return min(f_half, s_half)\nfor _ in range(int(input())):\n    n = input()\n    s = list(map(ord, str(input())))\n    A = 97\n    mid = len(s) // 2\n    moves = think(A, mid, s)\n    print(moves)", "def dfs(l, r, c, s):\n    if len(s) == 1:\n        return (s[0] == c) ^ 1\n    mid = (l + r) // 2\n    (L, R) = (s[:mid], s[mid:])\n    (lC, rC) = (len(L) - L.count(c), len(R) - R.count(c))\n    ans1 = lC + dfs(0, mid, chr(ord(c) + 1), R)\n    ans2 = rC + dfs(0, mid, chr(ord(c) + 1), L)\n    return min(ans1, ans2)\n\ndef solve():\n    n = int(input())\n    s = input()\n    ans = dfs(0, n, 'a', s)\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    solve()", "def f(s, c):\n    if len(s) == 1:\n        return 0 if s == c else 1\n    (s, t) = (s[:len(s) // 2], s[len(s) // 2:])\n    return min(len(s) - t.count(c) + f(s, chr(ord(c) + 1)), len(t) - s.count(c) + f(t, chr(ord(c) + 1)))\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    print(f(s, 'a'))", "def good_string(word, length, single):\n    if length == 1:\n        if word != single:\n            return 1\n        else:\n            return 0\n    single_2 = chr(1 + ord(single))\n    n = int(length / 2)\n    first_word = word[:n]\n    last_word = word[n:]\n    single_2 = chr(1 + ord(single))\n    res_1 = len(first_word) - first_word.count(single) + good_string(last_word, len(last_word), single_2)\n    res_2 = len(last_word) - last_word.count(single) + good_string(first_word, len(first_word), single_2)\n    return min(res_1, res_2)\ntotal = int(input())\nfor i in range(total):\n    length = int(input())\n    word = input()\n    print(good_string(word, length, 'a'))", "alpha = 'abcdefghijklmnopqrstuvqxyz'\n\ndef solve(s, lvl, cost):\n    n = len(s)\n    if n == 1:\n        if s == alpha[lvl]:\n            return cost\n        else:\n            return cost + 1\n    c1 = n // 2 - s[:n // 2].count(alpha[lvl]) + solve(s[n // 2:], lvl + 1, cost)\n    c2 = n // 2 - s[n // 2:].count(alpha[lvl]) + solve(s[:n // 2], lvl + 1, cost)\n    return cost + min(c1, c2)\n\ndef tc():\n    n = int(input())\n    s = input()\n    ans = solve(s, 0, 0)\n    print(ans)\nT = int(input())\nfor _ in range(T):\n    tc()", "import math\nimport sys\nLI = lambda : list(map(int, input().split()))\nMI = lambda : map(int, input().split())\nSI = lambda : input()\nII = lambda : int(input())\nt = II()\nfor q in range(t):\n    n = II()\n    s = SI()\n    d = [0] * 26\n    dp = [0] * n\n\n    def rec(a, z):\n        if len(a) == 0:\n            return 0\n        elif len(a) == 1:\n            return int(a != z)\n        mid = len(a) // 2\n        l = a[:mid]\n        r = a[mid:]\n        f = mid - l.count(z) + rec(r, chr(ord(z) + 1))\n        s = mid - r.count(z) + rec(l, chr(ord(z) + 1))\n        return min(f, s)\n    print(rec(s, 'a'))", "import sys\nfrom math import sqrt, gcd, ceil, log\nfrom bisect import bisect\nfrom collections import defaultdict, Counter, deque\nfrom heapq import heapify, heappush, heappop\ninp = sys.stdin.readline\nread = lambda : list(map(int, inp().strip().split()))\n\ndef solve():\n    ans = ''\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n\n        def getCost(l, r, ch):\n            return r - l - s[l:r].count(chr(ch))\n\n        def getMin(l, r, ch):\n            if l + 1 == r:\n                return [0, 1][chr(ch) != s[l]]\n            return min(getCost(l, (l + r) // 2, ch) + getMin((l + r) // 2, r, ch + 1), getCost((l + r) // 2, r, ch) + getMin(l, (l + r) // 2, ch + 1))\n        ans += str(getMin(0, n, 97)) + '\\n'\n    print(ans)\nsolve()", "def task_1(s, target):\n    return len(s) - s.count(target)\n\ndef main_task(start, end, target):\n    if start + 1 == end:\n        if s[start] == target:\n            return 0\n        else:\n            return 1\n    m = (start + end) // 2\n    a = task_1(s[start:m], target) + main_task(m, end, chr(ord(target) + 1))\n    b = task_1(s[m:end], target) + main_task(start, m, chr(ord(target) + 1))\n    return min(a, b)\nfor i in range(int(input())):\n    n = int(input())\n    s = input()\n    print(main_task(0, n, 'a'))"]