["from math import perm as A, factorial as P\nMOD = 1000 * 1000 * 1000 + 7\n\ndef solve():\n    (n, x, pos) = map(int, input().split())\n    left_count = 0\n    right_count = 0\n    left = 0\n    right = n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            left = middle + 1\n            left_count += 1\n        else:\n            right = middle\n            right_count += 1\n    left_count -= 1\n    ans = A(x - 1, left_count) % MOD\n    ans *= A(n - x, right_count) % MOD\n    ans *= P(n - 1 - left_count - right_count) % MOD\n    print(ans % MOD, end='')\nsolve()", "(n, x, pos) = map(int, input().split())\nlarge = 0\nsmall = 0\nmod = 10 ** 9 + 7\n(l, h) = (0, n)\nwhile l < h:\n    m = (l + h) // 2\n    if m <= pos:\n        if m != pos:\n            small += 1\n        l = m + 1\n    else:\n        h = m\n        large += 1\n(great, less) = (n - x, x - 1)\nans = 1\nfor i in range(large):\n    ans = ans * great % mod\n    great -= 1\nfor i in range(small):\n    ans = ans * less % mod\n    less -= 1\ntot = less + great\nfor i in range(1, 1 + tot):\n    ans = ans * i % mod\nprint(ans)", "import sys\nfrom math import *\nm = 10 ** 9 + 7\n\ndef f(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans = ans * i % m\n    return ans\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\nl = x - 1\ng = n - x\nans = 1\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < pos:\n        ans *= l\n        l -= 1\n        left = mid + 1\n    elif mid > pos:\n        ans *= g\n        g -= 1\n        right = mid\n    else:\n        left = mid + 1\nif l < 0 or g < 0:\n    print(0)\nelse:\n    print(ans * f(l + g) % m)", "import sys\nfrom os import path\nMOD = 1000000000.0 + 7\n\ndef open_inputs():\n    if path.exists('input.txt'):\n        sys.stdin = open('input.txt', 'r')\n        sys.stdout = open('output.txt', 'w')\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef com(_n: int, _x: int, _p: int):\n    total_less = 0\n    total_great = 0\n    L = 0\n    R = _n\n    while L < R:\n        middle = int((L + R) / 2)\n        if middle == _p:\n            L = middle + 1\n        elif middle > _p:\n            R = middle\n            total_great += 1\n        else:\n            L = middle + 1\n            total_less += 1\n    result = 1\n    for i in range(total_less):\n        val = _x - 1 - i\n        result *= val\n        result %= MOD\n    for i in range(total_great):\n        val = _n - _x - i\n        result *= val\n        result %= MOD\n    balance = _n - total_great - total_less - 1\n    for i in range(2, balance + 1):\n        result *= i\n        result %= MOD\n    print(int(result))\n\ndef main():\n    open_inputs()\n    [a, b, c] = get_ints()\n    com(a, b, c)\nmain()", "import sys\nimport math\n\ndef fact(n, k):\n    a = math.factorial(n) // math.factorial(n - k)\n    return a\n\ndef fn(n, x, p):\n    left = 0\n    right = n\n    mid = (left + right) / 2\n    y = mid\n    greaterx = 0\n    lesserx = -1\n    while left < right:\n        mid = (left + right) // 2\n        if mid <= p:\n            left = mid + 1\n            lesserx = lesserx + 1\n        else:\n            right = mid\n            greaterx = greaterx + 1\n    try:\n        ans = fact(n - x, greaterx) * fact(x - 1, lesserx) * math.factorial(n - 1 - greaterx - lesserx)\n        return ans % (10 ** 9 + 7)\n    except:\n        return 0\ninput = sys.stdin.read()\ndata = list(map(int, input.split()))\nn = data[0]\nx = data[1]\np = data[2]\nprint(fn(n, x, p))", "from math import *\nmod = 1000000007\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\n(cnts, cntb) = (0, 0)\nwhile left < right:\n    mid = (left + right) // 2\n    if mid > pos:\n        cntb += 1\n    if mid < pos:\n        cnts += 1\n    if mid <= pos:\n        left = mid + 1\n    else:\n        right = mid\na = comb(x - 1, cnts) % mod\nb = comb(n - x, cntb) % mod\nc = factorial(n - 1 - cnts - cntb) % mod\nd = factorial(cnts) % mod\ne = factorial(cntb) % mod\nprint(a * b * c * d * e % mod)", "from sys import stdin\nfrom math import perm\nmod = 10 ** 9 + 7\n\ndef fact(num):\n    f = 1\n    for i in range(2, num + 1):\n        f = f * i % mod\n    return f\n(n, x, pos) = map(int, input().split())\n(high, low) = (n - x, x - 1)\n(h, l, mid) = (n, 0, n)\nwhile l < h:\n    mid = (h + l) // 2\n    if mid > pos:\n        high -= 1\n        h = mid\n    elif mid < pos:\n        low -= 1\n        l = mid + 1\n    else:\n        l = mid + 1\nans = perm(n - x, n - x - high) * perm(x - 1, x - 1 - low) * fact(high + low)\nprint(ans % mod)", "(a, b, c) = map(int, input().split())\n(l, h) = (0, a)\nr = 1\nz = 0\n(p, q) = (b - 1, a - b)\nwhile l < h:\n    m = (l + h) // 2\n    if m == c:\n        z += 1\n        l = m + 1\n    elif m > c:\n        z += 1\n        r *= q\n        q -= 1\n        h = m\n    else:\n        z += 1\n        r *= p\n        p -= 1\n        l = m + 1\nfor i in range(2, a - z + 1):\n    r = r * i % 1000000007\nprint(r)", "(n, x, pos) = map(int, input().split())\nl = 0\nr = n\nsub = n - x\npro = 1\nsmall = x - 1\ncnt = 0\nwhile l < r:\n    mid = (l + r) // 2\n    if mid > pos:\n        pro = pro * sub\n        sub -= 1\n        r = mid\n        cnt += 1\n    elif mid < pos:\n        l = mid + 1\n        pro *= small\n        small -= 1\n        cnt += 1\n    else:\n        l = mid + 1\n        cnt += 1\nfor i in range(2, n - cnt + 1):\n    pro = pro * i % 1000000007\nprint(pro)", "from math import comb, factorial\nmod = 10 ** 9 + 7\n(n, x, pos) = map(int, input().split())\nlt = 0\ngt = 0\nleft = 0\nright = n\nwhile left < right:\n    middle = (left + right) // 2\n    if middle <= pos:\n        if middle < pos:\n            lt += 1\n        left = middle + 1\n    else:\n        gt += 1\n        right = middle\nrem = factorial(n - 1 - lt - gt) % mod\nlt = comb(x - 1, lt) % mod * factorial(lt)\ngt = comb(n - x, gt) % mod * factorial(gt)\nprint(lt * gt % mod * rem % mod)", "from math import factorial, perm\nimport sys\n\ndef input_int_arr():\n    return map(int, sys.stdin.readline().split())\n\ndef print_ln(num):\n    sys.stdout.write(str(num) + '\\n')\n\ndef binary_search(left, right, x, pos):\n    count_less = count_bigger = 0\n    while left < right:\n        mid = left + (right - left) // 2\n        if pos >= mid:\n            if pos != mid:\n                count_less += 1\n            left = mid + 1\n        else:\n            right = mid\n            count_bigger += 1\n    return (count_less, count_bigger)\n\ndef main():\n    MOD = 1000000007\n    (n, x, pos) = input_int_arr()\n    (count_less, count_bigger) = binary_search(0, n, x, pos)\n    (smaller_numbers, bigger_numbers) = (x - 1, n - x)\n    smaller_count = perm(smaller_numbers, count_less) % MOD\n    bigger_count = perm(bigger_numbers, count_bigger) % MOD\n    other_count = factorial(n - 1 - count_less - count_bigger) % MOD\n    res = int(smaller_count * bigger_count * other_count % MOD)\n    print_ln(res)\nmain()", "import math\n(n, x, p) = map(int, input().split())\n(low, high, less_count, more_count) = (0, n, 0, 0)\nwhile low < high:\n    mid = (low + high) // 2\n    if mid > p:\n        more_count += 1\n        high = mid\n    else:\n        less_count += int(p != mid)\n        low = mid + 1\n(left, avail_less, avail_more) = (n - less_count - more_count - 1, x - 1, n - x)\n(less_choices, more_choices) = (math.comb(avail_less, less_count), math.comb(avail_more, more_count))\n(less_choices, more_choices) = (less_choices * math.factorial(less_count) % (10 ** 9 + 7), more_choices * math.factorial(more_count) % (10 ** 9 + 7))\nprint(less_choices * more_choices * math.factorial(left) % (10 ** 9 + 7))", "import math\n(n, x, p) = map(int, input().split())\n(low, high, less_count, more_count) = (0, n, 0, 0)\nwhile low < high:\n    mid = (low + high) // 2\n    if mid > p:\n        more_count += 1\n        high = mid\n    else:\n        less_count += int(p != mid)\n        low = mid + 1\n(left, avail_less, avail_more) = (n - less_count - more_count - 1, x - 1, n - x)\n(less_choices, more_choices) = (math.comb(avail_less, less_count) * math.factorial(less_count) % (10 ** 9 + 7), math.comb(avail_more, more_count) * math.factorial(more_count) % (10 ** 9 + 7))\nprint(less_choices * more_choices * math.factorial(left) % (10 ** 9 + 7))", "from math import comb\nfrom math import factorial as fac\n\ndef calc(n, p):\n    (l, h) = (0, 0)\n    left = 0\n    right = n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= p:\n            if middle != p:\n                l += 1\n            left = middle + 1\n        if middle > p:\n            right = middle\n            h += 1\n    return [l, h]\n(n, x, p) = [*map(int, input().split())]\n(l, h) = calc(n, p)\nif n - x < h or x - 1 < l:\n    print(0)\nelse:\n    ans = comb(n - x, h) * fac(h) * comb(x - 1, l) * fac(l) * fac(n - (1 + l + h))\n    MOD = 10 ** 9 + 7\n    print(ans % MOD)", "import sys\nfrom math import factorial, comb\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\na = 0\nb = 0\nwhile left < right:\n    middle = left + (right - left) // 2\n    if pos == middle:\n        left = middle + 1\n    elif pos < middle:\n        b += 1\n        right = middle\n    else:\n        a += 1\n        left = middle + 1\nrem = factorial(n - 1 - a - b) % mod\na = comb(x - 1, a) % mod * factorial(a)\nb = comb(n - x, b) % mod * factorial(b)\nprint(a * b % mod * rem % mod)", "import math\n(n, x, pos) = map(int, input().split())\nsmallNum = x - 1\nbigNum = n - x\nfixed_small = 0\nfixed_big = 0\n\ndef A(n, r):\n    ans = 1\n    p = int(math.pow(10, 9) + 7)\n    for i in range(n, n - r, -1):\n        ans = ans * i % p\n    return ans\nleft = 0\nright = n\nwhile left < right:\n    middle = (left + right) // 2\n    if middle <= pos:\n        left = middle + 1\n        if middle < pos:\n            fixed_small += 1\n    else:\n        right = middle\n        fixed_big += 1\nans = A(smallNum, fixed_small) * A(bigNum, fixed_big) * A(n - fixed_big - fixed_small - 1, n - fixed_big - fixed_small - 1) % int(math.pow(10, 9) + 7)\nprint(int(ans))", "(n, x, pos) = map(int, input().split())\n(l, h) = (0, n)\nr = 1\nz = 0\n(p, q) = (x - 1, n - x)\nwhile l < h:\n    m = (l + h) // 2\n    if m == pos:\n        z += 1\n        l = m + 1\n    elif m > pos:\n        z += 1\n        r *= q\n        q -= 1\n        h = m\n    else:\n        z += 1\n        r *= p\n        p -= 1\n        l = m + 1\nfor i in range(2, n - z + 1):\n    r = r * i % 1000000007\nprint(r)", "prime = 10 ** 9 + 7\n\ndef process(n, x, pos):\n    s = 0\n    e = n\n    smaller = []\n    larger = []\n    while s < e:\n        m = (s + e) // 2\n        if m <= pos:\n            if m < pos:\n                smaller.append(m)\n            s = m + 1\n        else:\n            larger.append(m)\n            e = m\n    if x - 1 < len(smaller):\n        return 0\n    num1 = 1\n    num2 = 1\n    num3 = 1\n    for i in range(len(smaller)):\n        num1 = num1 * (x - 1 - i) % prime\n    for i in range(len(larger)):\n        num2 = num2 * (n - x - i) % prime\n    for i in range(1, n - (len(smaller) + len(larger))):\n        num3 = num3 * i % prime\n    answer = num1 * num2 * num3 % prime\n    return answer\n(n, x, pos) = [int(x) for x in input().split()]\nprint(process(n, x, pos))", "import math\nfor _ in range(1):\n    (n, x, pos) = map(int, input().split())\n    fact = []\n    mod = 1000000007\n    fact.append(1)\n    for i in range(n + 1):\n        fact.append(fact[i] % mod * (i + 1) % mod % mod)\n    l = 0\n    r = n\n    (small, big) = (x - 1, n - x)\n    ans = 1\n    while l < r:\n        mid = (l + r) // 2\n        if mid > pos:\n            r = mid\n            ans *= big\n            ans %= mod\n            big -= 1\n        elif mid <= pos:\n            l = mid + 1\n            if mid != pos:\n                ans *= small\n                ans %= mod\n                small -= 1\n    ans *= fact[small + big]\n    ans %= mod\n    print(ans % mod)", "def fact(n):\n    ans = 1\n    for i in range(2, n + 1):\n        ans *= i\n    return ans\n(n, m, k) = [int(x) for x in input().split()]\nl = m - 1\ng = n - l - 1\nans = 1\nstart = 0\nend = n\nwhile start < end:\n    mid = (start + end) // 2\n    if mid == k:\n        start = mid + 1\n    elif mid < k:\n        ans *= l\n        l -= 1\n        start = mid + 1\n    else:\n        ans *= g\n        g -= 1\n        end = mid\nans *= fact(l + g)\nprint(ans % (10 ** 9 + 7))", "(n, x, pos) = [int(k) for k in input().split()]\nans = 1\ngreater = n - x\nsmaller = x - 1\nleft = 0\nright = n\nmid = n\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < pos:\n        ans *= smaller\n        ans = ans % 1000000007\n        smaller -= 1\n        left = mid + 1\n    elif mid > pos:\n        ans *= greater\n        ans = ans % 1000000007\n        greater -= 1\n        right = mid\n    else:\n        left = mid + 1\nfor i in range(1, smaller + greater + 1):\n    ans *= i\n    ans = ans % 1000000007\nprint(ans)", "(a, b, c) = map(int, input().split())\n(l, h) = (0, a)\nr = 1\nz = 0\n(p, q) = (b - 1, a - b)\nwhile l < h:\n    m = (l + h) // 2\n    if m == c:\n        z += 1\n        l = m + 1\n    elif m > c:\n        z += 1\n        r *= q\n        q -= 1\n        h = m\n    else:\n        z += 1\n        r *= p\n        p -= 1\n        l = m + 1\nfor i in range(2, a - z + 1):\n    r = r * i % 1000000007\nprint(r)", "from math import comb, factorial\nmod = 10 ** 9 + 7\n(n, x, pos) = map(int, input().split())\nlt = 0\ngt = 0\nleft = 0\nright = n\nwhile left < right:\n    middle = (left + right) // 2\n    if middle <= pos:\n        if middle < pos:\n            lt += 1\n        left = middle + 1\n    else:\n        gt += 1\n        right = middle\nrem = factorial(n - 1 - lt - gt) % mod\nlt = comb(x - 1, lt) % mod * factorial(lt)\ngt = comb(n - x, gt) % mod * factorial(gt)\nprint(lt * gt % mod * rem % mod)", "def algo(arr, y):\n    ans = []\n    left = 0\n    right = len(arr)\n    while left < right:\n        middle = (left + right) // 2\n        ans.append(arr[middle])\n        if arr[middle] <= y:\n            left = middle + 1\n        else:\n            right = middle\n    if left > 0 and arr[left - 1] == y:\n        return (True, ans)\n    return (False, ans)\nmod = 1000000000 + 7\n\ndef C(n, k):\n    if 0 <= k <= n:\n        nn = 1\n        kk = 1\n        for t in range(1, min(k, n - k) + 1):\n            nn *= n\n            kk *= t\n            n -= 1\n        return nn // kk % mod\n    else:\n        return 0\n\ndef fact(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n        ans %= mod\n    return ans\n(n, x, pos) = list(map(int, input().split()))\na = []\nfor i in range(n):\n    if i < pos:\n        a.append(x - 1)\n    elif i == pos:\n        a.append(x)\n    else:\n        a.append(x + 1)\n(res, seq) = algo(a, x)\nassert res\nsum1 = 0\nsum2 = 0\nfor elem in seq:\n    if elem < x:\n        sum1 += 1\n    elif elem > x:\n        sum2 += 1\nanswer = fact(n - 1 - sum1 - sum2) * C(x - 1, sum1)\nanswer %= mod\nanswer *= fact(sum1)\nanswer %= mod\nanswer *= C(n - x, sum2)\nanswer %= mod\nanswer *= fact(sum2)\nanswer %= mod\nprint(answer)", "(n, x, pos) = input().split()\nn = int(n)\nx = int(x)\npos = int(pos)\nmod = 1000000000.0 + 7\nbig = n - x\nsmall = x - 1\nleft = 0\nright = n\nans = 1\nwhile left < right:\n    middle = (left + right) // 2\n    n -= 1\n    if middle == pos:\n        left = middle + 1\n        continue\n    elif middle > pos:\n        ans = ans * big % mod\n        right = middle\n        if big == 0:\n            print(0)\n            exit()\n        big -= 1\n    elif middle < pos:\n        left = middle + 1\n        ans = ans * small % mod\n        if small == 0:\n            print(0)\n            exit()\n        small -= 1\nfor i in range(1, n + 1):\n    ans = ans * i % mod\nprint(int(ans))", "mod = int(1000000000.0 + 7)\n(n, x, pos) = map(int, input().split())\n\ndef bs(pos):\n    l = 0\n    r = n\n    small = set()\n    large = set()\n    eq = 0\n    while l < r:\n        mid = l + r >> 1\n        if mid <= pos:\n            if mid != pos:\n                small.add(mid)\n            else:\n                eq += 1\n            l = mid + 1\n        else:\n            r = mid\n            if mid < n:\n                large.add(mid)\n    if l != pos and l < n:\n        large.add(l)\n    return (eq, len(small), len(large))\n(eq, small, large) = bs(pos)\nlr = n - x\nsm = n - lr - 1\nfact = [1] * (n + 1)\nfor i in range(2, n + 1):\n    fact[i] = fact[i - 1] * i % mod\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    if n <= r or r == 0 or r == n:\n        return 1\n    return fact[n] % mod * inv(fact[r]) % mod * inv(fact[n - r]) % mod\nprint(fact[n - large - small - 1] % mod * ncr(n - lr - 1, small) % mod * fact[small] % mod * ncr(lr, large) % mod * fact[large] % mod)", "from sys import stdin\nfrom math import factorial as f\nMOD = 1000000007\n\ndef bs(a, x):\n    left = 0\n    right = len(a)\n    inds = []\n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] <= x:\n            inds.append((mid, 'lower'))\n            left = mid + 1\n        else:\n            inds.append((mid, 'higher'))\n            right = mid\n    return inds\n(n, x, pos) = map(int, stdin.readline().split())\nfake = [i for i in range(n)]\ninds = bs(fake, pos)\nhigherNums = n - x\nlowerNums = x - 1\nfinal = 1\nfor (tmp, name) in inds:\n    if tmp == pos:\n        continue\n    elif name == 'lower':\n        final *= lowerNums\n        lowerNums -= 1\n    else:\n        final *= higherNums\n        higherNums -= 1\n    final %= MOD\nremain = higherNums + lowerNums\nfinal *= f(remain) % MOD\nprint(final % MOD)", "mod = 1000000007\n\ndef facto(f, q):\n    facto = 1\n    for i in range(f, q + 1):\n        facto = facto * i % mod\n    return facto\n(n, x, p) = map(int, input().split())\nleft = 0\nright = n\nr = 0\nl = 0\nwhile left < right:\n    middle = (left + right) // 2\n    if middle == p:\n        left = middle + 1\n    elif middle > p:\n        right = middle\n        r += 1\n    else:\n        left = middle + 1\n        l += 1\nif l <= x - 1 and r <= n - x:\n    ans = facto(1, n - 1 - r - l) * facto(n - x - r + 1, n - x) * facto(x - 1 - l + 1, x - 1)\n    ans = ans % mod\n    print(ans)\nelse:\n    print('0')", "mod = 1000000007\n(n, x, pos) = map(int, input().split())\nans = 1\nleft = 0\nright = n\ntoLeft = n - x\ntoRight = x - 1\nfailed = False\nc = 0\nwhile left < right:\n    middle = (left + right) // 2\n    if middle == pos:\n        left = middle + 1\n        c += 1\n    elif middle > pos:\n        if toLeft == 0:\n            failed = True\n            break\n        else:\n            ans *= toLeft\n            ans %= mod\n            toLeft -= 1\n            right = middle\n            c += 1\n    elif toRight == 0:\n        failed = True\n        break\n    else:\n        ans *= toRight\n        ans %= mod\n        toRight -= 1\n        left = middle + 1\n        c += 1\nif failed:\n    print(0)\nelse:\n    for i in range(n - c):\n        ans *= i + 1\n        ans %= mod\n    print(ans)", "(n, x, pos) = list(map(int, input().split()))\nmax = 7 + 1000000000.0\nrem = 1\nstart = 0\nend = n\nleft_value = x - 1\nright_value = n - x\nwhile start < end:\n    mid = (start + end) // 2\n    if mid > pos:\n        rem = rem * right_value % max\n        right_value -= 1\n        n -= 1\n        end = mid\n    elif mid < pos:\n        rem = rem * left_value % max\n        left_value -= 1\n        n -= 1\n        start = mid + 1\n    else:\n        start = mid + 1\nfor i in range(1, n):\n    rem = rem * i % max\nrem = rem % max\nprint(int(rem))", "import math\n\ndef binary_search(l, p):\n    a = [i for i in range(l)]\n    le = 0\n    ri = l\n    cu = set()\n    cl = set()\n    while le < ri:\n        m = (le + ri) // 2\n        if a[m] <= p:\n            cl.add(m)\n            le = m + 1\n        else:\n            cu.add(m)\n            ri = m\n    return [len(cl) - 1, len(cu)]\n(n, x, pos) = [int(i) for i in input().split()]\nch = binary_search(n, pos)\nfixed = math.perm(x - 1, ch[0]) % (10 ** 9 + 7) * (math.perm(n - x, ch[1]) % (10 ** 9 + 7)) % (10 ** 9 + 7)\nrest = math.factorial(n - ch[0] - ch[1] - 1) % (10 ** 9 + 7)\nprint(fixed * rest % (10 ** 9 + 7))", "m = 1000000007\n\ndef P(a, b):\n    res = 1\n    i = a - b + 1\n    while i <= a:\n        res = res * i % m\n        i += 1\n    return res\n(n, x, pos) = input().split()\nn = int(n)\nx = int(x)\npos = int(pos)\n(l, r) = (0, n)\n(gc, lec) = (0, 0)\nwhile l < r:\n    mid = int((l + r) / 2)\n    if pos == mid:\n        l = mid + 1\n    elif pos + 1 <= mid:\n        r = mid\n        gc += 1\n    elif pos + 1 > mid:\n        l = mid + 1\n        lec += 1\nans = P(n - x, gc) * P(x - 1, lec) % m * P(n - lec - gc - 1, n - lec - gc - 1) % m\nprint(ans)", "(n, x, pos) = map(int, input().split())\n\ndef fact(n):\n    if n == 1 or n == 0:\n        return 1\n    return n * fact(n - 1) % (pow(10, 9) + 7)\narr = []\nc = 0\nfor i in range(n):\n    if i < pos:\n        arr.append(x - c)\n        c = c + 1\n    elif i > pos:\n        arr.append(x + c)\n        c = c + 1\n    else:\n        arr.append(x)\n\ndef bs(arr, x, s):\n    while True:\n        l = 0\n        r = len(arr)\n        while l < r:\n            mid = (l + r) // 2\n            s.add(mid)\n            if arr[mid] <= x:\n                l = mid + 1\n            else:\n                r = mid\n        if l > 0 and arr[l - 1] == x:\n            return True\n        else:\n            return False\ns = set()\nbs(arr, x, s)\ncrr = []\nfor i in s:\n    if i < pos:\n        crr.append(-1)\n    elif i > pos:\n        crr.append(1)\nans = 1\nbc = n - x\ncc = x - 1\nfor i in crr:\n    if i == 1:\n        ans = ans * bc\n        bc = bc - 1\n    if i == -1:\n        ans = ans * cc\n        cc = cc - 1\nans = ans * fact(n - len(crr) - 1) % (pow(10, 9) + 7)\nprint(ans)", "global mod\nmod = 1000000007\n\ndef power(n, x):\n    val = 1\n    while x != 0:\n        if x & 1:\n            val = val * n % mod\n        n = n * n % mod\n        x //= 2\n    return val\n\ndef fact(n):\n    val = 1\n    for i in range(1, n + 1):\n        val = val * i % mod\n    return val\n\ndef comb(n, x):\n    y1 = power(fact(x), mod - 2) % mod\n    y2 = power(fact(n - x), mod - 2) % mod\n    y = fact(n) % mod\n    return y * y1 % mod * y2 % mod % mod\n(n, x, pos) = map(int, input().split())\n(less, more) = (0, 0)\n(l, h) = (0, n)\nwhile l < h:\n    mid = (l + h) // 2\n    if mid <= pos:\n        less += 1\n        l = mid + 1\n    else:\n        more += 1\n        h = mid\nless -= 1\nif less <= x - 1 and more <= n - x:\n    ans = comb(x - 1, less) * fact(less) % mod * (comb(n - x, more) * fact(more)) % mod % mod * fact(n - 1 - (less + more)) % mod % mod\n    print(ans)\nelse:\n    print(0)", "import math\n(n, x, pos) = map(int, input().split())\nl = 0\nr = n\ngt = 0\nlt = 0\nwhile l < r:\n    m = (l + r) // 2\n    if m > pos:\n        r = m\n        gt += 1\n    elif m < pos:\n        l = m + 1\n        lt += 1\n    else:\n        l = m + 1\n\ndef perm(nn, kk=None):\n    rr = math.factorial(nn)\n    if kk is not None:\n        rr //= math.factorial(nn - kk)\n    return rr\nif lt > x - 1 or gt > n - x:\n    res = 0\nelse:\n    res = perm(x - 1, lt) * perm(n - x, gt) * perm(n - lt - gt - 1) % 1000000007\nprint(res)", "def comb(n, x):\n    (a, b) = (1, 1)\n    for i in range(1, x + 1):\n        a *= n + 1 - i\n        b *= i\n    return a // b % mod\n\ndef fact(n):\n    val = 1\n    for i in range(1, n + 1):\n        val = val * i % mod\n    return val % mod\nmod = 1000000007\n(n, x, pos) = map(int, input().split())\n(less, more) = (0, 0)\n(l, h) = (0, n)\nwhile l < h:\n    mid = (l + h) // 2\n    if mid <= pos:\n        less += 1\n        l = mid + 1\n    else:\n        more += 1\n        h = mid\nless -= 1\nif less <= x - 1 and more <= n - x:\n    ans = comb(x - 1, less) * fact(less) % mod * (comb(n - x, more) * fact(more)) % mod % mod * fact(n - 1 - (less + more)) % mod % mod\n    print(ans)\nelse:\n    print(0)", "global mod\nmod = 1000000007\n\ndef power(n, x):\n    val = 1\n    while x != 0:\n        if x & 1:\n            val = val * n % mod\n        n = n * n % mod\n        x //= 2\n    return val\n\ndef fact(n):\n    val = 1\n    for i in range(1, n + 1):\n        val = val * i % mod\n    return val\n\ndef comb(n, x):\n    y1 = power(fact(x), mod - 2) % mod\n    y2 = power(fact(n - x), mod - 2) % mod\n    y = fact(n) % mod\n    return y * y1 % mod * y2 % mod % mod\n(n, x, pos) = map(int, input().split())\n(less, more) = (0, 0)\n(l, h) = (0, n)\nwhile l < h:\n    mid = (l + h) // 2\n    if mid <= pos:\n        less += 1\n        l = mid + 1\n    else:\n        more += 1\n        h = mid\nless -= 1\nif less <= x - 1 and more <= n - x:\n    ans = comb(x - 1, less) * fact(less) % mod * (comb(n - x, more) * fact(more)) % mod % mod * fact(n - 1 - (less + more)) % mod % mod\n    print(ans)\nelse:\n    print(0)", "import math\nyes = 'YES'\nno = 'NO'\nlower = 'L'\nhigher = 'H'\nsame = 'O'\n\ndef bin_search(a, x):\n    left = 0\n    right = len(a)\n    res = []\n    while left < right:\n        mid = (left + right) // 2\n        if a[mid] < x:\n            left = mid + 1\n            res.append(higher)\n        elif a[mid] == x:\n            left = mid + 1\n            res.append(same)\n        else:\n            right = mid\n            res.append(lower)\n    return res\n\ndef solve():\n    numbers = list(map(int, input().split(' ')))\n    options = bin_search([i for i in range(numbers[0])], numbers[2])\n    res = 1\n    (higher_numbers, lower_numbers) = (numbers[0] - numbers[1], numbers[1] - 1)\n    for o in options:\n        if o == higher:\n            res *= lower_numbers\n            lower_numbers -= 1\n        elif o == lower:\n            res *= higher_numbers\n            higher_numbers -= 1\n    res *= math.factorial(numbers[0] - len(options))\n    print(res % (10 ** 9 + 7))\n    return None\nsolve()", "[n, k, pos] = [int(i) for i in input().split()]\nl = 0\nr = n\nc1 = 0\nc2 = 0\nwhile l < r:\n    m = (l + r) // 2\n    if m <= pos:\n        c1 += 1\n        l = m + 1\n    else:\n        c2 += 1\n        r = m\nans = 1\nfor i in range(n - (c1 + c2)):\n    ans = ans * (i + 1)\n    ans = ans % 1000000007\nc1 -= 1\np1 = k - 1\np2 = n - k\nfor i in range(c1):\n    ans = ans * p1\n    ans = ans % 1000000007\n    p1 -= 1\nfor i in range(c2):\n    ans = ans * p2\n    ans = ans % 1000000007\n    p2 -= 1\nprint(ans)", "(n, x, p) = map(int, input().split())\nMOD = 1000000007\nnums = [i + 1 for i in range(n)]\n(left, right) = (0, n)\n(a, b) = (-1, 0)\nwhile left < right:\n    middle = (left + right) // 2\n    if nums[middle] <= nums[p]:\n        left = middle + 1\n        a += 1\n    else:\n        right = middle\n        b += 1\ntotal = 1\nfor i in range(x - 1, x - a - 1, -1):\n    total = total * i % MOD\nfor i in range(n - x, n - x - b, -1):\n    total = total * i % MOD\nfor i in range(1, n - a - b):\n    total = total * i % MOD\nprint(total)", "(a, b, c) = map(int, input().split())\n(l, h) = (0, a)\nr = 1\nz = 0\n(p, q) = (b - 1, a - b)\nwhile l < h:\n    m = (l + h) // 2\n    if m == c:\n        z += 1\n        l = m + 1\n    elif m > c:\n        z += 1\n        r *= q\n        q -= 1\n        h = m\n    else:\n        z += 1\n        r *= p\n        p -= 1\n        l = m + 1\nfor i in range(2, a - z + 1):\n    r = r * i % 1000000007\nprint(r)", "from math import factorial\n\ndef P(n, k):\n    if k <= n:\n        return factorial(n) // factorial(n - k)\n    else:\n        return 0\n(n, x, pos) = map(int, input().split())\nMOD = 10 ** 9 + 7\nl = 0\nu = n\ncnt_less = 0\ncnt_big = 0\nwhile l < u:\n    mid = (l + u) // 2\n    if mid <= pos:\n        if mid < pos:\n            cnt_less += 1\n        l = mid + 1\n    else:\n        cnt_big += 1\n        u = mid\nhasBig = n - x\nhasLess = x - 1\nans = 1\nans *= P(hasBig, cnt_big)\nans %= MOD\nans *= P(hasLess, cnt_less)\nans %= MOD\nans *= factorial(hasBig - cnt_big + hasLess - cnt_less)\nprint(ans % MOD)", "import bisect\nimport math\n\ndef binsearch(arr, x):\n    left = 0\n    right = len(arr)\n    big = 0\n    small = 0\n    while left < right:\n        middle = int((left + right) / 2)\n        if arr[middle] < x:\n            left = middle + 1\n            small += 1\n        elif arr[middle] == x:\n            left = middle + 1\n        else:\n            right = middle\n            big += 1\n    return (big, small)\n    pass\n\ndef solve(n, x, pos):\n    p = 10 ** 9 + 7\n    arr = [int(x) for x in range(n)]\n    (big, small) = binsearch(arr, pos)\n    k1 = math.factorial(small) * math.comb(x - 1, small)\n    k2 = math.factorial(big) * math.comb(n - x, big)\n    per = math.factorial(n - (small + big + 1))\n    return k1 % p * k2 % p * per % p % p\n    pass\nt = 1\nans = []\nfor i in range(t):\n    s = [int(x) for x in input().split()]\n    n = s[0]\n    x = s[1]\n    pos = s[2]\n    ans.append(solve(n, x, pos))\nfor a in ans:\n    print(a)", "def nCr(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n\ndef nPr(n, r):\n    return fact(n) // fact(n - r)\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\nmod = 1000000007\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\ngr = 0\nsm = 0\nwhile left < right:\n    middle = (left + right) // 2\n    if middle <= pos:\n        left = middle + 1\n        gr += 1\n    elif middle > pos:\n        right = middle\n        sm += 1\ngr -= 1\nif gr > x - 1 or sm > n - x:\n    print(0)\nelse:\n    print(nPr(x - 1, gr) % mod * (nPr(n - x, sm) % mod) * (fact(n - gr - sm - 1) % mod) % mod)", "import math\nmod = 10 ** 9 + 7\n(n, x, pos) = list(map(int, input().split()))\n(l, h) = (0, n)\ngv = n - x\nlv = x - 1\nout = 1\ncnt = 0\nwhile l < h:\n    m = (l + h) // 2\n    cnt += 1\n    if m == pos:\n        l = m + 1\n    elif m < pos:\n        l = m + 1\n        out *= lv\n        lv -= 1\n    else:\n        h = m\n        out *= gv\n        gv -= 1\n    out %= mod\nout *= math.factorial(n - cnt) % mod\nout %= mod\nprint(out)", "(n, x, p) = map(int, input().split())\n(l, r) = (0, n)\nbig = small = 0\nwhile l < r:\n    m = (l + r) // 2\n    if p < m:\n        r = m\n        big += 1\n    else:\n        l = m + 1\n        if m != p:\n            small += 1\nans = 1\nmod = 1000000007\nfor i in range(big):\n    ans = ans * (n - x - i) % mod\nfor i in range(1, small + 1):\n    ans = ans * (x - i) % mod\nfor i in range(1, n - small - big):\n    ans = ans * i % mod\nprint(ans)", "import sys\nimport math\ninput = lambda : sys.stdin.readline().rstrip()\n(n, x, pos) = map(int, input().split())\nless = x - 1\nmore = n - x\nl = 0\nr = n\nc = 1\navail = n - 1\nmod = 10 ** 9 + 7\nwhile l < r:\n    mid = (l + r) // 2\n    if mid == pos:\n        l = mid + 1\n    elif mid < pos:\n        c *= less\n        less -= 1\n        l = mid + 1\n        avail -= 1\n    else:\n        c *= more\n        more -= 1\n        r = mid\n        avail -= 1\nless += more\nc *= math.factorial(less)\nprint(c % mod)", "import math\ng = lambda : map(int, input().split())\nmod = 10 ** 9 + 7\n(n, x, pos) = g()\nans = 1\nr = n\nl = 0\nans = 1\nup = n - x\nsm = x - 1\ncount = 0\nwhile l < r:\n    m = (l + r) // 2\n    if m <= pos:\n        if m != pos:\n            ans = ans * sm\n            sm -= 1\n        l = m + 1\n    else:\n        if m != pos:\n            ans = ans * up\n            up -= 1\n        r = m\n    count += 1\n    ans = ans % mod\nans *= math.factorial(n - count) % mod\nans %= mod\nprint(ans)", "import math\n(n, x, p) = map(int, input().split())\nleft = 0\nright = n\nmore = n - x\nless = n - more - 1\nanswer = 1\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < p:\n        answer *= less\n        less -= 1\n        left = mid + 1\n    elif mid > p:\n        answer *= more\n        more -= 1\n        right = mid\n    else:\n        left = mid + 1\nanswer *= math.factorial(more + less)\nprint(answer % 1000000007)", "import math\n\ndef binary_search(a, x):\n    left = 0\n    right = len(a)\n    n_less = 0\n    n_greater = 0\n    while left < right:\n        middle = (left + right) // 2\n        if a[middle] <= x:\n            left = middle + 1\n            if x != middle:\n                n_less += 1\n        else:\n            right = middle\n            n_greater += 1\n    if left > 0 and a[left - 1] == x:\n        return (True, n_less, n_greater)\n    else:\n        return (False, n_less, n_greater)\n\ndef combination(n, k):\n    if k > n:\n        return 0\n    else:\n        return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\nnxpos = input().split(' ')\nn = int(nxpos[0])\nx = int(nxpos[1])\npos = int(nxpos[2])\nn_smaller_numbers = x - 1\nn_bigger_numbers = n - x\na = [i for i in range(n)]\n(_, n_less, n_greater) = binary_search(a, pos)\nc1 = combination(n_smaller_numbers, n_less) * math.factorial(n_less)\nc2 = combination(n_bigger_numbers, n_greater) * math.factorial(n_greater)\nres = c1 * c2 * math.factorial(n - n_less - n_greater - 1)\nprint(res % (1000000000 + 7))", "import math\n(n, x, pos) = [int(k) for k in input().split()]\nans = 1\ngreater = n - x\nsmaller = x - 1\nleft = 0\nright = n\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < pos:\n        ans *= smaller\n        smaller -= 1\n        left = mid + 1\n    elif mid > pos:\n        ans *= greater\n        greater -= 1\n        right = mid\n    else:\n        left = mid + 1\nans *= math.factorial(smaller + greater)\nans = ans % 1000000007\nprint(ans)", "def solve(n, val, pos):\n    l = 0\n    r = n\n    small = val - 1\n    big = n - val\n    (pos1, pos2) = (0, 0)\n    while l < r:\n        mid = (l + r) // 2\n        if mid <= pos:\n            pos1 += 1\n            l = mid + 1\n        elif mid > pos:\n            pos2 += 1\n            r = mid\n    (ans, mod) = (1, 10 ** 9 + 7)\n    for i in range(n - (pos1 + pos2)):\n        ans = ans * (i + 1)\n        ans = ans % mod\n    pos1 -= 1\n    for _ in range(pos1):\n        ans = ans * small\n        ans = ans % mod\n        small -= 1\n    for _ in range(pos2):\n        ans = ans * big\n        ans = ans % mod\n        big -= 1\n    print(ans)\n(n, x, pos) = map(int, input().split())\nsolve(n, x, pos)", "import math\n(n, x, pos) = map(int, input().split())\n(left, right) = (0, n)\nmore = n - x\nless = n - more - 1\nans = 1\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < pos:\n        ans *= less\n        less -= 1\n        left = mid + 1\n    elif mid > pos:\n        ans *= more\n        more -= 1\n        right = mid\n    else:\n        left = mid + 1\nans *= math.factorial(more + less)\nprint(ans % 1000000007)", "def ncr(n, r, p):\n    if r > n:\n        return 0\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef fac(n, p):\n    if n >= p:\n        return 0\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i % p\n    return result\n(n, x, pos) = list(map(int, input().split(' ')))\ns = g = 0\na = 0\nb = n\nwhile a < b:\n    mid = (a + b) // 2\n    if mid <= pos:\n        s += 1\n        a = mid + 1\n    else:\n        g += 1\n        b = mid\np = 1000\np = p * p * p + 7\nprint(ncr(x - 1, s - 1, p) * fac(s - 1, p) * ncr(n - x, g, p) * fac(g, p) * fac(n - s - g, p) % p)", "(a, e, x) = [int(i) for i in input().split()]\n(b, s) = (a - e, e - 1)\n(l, r, c, res) = (0, a, a - 1, 1)\nmodulo = 10 ** 9 + 7\nwhile l < r:\n    m = (l + r) // 2\n    if m < x:\n        c -= 1\n        l = m + 1\n        res *= s % (10 ** 9 + 7)\n        s -= 1\n    elif m == x:\n        res = res\n        l = m + 1\n    else:\n        c -= 1\n        res *= b % modulo\n        b -= 1\n        r = m\nf = 1\nfor i in range(1, c + 1):\n    f *= i % modulo\nprint(res * f % modulo)", "import math\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\nmore = n - x\nless = n - more - 1\nans = 1\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < pos:\n        ans *= less\n        less -= 1\n        left = mid + 1\n    elif mid > pos:\n        ans *= more\n        more -= 1\n        right = mid\n    else:\n        left = mid + 1\nans *= math.factorial(more + less)\nprint(ans % 1000000007)", "import math\n\ndef bins(a, x, pos):\n    posl = []\n    (left, right) = (0, len(a))\n    while left < right:\n        middle = math.floor((left + right) / 2)\n        if a[middle] <= x:\n            left = middle + 1\n            if middle != pos:\n                posl.append('l')\n        else:\n            right = middle\n            if middle != pos:\n                posl.append('r')\n    return posl\n(n, x, pos) = list(map(int, input().split()))\na = [0] * pos\na.append(x)\na.extend([x + 1] * (n - pos - 1))\nb = bins(a, x, pos)\n(r, l) = (b.count('r'), b.count('l'))\nrcount = n - x\nlcount = x - 1\ncount = n - 1\nres = 1\nfor i in range(r):\n    res *= rcount\n    rcount -= 1\n    count -= 1\nfor i in range(l):\n    res *= lcount\n    lcount -= 1\n    count -= 1\nfor i in range(1, count + 1):\n    res *= i % 1000000007\nprint(res % 1000000007)", "import math\nmod = 10 ** 9 + 7\n(n, x, pos) = list(map(int, input().split()))\n(l, h) = (0, n)\ngv = n - x\nlv = x - 1\nout = 1\ncnt = 0\nwhile l < h:\n    m = (l + h) // 2\n    cnt += 1\n    if m == pos:\n        l = m + 1\n    elif m < pos:\n        l = m + 1\n        out *= lv\n        lv -= 1\n    else:\n        h = m\n        out *= gv\n        gv -= 1\n    out %= mod\nout *= math.factorial(n - cnt) % mod\nout %= mod\nprint(out)", "mod = 1000000007\n\ndef power(n, x):\n    val = 1\n    while x != 0:\n        if x & 1:\n            val = val * n % mod\n        n = n * n % mod\n        x //= 2\n    return val\n\ndef fact(n):\n    val = 1\n    for i in range(1, n + 1):\n        val = val * i % mod\n    return val\n\ndef comb(n, x):\n    y1 = power(fact(x), mod - 2) % mod\n    y2 = power(fact(n - x), mod - 2) % mod\n    y = fact(n) % mod\n    return y * y1 % mod * y2 % mod % mod\n(n, x, pos) = map(int, input().split())\n(less, more) = (0, 0)\n(l, h) = (0, n)\nwhile l < h:\n    mid = (l + h) // 2\n    if mid <= pos:\n        less += 1\n        l = mid + 1\n    else:\n        more += 1\n        h = mid\nless -= 1\nif less <= x - 1 and more <= n - x:\n    ans = comb(x - 1, less) * fact(less) % mod * (comb(n - x, more) * fact(more)) % mod % mod * fact(n - 1 - (less + more)) % mod % mod\n    print(ans)\nelse:\n    print(0)", "(a, b, c) = map(int, input().split())\n(l, h) = (0, a)\nr = 1\nz = 0\n(p, q) = (b - 1, a - b)\nwhile l < h:\n    m = (l + h) // 2\n    if m == c:\n        z += 1\n        l = m + 1\n    elif m > c:\n        z += 1\n        r *= q\n        q -= 1\n        h = m\n    else:\n        z += 1\n        r *= p\n        p -= 1\n        l = m + 1\nfor i in range(2, a - z + 1):\n    r = r * i % 1000000007\nprint(r)", "(n, a, b) = map(int, input().split())\nmod = 1000000000 + 7\nans = 1\n(cnt, cnt1) = (0, 0)\n(i, j) = (0, n)\nwhile i < j:\n    mid = (i + j) // 2\n    if mid < b:\n        ans *= a - 1 - cnt1\n        ans %= mod\n        cnt1 += 1\n        i = mid + 1\n    elif mid > b:\n        ans *= n - a - cnt\n        ans %= mod\n        cnt += 1\n        j = mid\n    else:\n        i = mid + 1\ncr = n - cnt - cnt1 - 1\nfor i in range(1, cr + 1):\n    ans *= i\n    ans %= mod\nprint(ans)", "import math\n\ndef ncr(a, b):\n    if a < b or a < 0 or b < 0:\n        return 0\n    c = math.factorial(a) // math.factorial(a - b)\n    c = int(c)\n    return c % 1000000007\n\ndef bs(n, x):\n    left = 0\n    right = n\n    (c1, c2) = (0, 0)\n    while left < right:\n        mid = (left + right) // 2\n        if mid <= x:\n            if mid != x:\n                c1 += 1\n            left = mid + 1\n        else:\n            c2 += 1\n            right = mid\n    return (c1, c2)\n(n, x, pos) = map(int, input().split())\n(c1, c2) = bs(n, pos)\nb = n - x\nx -= 1\nd = ncr(x, c1)\ne = ncr(b, c2)\na = int(math.factorial(n - c1 - c2 - 1))\nm = 1000000007\nprint(a % m * d % m * e % m % m)", "(a, b, c) = map(int, input().split())\n(l, h) = (0, a)\nr = 1\nz = 0\n(p, q) = (b - 1, a - b)\nwhile l < h:\n    m = (l + h) // 2\n    if m == c:\n        z += 1\n        l = m + 1\n    elif m > c:\n        z += 1\n        r *= q\n        q -= 1\n        h = m\n    else:\n        z += 1\n        r *= p\n        p -= 1\n        l = m + 1\nfor i in range(2, a - z + 1):\n    r = r * i % 1000000007\nprint(r)", "vals = input().split()\nn = int(vals[0])\nx = int(vals[1])\npos = int(vals[2])\nbig = 0\nsmall = 0\nans = 1\n(l, r) = (0, n)\nwhile l < r:\n    mid = (l + r) // 2\n    if mid == pos:\n        l = mid + 1\n    elif mid > pos:\n        r = mid\n        big += 1\n    else:\n        l = mid + 1\n        small += 1\nif small >= x or big > n - x:\n    print(0)\nelse:\n    MOD = int(1000000000.0 + 7)\n    for i in range(1, small + 1):\n        ans = ans * (x - i) % MOD\n    for i in range(1, big + 1):\n        ans = ans * (n - x + 1 - i) % MOD\n    for i in range(1, n - small - big):\n        ans = ans * i % MOD\n    print(ans)", "import sys\nimport math\nfrom bisect import bisect_right as br\nfrom statistics import mode\nfrom itertools import combinations as cb\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\n(n, x, pos) = int_arr()\ni = 0\nj = n\nans = 1\nl = x - 1\nr = n - x\nmod = 10 ** 9 + 7\nwhile i < j:\n    mid = (i + j) // 2\n    if mid < pos:\n        i = mid + 1\n        ans = ans * l % mod\n        l -= 1\n    elif mid > pos:\n        j = mid\n        ans = ans * r % mod\n        r -= 1\n    else:\n        i = mid + 1\nrem = l + r\nfor i in range(1, rem + 1):\n    ans = ans * i % mod\nprint(ans)", "from enum import Enum, auto\nMOD = 10 ** 9 + 7\n\nclass State(Enum):\n    LOWER = (auto(),)\n    HIGHER = (auto(),)\n    NO_CARE = (auto(),)\n\ndef include_states(n, pos, states):\n    left = 0\n    right = n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            left = middle + 1\n            states[middle] = State.LOWER\n        else:\n            right = middle\n            states[middle] = State.HIGHER\n    if left - 1 != pos:\n        return -1\n(n, x, pos) = (int(x) for x in input().split())\nstates = n * [State.NO_CARE]\nif include_states(n, pos, states) == -1:\n    print(0)\n    exit(0)\nhigher = [i for (i, state) in enumerate(states) if state is State.HIGHER and i != pos]\nlower = [i for (i, state) in enumerate(states) if state is State.LOWER and i != pos]\nno_care = [i for (i, state) in enumerate(states) if state is State.NO_CARE and i != pos]\nstart = n\nresults = [1] * n\n(higher_len, lower_len, no_care_len) = (len(higher), len(lower), len(no_care))\ntmp_high = n - x\nfor index in higher:\n    results[index] = tmp_high\n    tmp_high -= 1\ntmp_lower = x - 1\nfor index in lower:\n    results[index] = tmp_lower\n    tmp_lower -= 1\ntmp_no_care = tmp_high + tmp_lower\nfor index in no_care:\n    results[index] = tmp_no_care\n    tmp_no_care -= 1\nresult = 1\nfor elem in results:\n    result = result * elem % MOD\nprint(result)", "def fact(n):\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n        ans %= mod\n    return ans\n\ndef binary_search(n, x, idx):\n    l = 0\n    r = n\n    ans = 1\n    bigger = 0\n    smaller = 0\n    while l < r:\n        mid = (l + r) // 2\n        if mid > idx:\n            ans *= n - x - bigger\n            ans %= mod\n            bigger += 1\n            r = mid\n        elif mid < idx:\n            l = mid + 1\n            ans *= x - 1 - smaller\n            ans %= mod\n            smaller += 1\n        else:\n            l = mid + 1\n    ans *= fact(n - smaller - bigger - 1)\n    return ans % mod\nmod = 1000000007\n(n, x, pos) = map(int, input().split())\nprint(binary_search(n, x, pos))", "mod = 10 ** 9 + 7\nfact = [0] * 1001\nfact[0] = 1\nfor i in range(1, 1001):\n    fact[i] = fact[i - 1] * i % mod\nncr = [[0] * 16 for i in range(1001)]\nncr[0][0] = 1\nncr[1][0] = 1\nncr[1][1] = 1\nfor i in range(2, 1001):\n    ncr[i][0] = 1\n    for j in range(1, min(i + 1, 16)):\n        ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]) % mod\n\ndef bs(x, n):\n    l = 0\n    r = n\n    left = 0\n    right = 0\n    while l < r:\n        mid = (l + r) // 2\n        if mid > x:\n            r = mid\n            right += 1\n        else:\n            if mid != x:\n                left += 1\n            l = mid + 1\n    return [left, right]\n(n, x, pos) = map(int, input().split())\n(l, r) = bs(pos, n)\nans = fact[n - (l + r) - 1]\nans = ans * ncr[n - x][r] * fact[r] % mod\nans = ans * ncr[x - 1][l] * fact[l] % mod\nprint(ans % mod)", "from collections import *\nfrom itertools import *\nfrom bisect import *\nfrom math import comb, perm, factorial\n\ndef inp():\n    return int(input())\n\ndef arrinp():\n    return [int(x) for x in input().split()]\nM = int(10 ** 9 + 7)\n\ndef checks(n, pos):\n    x = pos + 1\n    A = [i + 1 for i in range(n)]\n    (left, right) = (0, len(A))\n    (sm_c, bi_c) = (0, 0)\n    while left < right:\n        middle = (left + right) // 2\n        if A[middle] < x:\n            left = middle + 1\n            sm_c += 1\n        elif A[middle] == x:\n            left = middle + 1\n        else:\n            right = middle\n            bi_c += 1\n    return (sm_c, bi_c)\n\ndef main():\n    (n, x, pos) = arrinp()\n    (sm_c, bi_c) = checks(n, pos)\n    lower = x - 1\n    upper = n - x\n    x = perm(lower, sm_c)\n    x *= perm(upper, bi_c)\n    x *= factorial(n - (sm_c + bi_c + 1))\n    print(x % (10 ** 9 + 7))\nmain()", "[n, k, pos] = [int(i) for i in input().split()]\nl = 0\nr = n\nc1 = 0\nc2 = 0\nwhile l < r:\n    m = (l + r) // 2\n    if m <= pos:\n        c1 += 1\n        l = m + 1\n    else:\n        c2 += 1\n        r = m\nans = 1\nfor i in range(n - (c1 + c2)):\n    ans = ans * (i + 1)\n    ans = ans % 1000000007\nc1 -= 1\np1 = k - 1\np2 = n - k\nfor i in range(c1):\n    ans = ans * p1\n    ans = ans % 1000000007\n    p1 -= 1\nfor i in range(c2):\n    ans = ans * p2\n    ans = ans % 1000000007\n    p2 -= 1\nprint(ans)", "import math\nimport sys\nsys.setrecursionlimit(1000000)\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\nans = 1\ntx = x - 1\nty = n - x\nwhile left < right:\n    mid = (left + right) // 2\n    if mid > pos:\n        ans = ans * ty % (10 ** 9 + 7)\n        ty -= 1\n        right = mid\n    elif mid < pos:\n        ans = ans * tx % (10 ** 9 + 7)\n        tx -= 1\n        left = mid + 1\n    else:\n        left = mid + 1\nfor i in range(1, tx + ty + 1):\n    ans = ans * i % (10 ** 9 + 7)\nprint(ans)", "import math\n[n, x, pos] = list(map(int, input().split()))\n\ndef binarySearch(a, x):\n    left = 0\n    right = len(a)\n    count = 0\n    lcount = 0\n    while left < right:\n        middle = (left + right) // 2\n        if a[middle] <= x:\n            left = middle + 1\n            if a[middle] < x:\n                lcount += 1\n        else:\n            right = middle\n            count += 1\n    if left > 0 and a[left - 1] == x:\n        return [True, count, lcount]\n    else:\n        return [False, count, lcount]\n\ndef binomial(n, k):\n    return 1 if n <= 0 else int(math.factorial(n)) // int(math.factorial(n - k))\nmod = 10 ** 9 + 7\n\ndef permutationCount(n, x, pos):\n    [good, count, lcount] = binarySearch(range(1, n + 1), pos + 1)\n    if n - x - count < 0 or x - 1 - lcount < 0:\n        return 0\n    return binomial(n - x, count) % mod * (binomial(x - 1, lcount) % mod) * int(math.factorial(n - count - lcount - 1) % mod)\nprint(permutationCount(n, x, pos) % mod)", "[n, k, pos] = [int(i) for i in input().split()]\nl = 0\nr = n\nc1 = 0\nc2 = 0\nans = 1\nwhile l < r:\n    m = (l + r) // 2\n    if m <= pos:\n        c1 += 1\n        l = m + 1\n    else:\n        c2 += 1\n        r = m\nfor i in range(n - (c1 + c2)):\n    ans *= i + 1\n    ans %= 1000000007\nc1 -= 1\np1 = k - 1\np2 = n - k\nfor i in range(c1):\n    ans *= p1\n    ans %= 1000000007\n    p1 -= 1\nfor i in range(c2):\n    ans *= p2\n    ans %= 1000000007\n    p2 -= 1\nprint(ans)", "factorial = [1, 1, 2]\nfor i in range(3, 1001):\n    factorial.append(i * factorial[-1])\n\ndef comb(n, r):\n    c = factorial[n] // factorial[n - r]\n    return int(c)\n(n, x, pos) = map(int, input().split())\nleft = 0\nright = n\nsmaller = 0\nequal = 0\nlarger = 0\nwhile left != right:\n    mid = (left + right) // 2\n    if pos < mid:\n        larger += 1\n        right = mid\n    elif pos > mid:\n        smaller += 1\n        left = mid + 1\n    elif pos == mid:\n        equal += 1\n        left = mid + 1\nif larger > n - x:\n    print(0)\nelif smaller > x - 1:\n    print(0)\nelse:\n    s = comb(x - 1, smaller)\n    l = comb(n - x, larger) % 1000000007\n    fact = factorial[n - smaller - larger - 1] % 1000000007\n    num = s * l * fact\n    num %= 1000000007\n    print(int(num))", "pr = []\n\ndef ok(n, t):\n    left = 0\n    right = n\n    while left < right:\n        m = int((left + right) / 2)\n        pr.append(m)\n        if m <= t:\n            left = m + 1\n        else:\n            right = m\n    return\nmod = int(1000000000.0) + 7\n(n, m, idx) = map(int, input().split())\nok(n, idx)\n(big, small, res) = (n - m, m - 1, 1)\nfor i in pr:\n    if i > idx:\n        res = res * big % mod\n        big -= 1\n    elif i < idx:\n        res = res * small % mod\n        small -= 1\n    else:\n        res = res % mod\nfor i in range(1, n - len(pr) + 1):\n    res = res * i % mod\nprint(res)", "mod = 10 ** 9 + 7\n(n, x, pos) = map(int, input().split())\n(left, right) = (0, n)\n(lower, higher, ans) = (x - 1, n - x, 1)\nwhile left < right:\n    mid = (left + right) // 2\n    if mid == pos:\n        left = mid + 1\n    elif mid > pos:\n        ans = ans * higher % mod\n        right = mid\n        higher -= 1\n    else:\n        ans = ans * lower % mod\n        lower -= 1\n        left = mid + 1\nlower += higher\nwhile lower > 0:\n    ans = ans * lower % mod\n    lower -= 1\nprint(ans % mod)", "(n, x, pos) = map(int, input().split())\n\ndef factoriel(n):\n    if n < 2:\n        return 1\n    b = n - 1\n    while b > 0:\n        n *= b % (10 ** 9 + 7)\n        b -= 1\n    return n\n\ndef test():\n    low = 0\n    big = 0\n    left = 0\n    right = n\n    while left < right:\n        middle = (left + right) // 2\n        if middle > pos:\n            right = middle\n            big += 1\n        else:\n            left = middle + 1\n            low += 1\n    return (low, big)\n(low, big) = test()\nlow -= 1\nans = 1\nt = x - 1\nfor i in range(low):\n    ans *= t\n    t -= 1\nt = n - x\nfor i in range(big):\n    ans *= t\n    t -= 1\nprint(ans * factoriel(n - 1 - (low + big)) % (10 ** 9 + 7))", "import math\n\ndef nPr(n, r):\n    return math.factorial(n) // math.factorial(n - r)\n(n, x, p) = map(int, input().split())\nsm = x - 1\nbig = n - x\nleft = 0\nright = n\nl = r = 0\nmod = 10 ** 9 + 7\nwhile left < right:\n    mid = (left + right) // 2\n    if mid <= p:\n        if mid != p:\n            l += 1\n        left = mid + 1\n    else:\n        r += 1\n        right = mid\nans = 0\nif l > sm or r > big or left - 1 != p:\n    print(0)\nelse:\n    ans = nPr(sm, l) % mod\n    ans %= mod\n    ans *= nPr(big, r) % mod\n    ans %= mod\n    ans *= math.factorial(n - (l + r + 1)) % mod\n    print(ans % mod)", "from sys import maxsize, stdout, stdin, stderr\nmod = int(1000000000.0 + 7)\n\ndef tup():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\n\ndef lint():\n    return [int(x) for x in stdin.readline().split()]\n\ndef S():\n    return input().strip()\n\ndef grid(r, c):\n    return [lint() for i in range(r)]\n\ndef debug(*args, c=6):\n    print('\\x1b[3{}m'.format(c), *args, '\\x1b[0m', file=stderr)\nfact = [0] * 1001\nfact[0] = 1\nfact[1] = 1\nfor i in range(1, 1001):\n    fact[i] = i * fact[i - 1] % mod\n(n, x, p) = tup()\nsm = x - 1\ngr = n - x\nl = 0\nh = n\nans = 1\nwhile l < h:\n    m = (l + h) // 2\n    if m == p:\n        l = m + 1\n    elif m > p:\n        h = m\n        ans = ans * gr % mod\n        gr -= 1\n    else:\n        ans = ans * sm % mod\n        l = m + 1\n        sm -= 1\n    n -= 1\nif ans > 0:\n    ans = ans * fact[n] % mod\n    print(ans)\nelse:\n    print(0)", "from functools import reduce\n(n, x, p) = list(map(int, input().split()))\na = 0\nb = -1\nleft = 0\nright = n\nwhile left < right:\n    middle = (left + right) // 2\n    if p >= middle:\n        left = middle + 1\n        b += 1\n    else:\n        right = middle\n        a += 1\nf = 1\nF1 = 1\nF2 = 1\nF3 = 1\nF4 = 1\nF5 = 1\nfor i in range(1, n + 1):\n    f *= i\n    if i == x - 1:\n        F1 = f\n    if i == x - b - 1:\n        F2 = f\n    if i == n - x:\n        F3 = f\n    if i == n - x - a:\n        F4 = f\n    if i == n - a - b - 1:\n        F5 = f\nans = F1 * F3 * F5 // (F2 * F4)\nif x - 1 - b < 0 or n - x - a < 0 or n - a - b - 1 < 0:\n    print(0)\nelse:\n    print(ans % (10 ** 9 + 7))", "import math\nimport sys, bisect\nfrom heapq import *\nfrom itertools import *\nfrom collections import *\nsys.setrecursionlimit(10 ** 6)\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\n(n, val, pos) = neo()\nless = val - 1\nlarge = n - val\ns = 0\ne = n\nAns = 1\nwhile s < e:\n    mid = (s + e) // 2\n    if mid < pos:\n        s = mid + 1\n        Ans *= less\n        less -= 1\n    elif mid > pos:\n        e = mid\n        Ans *= large\n        large -= 1\n    else:\n        s = mid + 1\nless += large\nfor i in range(less, 0, -1):\n    Ans *= i\nprint(Ans % (10 ** 9 + 7))", "[n, k, pos] = [int(i) for i in input().split()]\nl = 0\nr = n\nc1 = 0\nc2 = 0\nwhile l < r:\n    m = (l + r) // 2\n    if m <= pos:\n        c1 += 1\n        l = m + 1\n    else:\n        c2 += 1\n        r = m\nans = 1\nfor i in range(n - (c1 + c2)):\n    ans = ans * (i + 1)\n    ans = ans % 1000000007\nc1 -= 1\np1 = k - 1\np2 = n - k\nfor i in range(c1):\n    ans = ans * p1\n    ans = ans % 1000000007\n    p1 -= 1\nfor i in range(c2):\n    ans = ans * p2\n    ans = ans % 1000000007\n    p2 -= 1\nprint(ans)", "lm = 1010\nf = {0: 1}\nmod = 10 ** 9 + 7\nfor i in range(1, lm):\n    f[i] = i * f[i - 1] % mod\n\ndef BnS(pos, n):\n    (l, r) = (0, n)\n    (sm, bg) = (0, 0)\n    while l < r:\n        m = (l + r) // 2\n        if m <= pos:\n            sm += 1\n            l = m + 1\n        else:\n            bg += 1\n            r = m\n    return (sm, bg)\n(N, x, pos) = map(int, input().split())\n(small, big) = BnS(pos, N)\n\ndef p(n, r):\n    if r > n:\n        return 0\n    ans = f[n] * pow(f[n - r], mod - 2, mod)\n    ans %= mod\n    return ans\nans = p(x - 1, small - 1) * p(N - x, big) % mod\nans = ans * f[N - (small + big)]\nans %= mod\nprint(ans)", "MOD = int(1000000000.0 + 7)\nfrom math import factorial\n(n, x, p) = input().split()\n(n, x, p) = (int(n), int(x), int(p))\ns = 0\ne = n\n\ndef perm(n, k):\n    if k <= n:\n        return factorial(n) // factorial(n - k)\n    else:\n        return 0\npos_greater_than = 0\npos_less_than = 0\nwhile s < e:\n    mid = (s + e) // 2\n    if p < mid:\n        pos_greater_than += 1\n        e = mid\n    elif p >= mid:\n        s = mid + 1\n        if p > mid:\n            pos_less_than += 1\nans1 = perm(n - x, pos_greater_than)\nans2 = perm(x - 1, pos_less_than)\nans3 = factorial(n - pos_greater_than - pos_less_than - 1)\nans = ans1 * ans2 * ans3 % MOD\nprint(ans)", "M = 10 ** 9 + 7\nN = 10 ** 3 + 1\nfact = [0 for i in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = i % M * fact[i - 1] % M % M\ninvfact = [0 for i in range(N)]\ninvfact[N - 1] = pow(fact[N - 1], M - 2, M)\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] % M * (i + 1) % M % M\n\ndef ncr(n, r):\n    if n < 0 or r > n or r < 0:\n        return 0\n    return fact[n] % M * invfact[r] % M % M * (invfact[n - r] % M) % M % M\nfor _ in range(1):\n    (n, x, pos) = map(int, input().split())\n    cntb = 0\n    cnts = 0\n    (left, right) = (0, n)\n    while left < right:\n        middle = (left + right) // 2\n        if middle < pos:\n            cnts = cnts + 1\n            left = middle + 1\n        elif middle > pos:\n            cntb = cntb + 1\n            right = middle\n        else:\n            left = middle + 1\n    ans = ncr(n - x, cntb) % M\n    ans = ans % M * fact[cntb] % M % M\n    ans = ans % M * ncr(x - 1, cnts) % M\n    ans = ans % M * fact[cnts] % M % M\n    ans = ans % M * fact[n - cnts - cntb - 1] % M % M\n    print(ans % M)", "mod = int(1000000000.0 + 7)\nfac = [1]\nfor i in range(1, 1001):\n    fac.append(fac[-1] * i % mod)\ninverse_fac = [pow(fac[-1], mod - 2, mod)]\nfor i in range(1000, 0, -1):\n    inverse_fac.append(inverse_fac[-1] * i % mod)\ninverse_fac.reverse()\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fac[n] * inverse_fac[n - r] % mod\n(n, x, pos) = map(int, input().split())\nreq_b = 0\nreq_s = 0\nhave_b = n - x\nhave_s = x - 1\nl = 0\nh = n\nwhile l < h:\n    mid = (l + h) // 2\n    if mid > pos:\n        h = mid\n        req_b += 1\n    elif mid < pos:\n        l = mid + 1\n        req_s += 1\n    else:\n        l = mid + 1\nbi = ncr(have_b, req_b)\nsm = ncr(have_s, req_s)\nremain = fac[n - req_b - req_s - 1]\nans = bi * sm % mod\nans = ans * remain % mod\nprint(ans)", "bigmod = 10 ** 9 + 7\n\ndef Bserach(n, pos, x):\n    left = 0\n    right = n\n    l = 0\n    r = -1\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            r += 1\n            left = middle + 1\n        else:\n            l += 1\n            right = middle\n    answer = 1\n    for i in range(l):\n        answer *= n - x - i\n        answer %= bigmod\n    for i in range(r):\n        answer *= x - 1 - i\n        answer %= bigmod\n    for i in range(1, n - l - r):\n        answer *= i\n        answer %= bigmod\n    return answer\n[n, x, pos] = list(map(int, input().split()))\nprint(Bserach(n, pos, x))", "(n, x, pos) = map(int, input().split())\na = [i for i in range(n)]\nzero = 0\none = 0\nleft = 0\nright = n\nwhile left < right:\n    middle = (left + right) // 2\n    if a[middle] <= pos:\n        zero += 1\n        left = middle + 1\n    else:\n        one += 1\n        right = middle\nres = 1\nmod = 10 ** 9 + 7\nfor i in range(zero - 1):\n    res *= x - 1 - i\n    res %= mod\nfor i in range(one):\n    res *= n - x - i\n    res %= mod\nfor j in range(n - zero - one):\n    res *= j + 1\n    res %= mod\nprint(res)", "(n, x, pos) = map(int, input().split())\n\ndef factoriel(n):\n    if n < 2:\n        return 1\n    b = n - 1\n    while b > 0:\n        n *= b\n        b -= 1\n    return n\n\ndef test():\n    low = 0\n    big = 0\n    left = 0\n    right = n\n    while left < right:\n        middle = (left + right) // 2\n        if middle > pos:\n            right = middle\n            big += 1\n        else:\n            left = middle + 1\n            low += 1\n    return (low, big)\n(low, big) = test()\nlow -= 1\nans = 1\nt = x - 1\nfor i in range(low):\n    ans *= t\n    t -= 1\nt = n - x\nfor i in range(big):\n    ans *= t\n    t -= 1\nprint(ans * factoriel(n - 1 - (low + big)) % (10 ** 9 + 7))", "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(99999)\n(n, x, p) = map(int, input().split())\nlx = x - 1\nrx = n - x\nmod = 10 ** 9 + 7\nl = 0\nr = n\nans = 1\nwhile l < r:\n    mid = (l + r) // 2\n    if mid > p:\n        r = mid\n        ans *= rx\n        rx -= 1\n    else:\n        if mid < p:\n            ans *= lx\n            lx -= 1\n        l = mid + 1\n    ans %= mod\nf = [1] * 1001\nfor i in range(2, 1001):\n    f[i] = f[i - 1] * i % mod\nprint(ans * f[lx + rx] % (10 ** 9 + 7))"]