["def solve():\n    (N, A, R, M) = map(int, input().split())\n    H = sorted(list(map(int, input().split())))\n    tB = [0] * (N + 1)\n    minCost = 10 ** 20\n    for (i, h) in enumerate(H):\n        tB[i + 1] = tB[i] + h\n    for i in range(N):\n        toAdd = H[i] * i - tB[i]\n        toSub = tB[N] - tB[i + 1] - H[i] * (N - i - 1)\n        if M >= A + R:\n            minCost = min(minCost, A * toAdd + R * toSub)\n        else:\n            mN = min(toAdd, toSub)\n            minCost = min(minCost, A * (toAdd - mN) + R * (toSub - mN) + M * mN)\n    if M < A + R:\n        sumH = sum(H)\n        (lcost, hcost) = (0, 0)\n        fH = sumH // N\n        for (i, h) in enumerate(H):\n            if h < fH:\n                lcost += (fH - h) * M\n            if h > fH + 1:\n                hcost += (h - fH - 1) * M\n        lcost += sumH % N * R\n        hcost += (N - sumH % N) * A\n        minCost = min(minCost, lcost, hcost)\n    print(minCost)\nsolve()", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    (N, A, R, M) = map(int, input().split())\n    H = [int(h) for h in input().split()]\n    H.sort()\n    tB = [0] * (N + 1)\n    for (i, h) in enumerate(H):\n        tB[i + 1] = tB[i] + h\n    minCost = 10 ** 20\n    for i in range(N):\n        toAdd = H[i] * i - tB[i]\n        toSub = tB[N] - tB[i + 1] - H[i] * (N - i - 1)\n        if M >= A + R:\n            minCost = min(minCost, A * toAdd + R * toSub)\n        else:\n            mN = min(toAdd, toSub)\n            minCost = min(minCost, A * (toAdd - mN) + R * (toSub - mN) + M * mN)\n    if M < A + R:\n        sumH = sum(H)\n        lcost = 0\n        hcost = 0\n        fH = sumH // N\n        for (i, h) in enumerate(H):\n            if h < fH:\n                lcost += (fH - h) * M\n            if h > fH + 1:\n                hcost += (h - fH - 1) * M\n        lcost += sumH % N * R\n        hcost += (N - sumH % N) * A\n        minCost = min(minCost, lcost)\n        minCost = min(minCost, hcost)\n    print(minCost)\n    return 0\nsolve()", "import bisect\n\ndef solve(H, heights, pref, N):\n    pos = bisect.bisect_left(heights, H)\n    res = 0\n    k1 = H * pos - pref[pos]\n    k2 = pref[N] - pref[pos] - H * (N - pos)\n    res = min(k1, k2)\n    k1 -= res\n    k2 -= res\n    res *= M\n    res += k1 * A\n    res += k2 * R\n    return res\n(N, A, R, M) = list(map(int, input().split()))\nheights = list(map(int, input().split()))\nM = min(M, A + R)\nheights = sorted(heights)\npref = [0 for i in range(N + 1)]\nfor i in range(N):\n    pref[i + 1] = pref[i] + heights[i]\nb1 = pref[N] // N\nb2 = b1 + 1\nans = 10 ** 25\ns1 = solve(b1, heights, pref, N)\ns2 = solve(b2, heights, pref, N)\nans = min([s1, s2, ans])\nfor i in range(N):\n    bi = heights[i]\n    ans = min(ans, solve(bi, heights, pref, N))\nprint(ans)", "def cost(arr, target, a, r, m):\n    c_add = 0\n    c_rem = 0\n    for hi in arr:\n        if hi > target:\n            c_rem += hi - target\n        else:\n            c_add += target - hi\n    move_amount = min(c_add, c_rem)\n    with_m = move_amount * m + (c_add - move_amount) * a + (c_rem - move_amount) * r\n    wout_m = c_add * a + c_rem * r\n    return min(with_m, wout_m)\n(n, a, r, m) = map(int, input().split())\nh = list(map(int, input().split()))\nle = min(h)\nri = max(h)\nwhile ri > le + 10:\n    mid = (le + ri) // 2\n    cm = cost(h, mid, a, r, m)\n    cn = cost(h, mid + 1, a, r, m)\n    if cn <= cm:\n        le = mid + 1\n    else:\n        ri = mid\nprint(min([cost(h, tar, a, r, m) for tar in range(le, ri + 1)]))", "import sys\nimport math\nimport itertools\nfrom collections import deque\n(n, a, r, m) = map(int, input().split())\nm = min(m, a + r)\nh = list(map(int, input().split()))\nlow = 0\nhigh = 0\n\ndef cost(he):\n    add = 0\n    remov = 0\n    for num in h:\n        if num < he:\n            add += he - num\n        else:\n            remov += num - he\n    need = abs(add - remov)\n    if add > remov:\n        need *= a\n    else:\n        need *= r\n    return min(add, remov) * m + need\nfor num in h:\n    high = max(high, num)\nwhile low < high:\n    mid = low + high >> 1\n    mid2 = mid + 1\n    val1 = cost(mid)\n    val2 = cost(mid2)\n    if val1 <= val2:\n        high = mid\n    else:\n        low = mid2\nans = cost(low)\nprint(ans)", "import sys\n\ndef check(t):\n    (na, nr) = (0, 0)\n    for h in p:\n        if h < t:\n            na += t - h\n        else:\n            nr += h - t\n    m = min(na, nr)\n    return min(m * M + A * (na - m) + R * (nr - m), na * A + nr * R)\n(N, A, R, M) = map(int, sys.stdin.readline().split())\np = list(map(int, sys.stdin.readline().split()))\nans = float('inf')\n(lo, hi) = (min(p), max(p))\nwhile lo <= hi:\n    mid = (lo + hi) // 2\n    (a, b) = (check(mid), check(mid + 1))\n    if a <= b:\n        hi = mid - 1\n        ans = min(ans, a)\n    else:\n        lo = mid + 1\nprint(ans)"]