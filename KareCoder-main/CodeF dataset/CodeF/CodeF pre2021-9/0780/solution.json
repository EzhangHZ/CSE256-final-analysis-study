["import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n\n    def ok():\n        if len(ans) < n:\n            return False\n        for (r, si) in enumerate(sii, 2):\n            s = ss[si]\n            cur = set(ans[r - len(s):r])\n            if s != cur:\n                return False\n        return True\n    for _ in range(II()):\n        n = II()\n        ee = [[n ** 2] * n for _ in range(n)]\n        for ei in range(n):\n            ee[ei][ei] = 0\n        ss = [set(LI()[1:]) for _ in range(n - 1)]\n        for a0 in range(1, n + 1):\n            used = set([a0])\n            ans = [a0]\n            sii = []\n            for _ in range(n - 1):\n                nxt = []\n                for (si, s) in enumerate(ss):\n                    cur = s - used\n                    if len(cur) == 1:\n                        for a in cur:\n                            nxt.append(a)\n                        sii.append(si)\n                if len(nxt) != 1:\n                    break\n                ans.append(nxt[0])\n                used.add(nxt[0])\n            if ok():\n                break\n        print(*ans)\nmain()", "import sys\nimport collections\nimport threading\nimport copy\n\ndef check(itr, sets):\n    d = {}\n\n    def dmap(x):\n        return d[x]\n    for i in range(len(itr)):\n        d[itr[i]] = i\n    for perm in sets:\n        tmp = sorted(list(map(dmap, perm)))\n        if len(tmp) != tmp[-1] - tmp[0] + 1:\n            return False\n    return True\n\ndef main():\n    n = int(input())\n    sets = []\n    start = set()\n    for _ in range(n - 1):\n        (l, *tmp) = map(int, input().split())\n        sets.append(set(tmp))\n        if l == 2:\n            start.add(tmp[0])\n            start.add(tmp[1])\n    ans = collections.deque()\n    for i in start:\n        permuts = copy.deepcopy(sets)\n        next = i\n        while len(ans) > 0:\n            ans.pop()\n        ans.append(next)\n        while len(ans) < n:\n            q = []\n            for permut in permuts:\n                if next in permut:\n                    permut.remove(next)\n                    if len(permut) == 1:\n                        q.append(permut)\n            if len(q) != 1:\n                break\n            next = list(q[0])[0]\n            ans.append(next)\n        if len(ans) == n and check(ans, sets):\n            print(*ans)\n            return\n    print('error')\n    return\ninput = sys.stdin.readline\ntnum = int(input())\nfor _ in range(tnum):\n    main()", "import copy\nt = int(input())\nfor T in range(t):\n    n = int(input())\n    seg = [set(list(map(int, input().split()))[1:]) for i in range(n - 1)]\n    p = [0] * n\n    for first in range(1, n + 1):\n        p[0] = first\n        ok = True\n        segt = copy.deepcopy(seg)\n        for i in range(1, n):\n            for s in segt:\n                s.discard(p[i - 1])\n            cnt1 = 0\n            save = -1\n            for s in segt:\n                if len(s) == 1:\n                    cnt1 += 1\n                    save = s\n            if cnt1 != 1:\n                ok = False\n                break\n            p[i] = save.pop()\n        if not ok:\n            continue\n        segt = copy.deepcopy(seg)\n        for s in segt:\n            yes = False\n            start = False\n            for i in range(n):\n                if p[i] in s:\n                    if not start:\n                        start = True\n                    s.discard(p[i])\n                elif start:\n                    break\n                if start and len(s) == 0:\n                    yes = True\n                    break\n            if not yes:\n                ok = False\n                break\n        if not ok:\n            continue\n        for i in p:\n            print(i, end=' ')\n        print()\n        break"]