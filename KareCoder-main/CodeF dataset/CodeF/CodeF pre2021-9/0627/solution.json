["import sys\ninput = sys.stdin.readline\nR = lambda : map(int, input().split())\nmod = 998244353\n(t,) = R()\nfor _ in [0] * t:\n    (n, k) = R()\n    a = tuple(R())\n    b = tuple(R())\n    vis = {i: 1 for i in range(n + 1)}\n    vis[0] = vis[n + 1] = 0\n    pos = {a: i for (i, a) in enumerate(a, 1)}\n    ans = 0\n    for i in b:\n        vis[pos[i]] = 0\n    for i in b:\n        if vis[pos[i] - 1] == 0 and vis[pos[i] + 1] == 0:\n            ans = -1\n            break\n        if vis[pos[i] - 1] == 1 and vis[pos[i] + 1] == 1:\n            ans += 1\n        vis[pos[i]] = 1\n    if ans != -1:\n        print(pow(2, ans, mod))\n    else:\n        print(0)", "q = 998244353\nans = []\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    pos = {a: i for (i, a) in enumerate(A, 1)}\n    u = {i: 0 for i in range(1, n + 1)}\n    for b in B:\n        u[pos[b]] = 1\n    u[0] = u[n + 1] = 1\n    cnt = 0\n    for b in B:\n        cur = 2 - u[pos[b] - 1] - u[pos[b] + 1]\n        if not cur:\n            ans.append(0)\n            break\n        elif cur == 2:\n            cnt += 1\n        u[pos[b]] = 0\n    else:\n        ans.append(pow(2, cnt, q))\nprint(*ans, sep='\\n')", "t = int(input())\ninv = [0] * (2 * 10 ** 5 + 5)\ncheck = [True] * (2 * 10 ** 5 + 5)\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        check[i] = True\n        inv[i + 1] = 0\n    for (idx, val) in enumerate(p):\n        inv[val] = idx\n    for val in b:\n        check[inv[val]] = False\n    ans = 1\n    mod = 998244353\n    for val in b:\n        curr = inv[val]\n        pos = 0\n        if curr + 1 < n and check[curr + 1]:\n            pos += 1\n        if curr - 1 >= 0 and check[curr - 1]:\n            pos += 1\n        ans = ans * pos % mod\n        check[curr] = True\n    print(ans)", "mod = 998244353\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    pos = {a: i for (i, a) in enumerate(A, 1)}\n    seen = {i: 0 for i in range(1, N + 1)}\n    for b in B:\n        seen[pos[b]] = 1\n    seen[0] = seen[N + 1] = 1\n    cnt = 0\n    for b in B:\n        cur = 2 - seen[pos[b] - 1] - seen[pos[b] + 1]\n        if not cur:\n            print(0)\n            break\n        elif cur == 2:\n            cnt += 1\n        seen[pos[b]] = 0\n    else:\n        print(pow(2, cnt, mod))", "mod = 998244353\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    pos = {a: i for (i, a) in enumerate(A, 1)}\n    seen = {i: 0 for i in range(1, N + 1)}\n    for b in B:\n        seen[pos[b]] = 1\n    seen[0] = seen[N + 1] = 1\n    ans = 1\n    for b in B:\n        ans = ans * (2 - seen[pos[b] - 1] - seen[pos[b] + 1]) % mod\n        seen[pos[b]] = 0\n    print(ans)", "mod = 998244353\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    pos = {a: i for (i, a) in enumerate(A, 1)}\n    seen = {i: 0 for i in range(1, N + 1)}\n    for b in B:\n        seen[pos[b]] = 1\n    seen[0] = seen[N + 1] = 1\n    ans = 1\n    for b in B:\n        ans = ans * (2 - seen[pos[b] - 1] - seen[pos[b] + 1]) % mod\n        seen[pos[b]] = 0\n    print(ans)", "MOD = 998244353\nT = int(input())\nfor _ in range(0, T):\n    (n, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    pos = [0] * (n + 1)\n    ind = [-1] * (n + 1)\n    for i in range(0, len(b)):\n        pos[b[i]] = 1\n    for i in range(0, len(a)):\n        ind[a[i]] = i\n    ans = 1\n    for i in range(0, len(b)):\n        ptr = ind[b[i]]\n        c = 0\n        if ptr - 1 >= 0 and pos[a[ptr - 1]] == 0:\n            c = (c + 1) % MOD\n        if ptr + 1 < n and pos[a[ptr + 1]] == 0:\n            c = (c + 1) % MOD\n        pos[a[ptr]] = 0\n        ans = ans * c % MOD\n    print(ans)", "MOD = 998244353\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    pos = [0] * (n + 1)\n    ind = [-1] * (n + 1)\n    ans = 1\n    for i in range(len(b)):\n        pos[b[i]] = 1\n    for i in range(len(a)):\n        ind[a[i]] = i\n    for i in range(len(b)):\n        ptr = ind[b[i]]\n        c = 0\n        if ptr - 1 >= 0 and pos[a[ptr - 1]] == 0:\n            c = (c + 1) % MOD\n        if ptr + 1 < n and pos[a[ptr + 1]] == 0:\n            c = (c + 1) % MOD\n        pos[a[ptr]] = 0\n        ans = ans * c % MOD\n    print(ans)", "mod = 998244353\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    pos = {a: i for (i, a) in enumerate(A, 1)}\n    seen = {i: 0 for i in range(1, N + 1)}\n    for b in B:\n        seen[pos[b]] = 1\n    seen[0] = seen[N + 1] = 1\n    ans = 1\n    for b in B:\n        ans = ans * (2 - seen[pos[b] - 1] - seen[pos[b] + 1]) % mod\n        seen[pos[b]] = 0\n    print(ans)", "T = int(input())\nfor _ in range(T):\n    res = 1\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    m = {}\n    for i in range(len(b)):\n        m[b[i]] = i + 1\n    for i in range(len(a)):\n        if a[i] in m.keys():\n            temp = 0\n            if i > 0 and (a[i - 1] in m.keys() and m[a[i]] > m[a[i - 1]] or a[i - 1] not in m.keys()):\n                temp += 1\n            if i < n - 1 and (a[i + 1] in m.keys() and m[a[i]] > m[a[i + 1]] or a[i + 1] not in m.keys()):\n                temp += 1\n            res *= temp\n    print(res % 998244353)", "tests = int(input())\nfor test in range(tests):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    q = [0] * n\n    for i in range(n):\n        q[a[i] - 1] = i\n    for i in range(k):\n        b[i] = q[b[i] - 1]\n    q = [0] * n\n    for i in range(k):\n        q[b[i]] = i\n    mod = 998244353\n    res = 1\n    for i in range(k):\n        cur = 0\n        if b[i] > 0 and q[b[i] - 1] <= i:\n            cur += 1\n        if b[i] < n - 1 and q[b[i] + 1] <= i:\n            cur += 1\n        if i == n - 2:\n            cur = min(cur, 1)\n        res = res * cur % mod\n    print(res)", "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(99999)\n\ndef solve(arrA, arrB):\n    mod = 998244353\n    flag = [0] * len(arrA)\n    d = collections.defaultdict(int)\n    for (i, c) in enumerate(arrA):\n        d[c] = i\n    ans = 1\n    for c in arrB[::-1]:\n        k = d[c]\n        sc = 0\n        if k - 1 >= 0:\n            sc += 1 - flag[k - 1]\n        if k + 1 < len(arrA):\n            sc += 1 - flag[k + 1]\n        ans *= sc\n        ans %= mod\n        flag[k] = 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arrA = list(map(int, input().split()))\n    arrB = list(map(int, input().split()))\n    print(solve(arrA, arrB))", "mxn = 998244353\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    pre = [i - 1 for i in range(n)]\n    next = [i + 1 for i in range(n)]\n    vis = [0] * (n + 1)\n    dct = [0] * (n + 1)\n    for i in range(n):\n        dct[a[i]] = i\n    for num in b:\n        vis[num] = 1\n    res = 1\n    case = 1\n    for num in b:\n        idx = dct[num]\n        left = -1\n        right = -1\n        count = 0\n        if pre[idx] >= 0:\n            left = a[pre[idx]]\n            if vis[left] == 0:\n                count += 1\n        if next[idx] < n:\n            right = a[next[idx]]\n            if vis[right] == 0:\n                count += 1\n        if not count:\n            print(0)\n            case = 0\n            break\n        else:\n            res = res * count % mxn\n            if left != -1 and vis[left] == 0:\n                di = pre[idx]\n            else:\n                di = next[idx]\n            if di:\n                next[di - 1] = next[di]\n            if di + 1 < n:\n                pre[di + 1] = pre[di]\n            vis[num] = 0\n    if case:\n        print(res)"]