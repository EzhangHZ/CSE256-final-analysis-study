["def main():\n    for t in range(int(input())):\n        (n, m) = map(int, input().split())\n        l = []\n        for i in range(n):\n            l.append(int(input(), 2))\n        l.sort()\n        median = (2 ** m - n - 1) // 2\n        for i in l:\n            if i <= median:\n                median += 1\n        while median in l:\n            median += 1\n        ans = bin(median)[2:]\n        temp = ''\n        for i in range(len(ans), m):\n            temp += '0'\n        print(temp + ans)\nmain()", "from bisect import *\nimport sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        (n, m) = MI()\n        isrem = set()\n        rem = []\n        for _ in range(n):\n            a = int(SI(), 2)\n            rem.append(a)\n            isrem.add(a)\n        rem.sort()\n        k = (1 << m) - n\n        rank = (k - 1) // 2\n        ans = rank\n        while 1:\n            while ans in isrem:\n                ans += 1\n            rn = bisect(rem, ans)\n            if ans - rn == rank:\n                break\n            ans = rank + rn\n        print(format(ans, 'b').zfill(m))\nmain()", "def prog():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        missing = [int(input().strip(), 2) for i in range(n)]\n        missing.sort()\n        missing2 = set(missing)\n        median = (2 ** m - n + 1) // 2\n        curr = median - 1\n        index = median\n        while curr in missing2:\n            curr -= 1\n            index -= 1\n        for i in missing:\n            if curr > i:\n                index -= 1\n            else:\n                break\n        while index != median:\n            curr += 1\n            if curr not in missing:\n                index += 1\n        value = curr\n        value = bin(value)[2:]\n        value = '0' * (m - len(value)) + value\n        print(value)\nprog()", "def toBinary(i, digit):\n    b = bin(i).replace('0b', '')\n    n = digit - len(b)\n    x = ''\n    for itr in range(n):\n        x = x + '0'\n    return x + b\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        l = []\n        for i in range(n):\n            l.append(int(input(), 2))\n        l.sort()\n        median = (2 ** m - n - 1) // 2\n        for i in l:\n            if i <= median or i == median:\n                median += 1\n        ans = toBinary(median, m)\n        print(ans)\nmain()", "T = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    l = [int(input(), 2) for _ in range(n)]\n    x = (2 ** m - 1 - n) // 2\n    for i in sorted(l):\n        if i <= x:\n            x += 1\n    ans = bin(x)[2:]\n    if len(ans) < m:\n        ans = '0' * (m - len(ans)) + ans\n    print(ans)", "T = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    l = [int(input(), 2) for _ in range(n)]\n    x = (2 ** m - 1 - n) // 2\n    for i in sorted(l):\n        if i <= x:\n            x += 1\n    ans = bin(x)[2:]\n    if len(ans) < m:\n        ans = '0' * (m - len(ans)) + ans\n    print(ans)", "T = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    nums = set()\n    even = True\n    curr_med = (2 ** m - 1) // 2\n    for i in range(n):\n        num = int(input(), 2)\n        nums.add(num)\n        if num > curr_med:\n            if not even:\n                curr_med -= 1\n                while curr_med in nums:\n                    curr_med -= 1\n        elif num < curr_med:\n            if even:\n                curr_med += 1\n                while curr_med in nums:\n                    curr_med += 1\n        elif even:\n            curr_med += 1\n            while curr_med in nums:\n                curr_med += 1\n        else:\n            curr_med -= 1\n            while curr_med in nums:\n                curr_med -= 1\n        if even:\n            even = False\n        else:\n            even = True\n    binary_string = '{0:b}'.format(curr_med)\n    print((m - len(binary_string)) * '0' + binary_string)", "T = int(input())\nfor _ in range(T):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    li = []\n    for i in range(n):\n        temp = input()\n        li.append(int(temp, 2))\n    li.sort()\n    temp5 = (2 ** m - n - 1) // 2\n    for i in range(n):\n        if li[i] <= temp5:\n            temp5 += 1\n    while temp5 in li:\n        temp5 += 1\n    temp6 = len(bin(temp5)[2:])\n    ans = '0' * (m - temp6) + str(bin(temp5)[2:])\n    print(ans)", "for t in range(int(input())):\n    (n, m) = map(int, input().split())\n    rem = []\n    real_rem = []\n    med = 2 ** (m - 1) - 1\n    for i in range(n):\n        iii = input()\n        rem.append(int(iii, 2))\n    even = True\n    while rem:\n        cur = rem[0]\n        real_rem += [cur]\n        rem = rem[1:]\n        if even:\n            if med < cur:\n                pass\n            else:\n                med += 1\n                while med in real_rem:\n                    med += 1\n        elif med <= cur:\n            med -= 1\n            while med in real_rem:\n                med -= 1\n        else:\n            pass\n        even = not even\n    print(bin(med)[2:].rjust(m, '0'))", "T = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    l = [int(input(), 2) for _ in range(n)]\n    x = (2 ** m - 1 - n) // 2\n    for i in sorted(l):\n        if i <= x:\n            x += 1\n    ans = bin(x)[2:]\n    if len(ans) < m:\n        ans = '0' * (m - len(ans)) + ans\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(input(), 2) for _ in range(n)]\n    x = (2 ** m - n - 1) // 2\n    for v in sorted(a):\n        if v <= x:\n            x += 1\n    print('{0:0={1}b}'.format(x, m))", "def check(ct, val, incre):\n    while bin(val) in ct:\n        val += incre\n    return val\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    length = 2 ** m\n    mid_index = (2 ** m - 1) // 2\n    ct = set()\n    for _ in range(n):\n        res = bin(int(input(), 2))\n        ct.add(res)\n        if int(res, 2) < mid_index:\n            length -= 1\n            if length % 2:\n                mid_index = check(ct, mid_index + 1, 1)\n        elif int(res, 2) > mid_index:\n            length -= 1\n            if not length % 2:\n                mid_index = check(ct, mid_index - 1, -1)\n        else:\n            length -= 1\n            if not length % 2:\n                mid_index = check(ct, mid_index - 1, -1)\n            else:\n                mid_index = check(ct, mid_index + 1, +1)\n    diff = abs(m - len(str(bin(mid_index))[2:]))\n    print('0' * diff + bin(mid_index)[2:])", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = [int(input(), 2) for _ in range(n)]\n    ans = (2 ** m - n - 1) // 2\n    for s in sorted(a):\n        if s <= ans:\n            ans += 1\n    ans = bin(ans)\n    ans = ans[2:]\n    ans = '0' * (m - len(ans)) + ans\n    print(ans)", "from bisect import bisect_left\n\ndef less_than(mid):\n    ind = bisect_left(arr, mid)\n    return mid - ind\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    a = set()\n    for i in range(n):\n        arr.append(int(input(), 2))\n        a.add(arr[-1])\n    arr.sort()\n    total = 2 ** m - n\n    l = 0\n    r = 2 ** m - 1\n    while l <= r:\n        mid = l + (r - l) // 2\n        l_mid = less_than(mid)\n        if mid not in a and 0 <= total - 2 * l_mid - 1 <= 1:\n            print(bin(mid)[2:].zfill(m))\n            break\n        elif l_mid >= total - l_mid:\n            r = mid - 1\n        else:\n            l = mid + 1", "def op_one_median(median, removed, op):\n    median += op\n    while median in removed:\n        median += op\n    return median\n\ndef add_one_median(median, removed):\n    res = op_one_median(median, removed, 1)\n    return res\n\ndef remove_one_median(median, removed):\n    res = op_one_median(median, removed, -1)\n    return res\nT = int(input())\nfor t in range(T):\n    (N, M) = list(map(int, input().split()))\n    median = 2 ** (M - 1) - 1\n    removed = set()\n    move_median_up = True\n    for i in range(N):\n        r = int(input(), 2)\n        removed.add(r)\n        if r < median:\n            if move_median_up:\n                median = add_one_median(median, removed)\n        elif r > median:\n            if not move_median_up:\n                median = remove_one_median(median, removed)\n        else:\n            f = add_one_median if move_median_up else remove_one_median\n            median = f(median, removed)\n        move_median_up = not move_median_up\n    print(format(median, '0{}b'.format(M)))", "from bisect import bisect_left, bisect_right\n\ndef solve():\n    (n, m) = map(int, input().split())\n    que = [int(input(), 2) for _ in range(n)]\n    K = 2 ** m - n\n    ban_set = set(que)\n    que.sort()\n\n    def count(X):\n        return X + 1 - bisect_right(que, X)\n    l = -1\n    r = 2 ** m\n    while r - l > 1:\n        Med = (r + l) // 2\n        if count(Med) >= (K + 1) // 2:\n            r = Med\n        else:\n            l = Med\n    while r in ban_set:\n        r -= 1\n    print(bin(r)[2:].zfill(m))\n    return\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        solve()\n    return\nmain()", "T = int(input())\n\ndef move_up(taken, s):\n    s += 1\n    while s in taken:\n        s += 1\n    return s\n\ndef move_down(taken, s):\n    s -= 1\n    while s in taken:\n        s -= 1\n    return s\nfor t in range(T):\n    (N, M) = [int(_) for _ in input().split()]\n    start = (1 << M - 1) - 1\n    taken = set()\n    rd = True\n    for i in range(N):\n        el = int(input(), 2)\n        taken.add(el)\n        if el > start:\n            if not rd:\n                start = move_down(taken, start)\n        elif el < start:\n            if rd:\n                start = move_up(taken, start)\n        elif rd:\n            start = move_up(taken, start)\n        else:\n            start = move_down(taken, start)\n        rd = not rd\n    print(format(start, '0{}b'.format(M)))", "import sys\n\ndef process():\n    (n, m) = [int(s) for s in sys.stdin.readline().split()]\n    med = (2 ** m - 1 - n) // 2\n    ss = set()\n    count = 0\n    for i in range(n):\n        r = int(sys.stdin.readline().strip(), 2)\n        if r < med:\n            count += 1\n        else:\n            ss.add(r)\n    while med in ss:\n        med += 1\n    for i in range(count):\n        med += 1\n        while med in ss:\n            med += 1\n    print(format(med, 'b').zfill(m))\nT = int(sys.stdin.readline())\nfor x in range(T):\n    process()", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for j in range(n):\n        x = input()\n        arr.append(int(x, 2))\n    current_median = 2 ** (m - 1) - 1\n    to_left = (2 ** m - n - 1) // 2 + 1\n    while True:\n        curr_to_left = current_median + 1\n        present = False\n        for j in arr:\n            if j == current_median:\n                present = True\n            if j <= current_median:\n                curr_to_left -= 1\n        if curr_to_left == to_left and present == False:\n            print(bin(current_median)[2:].zfill(m))\n            break\n        elif curr_to_left < to_left:\n            current_median += 1\n        else:\n            current_median -= 1", "T = int(input())\nfor _ in range(T):\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    li = []\n    for i in range(n):\n        temp = input()\n        li.append(temp)\n    li.sort()\n    temp5 = (2 ** m - n - 1) // 2\n    for i in range(n):\n        if int(li[i], 2) <= temp5:\n            temp5 += 1\n        else:\n            break\n    temp6 = len(bin(temp5)[2:])\n    ans = '0' * (m - temp6) + str(bin(temp5)[2:])\n    print(ans)", "import math\n\ndef binaryToDecimal(n):\n    return int(n, 2)\n\ndef decimalToBinary(n, k):\n    return '{0:b}'.format(n).zfill(k)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        solve()\n\ndef solve():\n    (n, m) = list(map(int, input().split(' ')))\n    if m == 1:\n        print((int(input()) + 1) % 2)\n        return\n    binaries = set()\n    middle = (2 ** m - 1) // 2\n    size = 2 ** m\n    for i in range(n):\n        current = binaryToDecimal(input())\n        binaries.add(current)\n        size -= 1\n        if size % 2 == 0:\n            if current >= middle:\n                middle -= 1\n                while middle in binaries:\n                    middle -= 1\n        elif current <= middle:\n            middle += 1\n            while middle in binaries:\n                middle += 1\n    print(decimalToBinary(middle, m))\nmain()", "from sys import stdin\nfor case in range(int(stdin.readline())):\n    (n, m) = [int(x) for x in stdin.readline().split()]\n    mid = 2 ** (m - 1) - 1\n    half = True\n    used = []\n    for a in range(n):\n        used.append(int(stdin.readline(), 2))\n    used.sort()\n    passed = set()\n    for a in used:\n        passed.add(a)\n        if a == mid:\n            if half:\n                half = False\n                mid += 1\n                while mid in passed:\n                    mid += 1\n            else:\n                half = True\n                mid -= 1\n                while mid in passed:\n                    mid -= 1\n        elif a < mid:\n            if half:\n                mid += 1\n                while mid in passed:\n                    mid += 1\n                half = False\n            else:\n                half = True\n        elif half:\n            half = False\n        else:\n            half = True\n            mid -= 1\n            while mid in passed:\n                mid -= 1\n    bruh = '{0:b}'.format(mid)\n    print('0' * (m - len(bruh)) + bruh)", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    median = (2 ** m - 1 - n) // 2\n    a = [int(input(), 2) for i in range(n)]\n    for i in sorted(a):\n        if i <= median:\n            median += 1\n    y = bin(median)[2:]\n    print('0' * (m - len(y)) + y)", "tc = int(input())\nfor _ in range(tc):\n    (n, m) = map(int, input().split())\n    cache = {}\n    curr = (2 ** m - 1) // 2\n    for i in range(n):\n        s = input()\n        x = int(s, 2)\n        cache[x] = 1\n        if i % 2 == 0:\n            if x <= curr:\n                while len(cache) != 0 and curr + 1 in cache:\n                    curr += 1\n                curr += 1\n        elif x >= curr:\n            while len(cache) != 0 and curr - 1 in cache:\n                curr -= 1\n            curr -= 1\n    temp = bin(curr)[2:]\n    if m != len(temp):\n        temp = '0' * abs(m - len(temp)) + temp\n    print(temp)", "T = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    l = [int(input(), 2) for _ in range(n)]\n    x = (2 ** m - 1 - n) // 2\n    for i in sorted(l):\n        if i <= x:\n            x += 1\n    ans = bin(x)[2:]\n    if len(ans) < m:\n        ans = '0' * (m - len(ans)) + ans\n    print(ans)", "def check(ct, val, incre):\n    while bin(val) in ct:\n        val += incre\n    return val\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    length = 2 ** m\n    mid_index = (2 ** m - 1) // 2\n    ct = set()\n    for _ in range(n):\n        res = bin(int(input(), 2))\n        ct.add(res)\n        if int(res, 2) < mid_index:\n            length -= 1\n            if length % 2:\n                mid_index = check(ct, mid_index + 1, 1)\n        elif int(res, 2) > mid_index:\n            length -= 1\n            if not length % 2:\n                mid_index = check(ct, mid_index - 1, -1)\n        else:\n            length -= 1\n            if not length % 2:\n                mid_index = check(ct, mid_index - 1, -1)\n            else:\n                mid_index = check(ct, mid_index + 1, +1)\n    diff = abs(m - len(str(bin(mid_index))[2:]))\n    print('0' * diff + bin(mid_index)[2:])", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    kl = []\n    for i in range(n):\n        kl.append(int(input(), 2))\n    kl.sort()\n    k = (2 ** m - 1 - n) // 2\n    for i in kl:\n        if k >= i:\n            k += 1\n    k = bin(k).replace('0b', '')\n    k = (m - len(k)) * '0' + k\n    print(k)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [int(input(), 2) for _ in range(n)]\n    x = (2 ** m - n - 1) // 2\n    for v in sorted(a):\n        if v <= x:\n            x += 1\n    print('{0:0={1}b}'.format(x, m))", "def dec(b, m):\n    return '{:0{}b}'.format(int(b, 2) - 1, m)\n\ndef inc(b, m):\n    return '{:0{}b}'.format(int(b, 2) + 1, m)\n\ndef median(n, m, a):\n    md = '0' + '1' * (m - 1)\n    state = 1\n    seen = {}\n    for e in a:\n        if e > md:\n            state -= 1\n            if state == -1:\n                while True:\n                    md = dec(md, m)\n                    if md not in seen:\n                        break\n                state = 1\n        elif e < md:\n            state += 1\n            if state == 2:\n                while True:\n                    md = inc(md, m)\n                    if md not in seen:\n                        break\n                state = 0\n        elif e == md:\n            if state == 1:\n                while True:\n                    md = inc(md, m)\n                    if md not in seen:\n                        break\n                state = 0\n            else:\n                while True:\n                    md = dec(md, m)\n                    if md not in seen:\n                        break\n                state = 1\n        seen[e] = 1\n    return md\nt = int(input().strip())\nfor _ in range(t):\n    (n, m) = list(map(int, input().strip().split()))\n    a = []\n    for _ in range(n):\n        a.append(input().strip())\n    print(median(n, m, a))", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    l = []\n    for j in range(n):\n        s = input()\n        l.append(int(s, 2))\n    l = sorted(l)\n    length = 2 ** m\n    newlen = length - n\n    med = newlen // 2\n    if newlen % 2 == 0:\n        med = med - 1\n    ele = med\n    for j in range(len(l)):\n        if l[j] <= med:\n            med = med + 1\n    med = bin(med)\n    med = med[2:]\n    count = m - len(med)\n    while count > 0:\n        print(0, end='')\n        count = count - 1\n    for j in range(len(med)):\n        print(med[j], end='')\n    print()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(input(), 2) for i in range(n)]\n    (L, R) = (0, 2 ** k - 1)\n    r = R\n    while L <= R:\n        m = (L + R) // 2\n        c = m + 1 - sum((x <= m for x in a))\n        if c >= (2 ** k - n + 1) // 2:\n            (r, R) = (m, m - 1)\n        else:\n            L = m + 1\n    while r in a:\n        r -= 1\n    print(('{0:0%db}' % k).format(r))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(input(), 2) for i in range(n)]\n    (L, R) = (0, 2 ** k - 1)\n    r = R\n    while L <= R:\n        m = (L + R) // 2\n        c = m + 1 - sum((x <= m for x in a))\n        if c >= (2 ** k - n + 1) // 2:\n            (r, R) = (m, m - 1)\n        else:\n            L = m + 1\n    while r in a:\n        r -= 1\n    print(('{0:0%db}' % k).format(r))", "import sys\nimport math\nimport collections\nimport threading\n\ndef main():\n    (n, m) = map(int, input().split())\n    a = [int(input(), 2) for _ in range(n)]\n    k = 2 ** m - len(a)\n    med = (k - 1) // 2\n    s = set()\n    for num in a:\n        s.add(num)\n        if num <= med:\n            med += 1\n            while med in s:\n                med += 1\n    ans = '0' * m + bin(med)[2:]\n    ans = ans[-m:]\n    print(ans)\ntn = int(input())\nfor _ in range(tn):\n    main()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(input(), 2) for i in range(n)]\n    (L, R) = (0, 2 ** k - 1)\n    r = R\n    while L <= R:\n        m = (L + R) // 2\n        c = m + 1 - sum((x <= m for x in a))\n        if c >= (2 ** k - n + 1) // 2:\n            (r, R) = (m, m - 1)\n        else:\n            L = m + 1\n    while r in a:\n        r -= 1\n    print(('{0:0%db}' % k).format(r))", "from bisect import *\nt = int(input())\n\ndef solve(a, m):\n    a = sorted(list(a))\n    L = 0\n    R = (1 << m) - 1\n    target = ((1 << m) - len(a) - 1) // 2\n    while R - L > 0:\n        M = (L + R) // 2\n        cntsmalleq = M - bisect_right(a, M, 0, len(a))\n        if cntsmalleq < target:\n            L = M + 1\n        else:\n            R = M\n    return L\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    print(format(solve(map(lambda x: int(x, 2), [input() for _ in range(n)]), m), '0' + str(m) + 'b'))", "T = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    binary = {int(input(), 2) for _ in range(N)}\n    ALL = 1 << M\n    L = -1\n    R = ALL\n    K = (ALL - N) // 2\n    half_or_bigger = lambda x: ALL - x - sum((1 if bina > x else 0 for bina in binary)) - 1\n    while R - L > 1:\n        mid = (R + L) // 2\n        if half_or_bigger(mid) >= K:\n            L = mid\n        else:\n            R = mid\n    while L in binary:\n        L -= 1\n    print(bin(L)[2:].zfill(M))", "def b_n(s):\n    return int(s, 2)\n\ndef n_b(n):\n    p = str(bin(n).replace('0b', ''))\n    while len(p) < m:\n        p = '0' + p\n    return p\nt = int(input())\nfor w in range(t):\n    nm = list(map(int, input().strip().split()))\n    n = nm[0]\n    m = nm[1]\n    arr = []\n    for g in range(n):\n        arr.append(str(input()))\n    for i in range(n):\n        arr[i] = b_n(arr[i])\n    k1 = 2 ** m - n\n    k = (k1 - 1) // 2\n    for i in sorted(arr):\n        if i <= k:\n            k += 1\n    print(n_b(k))", "from collections import Counter\nimport sys\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\ninf = int(1e+18)\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ndef inverse(a):\n    return pow(a, mod - 2, mod)\n\ndef usearch(x, a):\n    lft = 0\n    rgt = len(a) + 1\n    while rgt - lft > 1:\n        mid = (rgt + lft) // 2\n        if a[mid] <= x:\n            lft = mid\n        else:\n            rgt = mid\n    return lft\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = 1 << m\n    s = {int(input(), 2) for i in range(n)}\n    mid = a // 2\n    need = (a - n + 1) // 2\n    cur = mid\n    while True:\n        lft = cur + 1\n        for x in s:\n            if x <= cur:\n                lft -= 1\n        if lft == need and cur not in s:\n            print(bin(cur)[2:].zfill(m))\n            return\n        if lft < need:\n            cur += 1\n        else:\n            cur -= 1\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        solve()\nmain()", "from collections import Counter\nT = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(int(input(), 2))\n    d = Counter(l)\n    mid = (2 ** m - n - 1) // 2\n    for i in sorted(l):\n        if i <= mid:\n            mid += 1\n    print('{0:0={1}b}'.format(mid, m))", "def read_int():\n    return int(input())\n\ndef read_string_array():\n    return input().split()\n\ndef read_int_array():\n    return [int(_) for _ in read_string_array()]\n\ndef read_line():\n    return input()\n\ndef solve(n, m, a):\n    a = [int(_, 2) for _ in a]\n    median = (2 ** m - 1) // 2\n    k = 2 ** m\n    removed = set()\n    c = 0\n    for b in a:\n        removed.add(b)\n        if b <= median:\n            median += 1\n            while median in removed:\n                median += 1\n        if k % 2 == 1:\n            median -= 1\n            while median in removed:\n                median -= 1\n        k -= 1\n    return bin(median)[2:].zfill(m)\nT = read_int()\nfor _ in range(T):\n    (N, M) = read_int_array()\n    A = [input() for _ in range(N)]\n    print(solve(N, M, A))", "import sys\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\nI = lambda : list(map(int, input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\ndef solve():\n    (n, m) = I()\n    a = [0] * n\n    for i in range(n):\n        a[i] = int(input(), 2)\n    a.sort()\n    need = (2 ** m - n - 1) // 2\n    (lo, hi) = (0, 2 ** m)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        k = bl(a, mid)\n        if mid - 1 - k < need - 1:\n            lo = mid + 1\n        else:\n            hi = mid\n    while lo in a:\n        lo += 1\n    for i in range(m - 1, -1, -1):\n        print(lo >> i & 1, end='')\n    print()\n(t,) = I()\nwhile t:\n    t -= 1\n    solve()", "import sys, heapq\nfrom collections import *\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 6)\nimport bisect\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split(' '))\n        total = 2 ** m\n        target = (total - n - 1) // 2\n        removes = []\n        for _ in range(n):\n            s = input()\n            cur = 0\n            for ch in s:\n                cur = cur << 1\n                if ch == '1':\n                    cur += 1\n            removes.append(cur)\n        removes.sort()\n        (lo, hi) = (0, 2 ** m - 1)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            i = bisect.bisect_left(removes, mid)\n            if mid - i <= target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        res = []\n        for i in range(m):\n            if hi & 1 << i:\n                res.append('1')\n            else:\n                res.append('0')\n        print(''.join(res[::-1]))\nmain()", "import math as mt\nimport sys\nimport collections as cc\nI = lambda : list(map(int, input().split()))\nfor tc in range(int(input())):\n    used = cc.defaultdict(int)\n    (n, m) = I()\n    mid = 2 ** (m - 1) - 1\n    k = 2 ** m\n    for i in range(n):\n        x = int(input(), 2)\n        used[x] = 1\n        if x == mid:\n            if k % 2 == 0:\n                t = mid + 1\n                an = -1\n                for ii in range(t, 2 ** m):\n                    if not used[ii]:\n                        an = ii\n                        break\n                mid = an\n            else:\n                t = mid - 1\n                an = -1\n                for ii in range(t, -1, -1):\n                    if not used[ii]:\n                        an = ii\n                        break\n                mid = an\n        elif x < mid:\n            if k % 2 == 0:\n                t = mid + 1\n                an = -1\n                for ii in range(t, 2 ** m):\n                    if not used[ii]:\n                        an = ii\n                        break\n                mid = an\n            else:\n                pass\n        elif x > mid:\n            if k % 2 == 0:\n                pass\n            else:\n                t = mid - 1\n                an = -1\n                for ii in range(t, -1, -1):\n                    if not used[ii]:\n                        an = ii\n                        break\n                mid = an\n        k -= 1\n    print(format(mid, '0' + str(m) + 'b'))", "import sys, heapq\nfrom collections import *\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split(' '))\n        total = 2 ** m\n        mid = (total - 1) // 2\n        removes = set()\n        for _ in range(n):\n            s = input()\n            cur = 0\n            for ch in s:\n                cur = cur << 1\n                if ch == '1':\n                    cur += 1\n            removes.add(cur)\n        removed = set()\n        for r in removes:\n            if total & 1 and r >= mid:\n                while mid - 1 in removed:\n                    mid -= 1\n                mid -= 1\n            elif total & 1 == 0 and r <= mid:\n                while mid + 1 in removed:\n                    mid += 1\n                mid += 1\n            total -= 1\n            removed.add(r)\n        res = []\n        for i in range(m):\n            if mid & 1 << i:\n                res.append('1')\n            else:\n                res.append('0')\n        print(''.join(res[::-1]))\nmain()", "def dd(i, nn):\n    s = bin(i).replace('0b', '')\n    l = len(s)\n    kk = ''\n    for i in range(nn - l):\n        kk = kk + '0'\n    print(kk + s)\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    aa = []\n    for pp in range(n):\n        pp = input()\n        aa.append(int(pp, 2))\n    y = 2 ** (m - 1) - 1\n    a = max(0, y - n)\n    b = min(y + n, 2 ** m - 1)\n    for i in range(a, b + 1):\n        l = i\n        r = 2 ** m - 1 - i\n        flag = 1\n        for k in aa:\n            if k == i:\n                flag = 0\n                break\n            if k < i:\n                l = l - 1\n            else:\n                r = r - 1\n        if flag == 0:\n            continue\n        if n % 2 == 0 and l == r - 1:\n            dd(i, m)\n        if n % 2 != 0 and l == r:\n            dd(i, m)", "def cvt(st):\n    st = st[::-1]\n    num = 0\n    for (i, ix) in enumerate(st):\n        num += int(int(ix) * int(2 ** i))\n    return num\nfor _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    maxx = 2 ** m - 1\n    ran = maxx + 1\n    med = maxx // 2\n    rem = set()\n    num = maxx + 1\n    for i in range(n):\n        if (ran - i) % 2 == 0:\n            st = input()\n            st = cvt(st)\n            if st <= med:\n                med += 1\n                while med in rem:\n                    med += 1\n            rem.add(st)\n        else:\n            st = input()\n            st = cvt(st)\n            if st >= med:\n                med -= 1\n                while med in rem:\n                    med -= 1\n            rem.add(st)\n    ans = [0 for i in range(m)]\n    i = 0\n    while med > 0:\n        if med % 2 == 1:\n            ans[i] = 1\n        else:\n            ans[i] = 0\n        i += 1\n        med //= 2\n    a = ''\n    for i in ans:\n        a += str(i)\n    print(a[::-1])", "from collections import defaultdict\n\ndef decimalToBinary(n, s):\n    if n > 1:\n        s = decimalToBinary(n // 2, s)\n    s = s + str(n % 2)\n    return s\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split(' '))\n    arr = []\n    for i in range(n):\n        s = input()\n        k = m - 1\n        c = 0\n        for j in s:\n            c += int(j) * 2 ** k\n            k -= 1\n        arr.append(c)\n    x = 2 ** m - n\n    if x % 2 == 0:\n        x = x // 2 - 1\n    else:\n        x = x // 2\n    d = {}\n    d = defaultdict(lambda : 0, d)\n    for i in arr:\n        d[i] = 1\n    arr.sort()\n    k = 0\n    for i in arr:\n        if i <= x:\n            k += 1\n        else:\n            break\n    i = 0\n    j = x + 1\n    y = 2 ** m\n    ans = x\n    while j < y:\n        if i >= k:\n            break\n        if d[j] == 0:\n            i += 1\n            ans = j\n        j += 1\n    ans = decimalToBinary(ans, '')\n    ans = '0' * (m - len(ans)) + ans\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (m, n) = map(int, input().split())\n    topn = (1 << n) - 1\n    data = [int(input(), 2) for _ in range(m)]\n    data.sort()\n    data.reverse()\n    median = topn // 2\n    expected = (topn - m) // 2\n    base = max(median - 200, 0)\n    top = min(median + 200, topn)\n    l = base\n    for x in range(base, top + 1):\n        l += 1\n        while data and data[-1] <= x:\n            data.pop()\n            l -= 1\n        if l - 1 == expected:\n            num = bin(x)[2:]\n            print('0' * (n - len(num)) + num)\n            break"]