["def main():\n    import sys\n    from collections import deque, defaultdict\n    from heapq import heappop, heappush\n    sys.setrecursionlimit(10 ** 9)\n    input = sys.stdin.readline\n    for __ in [0] * int(input()):\n        (N, M) = map(int, input().split())\n        deg = [0] * N\n        directed = defaultdict(list)\n        undirected = defaultdict(list)\n        for _ in [0] * M:\n            (t, a, b) = map(int, input().split())\n            a -= 1\n            b -= 1\n            if t:\n                directed[a].append(b)\n                deg[b] += 1\n            else:\n                undirected[a].append(b)\n                undirected[b].append(a)\n        q = deque([i for (i, d) in enumerate(deg) if d == 0])\n        topological = []\n        while q:\n            v = q.popleft()\n            topological.append(v)\n            if v not in directed:\n                continue\n            for u in directed[v]:\n                deg[u] -= 1\n                if deg[u] == 0:\n                    q.append(u)\n        if len(topological) != N:\n            print('NO')\n            continue\n        del deg\n        print('YES')\n        used = [0] * N\n        for v in topological:\n            if v in directed:\n                for u in directed[v]:\n                    print(v + 1, u + 1)\n            if v in undirected:\n                for u in undirected[v]:\n                    if used[u]:\n                        continue\n                    print(v + 1, u + 1)\n            used[v] = 1\n        del used\nmain()", "from collections import deque\n\ndef solve():\n    (n, m) = map(int, input().split())\n    G = [[] for i in range(n + 1)]\n    edge = []\n    In = [0] * (n + 1)\n    for i in range(m):\n        (t, x, y) = map(int, input().split())\n        if t == 1:\n            G[x].append(y)\n            In[y] += 1\n        edge.append((t, x, y))\n    visited = [False] * (n + 10)\n    stack = deque([])\n    order = []\n    Order = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if In[i] == 0:\n            stack.append(i)\n    while stack:\n        x = stack.popleft()\n        order.append(x)\n        for node in G[x]:\n            In[node] -= 1\n            if In[node] == 0:\n                stack.append(node)\n    for (i, v) in enumerate(order):\n        Order[v] = i + 1\n    not_dag = any((Order[i] < 0 for i in range(1, n + 1)))\n    ans = []\n    for (t, x, y) in edge:\n        if t == 1 and Order[x] > Order[y]:\n            not_dag = True\n            break\n        elif t == 1:\n            ans.append((x, y))\n        elif Order[x] > Order[y]:\n            ans.append((y, x))\n        else:\n            ans.append((x, y))\n    if not_dag:\n        print('NO')\n    else:\n        print('YES')\n        for (x, y) in ans:\n            print(x, y)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        solve()\n    return\nmain()", "t = int(input())\nMaxn = 210000\nwhile t > 0:\n    t -= 1\n    (n, m) = map(int, input().split())\n    to = [[]]\n    for i in range(0, n):\n        to.append([])\n    d = [0] * (n + 1)\n    ran = [0] * (n + 1)\n    q = []\n    cnt = 0\n    to[0].append(1)\n    for i in range(0, m):\n        (bj, u, v) = map(int, input().split())\n        if bj:\n            to[u].append(v)\n            d[v] += 1\n            q.append((u, v))\n        else:\n            q.append((u, v))\n    que = []\n    for i in range(1, n + 1):\n        if d[i] == 0:\n            que.append(i)\n    while len(que):\n        now = que.pop()\n        cnt += 1\n        ran[now] = cnt\n        for i in to[now]:\n            d[i] -= 1\n            if d[i] == 0:\n                que.append(i)\n    if cnt != n:\n        print('NO')\n        continue\n    print('YES')\n    for i in q:\n        if ran[i[0]] < ran[i[1]]:\n            print(i[0], i[1])\n        else:\n            print(i[1], i[0])", "import sys\n\ndef toposort(graph):\n    res = []\n    found = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n    for node in res:\n        if any((found[nei] for nei in graph[node])):\n            return None\n        found[node] = 0\n    return res[::-1]\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    g = [[] for _ in range(n + 1)]\n    ug = []\n    for i in range(m):\n        (t, u, v) = map(int, input().split())\n        if t == 0:\n            ug.append([u, v])\n        else:\n            g[u].append(v)\n    sorted = toposort(g)\n    if not sorted:\n        print('NO')\n    else:\n        print('YES')\n        index = [0] * (n + 1)\n        for i in range(n + 1):\n            index[sorted[i]] = i\n        for i in range(n + 1):\n            for u in g[i]:\n                print(i, u)\n        for (u, v) in ug:\n            if index[u] < index[v]:\n                print(u, v)\n            else:\n                print(v, u)", "import collections\ntest = int(input())\nfor _ in range(test):\n    (n, m) = map(int, input().split())\n    res = []\n    gress = [0] * (n + 1)\n    dn = collections.defaultdict(list)\n    for _ in range(m):\n        (d, x, y) = map(int, input().split())\n        if d == 1:\n            dn[x].append(y)\n            gress[y] += 1\n        res.append([d, x, y])\n    zp = [i for i in range(1, n + 1) if gress[i] == 0]\n    count = 0\n    p = [0] * (n + 1)\n    while zp:\n        u = zp.pop()\n        count += 1\n        p[u] = count\n        for v in dn[u]:\n            gress[v] -= 1\n            if gress[v] == 0:\n                zp.append(v)\n    if count == n:\n        print('YES')\n        for (d, x, y) in res:\n            if d == 1:\n                print(x, y)\n            elif p[x] < p[y]:\n                print(x, y)\n            else:\n                print(y, x)\n    else:\n        print('NO')", "from collections import defaultdict, deque\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    gr0 = defaultdict(list)\n    gr1 = defaultdict(list)\n    edges = []\n    indeg = [0] * (n + 1)\n    for i in range(m):\n        (t, x, y) = map(int, input().split())\n        if t == 0:\n            edges.append([x, y])\n        else:\n            gr0[x].append(y)\n            indeg[y] += 1\n    q = deque()\n    for i in range(1, n + 1):\n        if indeg[i] == 0:\n            q.append(i)\n    cnt = 0\n    top = []\n    while q:\n        s = q.popleft()\n        top.append(s)\n        for i in gr0[s]:\n            indeg[i] -= 1\n            if indeg[i] == 0:\n                q.append(i)\n        cnt += 1\n    if cnt != n:\n        print('NO')\n        continue\n    mp = {}\n    for i in range(n):\n        mp[top[i]] = i\n    for (x, y) in edges:\n        if mp[x] < mp[y]:\n            gr0[x].append(y)\n        else:\n            gr0[y].append(x)\n    print('YES')\n    for i in gr0.keys():\n        for j in gr0[i]:\n            print(i, j)", "t = int(input())\nMaxn = 210000\nwhile t > 0:\n    t -= 1\n    (n, m) = map(int, input().split())\n    to = [[]]\n    for i in range(0, n):\n        to.append([])\n    d = [0] * (n + 1)\n    ran = [0] * (n + 1)\n    q = []\n    cnt = 0\n    to[0].append(1)\n    for i in range(0, m):\n        (bj, u, v) = map(int, input().split())\n        if bj:\n            to[u].append(v)\n            d[v] += 1\n            q.append((u, v))\n        else:\n            q.append((u, v))\n    que = []\n    for i in range(1, n + 1):\n        if d[i] == 0:\n            que.append(i)\n    while len(que):\n        now = que.pop()\n        cnt += 1\n        ran[now] = cnt\n        for i in to[now]:\n            d[i] -= 1\n            if d[i] == 0:\n                que.append(i)\n    if cnt != n:\n        print('NO')\n        continue\n    print('YES')\n    for i in q:\n        if ran[i[0]] < ran[i[1]]:\n            print(i[0], i[1])\n        else:\n            print(i[1], i[0])", "from collections import defaultdict, deque\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    gr0 = defaultdict(list)\n    gr1 = defaultdict(list)\n    edges = []\n    indeg = [0] * (n + 1)\n    for i in range(m):\n        (t, x, y) = map(int, input().split())\n        if t == 0:\n            edges.append([x, y])\n        else:\n            gr0[x].append(y)\n            indeg[y] += 1\n    q = deque()\n    cnt = 0\n    top = []\n    mp = {}\n    for i in range(1, n + 1):\n        if indeg[i] == 0:\n            q.append(i)\n    while q:\n        s = q.popleft()\n        top.append(s)\n        for i in gr0[s]:\n            indeg[i] -= 1\n            if indeg[i] == 0:\n                q.append(i)\n        cnt += 1\n    if cnt != n:\n        print('NO')\n        continue\n    for i in range(n):\n        mp[top[i]] = i\n    for (x, y) in edges:\n        if mp[x] < mp[y]:\n            gr0[x].append(y)\n        else:\n            gr0[y].append(x)\n    print('YES')\n    for i in gr0.keys():\n        for j in gr0[i]:\n            print(i, j)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    go = {i: set() for i in range(1, n + 1)}\n    gi = {i: set() for i in range(1, n + 1)}\n    eu = []\n    ed = []\n    for i in range(m):\n        (t, x, y) = map(int, input().split())\n        if t:\n            go[x].add(y)\n            gi[y].add(x)\n            ed.append((x, y))\n        else:\n            eu.append((x, y))\n    l = []\n    s = [i for i in gi if len(gi[i]) == 0]\n    while s:\n        i = s.pop()\n        l.append(i)\n        for j in go[i]:\n            gi[j].discard(i)\n            if gi[j] == set():\n                s.append(j)\n        go[i].clear()\n    if any(go.values()):\n        print('NO')\n    else:\n        print('YES')\n        x = {}\n        for (i, j) in enumerate(l):\n            x[j] = i\n        for i in range(1, n + 1):\n            if i not in x:\n                x[i] = n + i\n        for (i, j) in eu:\n            if x[i] < x[j]:\n                print(i, j)\n            else:\n                print(j, i)\n        for (i, j) in ed:\n            print(i, j)", "from collections import deque\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    ud = defaultdict(list)\n    d = defaultdict(list)\n    pi = [0] * (n + 1)\n    v = [0] * (n + 1)\n    pis = [0] * (n + 1)\n    u = 0\n    co = 0\n    for _ in range(m):\n        (t, a, b) = list(map(int, input().split()))\n        if t == 0:\n            ud[a].append(b)\n            ud[b].append(a)\n        else:\n            d[a].append(b)\n            pi[b] += 1\n    queue = deque([])\n    for i in range(1, n + 1):\n        if pi[i] == 0:\n            queue.append(i)\n            pis[i] = co\n            co += 1\n            v[i] = 1\n    while len(queue) != 0:\n        a = queue.popleft()\n        for i in d[a]:\n            pi[i] -= 1\n            if pi[i] == 0:\n                queue.append(i)\n                pis[i] = co\n                co += 1\n                v[i] = 1\n    if sum(v) == n:\n        print('YES')\n    else:\n        print('NO')\n        continue\n    for i in ud:\n        for j in ud[i]:\n            if pis[i] < pis[j]:\n                print(i, j)\n    for i in ud:\n        for j in ud[i]:\n            if pis[i] == pis[j] and i < j:\n                print(i, j)\n    for i in d:\n        for j in d[i]:\n            print(i, j)"]