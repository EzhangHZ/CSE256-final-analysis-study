["def find_max(l, i, j):\n    current_max = l[i]\n    current_max_index = i\n    for k in range(i, j + 1):\n        if current_max < l[k]:\n            current_max = l[k]\n            current_max_index = k\n    return current_max_index\n\ndef recursive_function(level, l, final_l, start, end):\n    if start > end:\n        return\n    else:\n        current_index = find_max(l, start, end)\n        final_l[current_index] = level\n        recursive_function(level + 1, l, final_l, start, current_index - 1)\n        recursive_function(level + 1, l, final_l, current_index + 1, end)\n\ndef main_function():\n    test_cases = range(int(input()))\n    for test_case in test_cases:\n        n = int(input())\n        a = [int(i) for i in input().split(' ')]\n        final_a = [0 for i in range(n)]\n        recursive_function(0, a, final_a, 0, len(a) - 1)\n        print(' '.join([str(i) for i in final_a]))\nmain_function()", "import sys\n\ndef solve(vet, dic={}, d=0):\n    if len(vet) == 0:\n        return {}\n    maximo = max(vet)\n    ind = vet.index(maximo)\n    dicEsq = solve(vet[0:ind], d=d + 1)\n    dicDir = solve(vet[ind + 1:], d=d + 1)\n    dicMax = {maximo: d}\n    ret = {**dicEsq, **dicMax, **dicDir}\n    return ret\n\ndef printRes(res):\n    ret = ''\n    for i in res:\n        ret += str(res[i]) + ' '\n    print(ret.strip())\nl = sys.stdin.readlines()\nt = int(l[0].replace('\\n', ''))\ni = 1\nfor _ in range(t):\n    n = int(l[i].replace('\\n', ''))\n    i += 1\n    a = [int(x) for x in l[i].replace('\\n', '').split()]\n    i += 1\n    res = solve(a)\n    printRes(res)", "def permutation_to_tree(arr, i, j, depth, depths):\n    if i == j:\n        depths[i] = depth\n        return\n    root_val = -1\n    root_index = -1\n    for k in range(i, j + 1):\n        if arr[k] > root_val:\n            root_val = arr[k]\n            root_index = k\n    depths[root_index] = depth\n    if root_index - 1 - i >= 0:\n        permutation_to_tree(arr, i, root_index - 1, depth + 1, depths)\n    if j - (root_index + 1) >= 0:\n        permutation_to_tree(arr, root_index + 1, j, depth + 1, depths)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    permutation = [int(x) for x in input().split(' ')]\n    depths = [-1 for _ in range(n)]\n    permutation_to_tree(permutation, 0, n - 1, 0, depths)\n    print(' '.join([str(x) for x in depths]))", "import math as m\ni = input()\ninp = []\nfor a in range(0, int(i)):\n    input()\n    inp.append([int(x) for x in input().split()])\n\ndef func(arr, depth):\n    n = len(arr)\n    if n == 1:\n        return [depth]\n    elif n == 0:\n        return []\n    m = arr[0]\n    p = 0\n    for i in range(1, len(arr)):\n        if arr[i] > m:\n            m = arr[i]\n            p = i\n    return func(arr[:p], depth + 1) + [depth] + func(arr[p + 1:], depth + 1)\nfor arr in inp:\n    d = func(arr, 0)\n    print(' '.join([str(x) for x in d]))", "def find_pos(l, r, height, ans):\n    height += 1\n    if l != []:\n        ans[max(l) - 1] = height\n        max_l = l.index(max(l))\n        l_l = l[:max_l]\n        r_l = l[max_l + 1:]\n        find_pos(l_l, r_l, height, ans)\n    if r != []:\n        ans[max(r) - 1] = height\n        max_r = r.index(max(r))\n        l_r = r[:max_r]\n        r_r = r[max_r + 1:]\n        find_pos(l_r, r_r, height, ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split(' ')))[:n]\n    ans = [0 for _ in range(n)]\n    max_a = a.index(max(a))\n    l = a[:max_a]\n    r = a[max_a + 1:]\n    height = 0\n    find_pos(l, r, height, ans)\n    for i in range(n):\n        a[i] = ans[a[i] - 1]\n    print(' '.join(map(str, a)))", "def verify(arr, i):\n    if len(arr) == 1:\n        return [i]\n    if len(arr) == 0:\n        return []\n    pos = arr.index(max(arr))\n    left = arr[:pos]\n    right = arr[pos + 1:]\n    return verify(left, i + 1) + [i] + verify(right, i + 1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    perm = verify(lst, 0)\n    for idx in perm:\n        print(idx, end=' ')\n    print()", "def helper(A, level, ans, k):\n    if len(A) == 0:\n        return\n    max_index = A.index(max(A))\n    ans[k + max_index] = level\n    helper(A[:max_index], level + 1, ans, k)\n    helper(A[max_index + 1:], level + 1, ans, max_index + 1 + k)\n    return ans\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = [0] * len(a)\n    ans = helper(a, 0, ans, 0)\n    print(*ans)", "def work(n, a):\n    res = [0] * n\n\n    def dfs(l, r, depth):\n        if l > r:\n            return\n        if l == r:\n            res[l] = depth\n            return\n        (maxv, idx) = (0, -1)\n        for i in range(l, r + 1):\n            if a[i] > maxv:\n                maxv = a[i]\n                idx = i\n        res[idx] = depth\n        dfs(l, idx - 1, depth + 1)\n        dfs(idx + 1, r, depth + 1)\n        return\n    dfs(0, n - 1, 0)\n    return res\n\ndef main():\n    test = int(input())\n    for _ in range(test):\n        n = int(input())\n        a = list(map(int, input().split()))\n        ans = work(n, a)\n        print(*ans)\n    return\nmain()", "def dfs(l, d, count):\n    if l:\n        m = max(l)\n        ind = l.index(m)\n        d[m] = count\n        d = dfs(l[:ind], d, count + 1)\n        d = dfs(l[ind + 1:], d, count + 1)\n    return d\nnodes = int(input())\nfor i in range(nodes):\n    n = int(input())\n    count = 0\n    l = list(map(int, input().split()))\n    ans = dfs(l, {}, 0)\n    res = []\n    for i in l:\n        res.append(ans[i])\n    print(*res)", "def dfs(l, d, count):\n    if l:\n        m = max(l)\n        ind = l.index(m)\n        d[m] = count\n        d = dfs(l[:ind], d, count + 1)\n        d = dfs(l[ind + 1:], d, count + 1)\n    return d\nnodes = int(input())\nfor i in range(nodes):\n    n = int(input())\n    count = 0\n    l = list(map(int, input().split()))\n    ans = dfs(l, {}, 0)\n    res = []\n    for i in l:\n        res.append(ans[i])\n    print(*res)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n    dic = {}\n    for h in lst:\n        dic[h] = -1\n\n    def fun(left, right, ma, ht):\n        if left == right:\n            dic[ma] = ht\n            return\n        else:\n            maxind = lst.index(ma)\n            dic[ma] = ht\n            if lst[left:maxind] != []:\n                fun(left, maxind - 1, max(lst[left:maxind]), ht + 1)\n            if lst[maxind + 1:right + 1] != []:\n                fun(maxind + 1, right, max(lst[maxind + 1:right + 1]), ht + 1)\n    fun(0, n - 1, max(lst), 0)\n    lsta = []\n    for j in dic.values():\n        lsta.append(j)\n    print(*lsta)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [0] * (n + 1)\n\n    def go(v, h):\n        if v:\n            x = max(v)\n            i = v.index(x)\n            d[x] = h\n            go(v[:i], h + 1)\n            go(v[i + 1:], h + 1)\n    go(a, 0)\n    print(*(d[a[i]] for i in range(n)))", "t = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    a = [int(i) for i in input().strip().split()]\n    mv = max(a)\n    mi = a.index(mv)\n    o = ['0'] * n\n    q = []\n    if mi > 0:\n        q.append((1, 0, mi - 1))\n    if mi < n - 1:\n        q.append((1, mi + 1, n - 1))\n    while len(q) > 0:\n        (d, ini, end) = q.pop(0)\n        mv = max(a[ini:end + 1])\n        mi = a.index(mv)\n        o[mi] = f'{d}'\n        if mi > ini:\n            q.append((d + 1, ini, mi - 1))\n        if mi < end:\n            q.append((d + 1, mi + 1, end))\n    print(' '.join(o))", "t = int(input())\n\ndef depth(n, start, end):\n    if start == end:\n        newVet[start] = n\n    else:\n        max = -1\n        j = start\n        while j <= end:\n            if a[j] > max:\n                max = a[j]\n                div = j\n            j += 1\n        newVet[div] = n\n        if start <= div - 1:\n            depth(n + 1, start, div - 1)\n        if div + 1 <= end:\n            depth(n + 1, div + 1, end)\nfor i in range(t):\n    length = int(input())\n    a = [int(n) for n in input().split()]\n    newVet = [-1] * length\n    depth(0, 0, length - 1)\n    print(*newVet)", "def busca(d, right, left):\n    if right <= left:\n        index = right\n        maior_n = 0\n        while index <= left:\n            if a[index] > maior_n:\n                maior_n = a[index]\n                maior_i = index\n            index += 1\n        a[maior_i] = d\n        busca(d + 1, maior_i + 1, left)\n        busca(d + 1, right, maior_i - 1)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input().split(' ')\n    for i in range(n):\n        a[i] = int(a[i])\n    busca(0, 0, n - 1)\n    for i in a:\n        print(i, end=' ')\n    print()", "def find_depth(left, right, depth):\n    if left > right:\n        return\n    max_index = left\n    max_val = dp[left]\n    for i in range(left, right + 1):\n        if a[i] > max_val:\n            max_val = a[i]\n            max_index = i\n    dp[max_index] = depth\n    find_depth(left, max_index - 1, depth + 1)\n    find_depth(max_index + 1, right, depth + 1)\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [-1] * n\n    find_depth(0, n - 1, 0)\n    print(*dp, sep=' ')", "import math as m\ni = input()\ninp = []\nfor a in range(0, int(i)):\n    input()\n    inp.append([int(x) for x in input().split()])\n\ndef func(arr, depth):\n    n = len(arr)\n    if n == 1:\n        return [str(depth)]\n    elif n == 0:\n        return []\n    m = arr[0]\n    p = 0\n    for i in range(1, len(arr)):\n        if arr[i] > m:\n            m = arr[i]\n            p = i\n    return func(arr[:p], depth + 1) + [str(depth)] + func(arr[p + 1:], depth + 1)\nfor arr in inp:\n    d = func(arr, 0)\n    print(' '.join(d))", "def find_max(arr, from_index, to_index):\n    max_v = arr[from_index]\n    index_v = from_index\n    for i in range(from_index, to_index + 1):\n        if arr[i] > max_v:\n            index_v = i\n            max_v = arr[i]\n    return index_v\n\ndef solve_depth(arr, d_arr, left, right, d):\n    if left == right:\n        d_arr[left] = d\n    elif left < right:\n        index = find_max(arr, left, right)\n        solve_depth(arr, d_arr, left, index - 1, d + 1)\n        solve_depth(arr, d_arr, index + 1, right, d + 1)\n        d_arr[index] = d\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        line = input().split()\n        arr = []\n        d_arr = []\n        for x in line:\n            arr.append(int(x))\n            d_arr.append(0)\n        solve_depth(arr, d_arr, 0, n - 1, 0)\n        for i in range(n):\n            print(str(d_arr[i]), end=' ')\n        print(' ')\nmain()", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    sol = [-1 for _ in range(N)]\n    numbers = list(map(int, input().split(' ')))\n\n    def prueba(arr, depth=0, der=0):\n        if not arr:\n            return\n        i = arr.index(max(arr))\n        sol[der + i] = depth\n        left = arr[:i]\n        right = arr[i + 1:]\n        prueba(left, depth + 1, der)\n        prueba(right, depth + 1, der + i + 1)\n    prueba(numbers)\n    print(*sol)", "def recursive(array, dic, depth):\n    if len(array) == 0:\n        return\n    raiz = max(array)\n    diccionario[raiz] = depth\n    izq = False\n    der = False\n    index_raiz = array.index(raiz)\n    l_izq = array[0:index_raiz]\n    l_der = array[index_raiz + 1:]\n    depth += 1\n    if izq and der:\n        return diccionario\n    recursive(l_izq, diccionario, depth)\n    recursive(l_der, diccionario, depth)\n    return diccionario\nt = int(input())\nfor _ in range(t):\n    l = int(input())\n    array = list(map(int, input().split()))\n    diccionario = dict()\n    depth = 0\n    while len(diccionario) < l:\n        dic = recursive(array, diccionario, depth)\n        for e in array:\n            print(dic[e], end=' ')\n    print()", "def tree(arr, cnt):\n    if not arr:\n        return\n    mx = max(arr)\n    d[mx] = cnt\n    ind = arr.index(mx)\n    tree(arr[:ind], cnt + 1)\n    tree(arr[ind + 1:], cnt + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    tree(a, 0)\n    for i in a:\n        print(d[i], end=' ')\n    print()", "n_testes = int(input())\nsequencias = []\nfor e in range(n_testes):\n    qntd_elementos = int(input())\n    sequencia = list(map(int, input().split()))\n    sequencias.append(sequencia)\n\ndef retorna_maior(seq, inicio, fim):\n    i_maior = inicio\n    for i in range(inicio, fim + 1):\n        if seq[i] > seq[i_maior]:\n            i_maior = i\n    return i_maior\n\ndef resolve(seq, inicio, fim, profundidade, resposta):\n    if inicio > fim:\n        return\n    indice_maior = retorna_maior(seq, inicio, fim)\n    resposta[indice_maior] = profundidade\n    resolve(seq, inicio, indice_maior - 1, profundidade + 1, resposta)\n    resolve(seq, indice_maior + 1, fim, profundidade + 1, resposta)\n    return resposta\nprofundidades = []\nfor s in sequencias:\n    profundidades.append(resolve(s, 0, len(s) - 1, 0, [0] * len(s)))\nfor p in profundidades:\n    print(str(p)[1:-1].replace(',', ''))", "depth = list()\n\ndef gen_depth(left, routedepth, right):\n    if left > right:\n        return 0\n    route = left\n    for i in range(left, right + 1):\n        if arr[route] < arr[i]:\n            route = i\n    depth[route] = routedepth\n    gen_depth(left, routedepth + 1, route - 1)\n    gen_depth(route + 1, routedepth + 1, right)\ntc = int(input())\nfor cs in range(tc):\n    n = int(input())\n    x = 0\n    line = input()\n    arr = list(map(int, line.split()))\n    for i in range(n):\n        depth.append(0)\n    gen_depth(0, 0, n - 1)\n    for i in range(n):\n        print(depth[i], end=' ')\n    print('')", "testcases = int(input())\n\ndef depth_function(input_list, depth_list, current_depth, index_left, index_right):\n    if index_left == index_right:\n        return None\n    max_sublist = max(input_list[index_left:index_right])\n    max_index = input_list.index(max_sublist)\n    depth_list[max_index] = current_depth\n    depth_function(input_list, depth_list, current_depth + 1, index_left, max_index)\n    depth_function(input_list, depth_list, current_depth + 1, max_index + 1, index_right)\nfor i in range(testcases):\n    n = int(input())\n    input_2 = input().split()\n    permutation = list(map(int, input_2))\n    depths = [0] * n\n    depth_function(permutation, depths, 0, 0, n)\n    print(' '.join(map(str, depths)))", "def sol(nums, begin, end, depth):\n    if end - begin < 1:\n        return\n    curNums = nums[begin:end]\n    i = nums.index(max(curNums))\n    ans[i] = depth\n    sol(nums, begin, i, depth + 1)\n    sol(nums, i + 1, end, depth + 1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    nums = list(map(int, input().split()))\n    ans = [0] * n\n    sol(nums, 0, n, 0)\n    print(' '.join(map(str, ans)))", "n = int(input())\n\ndef divide(arr):\n    max_ind = 0\n    for i in range(len(arr)):\n        if arr[i] > arr[max_ind]:\n            max_ind = i\n    return (arr[max_ind], arr[:max_ind], arr[max_ind + 1:])\n\ndef conquer(arr, ans, hash_map, depth):\n    (max_num, left, right) = divide(arr)\n    ind = hash_map[max_num]\n    ans[ind] = depth\n    if len(left) > 0:\n        conquer(left, ans, hash_map, depth + 1)\n    if len(right) > 0:\n        conquer(right, ans, hash_map, depth + 1)\nfor _ in range(n):\n    length = int(input())\n    arr = list(map(int, input().split()))\n    ans = [0] * length\n    depth = 0\n    hash_map = {}\n    for (i, val) in enumerate(arr):\n        hash_map[val] = i\n    conquer(arr, ans, hash_map, depth)\n    print(' '.join(map(str, ans)))", "def s():\n    n = int(input())\n    a = [int(it) for it in input().split()]\n    h = [0] * (n + 1)\n\n    def f(hi, x):\n        if len(x) == 1:\n            h[x[0]] = hi\n            return\n        maxi = x.index(max(x))\n        h[x[maxi]] = hi\n        if maxi > 0:\n            f(hi + 1, x[0:maxi])\n        if maxi < len(x) - 1:\n            f(hi + 1, x[maxi + 1:])\n    f(0, a)\n    for it in a:\n        print(h[it], end=' ')\n    print()\nk = int(input())\nfor i in range(k):\n    s()", "depths = []\n\ndef make_tree(seq, current_depth, shift_idx):\n    if len(seq) == 0:\n        return\n    max_index = shift_idx\n    max_val = 1\n    for (idx, val) in enumerate(seq):\n        idx += shift_idx\n        if val > max_val:\n            max_val = val\n            max_index = idx\n    depths[max_index] = current_depth\n    if len(seq) <= 1:\n        return\n    make_tree(seq[:max_index - shift_idx], current_depth + 1, shift_idx)\n    make_tree(seq[max_index + 1 - shift_idx:], current_depth + 1, max_index + 1)\nn_tests = int(input())\nfor t in range(n_tests):\n    input()\n    in_seq = input().split(' ')\n    in_seq = list(map(int, in_seq))\n    depths = [-1 for x in in_seq]\n    make_tree(in_seq, 0, 0)\n    print(' '.join(list(map(str, depths))))", "import sys\nimport math\nN = int(10000.0 + 5)\nsys.setrecursionlimit(N)\n\ndef charming():\n    n = int(input())\n    a = [0] + list(map(int, input().split()))\n    dep = [0] * (n + 1)\n\n    def dfs(l, r, d):\n        if l > r:\n            return\n        if l == r:\n            dep[l] = d\n            return\n        mx = max(a[l:r + 1])\n        mx_id = a[l:r + 1].index(mx) + l\n        dep[mx_id] = d\n        dfs(l, mx_id - 1, d + 1)\n        dfs(mx_id + 1, r, d + 1)\n    dfs(1, n, 0)\n    for i in range(1, n + 1):\n        print(dep[i], end=' ')\n    print()\nfor t in range(int(input())):\n    charming()", "def getdepth(l, arr):\n    if not arr:\n        return\n    mx = max(arr)\n    ind = arr.index(mx)\n    d[mx] = l\n    getdepth(l + 1, arr[:ind])\n    getdepth(l + 1, arr[ind + 1:])\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    getdepth(0, a)\n    for i in a:\n        print(d[i], end=' ')\n    print()", "def get_depth(l, depth):\n    if len(l) > 0:\n        if len(l) > 1:\n            ele = max(l)\n            d[ele] = depth\n            depth += 1\n            loc = l.index(ele)\n            l1 = l[:loc]\n            try:\n                l2 = l[loc + 1:]\n            except:\n                l2 = []\n            get_depth(l1, depth)\n            get_depth(l2, depth)\n        else:\n            d[l[0]] = depth\nT = int(input())\nfor _ in range(0, T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {i: 0 for i in a}\n    get_depth(a, 0)\n    print(*list(d.values()))", "def solve(l, r, lst, arr, cnt):\n    if l <= r:\n        mx = arr[l]\n        index = l\n        for i in range(l, r + 1):\n            if lst[i] > mx:\n                mx = lst[i]\n                index = i\n        arr[index] = cnt\n        cnt += 1\n        solve(l, index - 1, lst, arr, cnt)\n        solve(index + 1, r, lst, arr, cnt)\n    return\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    lst = list(map(int, input().split(' ')))\n    arr = [0] * n\n    solve(0, n - 1, lst, arr, 0)\n    for i in range(n):\n        if i == n - 1:\n            print(arr[i])\n        else:\n            print(arr[i], end=' ')", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    arr = list(map(int, input().split()))\n    res = [0] * n\n\n    def f(start, end, depth):\n        if start > end:\n            return\n        x = max(arr[start:end + 1])\n        index = arr.index(x)\n        res[index] = depth\n        f(start, index - 1, depth + 1)\n        f(index + 1, end, depth + 1)\n    f(0, n - 1, 0)\n    print(*res)", "import sys\n\ndef solve(n, a):\n    d = [0] * n\n\n    def set_d_max(start, end, d_last):\n        if start == end:\n            return\n        i_max = start\n        for i in range(start + 1, end):\n            if a[i] > a[i_max]:\n                i_max = i\n        d[i_max] = d_last\n        set_d_max(start, i_max, d_last + 1)\n        set_d_max(i_max + 1, end, d_last + 1)\n    set_d_max(0, n, 0)\n    return ' '.join(map(str, d))\n\ndef main():\n    res = ''\n    input = sys.stdin.readline\n    print = sys.stdout.write\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        res += str(solve(n, a)) + '\\n'\n    print(res)\nmain()", "def tree(arr, cnt):\n    if not arr:\n        return\n    mx = max(arr)\n    d[mx] = cnt\n    ind = arr.index(mx)\n    tree(arr[:ind], cnt + 1)\n    tree(arr[ind + 1:], cnt + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    tree(a, 0)\n    for i in a:\n        print(d[i], end=' ')\n    print()", "import sys\nYES = 'YES'\nNO = 'NO'\nMOD = 1000000007\n\ndef input_int():\n    return int(input())\n\ndef input_list():\n    return input().split(' ')\n\ndef input_list_int():\n    return list(map(int, input_list()))\n\ndef find_h(l, r, a, cur, h):\n    if l >= r:\n        return\n    me = a[l]\n    mi = l\n    for i in range(l, r):\n        if me < a[i]:\n            me = a[i]\n            mi = i\n    h[mi] = cur\n    find_h(l, mi, a, cur + 1, h)\n    find_h(mi + 1, r, a, cur + 1, h)\n\ndef solve():\n    n = input_int()\n    a = input_list_int()\n    h = [-1] * n\n    find_h(0, n, a, 0, h)\n    for i in range(0, n):\n        print(h[i], end=' ')\n    print()\nquery_count = input_int()\nwhile query_count:\n    query_count -= 1\n    solve()", "def f(l, r, d):\n    if l >= r:\n        return\n    m = -1\n    ind = l\n    for i in range(l, r):\n        if a[i] > m:\n            ind = i\n            m = a[i]\n    t[ind] = d\n    f(l, ind, d + 1)\n    f(ind + 1, r, d + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    t = [0] * n\n    f(0, n, 0)\n    for i in t:\n        print(i, end=' ')\n    print()", "def solveTree(nodes, depth=0):\n    if len(nodes) == 1:\n        return [depth]\n    if not len(nodes):\n        return []\n    max_el = max(nodes)\n    max_in = nodes.index(max_el)\n    left = nodes[:max_in]\n    right = nodes[max_in + 1:]\n    res = [-1] * len(nodes)\n    res = solveTree(left, depth + 1) + [depth] + solveTree(right, depth + 1)\n    return res\nt = int(input())\nfor _ in range(t):\n    N = int(input())\n    nodes = list(map(int, input().split()))\n    for i in solveTree(nodes):\n        print(i, end=' ')\n    print()", "def dfs(l, d, c):\n    if l:\n        m = max(l)\n        ind = l.index(m)\n        d[m] = c\n        d = dfs(l[:ind], d, c + 1)\n        d = dfs(l[ind + 1:], d, c + 1)\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    c = 0\n    l = list(map(int, input().split()))\n    ans = dfs(l, {}, 0)\n    res = []\n    for i in l:\n        res.append(ans[i])\n    print(*res)", "def subArray(source, arr, dept):\n    res = []\n    res1 = []\n    res2 = []\n    if len(arr) == 1:\n        return [dept]\n    index = arr.index(max(arr))\n    arr1 = arr[0:index]\n    arr2 = arr[index + 1:len(arr)]\n    arr[index] = dept\n    while True:\n        if len(arr1) > 0:\n            res1 = subArray(source, arr1, dept + 1)\n        if len(arr2) > 0:\n            res2 = subArray(source, arr2, dept + 1)\n            break\n        else:\n            break\n    res = res1 + [dept] + res2\n    return res\nn = int(input())\nfor i in range(0, n):\n    m = int(input())\n    arr = [int(x) for x in input().split()]\n    print(str(subArray(arr, arr, 0))[1:-1].replace(', ', ' '))", "def build(l, r, depth):\n    mxid = max(range(l, r + 1), key=lambda a: ls[a])\n    if mxid > l:\n        build(l, mxid - 1, depth + 1)\n    if mxid < r:\n        build(mxid + 1, r, depth + 1)\n    d[mxid] = depth\nfor _ in range(int(input())):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    d = [0] * n\n    build(0, n - 1, 0)\n    print(' '.join(map(str, d)))", "def solve(arr, level=0):\n    if len(arr) == 0:\n        return\n    m = max(arr)\n    i = a.index(m)\n    out[i] = level\n    x = arr.index(m)\n    solve(arr[0:x], level + 1)\n    solve(arr[x + 1:], level + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    out = [-1 for i in range(n)]\n    b = list(a)\n    solve(b)\n    print(*out)", "__version__ = '0.1'\n__date__ = '2021-03-13'\nimport sys\n\ndef rec_tree(a, k):\n    if len(a) == 1:\n        return [k]\n    curr = a.index(max(a))\n    n = len(a)\n    if curr > 0:\n        left = rec_tree(a[:curr], k + 1)\n    else:\n        left = []\n    if curr < n - 1:\n        right = rec_tree(a[curr + 1:], k + 1)\n    else:\n        right = []\n    return left + [k] + right\n\ndef solve(n, a):\n    return ' '.join(map(str, rec_tree(a, 0)))\n\ndef main(argv=None):\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        print(solve(n, a))\n    return 0\nSTATUS = main()\nsys.exit(STATUS)", "def divider(arr, level):\n    if len(arr):\n        max_val = max(arr)\n        max_index = arr.index(max_val)\n        left_arr = arr[:max_index]\n        right_arr = arr[max_index + 1:]\n        return [(max_val, level), *divider(left_arr, level + 1), *divider(right_arr, level + 1)]\n    else:\n        return []\nin_length = int(input())\nfinal_ouput = []\nfor i in range(in_length):\n    length = input()\n    inputs = [int(el) for el in input().split()]\n    outputs = inputs[:]\n    has_subdivisions = True\n    original_level = 0\n    mid_ans = divider(inputs, original_level)\n    for (j, inp) in enumerate(inputs):\n        num = mid_ans[j][0]\n        idx = inputs.index(num)\n        outputs[idx] = str(mid_ans[j][1])\n    final_ouput.append(' '.join(outputs))\nfor out in final_ouput:\n    print(out)", "def ass(a, b):\n    print(f'Assertion error: {a} != {b}' if a != b else 'OK')\n\ndef nr():\n    return nrs()[0]\n\ndef nrs():\n    return [int(item) for item in input().split()]\n\ndef word():\n    return input()\n\ndef words():\n    return [item for item in input().split()]\n\ndef dump(lst):\n    for (i, item) in enumerate(lst):\n        print(i, item)\n\ndef binsearch(arr, a, b):\n    m = (a + b) // 2\n    if a >= b:\n        return a - 1 if arr[a] == 0 else a\n    return binsearch(arr, a, m - 1) if arr[m] == 0 else binsearch(arr, m + 1, b)\n\ndef gcd(x, y):\n    return x if y == 0 else gcd(y, x % y)\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef f(arr, level=0):\n    if len(arr) == 0:\n        return []\n    m = max(arr)\n    i = arr.index(m)\n    return f(arr[:i], level + 1) + [level] + f(arr[i + 1:], level + 1)\nfor i in range(nr()):\n    n = nrs()\n    print(*f(nrs()))", "def permutTransf(a, level):\n    if len(a) == 0:\n        return []\n    if len(a) == 1:\n        return [level]\n    z = a.index(max(a))\n    x = permutTransf(a[:z], level + 1)\n    y = permutTransf(a[z + 1:], level + 1)\n    return x + [level] + y\nfor t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*permutTransf(a, 0))", "def pinpin(l, r, d, ans, a):\n    if l > r:\n        return\n    x = max(a[l:r + 1])\n    if x == -1:\n        return\n    pos_x = a.index(x)\n    a[pos_x] = -1\n    ans[pos_x] = d\n    pinpin(l, pos_x - 1, d + 1, ans, a)\n    pinpin(pos_x + 1, r, d + 1, ans, a)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = [-1] * n\n    pinpin(0, n - 1, 0, ans, a)\n    print(*ans)", "def aux(length, values, x):\n    if length == 0:\n        return []\n    if length == 1:\n        return [x]\n    maximum = values.index(max(values))\n    first = values[:maximum]\n    last = values[maximum + 1:]\n    return aux(len(first), first, x + 1) + [x] + aux(len(last), last, x + 1)\n\ndef main():\n    number = int(input())\n    for i in range(number):\n        cont = 0\n        values = []\n        length_permutation = int(input())\n        input_values = input().split(' ')\n        for i in input_values:\n            values.append(int(i))\n        result = aux(length_permutation, values, cont)\n        output = ''\n        for i in range(len(result)):\n            output += str(result[i]) + ' '\n        print(output)\nmain()", "def searchIndexRoot(array, p, r):\n    index = 0\n    root = 0\n    for i in range(p, r + 1):\n        if array[i] > root:\n            root = array[i]\n            index = i\n    return index\n\ndef calcDeph(array, p, r, deph):\n    deph += 1\n    if p <= r:\n        index = searchIndexRoot(array, p, r)\n        calcDeph(array, p, index - 1, deph)\n        calcDeph(array, index + 1, r, deph)\n        array[index] = deph\n    return array\n\ndef formatResult(array):\n    lengthArray = len(array)\n    result = ''\n    for i in range(lengthArray):\n        if i < lengthArray:\n            result += str(array[i]) + ' '\n        else:\n            result += str(array[i])\n    return result\ntests = int(input())\nfor i in range(tests):\n    permutationLength = int(input())\n    array = list(map(int, input().split()))\n    result = calcDeph(array, 0, permutationLength - 1, -1)\n    print(formatResult(result))", "def add_nodes(permutacao, profundidade, lista_nos):\n    max_value = max(permutacao)\n    max_index = permutacao.index(max_value)\n    lista_nos[max_value - 1] = profundidade\n    profundidade += 1\n    if max_index != 0:\n        add_nodes(permutacao[:max_index], profundidade, lista_nos)\n    if max_index != len(permutacao) - 1:\n        add_nodes(permutacao[max_index + 1:], profundidade, lista_nos)\nn_testes = input()\nfor i in range(int(n_testes)):\n    n_elements = input()\n    permutacao = list(map(int, input().split()))\n    nos = [0] * int(n_elements)\n    add_nodes(permutacao, 0, nos)\n    result = ''\n    for j in permutacao:\n        result += str(nos[j - 1]) + ' '\n    print(result)", "def get_max_value(arr, left, right):\n    max_value_id = left\n    for idx in range(left, right + 1):\n        if arr[max_value_id] < arr[idx]:\n            max_value_id = idx\n    return max_value_id\n\ndef generate_tree(arr, depth, left, right, current_depth=0):\n    idx = get_max_value(arr, left, right)\n    depth[arr[idx]] = current_depth\n    if idx != left:\n        depth = generate_tree(arr, depth, left, idx - 1, current_depth + 1)\n    if idx != right:\n        depth = generate_tree(arr, depth, idx + 1, right, current_depth + 1)\n    return depth\nn = int(input())\nfor _ in range(n):\n    input()\n    permutation = [int(i) for i in input().split()]\n    depth = {}\n    depth = generate_tree(permutation, depth, 0, len(permutation) - 1)\n    permutation_depth = [str(depth[i]) for i in permutation]\n    print(' '.join(permutation_depth))", "def nr():\n    return nrs()[0]\n\ndef nrs():\n    return [int(i) for i in input().split()]\n\ndef f(a, l=0):\n    if len(a) == 0:\n        return []\n    i = a.index(max(a))\n    return f(a[:i], l + 1) + [l] + f(a[i + 1:], l + 1)\nfor i in range(nr()):\n    n = nrs()\n    print(*f(nrs()))", "def tree(l, r, depth):\n    if l > r:\n        return\n    m = max(a[l:r + 1])\n    mi = a.index(m)\n    d[mi] = depth\n    tree(l, mi - 1, depth + 1)\n    tree(mi + 1, r, depth + 1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [0] * n\n    tree(0, n - 1, 0)\n    print(*d, sep=' ')", "from typing import Tuple, List\n\ndef read_test_case() -> Tuple[str, List[int]]:\n    array_size = input()\n    test_array = [int(i) for i in input().split(' ')]\n    return (array_size, test_array)\n\ndef array_to_depth(array: List[int], size: int, depth: int) -> str:\n    index = array.index(max(array))\n    left = array_to_depth(array[:index], index, depth + 1) if index != 0 else ''\n    right = array_to_depth(array[index + 1:], size - index - 1, depth + 1) if index != size - 1 else ''\n    return f'{left} {depth} {right}'.strip()\nnumber_of_test_cases = int(input())\nfor _ in range(number_of_test_cases):\n    (size, array) = read_test_case()\n    result = array_to_depth(array, int(size), 0)\n    print(result)", "def permutationTransformation(array, i, j, blank, p):\n    if j - i < 0:\n        return\n    mi = i\n    for x in range(i, j + 1):\n        if array[x] > array[mi]:\n            mi = x\n    blank[mi] = p\n    permutationTransformation(array, i, mi - 1, blank, p + 1)\n    permutationTransformation(array, mi + 1, j, blank, p + 1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    blank = [0] * n\n    permutationTransformation(l, 0, n - 1, blank, 0)\n    for x in blank:\n        print(x, end=' ')\n    print()", "def depth(l, level):\n    tree.append(max(l))\n    zone.append(level)\n    level = level + 1\n    left = l[:l.index(max(l))]\n    right = l[l.index(max(l)) + 1:]\n    if len(left) > 0:\n        depth(left, level)\n    if len(right) > 0:\n        depth(right, level)\ntest_cases = int(input())\nwhile test_cases > 0:\n    list_l = int(input())\n    l = list(map(int, input().split()))\n    tree = []\n    zone = []\n    depth(l, 0)\n    answer = []\n    for i in l:\n        j = tree.index(i)\n        answer.append(zone[j])\n    answerstr = ' '.join(map(str, answer))\n    print(answerstr)\n    test_cases = test_cases - 1", "import sys\nsys.setrecursionlimit(10 ** 9)\nfor _ in range(int(input())):\n\n    def dfs(ii):\n        lmi = lmv = -1\n        for i in range(ii - 1, -1, -1):\n            if b[i] != -1:\n                break\n            if a[i] > lmv:\n                lmv = a[i]\n                lmi = i\n        if lmi != -1:\n            b[lmi] = b[ii] + 1\n            dfs(lmi)\n        rmi = rmv = -1\n        for i in range(ii + 1, n):\n            if b[i] != -1:\n                break\n            if a[i] > rmv:\n                rmv = a[i]\n                rmi = i\n        if rmi != -1:\n            b[rmi] = b[ii] + 1\n            dfs(rmi)\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [-1] * n\n    mv = mi = 0\n    for i in range(n):\n        if a[i] > mv:\n            mv = a[i]\n            mi = i\n    b[mi] = 0\n    dfs(mi)\n    print(*b)", "response = {}\n\ndef get_sub_array(start, end, array):\n    return array[start:end]\n\ndef build_tree(array, depth):\n    if len(array) > 0:\n        maximum = max(array)\n        response[maximum]['depth'] = depth\n        index = array.index(maximum)\n        build_tree(get_sub_array(0, index, array), depth + 1)\n        build_tree(get_sub_array(index + 1, len(array), array), depth + 1)\n\ndef print_result(array):\n    result = ''\n    for j in range(len(array)):\n        result = result + str(response[array[j]]['depth'])\n        if j < len(array) - 1:\n            result = result + ' '\n    print(result)\nfor _ in range(int(input())):\n    n = int(input())\n    numbers = list(map(int, input().split()))\n    for i in range(len(numbers)):\n        number = numbers[i]\n        response[number] = {}\n        response[number]['index'] = i\n        response[number]['depth'] = 0\n    build_tree(numbers, 0)\n    print_result(numbers)", "def tree(temp, i):\n    m = arr.index(max(temp))\n    r[m] = i\n    t = temp.index(max(temp))\n    if t > 0:\n        tree(temp[0:t], i + 1)\n    if t < len(temp) - 1:\n        tree(temp[t + 1:len(temp)], i + 1)\n    return\nt = int(input())\nfor j in range(t):\n    l = int(input())\n    arr = list(map(int, input().split()))\n    r = [-1] * l\n    tree(arr, 0)\n    print(*r, sep=' ')", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [0] * n\n\n    def solve(w, c):\n        if w:\n            x = max(w)\n            i = w.index(x)\n            d[a.index(x)] = c\n            solve(w[i + 1:], c + 1)\n            solve(w[:i], c + 1)\n    solve(a, 0)\n    print(' '.join(map(str, d)))", "def build(v, count):\n    if v == []:\n        return\n    maxi = 0\n    for (ind, val) in enumerate(v):\n        if v[ind] > v[maxi]:\n            maxi = ind\n    resp[v[maxi]] = count\n    build(v[0:maxi], count + 1)\n    build(v[maxi + 1:], count + 1)\ne = int(input())\nwhile e:\n    e -= 1\n    n = int(input())\n    resp = [0] * (n + 1)\n    lista = input()\n    lista = list(map(int, lista.split()))\n    build(lista, 0)\n    for i in range(0, n):\n        print(resp[lista[i]], end=' ')\n    print()", "import sys\nrd = sys.stdin.readline\n\ndef conq(a, b, res, label):\n    if len(b) == 0:\n        return res\n    x = a.index(max(b))\n    x1 = b.index(max(b))\n    res[x] = label\n    conq(a, b[:x1], res, label + 1)\n    conq(a, b[x1 + 1:], res, label + 1)\n    return res\nfor _ in range(int(rd())):\n    n = int(rd())\n    a = list(map(int, rd().split()))\n    res = [0] * n\n    print(' '.join(map(str, conq(a, a, res, 0))))", "def permutation_transformation(A, l, r, d, D):\n    m = l\n    i = l\n    while i <= r:\n        if A[i] > A[m]:\n            m = i\n        i += 1\n    if l < m:\n        permutation_transformation(A, l, m - 1, d + 1, D)\n    print(d, end=' ')\n    if m < r:\n        permutation_transformation(A, m + 1, r, d + 1, D)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = list(map(int, input().split(' ')))\n    D = [0 for _ in range(n)]\n    permutation_transformation(A, 0, n - 1, 0, D)\n    print()", "x = int(input())\n\ndef locate(arr, f, e, n):\n    max = f\n    if f == e:\n        arr[f] = n\n        return\n    if f > e:\n        return\n    for i in range(f, e + 1):\n        if arr[i] > arr[max]:\n            max = i\n    arr[max] = n\n    locate(arr, f, max - 1, n + 1)\n    locate(arr, max + 1, e, n + 1)\nwhile x:\n    n = int(input())\n    num = list(map(int, input().split()))\n    locate(num, 0, n - 1, 0)\n    print(*num)\n    x -= 1", "import sys\nimport threading\n\ndef input():\n    return sys.stdin.readline().rstrip('\\r\\n')\n\nclass Node:\n\n    def __init__(self, val, left=None, right=None) -> None:\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        perms = list(map(int, input().split()))\n\n        def recur(left, right):\n            if left > right:\n                return None\n            max_idx = -1\n            max_val = 0\n            for idx in range(left, right + 1):\n                if perms[idx] > max_val:\n                    max_val = perms[idx]\n                    max_idx = idx\n            cur = Node(perms[max_idx])\n            cur.left = recur(left, max_idx - 1)\n            cur.right = recur(max_idx + 1, right)\n            return cur\n        depths = [0] * (n + 1)\n\n        def dfs(node, depth):\n            if not node:\n                return\n            depths[node.val] = depth\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n        root = recur(0, n - 1)\n        dfs(root, 0)\n        ans = [0] * n\n        for (idx, val) in enumerate(perms):\n            ans[idx] = depths[val]\n        print(*ans)\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = [0] * n\n    s = [(0, n, 0)]\n    while s:\n        (i_s, i_e, lv) = s.pop()\n        max_d = max(a[i_s:i_e])\n        max_i = a.index(max_d)\n        ans[max_i] = lv\n        if i_s < max_i:\n            s.append((i_s, max_i, lv + 1))\n        if max_i + 1 < i_e:\n            s.append((max_i + 1, i_e, lv + 1))\n    print(' '.join(map(str, ans)))", "def f(l, r, g):\n    if l > r:\n        return\n    maxx = l\n    for i in range(l + 1, r + 1):\n        if a[maxx] < a[i]:\n            maxx = i\n    d[maxx] = g\n    f(l, maxx - 1, g + 1)\n    f(maxx + 1, r, g + 1)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = [0] * n\n    f(0, n - 1, 0)\n    print(*d)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef make(arr, depths, d, indices):\n    if not arr:\n        return\n    index = arr.index(max(arr))\n    depths[indices[arr[index]]] = str(d)\n    make(arr[:index], depths, d + 1, indices)\n    make(arr[index + 1:], depths, d + 1, indices)\n\ndef solve(n, arr, ans):\n    depths = [0] * n\n    indices = {}\n    for i in range(n):\n        indices[arr[i]] = i\n    make(arr, depths, 0, indices)\n    ans.append(' '.join(depths))\n\ndef main():\n    t = int(input())\n    ans = []\n    for i in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        solve(n, arr, ans)\n    print('\\n'.join(ans))\nmain()", "from collections import defaultdict\nddict = defaultdict(int)\n\ndef rec(arr, deeps):\n    if len(arr) == 0:\n        return\n    if len(arr) == 1:\n        ddict[arr[0]] = deeps\n        return None\n    max_ind = arr.index(max(arr))\n    ddict[arr[max_ind]] = deeps\n    rec(arr[:max_ind], deeps + 1)\n    rec(arr[max_ind + 1:], deeps + 1)\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    if len(a) == 1:\n        return [0]\n    rec(a, 0)\n    return [ddict[elem] for elem in a]\nt = int(input())\nfor _ in range(t):\n    res = [str(x) for x in solve()]\n    print(' '.join(res))", "def myfunction(a, start, end, depth, d):\n    if start <= end:\n        ind = -1\n        m = 0\n        for i in range(start, end + 1):\n            if a[i] > m:\n                ind = i\n                m = a[i]\n        if ind != -1:\n            d[ind] = depth\n        myfunction(a, start, ind - 1, depth + 1, d)\n        myfunction(a, ind + 1, end, depth + 1, d)\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = [0] * n\n    myfunction(a, 0, n - 1, 0, d)\n    for i in d:\n        print(i, end=' ')\n    print('')", "def no_of_edges(A, n, levels, l, u, k):\n    if l <= u:\n        index = l\n        maxi = A[l]\n        for i in range(l, u + 1):\n            if A[i] > maxi:\n                maxi = A[i]\n                index = i\n        levels[index] = k\n        no_of_edges(A, n, levels, l, index - 1, k + 1)\n        no_of_edges(A, n, levels, index + 1, u, k + 1)\n    else:\n        return levels\n    return levels\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = [int(i) for i in input().split()]\n    levels = []\n    for i in range(n):\n        levels.append(0)\n    levels = no_of_edges(A, n, levels, 0, n - 1, 0)\n    for i in levels:\n        print(i, end=' ')\n    print()", "def dfs(d, a):\n    if len(a) == 1:\n        return [d]\n    elif len(a) == 0:\n        return []\n    i = a.index(max(a))\n    return dfs(d + 1, a[:i]) + [d] + dfs(d + 1, a[i + 1:])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    l = dfs(0, a)\n    print(*l, sep=' ')", "def f(d, i, j):\n    if i < j:\n        k = a.index(max(a[i:j]), i, j)\n        r[k] = d\n        d += 1\n        f(d, i, k)\n        f(d, k + 1, j)\nfor s in [*open(0)][2::2]:\n    a = (*map(int, s.split()),)\n    n = len(a)\n    r = [0] * n\n    f(0, 0, n)\n    print(*r)", "result = []\ncases = int(input())\ntempli = [0] * 100\n\ndef getSeq(li, dep, start, end):\n    if start >= end:\n        return\n    x = li.index(max(li[start:end]))\n    templi[x] = dep\n    if x > 0:\n        getSeq(li, dep + 1, start, x)\n    if x + 1 < len(li):\n        getSeq(li, dep + 1, x + 1, end)\nfor i in range(cases):\n    num = int(input())\n    ain = list(map(int, input().split(' ')))\n    getSeq(ain, 0, 0, len(ain))\n    result.append(' '.join((str(s) for s in templi[:len(ain)])))\n    templi = [0] * 100\nfor _ in result:\n    print(_)", "def arrIn():\n    return list(map(int, input().split()))\n\ndef mapIn():\n    return map(int, input().split())\n\ndef solve(l, arr, d):\n    if len(l) == 0:\n        return\n    if len(l) == 1:\n        arr[l[0]] = d\n    else:\n        m = max(l)\n        for i in range(len(l)):\n            if l[i] == m:\n                arr[m] = d\n                solve(l[:i], arr, d + 1)\n                solve(l[i + 1:], arr, d + 1)\n                break\nfor ii in range(int(input())):\n    n = int(input())\n    l = arrIn()\n    arr = [0] * (n + 1)\n    solve(l, arr, 0)\n    for i in range(n):\n        print(arr[l[i]], end=' ')\n    print()", "def solve(l, r, d, arr, depth, ans):\n    if l > r:\n        return\n    mx = max(arr[l:r + 1])\n    ind = d[mx]\n    ans[ind] = depth\n    solve(ind + 1, r, d, arr, depth + 1, ans)\n    solve(l, ind - 1, d, arr, depth + 1, ans)\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = dict()\n    for i in range(n):\n        d[arr[i]] = i\n    depth = 0\n    ans = [0 for i in range(n)]\n    ans = solve(0, n - 1, d, arr, depth, ans)\n    print(*ans)", "def deez(left, right, middle, c):\n    if left < middle or middle < right:\n        if left < middle:\n            t = l.index(max(l[left:middle]))\n            l1[t] = c\n            deez(left, middle, t, c + 1)\n        if middle + 1 < right:\n            k = l.index(max(l[middle + 1:right]))\n            l1[k] = c\n            deez(middle + 1, right, k, c + 1)\n    else:\n        return\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    l1 = [0] * n\n    w = l.index(max(l))\n    deez(0, n, w, 1)\n    print(*l1)", "def cal(a, left, right, memo, d=0):\n    if a[left:right] == []:\n        return\n    m = max(a[left:right])\n    memo[a.index(m)] = d\n    b = a.index(m)\n    cal(a, left, b, memo, d + 1)\n    cal(a, b + 1, right, memo, d + 1)\n    return\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    memo = [0 for _ in range(n)]\n    left = 0\n    right = n\n    cal(l, left, right, memo)\n    print(' '.join(map(str, memo)))", "def find_h(a, depth):\n    if not a:\n        return\n    max_item = max(a)\n    max_ind = a.index(max_item)\n    d[max_item] = depth\n    find_h(a[:max_ind], depth + 1)\n    find_h(a[max_ind + 1:], depth + 1)\nn = int(input())\nfor i in range(n):\n    l = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    find_h(a, 0)\n    for i in a:\n        print(d[i], end=' ')\n    print()", "import math\n\ndef bs(level, c, l, i, j):\n    if i < j:\n        m = -1000\n        ind = -1\n        x = i\n        y = j\n        for i in range(i, j):\n            if m < l[i]:\n                ind = i\n                m = l[i]\n        level[ind] = c\n        c += 1\n        bs(level, c, l, x, ind)\n        bs(level, c, l, ind + 1, y)\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    level = [0] * n\n    c = 0\n    bs(level, c, l, 0, n)\n    print(*level)", "t = int(input())\n\ndef helper(arr, start, end, memo, curr_depth):\n    if start > end:\n        return\n    val = -1\n    val_index = -1\n    for (index, value) in enumerate(arr[start:end + 1]):\n        if value > val:\n            val = value\n            val_index = index + start\n    memo[val_index] = curr_depth\n    helper(arr, start, val_index - 1, memo, curr_depth + 1)\n    helper(arr, val_index + 1, end, memo, curr_depth + 1)\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    memo = [0] * n\n    helper(arr, 0, n - 1, memo, 0)\n    print(*memo)", "def dfs(l, d, c):\n    if l:\n        m = max(l)\n        ind = l.index(m)\n        d[m] = c\n        d = dfs(l[:ind], d, c + 1)\n        d = dfs(l[ind + 1:], d, c + 1)\n    return d\nfor _ in range(int(input())):\n    n = int(input())\n    c = 0\n    l = list(map(int, input().split()))\n    ans = dfs(l, {}, 0)\n    res = []\n    for i in l:\n        res.append(ans[i])\n    print(*res)", "def build(l, r, depth):\n    mxid = max(range(l, r + 1), key=lambda a: ls[a])\n    if mxid > l:\n        build(l, mxid - 1, depth + 1)\n    if mxid < r:\n        build(mxid + 1, r, depth + 1)\n    d[mxid] = depth\nfor _ in range(int(input())):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    d = [0] * n\n    build(0, n - 1, 0)\n    print(' '.join(map(str, d)))", "def helper(a, level=0, d={}):\n    if a:\n        maxi = max(a)\n        i = a.index(maxi)\n        d[maxi] = level\n        helper(a[:i], level + 1, d)\n        helper(a[i + 1:], level + 1, d)\n    return d\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = helper(a, 0, {})\n    for i in a:\n        print(d[i], end=' ')\n    print(end='\\n')", "for _ in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    output = [0] * len(lis)\n\n    def recurse(low, high, d):\n        max1 = -float('Inf')\n        index = -1\n        if low > high:\n            return\n        for i in range(low, high + 1):\n            if lis[i] > max1:\n                max1 = lis[i]\n                index = i\n        output[index] = d\n        recurse(low, index - 1, d + 1)\n        recurse(index + 1, high, d + 1)\n    recurse(0, len(lis) - 1, 0)\n    for i in output:\n        print(i, end=' ')\n    print()", "def tree(arr, d):\n    if not arr:\n        return\n    m = max(arr)\n    mi = arr.index(m)\n    ans[m] = d\n    tree(arr[:mi], d + 1)\n    tree(arr[mi + 1:], d + 1)\nfor case in range(int(input())):\n    ans = {}\n    n = int(input())\n    arr = [int(i) for i in input().split(' ')]\n    tree(arr, 0)\n    for i in arr:\n        print(ans[i], end=' ')\n    print()", "def max_index(a, l, r):\n    idx = l\n    mx = a[l]\n    for i in range(l, r + 1):\n        if a[i] > mx:\n            idx = i\n            mx = a[i]\n    return idx\n\nclass Node:\n\n    def __init__(self, data=None, left=None, right=None, depth=-1):\n        self.left = left\n        self.right = right\n        self.data = data\n        self.depth = depth\n\ndef create_perm_tree(a, l, r, d, node_map):\n    if r - l < 0 or len(node_map) == len(a):\n        return None\n    mx_i = max_index(a, l, r)\n    nd = Node()\n    nd.data = a[mx_i]\n    nd.depth = d\n    create_perm_tree(a, l, mx_i - 1, d + 1, node_map)\n    create_perm_tree(a, mx_i + 1, r, d + 1, node_map)\n    node_map[mx_i] = nd.depth\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    node_map = {}\n    create_perm_tree(a, 0, n - 1, 0, node_map)\n    res = []\n    for i in range(n):\n        res.append(node_map[i])\n    print(' '.join((str(r) for r in res)))"]