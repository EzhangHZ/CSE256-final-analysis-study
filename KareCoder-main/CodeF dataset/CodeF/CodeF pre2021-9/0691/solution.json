["import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nMOD = 10 ** 9 + 7\n\ndef solve():\n    S = input().rstrip()\n    d = {i: v for (v, i) in enumerate(S)}\n    res = []\n    seen = set()\n    for (i, s) in enumerate(S):\n        if s not in seen:\n            while res and s > res[-1] and (d[res[-1]] > i):\n                seen.discard(res.pop())\n            res.append(s)\n            seen.add(s)\n    print(''.join(res))\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport collections\nfrom copy import copy, deepcopy\nfrom typing import OrderedDict\n\nclass Solution:\n\n    def trim(self):\n        return input()\n\n    def rInt(self):\n        return int(self.trim())\n\n    def rStr(self):\n        return str(self.trim())\n\n    def rCharList(self):\n        s = self.trim()\n        return list(s[:len(s) - 1])\n\n    def rIntMap(self):\n        return map(int, self.trim().split())\n\n    def rIntList(self):\n        return list(self.rIntMap())\n\n    def rStrList(self):\n        return list(map(str, self.trim().split()))\n\n    def process(self, case, S):\n        (s, visited) = ([], set())\n        n = len(S)\n        last = {v: i for (i, v) in enumerate(S)}\n        left = 1\n        for i in range(n):\n            if S[i] not in visited:\n                while s and i < last[s[-1]] and (s[-1] < S[i]):\n                    visited.discard(s.pop())\n                if left:\n                    s.append(S[i])\n                left += 1\n                visited.add(S[i])\n        print(''.join(s))\n\ndef main():\n    s = Solution()\n    tc = s.rInt()\n    for i in range(tc):\n        S = s.rStr()\n        s.process(i + 1, S)\nmain()", "import sys\nimport collections\nfrom copy import copy, deepcopy\nfrom typing import OrderedDict\n\nclass Solution:\n\n    def trim(self):\n        return input()\n\n    def rInt(self):\n        return int(self.trim())\n\n    def rStr(self):\n        return str(self.trim())\n\n    def rCharList(self):\n        s = self.trim()\n        return list(s[:len(s) - 1])\n\n    def rIntMap(self):\n        return map(int, self.trim().split())\n\n    def rIntList(self):\n        return list(self.rIntMap())\n\n    def rStrList(self):\n        return list(map(str, self.trim().split()))\n\n    def process(self, case, S):\n        (s, visited) = ([], set())\n        n = len(S)\n        last = {v: i for (i, v) in enumerate(S)}\n        left = 1\n        for i in range(n):\n            if S[i] not in visited:\n                while s and i < last[s[-1]] and (s[-1] < S[i]):\n                    visited.discard(s.pop())\n                if left:\n                    s.append(S[i])\n                left += 1\n                visited.add(S[i])\n        print(''.join(s))\n\ndef main():\n    s = Solution()\n    tc = s.rInt()\n    for i in range(tc):\n        S = s.rStr()\n        s.process(i + 1, S)\nmain()", "n = int(input())\nfor _ in range(n):\n    s = input()\n    stack = []\n    seen = set()\n    last_occurrence = {c: i for (i, c) in enumerate(s)}\n    for (i, c) in enumerate(s):\n        if c not in seen:\n            while stack and c > stack[-1] and (i < last_occurrence[stack[-1]]):\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    stack = []\n    seen = set()\n    last_occurrence = {c: i for (i, c) in enumerate(s)}\n    for (i, c) in enumerate(s):\n        if c not in seen:\n            while stack and c > stack[-1] and (i < last_occurrence[stack[-1]]):\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    d = {i: v for (v, i) in enumerate(s)}\n    stack = []\n    seen = set()\n    for i in range(n):\n        if s[i] not in seen:\n            while stack and s[i] > stack[-1] and (d[stack[-1]] > i):\n                seen.discard(stack.pop())\n            stack.append(s[i])\n            seen.add(s[i])\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    l = len(s)\n    stack = []\n    d = {i: v for (v, i) in enumerate(s)}\n    st = set()\n    for i in range(l):\n        if s[i] not in st:\n            while stack and s[i] > stack[-1] and (d[stack[-1]] > i):\n                st.discard(stack.pop())\n            stack.append(s[i])\n            st.add(s[i])\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    d = {i: v for (v, i) in enumerate(s)}\n    stack = []\n    seen = set()\n    for i in range(n):\n        if s[i] not in seen:\n            while stack and s[i] > stack[-1] and (d[stack[-1]] > i):\n                seen.discard(stack.pop())\n            stack.append(s[i])\n            seen.add(s[i])\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    d = {i: v for (v, i) in enumerate(s)}\n    stack = []\n    seen = set()\n    for i in range(n):\n        if s[i] not in seen:\n            while stack and s[i] > stack[-1] and (d[stack[-1]] > i):\n                seen.discard(stack.pop())\n            stack.append(s[i])\n            seen.add(s[i])\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    d = {i: v for (v, i) in enumerate(s)}\n    stack = []\n    seen = set()\n    for i in range(n):\n        if s[i] not in seen:\n            while stack and s[i] > stack[-1] and (d[stack[-1]] > i):\n                seen.discard(stack.pop())\n            stack.append(s[i])\n            seen.add(s[i])\n    print(''.join(stack))", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    d = {i: v for (v, i) in enumerate(s)}\n    stack = []\n    seen = set()\n    for i in range(n):\n        if s[i] not in seen:\n            while stack and s[i] > stack[-1] and (d[stack[-1]] > i):\n                seen.discard(stack.pop())\n            stack.append(s[i])\n            seen.add(s[i])\n    print(''.join(stack))", "from collections import Counter\nfor _ in range(int(input())):\n    s = input()\n    f = Counter(s)\n    st = []\n    onst = set()\n    for (i, c) in enumerate(s):\n        f[c] -= 1\n        if c in onst:\n            continue\n        while st and c > st[-1] and f[st[-1]]:\n            onst.remove(st.pop())\n        st.append(c)\n        onst.add(c)\n    print(''.join(st))", "from collections import Counter\nfor _ in range(int(input())):\n    s = input()\n    f = Counter(s)\n    st = []\n    onst = set()\n    for (i, c) in enumerate(s):\n        f[c] -= 1\n        if c in onst:\n            continue\n        while st and c > st[-1] and f[st[-1]]:\n            onst.remove(st.pop())\n        st.append(c)\n        onst.add(c)\n    print(''.join(st))", "from collections import Counter\nfor _ in range(int(input())):\n    s = input()\n    f = Counter(s)\n    st = []\n    onst = set()\n    for (i, c) in enumerate(s):\n        f[c] -= 1\n        if c in onst:\n            continue\n        while st and c > st[-1] and f[st[-1]]:\n            onst.remove(st.pop())\n        st.append(c)\n        onst.add(c)\n    print(''.join(st))", "from collections import Counter\nfor _ in range(int(input())):\n    s = input()\n    f = Counter(s)\n    st = []\n    onst = set()\n    for (i, c) in enumerate(s):\n        f[c] -= 1\n        if c in onst:\n            continue\n        while st and c > st[-1] and f[st[-1]]:\n            onst.remove(st.pop())\n        st.append(c)\n        onst.add(c)\n    print(''.join(st))", "from collections import Counter\nn = int(input())\nfor i in range(n):\n    s = input()\n    f = Counter(s)\n    stack = []\n    seen = set()\n    for i in s:\n        f[i] -= 1\n        if i in stack:\n            continue\n        while stack and stack[-1] < i and (f[stack[-1]] != 0):\n            stack.pop()\n        stack.append(i)\n        seen.add(i)\n    print(''.join(stack))", "from typing import Set, Deque, Dict, List, Tuple, Any, OrderedDict, DefaultDict\nimport math\nfrom functools import total_ordering\nfrom queue import deque, PriorityQueue\nfrom collections import OrderedDict as Map\n\n@total_ordering\nclass MyComparer(object):\n\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\n    def __lt__(self, other):\n        if self.first == other.first:\n            return self.second > other.second\n        return self.first > other.first\n\nclass Problem(object):\n\n    def removeDuplicateLetters(self, s):\n        cnt = [0] * 26\n        vis = [0] * 26\n        n = len(s)\n        for i in s:\n            cnt[ord(i) - ord('a')] += 1\n        res = []\n        for i in range(n):\n            cnt[ord(s[i]) - ord('a')] -= 1\n            if not vis[ord(s[i]) - ord('a')]:\n                while len(res) > 0 and res[-1] < s[i] and (cnt[ord(res[-1]) - ord('a')] > 0):\n                    vis[ord(res[-1]) - ord('a')] = 0\n                    del res[-1]\n                res += s[i]\n                vis[ord(s[i]) - ord('a')] = 1\n        return ''.join(res)\n\n    def solve(self):\n        s = input()\n        out = self.removeDuplicateLetters(s)\n        print(out)\ntc = 1\ntc = int(input())\nfor _ in range(tc):\n    problem = Problem()\n    problem.solve()", "t = int(input())\nfor _ in range(t):\n    list_s = input()\n    lastPositions = {c: pos for (pos, c) in enumerate(list_s)}\n    assigned = {c: False for c in lastPositions}\n    new_string = []\n    for (pos, c) in enumerate(list_s):\n        if len(new_string) == len(assigned):\n            break\n        if not assigned[c]:\n            i = len(new_string) - 1\n            while i >= 0 and new_string[i] < c and (pos < lastPositions[new_string[i]]):\n                assigned[new_string[i]] = False\n                i -= 1\n            new_string = new_string[:i + 1]\n            new_string.append(c)\n            assigned[c] = True\n    print(''.join(new_string))", "for _ in range(int(input())):\n    stroke = input()\n    arr = {b: a for (a, b) in enumerate(stroke)}\n    tec = []\n    tecs = set()\n    for (num, j) in enumerate(stroke):\n        if j not in tecs:\n            while len(tec) != 0 and tec[-1] < j and (num < arr[tec[-1]]):\n                tecs.discard(tec.pop())\n            tec.append(j)\n            tecs.add(j)\n    print(*tec, sep='')", "t = int(input())\nfor j in range(t):\n    s = input()\n    n = len(s)\n    d = {}\n    for i in range(n):\n        d[s[i]] = i\n    ans = []\n    st = set()\n    for i in range(n):\n        if s[i] not in st:\n            while ans and s[i] > ans[-1] and (d[ans[-1]] > i):\n                st.remove(ans.pop())\n            ans.append(s[i])\n            st.add(s[i])\n    print(*ans, sep='')", "for _ in range(int(input())):\n    ans = ''\n    s = input()\n    occ = {}\n    for c in s:\n        if c not in occ:\n            occ[c] = 0\n        occ[c] += 1\n    remove = set()\n    prev_i = -1\n    for i in range(len(s)):\n        occ[s[i]] -= 1\n        if s[i] in remove:\n            continue\n        if prev_i == -1 or s[i] > s[prev_i]:\n            prev_i = i\n        if occ[s[i]] == 0:\n            order = sorted(set(s[prev_i:i]), reverse=True)\n            order_i = 0\n            for j in range(prev_i, i):\n                while order_i < len(order) and order[order_i] in remove:\n                    order_i += 1\n                if order_i < len(order) and order[order_i] == s[j] and (s[j] >= s[i]) and (s[j] not in remove):\n                    ans += s[j]\n                    remove.add(s[j])\n                    prev_i = j\n                    order = sorted(set(s[prev_i:i]), reverse=True)\n                    order_i = 0\n            if s[i] not in remove:\n                ans += s[i]\n                remove.add(s[i])\n                prev_i = i\n    print(ans)", "from queue import PriorityQueue\ncas = int(input())\nwhile cas:\n    cas -= 1\n    a = input()\n    cnt = [0 for i in range(26)]\n    vis = [0 for i in range(26)]\n    for i in range(len(a)):\n        c = ord(a[i]) - ord('a')\n        cnt[c] += 1\n    st = [30]\n    s = 0\n    for i in range(len(a)):\n        tmp = ord(a[i]) - ord('a')\n        if vis[tmp] == 0:\n            while s and st[s] < tmp and (cnt[st[s]] >= 1):\n                vis[st[s]] = 0\n                st.pop(s)\n                s -= 1\n            st.append(tmp)\n            s += 1\n            vis[tmp] = 1\n        cnt[tmp] -= 1\n    for i in range(1, len(st)):\n        c = chr(ord('a') + st[i])\n        if i == len(st) - 1:\n            print(c)\n        else:\n            print(c, end='')", "def count(s, remove=None):\n    c = dict()\n    y = ''\n    o = ''\n    for x in s:\n        if x == y or x == remove:\n            continue\n        if x not in c:\n            c[x] = 0\n        c[x] += 1\n        o += x\n        y = x\n    return (o, c)\n\ndef one(s):\n    ptr = 0\n    best = ''\n    (s, c) = count(s)\n    while True:\n        leader = ''\n        i = 0\n        while i < len(s):\n            x = s[i]\n            if x in best:\n                i += 1\n                continue\n            c[x] -= 1\n            if x > leader:\n                leader = x\n                li = i\n            if c[x] == 0:\n                break\n            i += 1\n        best += leader\n        ptr = li + 1\n        if ptr > len(s):\n            break\n        (s, c) = count(s[li + 1:], leader)\n    return best\nfor _ in range(int(input())):\n    s = input()\n    r = one(s)\n    print(f'{r}')", "for i in range(int(input())):\n    s = input()\n    if len(set(s[0:])) != len(s):\n        n = len(set(s[0:]))\n        abc = sorted(set(s[0:]))\n        while s:\n            DEL = ''\n            for j in range(len(abc) - 1, -1, -1):\n                if len(set(s[s.index(abc[j]):])) == n:\n                    DEL = abc[j]\n                    break\n            print(DEL, end='')\n            s = s[s.index(DEL) + 1:].replace(DEL, '')\n            n -= 1\n            abc.pop(abc.index(DEL))\n        print()\n    else:\n        print(s)", "for i in range(int(input())):\n    s = input()\n    if len(set(s[0:])) != len(s):\n        S = set(s[0:])\n        abc = sorted(set(s[0:]))\n        while s:\n            DEL = ''\n            for j in range(len(abc) - 1, -1, -1):\n                if len(set(s[s.index(abc[j]):])) == len(S):\n                    DEL = abc[j]\n                    break\n            print(DEL, end='')\n            s = s[s.index(DEL) + 1:]\n            s = s.replace(DEL, '')\n            S.pop()\n            abc.pop(abc.index(DEL))\n        print()\n    else:\n        print(s)", "for i in range(int(input())):\n    s = input()\n    if len(set(s[0:])) != len(s):\n        n = len(set(s[0:]))\n        a = sorted(set(s[0:]))\n        while s:\n            DEL = ''\n            for j in range(len(a) - 1, -1, -1):\n                if len(set(s[s.index(a[j]):])) == n:\n                    DEL = a[j]\n                    break\n            print(DEL, end='')\n            s = s[s.index(DEL) + 1:]\n            s = s.replace(DEL, '')\n            n -= 1\n            a.pop(a.index(DEL))\n        print()\n    else:\n        print(s)", "for i in range(int(input())):\n    s = input()\n    if len(set(s[0:])) != len(s):\n        n = len(set(s[0:]))\n        abc = sorted(set(s[0:]))\n        while s:\n            DEL = ''\n            for j in range(len(abc) - 1, -1, -1):\n                if len(set(s[s.index(abc[j]):])) == n:\n                    DEL = abc[j]\n                    break\n            print(DEL, end='')\n            s = s[s.index(DEL) + 1:]\n            s = s.replace(DEL, '')\n            n -= 1\n            abc.pop(abc.index(DEL))\n        print()\n    else:\n        print(s)", "def CountAparicions(s):\n    repeatedChars = {}\n    for i in range(len(s)):\n        char = s[i]\n        if char in repeatedChars:\n            repeatedChars[char] += 1\n        else:\n            repeatedChars[char] = 1\n    return repeatedChars\n\ndef MaxSubStr(word, NewWord=''):\n    if word == '':\n        return NewWord\n    possibleLetters = []\n    numberOfAparicions = {}\n    counted = CountAparicions(word)\n    for letter in word:\n        if letter in possibleLetters:\n            numberOfAparicions[letter] += 1\n            if numberOfAparicions[letter] == counted[letter]:\n                break\n        else:\n            numberOfAparicions[letter] = 1\n        possibleLetters.append(letter)\n        if counted[letter] == 1:\n            break\n    del numberOfAparicions\n    NewLetter = max(possibleLetters)\n    NewLetterIndex = word.find(NewLetter)\n    word = word[NewLetterIndex + 1:]\n    NewWord += NewLetter\n    word = word.replace(NewLetter, '')\n    return MaxSubStr(word, NewWord)\nnumberIterations = int(input())\ni = 0\nwhile i < numberIterations:\n    s = input()\n    s = ''.join((e for e in s if e.isalpha()))\n    if s == '':\n        continue\n    s1 = MaxSubStr(s)\n    print(s1)\n    i += 1", "for i in range(int(input())):\n    s = input()\n    if len(set(s[0:])) != len(s):\n        while s:\n            DEL = ''\n            S = set(s[0:])\n            abc = sorted(set(s[0:]))\n            for j in range(len(abc) - 1, -1, -1):\n                if len(set(s[s.index(abc[j]):])) == len(S):\n                    DEL = abc[j]\n                    break\n            print(DEL, end='')\n            s = s[s.index(DEL) + 1:]\n            s = s.replace(DEL, '')\n        print()\n    else:\n        print(s)", "def solve():\n    s = input()\n    exists = [[]] * 26\n    for i in range(len(s) - 1, -1, -1):\n        ch = ord(s[i]) - ord('a')\n        if exists[ch]:\n            exists[ch].append(i)\n        else:\n            exists[ch] = [i]\n    start = 0\n    while True:\n        something_happened = False\n        for use in range(25, -1, -1):\n            if not exists[use]:\n                continue\n            where = exists[use][-1]\n            suitable = True\n            for occur in exists:\n                if occur and occur[0] < where:\n                    suitable = False\n                    break\n            if suitable:\n                print(s[where], end='')\n                exists[use] = []\n                start = where + 1\n                for c in range(26):\n                    while exists[c] and exists[c][-1] < start:\n                        exists[c].pop()\n                something_happened = True\n                break\n        if not something_happened:\n            break\n    print()\n\ndef main():\n    t = int(input())\n    while t:\n        solve()\n        t -= 1\nmain()", "t = int(input())\nfor k in range(t):\n    a = input()\n    b = list(a)\n    new = []\n    povt = {}\n    for i in b:\n        if i in povt.keys():\n            povt[i] += 1\n        else:\n            povt[i] = 1\n    i = 0\n    while i < len(b) - 1:\n        if b[i] in b[:i]:\n            povt[b[i]] -= 1\n            b.pop(i)\n            if i < 0:\n                i -= 1\n        elif povt[b[i]] > 1:\n            if b[i + 1] in b[:i + 1]:\n                povt[b[i + 1]] -= 1\n                b.pop(i + 1)\n            elif ord(b[i + 1]) >= ord(b[i]):\n                povt[b[i]] -= 1\n                b.pop(i)\n                if i > 0:\n                    i -= 1\n                continue\n            elif ord(b[i + 1]) < ord(b[i]):\n                i += 1\n        else:\n            i += 1\n    if povt[b[-1]] > 1:\n        b.pop(-1)\n    print(*b, sep='')"]