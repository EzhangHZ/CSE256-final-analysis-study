["import threading\nimport sys\n(*data,) = map(int, sys.stdin.read().split()[::-1])\n\ndef inp():\n    return data.pop()\nmodulo = 10 ** 9 + 7\n\ndef dfssize(g, v, par, size, edges):\n    for ch in g[v]:\n        if ch != par:\n            dfssize(g, ch, v, size, edges)\n            size[v] += size[ch]\n            edges.append(size[ch] * (len(g) - size[ch]))\n    size[v] += 1\n\ndef mult(vals):\n    ans = 1\n    for v in vals:\n        ans = ans * v % modulo\n    return ans\n\ndef solve(g, kp):\n    size = [0] * len(g)\n    kp.sort()\n    edges = []\n    dfssize(g, 0, par=-1, size=size, edges=edges)\n    n = len(g)\n    if len(kp) > n - 1:\n        kp[n - 2:] = [mult(kp[n - 2:])]\n    while len(kp) < n - 1:\n        kp = [1] * (n - 1 - len(kp)) + kp\n    ans = 0\n    edges.sort(reverse=True)\n    kp = kp[::-1]\n    for (a, b) in zip(edges, kp):\n        ans += a * b\n        ans %= modulo\n    return ans\nthreading.stack_size(2 ** 27)\nsys.setrecursionlimit(10 ** 5 + 100)\n\ndef main():\n    for _ in range(int(inp())):\n        n = int(inp())\n        g = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (src, dst) = (inp(), inp())\n            src -= 1\n            dst -= 1\n            g[src].append(dst)\n            g[dst].append(src)\n        m = int(inp())\n        (*kp,) = [inp() for _ in range(m)]\n        print(solve(g, kp))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, threading\n\ndef rl():\n    return [int(w) for w in sys.stdin.readline().split()]\nMOD = 1000000007\n\ndef main():\n\n    def walk(u, v):\n        s = 1\n        for i in adj[v]:\n            if i != u:\n                c = walk(v, i)\n                w.append(c * (n - c))\n                s += c\n        return s\n    for _ in range(rl()[0]):\n        (n,) = rl()\n        adj = [[] for _ in range(n + 1)]\n        for i in range(1, n):\n            (u, v) = rl()\n            adj[u].append(v)\n            adj[v].append(u)\n        (m,) = rl()\n        p = rl()\n        while len(p) < n - 1:\n            p.append(1)\n        p.sort()\n        w = []\n        walk(0, 1)\n        w.sort()\n        r = 0\n        for i in range(n - 2):\n            r = (r + w[i] * p[i]) % MOD\n        l = w[n - 2]\n        for i in range(n - 2, max(m, n - 1)):\n            l = l * p[i] % MOD\n        r = (r + l) % MOD\n        print(r)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, threading\n\ndef rl():\n    return [int(w) for w in sys.stdin.readline().split()]\nMOD = 1000000007\n\ndef main():\n\n    def walk(u, v):\n        s = 1\n        for i in adj[v]:\n            if i != u:\n                c = walk(v, i)\n                w.append(c * (n - c))\n                s += c\n        return s\n    for _ in range(rl()[0]):\n        (n,) = rl()\n        adj = [[] for _ in range(n + 1)]\n        for i in range(1, n):\n            (u, v) = rl()\n            adj[u].append(v)\n            adj[v].append(u)\n        (m,) = rl()\n        p = rl()\n        while len(p) < n - 1:\n            p.append(1)\n        p.sort()\n        w = []\n        walk(0, 1)\n        w.sort()\n        r = 0\n        for i in range(n - 2):\n            r = (r + w[i] * p[i]) % MOD\n        l = w[n - 2]\n        for i in range(n - 2, max(m, n - 1)):\n            l = l * p[i] % MOD\n        r = (r + l) % MOD\n        print(r)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading, sys\n(*data,) = map(int, sys.stdin.read().split()[::-1])\n\ndef inp():\n    return data.pop()\nmodulo = 10 ** 9 + 7\n\ndef dfssize(g, v, par, size, edges):\n    for ch in g[v]:\n        if ch != par:\n            dfssize(g, ch, v, size, edges)\n            size[v] += size[ch]\n            edges.append(size[ch] * (len(g) - size[ch]))\n    size[v] += 1\n\ndef mult(vals):\n    ans = 1\n    for v in vals:\n        ans = ans * v % modulo\n    return ans\n\ndef solve(g, kp):\n    size = [0] * len(g)\n    kp.sort()\n    edges = []\n    dfssize(g, 0, par=-1, size=size, edges=edges)\n    n = len(g)\n    if len(kp) > n - 1:\n        kp[n - 2:] = [mult(kp[n - 2:])]\n    while len(kp) < n - 1:\n        kp = [1] * (n - 1 - len(kp)) + kp\n    ans = 0\n    edges.sort(reverse=True)\n    kp = kp[::-1]\n    for (a, b) in zip(edges, kp):\n        ans += a * b\n        ans %= modulo\n    return ans\nthreading.stack_size(2 ** 27)\nsys.setrecursionlimit(10 ** 5 + 100)\n\ndef main():\n    for _ in range(int(inp())):\n        n = int(inp())\n        g = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (src, dst) = (inp(), inp())\n            src -= 1\n            dst -= 1\n            g[src].append(dst)\n            g[dst].append(src)\n        m = int(inp())\n        (*kp,) = [inp() for _ in range(m)]\n        print(solve(g, kp))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading, sys\n(*data,) = map(int, sys.stdin.read().split()[::-1])\nmodulo = 10 ** 9 + 7\n\ndef inp():\n    return data.pop()\n\ndef dfssize(g, v, par, size, edges):\n    for ch in g[v]:\n        if ch != par:\n            dfssize(g, ch, v, size, edges)\n            size[v] += size[ch]\n            edges.append(size[ch] * (len(g) - size[ch]))\n    size[v] += 1\n\ndef mult(vals):\n    ans = 1\n    for v in vals:\n        ans = ans * v % modulo\n    return ans\n\ndef solve(g, kp):\n    size = [0] * len(g)\n    kp.sort()\n    edges = []\n    dfssize(g, 0, par=-1, size=size, edges=edges)\n    n = len(g)\n    if len(kp) > n - 1:\n        kp[n - 2:] = [mult(kp[n - 2:])]\n    while len(kp) < n - 1:\n        kp = [1] * (n - 1 - len(kp)) + kp\n    ans = 0\n    edges.sort(reverse=True)\n    kp = kp[::-1]\n    for (a, b) in zip(edges, kp):\n        ans += a * b\n        ans %= modulo\n    return ans\nthreading.stack_size(2 ** 27)\nsys.setrecursionlimit(10 ** 5 + 100)\n\ndef main():\n    for _ in range(int(inp())):\n        n = int(inp())\n        g = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (src, dst) = (inp(), inp())\n            src -= 1\n            dst -= 1\n            g[src].append(dst)\n            g[dst].append(src)\n        m = int(inp())\n        (*kp,) = [inp() for _ in range(m)]\n        print(solve(g, kp))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, threading\n\ndef rl():\n    return [int(w) for w in sys.stdin.readline().split()]\nMOD = 1000000007\n\ndef main():\n\n    def walk(u, v):\n        s = 1\n        for i in adj[v]:\n            if i != u:\n                c = walk(v, i)\n                w.append(c * (n - c))\n                s += c\n        return s\n    for _ in range(rl()[0]):\n        (n,) = rl()\n        adj = [[] for _ in range(n + 1)]\n        for i in range(1, n):\n            (u, v) = rl()\n            adj[u].append(v)\n            adj[v].append(u)\n        (m,) = rl()\n        p = rl()\n        while len(p) < n - 1:\n            p.append(1)\n        p.sort()\n        w = []\n        walk(0, 1)\n        w.sort()\n        r = 0\n        for i in range(n - 2):\n            r = (r + w[i] * p[i]) % MOD\n        l = w[n - 2]\n        for i in range(n - 2, max(m, n - 1)):\n            l = l * p[i] % MOD\n        r = (r + l) % MOD\n        print(r)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\nmod = 1000000007\n\ndef main():\n\n    def dfs(p, cn, n):\n        sz = 1\n        for nn in g[cn]:\n            if nn != p:\n                x = dfs(cn, nn, n)\n                pq.append(x * (n - x))\n                sz += x\n        return sz\n    for test in range(int(input())):\n        n = int(input())\n        g = defaultdict(list)\n        for _ in range(1, n):\n            (u, v) = map(int, input().split())\n            g[u].append(v)\n            g[v].append(u)\n        m = int(input())\n        p = list(map(int, input().split()))\n        while len(p) < n - 1:\n            p.append(1)\n        p.sort()\n        pq = []\n        dfs(-1, 1, n)\n        pq.sort()\n        res = 0\n        for i in range(n - 2):\n            res = (res + pq[i] * p[i]) % mod\n        l = pq[n - 2]\n        for i in range(n - 2, max(m, n - 1)):\n            l = l * p[i] % mod\n        res = (res + l) % mod\n        print(res)\nthreading.Thread(target=main).start()", "import sys, threading\n\ndef main():\n\n    def dfs(ver):\n        if v[ver] == 1:\n            return 0\n        else:\n            v[ver] = 1\n            res = 1\n            for w in adj[ver]:\n                if v[w] == 0:\n                    res += dfs(w)\n            if ver != 1:\n                ans.append(res * (n - res))\n            return res\n    re = 10 ** 9 + 7\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        adj = [[] for j in range(n + 1)]\n        for j in range(n - 1):\n            (u, v) = map(int, input().split())\n            adj[u].append(v)\n            adj[v].append(u)\n        m = int(input())\n        p = list(map(int, input().split()))\n        p.sort()\n        v = [0] * (n + 1)\n        ans = []\n        dfs(1)\n        ans.sort()\n        s = 0\n        if n - 1 >= m:\n            p.reverse()\n            ans.reverse()\n            j = 0\n            while j < m:\n                s = (s + ans[j] * p[j]) % re\n                j += 1\n            while j < n - 1:\n                s = (s + ans[j]) % re\n                j += 1\n        else:\n            z = m - 1\n            q = 1\n            while z >= n - 2:\n                q = p[z] * q % re\n                z += -1\n            s = (s + q * ans[-1]) % re\n            j = n - 3\n            while j >= 0:\n                s = (s + ans[j] * p[j]) % re\n                j += -1\n        print(s % re)\nsys.setrecursionlimit(2 * 10 ** 5)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "import sys, threading\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict as dft\n\ndef main():\n\n    def dfs(nd):\n        vis[nd] = 1\n        d = 1\n        for lnk in dct[nd]:\n            if vis[lnk] == 0:\n                num = dfs(lnk)\n                d += num\n        w.append(d * (n - d))\n        return d\n    mxn = 10 ** 9 + 7\n    for _ in range(int(input())):\n        n = int(input())\n        w = []\n        dct = dft(list)\n        for i in range(n - 1):\n            (a, b) = map(int, input().split())\n            dct[a].append(b)\n            dct[b].append(a)\n        m = int(input())\n        fac = list(map(int, input().split()))\n        fac.sort()\n        for xx in range(m - n + 1):\n            if not fac:\n                break\n            temp = fac.pop()\n            fac[-1] = fac[-1] * temp % mxn\n            m -= 1\n        res = 0\n        vis = [0] * (n + 1)\n        dfs(1)\n        w.sort(reverse=True)\n        for num in w:\n            if not fac:\n                temp = 1\n            else:\n                temp = fac.pop()\n            res = (num * temp + res) % mxn\n        print(res)\nsys.setrecursionlimit(5 * 10 ** 5)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "import sys, threading\n\ndef dfs(curr, prev):\n    sz[curr] = 1\n    for i in graph[curr]:\n        if i != prev:\n            dfs(i, curr)\n            sz[curr] += sz[i]\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        global graph\n        graph = [[] for i in range(n)]\n        for i in range(n - 1):\n            (uu, vv) = [int(i) - 1 for i in input().split()]\n            graph[uu].append(vv)\n            graph[vv].append(uu)\n        m = int(input())\n        p = [int(i) for i in input().split()]\n        p.sort()\n        global sz\n        sz = [0] * n\n        dfs(0, 0)\n        c = []\n        mod = 10 ** 9 + 7\n        for i in sz[1:]:\n            c.append(i * (n - i))\n        c.sort()\n        ans = 0\n        while len(p) > len(c):\n            temp = p.pop()\n            p[-1] *= temp\n            p[-1] %= mod\n        for i in range(n - 2, -1, -1):\n            if len(p) > 0:\n                ans += p.pop() * c.pop()\n                ans %= mod\n            else:\n                ans += c.pop()\n                ans %= mod\n        print(ans)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport collections as cc\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\nmod = 10 ** 9 + 7\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nfor tc in range(int(input())):\n    (n,) = I()\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = I()\n        g[x].append(y)\n        g[y].append(x)\n    (m,) = I()\n    l = sorted(I())\n    if m < n - 1:\n        l = [1] * (n - 1 - m) + l\n    else:\n        temp = 1\n        for j in range(m - n + 1):\n            temp = temp * l[-j - 1] % mod\n        l[n - 2] = l[n - 2] * temp % mod\n    odr = []\n    st = [1]\n    visi = [0] * (n + 1)\n    visi[1] = 1\n    par = [-1] * (n + 1)\n    while st:\n        x = st.pop()\n        odr.append(x)\n        for to in g[x]:\n            if visi[to] == 0:\n                st.append(to)\n                par[to] = x\n                visi[to] = 1\n    tem = [1] * (n + 1)\n    te = []\n    for x in odr[1:][::-1]:\n        te.append(tem[x] * (n - tem[x]))\n        tem[par[x]] += tem[x]\n    te.sort()\n    ans = 0\n    for i in range(n - 1):\n        ans = (ans + te[i] * l[i]) % mod\n    print(ans)", "import sys, threading\n\ndef main():\n\n    def dfs(vertex, sizes, graph, parent):\n        for u in graph[vertex]:\n            if u != parent:\n                sizes[vertex] += dfs(u, sizes, graph, vertex)\n        return sizes[vertex]\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        e = []\n        for j in range(n - 1):\n            (u, v) = map(int, input().split())\n            u -= 1\n            v -= 1\n            e.append((u, v))\n        g = [[] for j in range(n)]\n        for f in e:\n            g[f[0]].append(f[1])\n            g[f[1]].append(f[0])\n        m = int(input())\n        pr = list(map(int, input().split()))\n        if m > n - 1:\n            pr.sort()\n            while len(pr) > n - 1:\n                pr[-2] *= pr[-1]\n                pr.pop()\n                pr[-1] %= 1000000007\n        else:\n            while len(pr) < n - 1:\n                pr.append(1)\n            pr.sort()\n        l = [1 for j in range(n)]\n        dfs(0, l, g, -1)\n        l.pop(0)\n        for j in range(n - 1):\n            l[j] = l[j] * (n - l[j])\n        l.sort()\n        s = 0\n        for j in range(n - 1):\n            s += pr[j] * l[j]\n            s %= 1000000007\n        print(s)\nsys.setrecursionlimit(5 * 10 ** 5)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "from collections import defaultdict\nmod = 10 ** 9 + 7\n\ndef dfs(node):\n    ch = defaultdict(lambda : 1)\n    stack = [node]\n    visited = [0 for i in range(n + 1)]\n    visited[node] = 1\n    for i in stack:\n        for j in tree[i]:\n            if not visited[j]:\n                visited[j] = i\n                stack.append(j)\n    while len(stack) > 1:\n        nxt = stack.pop()\n        ch[visited[nxt]] += ch[nxt]\n    return sorted(ch.values())\nfor _ in range(int(input())):\n    n = int(input())\n    tree = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    children = dfs(1)\n    k = int(input())\n    primes = sorted(map(int, input().split()))\n    for i in range(k - (n - 1)):\n        curr = primes.pop()\n        primes[-1] = curr * primes[-1] % mod\n    primes = [1] * max(n - 1 - k, 0) + primes\n    passage = []\n    for i in range(n - 1):\n        passage.append(children[i] * (n - children[i]))\n    passage.sort()\n    ans = 0\n    for (i, j) in zip(primes, passage):\n        ans += i * j\n        ans = ans % mod\n    print(ans % mod)"]