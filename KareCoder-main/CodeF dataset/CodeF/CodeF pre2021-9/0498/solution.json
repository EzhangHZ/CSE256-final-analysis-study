["nCasos = int(input())\nfor _ in range(nCasos):\n    sub = int(input())\n    result = [0] * (sub + 1)\n    matriz = [[] for _ in range(sub + 1)]\n    matriz[sub] = [1]\n    count = 1\n    for i in range(sub, 0, -1):\n        if len(matriz[i]) > 0:\n            subMatriz = sorted(matriz[i])\n            for k in subMatriz:\n                if (i - 1) // 2 > 0:\n                    matriz[(i - 1) // 2].append(k)\n                result[k + (i - 1) // 2] = count\n                count += 1\n                matriz[i // 2].append(k + (i + 1) // 2)\n    print(' '.join(list(map(str, result[1:]))))", "import sys\ninput = sys.stdin.readline\n\ndef build(l, r, a):\n    if l > r:\n        return\n    if l == r:\n        a[l] = 1\n        return\n    m = (l + r) // 2\n    a[m] = r - l + 1\n    build(l, m - 1, a)\n    build(m + 1, r, a)\n\ndef solve(a):\n    res = []\n    for ii in range(len(a)):\n        res.append((a[ii], ii))\n    res.sort(key=lambda x: (-x[0], x[1]))\n    val = 1\n    ans = [0 for _ in range(len(res))]\n    for el in res:\n        ans[el[1]] = val\n        val += 1\n    return ' '.join(map(str, ans))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0 for _ in range(n)]\n    build(0, n - 1, a)\n    print(solve(a))", "def array_building(l, r, result):\n    if l > r:\n        return\n    elif l == r:\n        result[l] = 1\n        return\n    num = (l + r) // 2\n    result[num] = r - l + 1\n    array_building(l, num - 1, result)\n    array_building(num + 1, r, result)\n\ndef solve():\n    n = int(input())\n    a = [0] * n\n    result = [0] * n\n    array_building(0, n - 1, result)\n    for i in range(n):\n        result[i] = (result[i], i)\n    result.sort(key=lambda x: (-x[0], x[1]))\n    for i in range(n):\n        a[result[i][1]] = i + 1\n    print(' '.join(map(str, a)))\n\ndef main():\n    for _ in range(int(input())):\n        solve()\nmain()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    res = [0] * (n + 1)\n    dp = [[] for _ in range(n + 1)]\n    dp[n] = [1]\n    count = 1\n    for i in range(n, 0, -1):\n        if len(dp[i]) > 0:\n            s_dp = sorted(dp[i])\n            for k in s_dp:\n                if (i - 1) // 2 > 0:\n                    dp[(i - 1) // 2].append(k)\n                res[k + (i - 1) // 2] = count\n                count += 1\n                dp[i // 2].append(k + (i + 1) // 2)\n    print(' '.join(list(map(str, res[1:]))))", "def generate(l, n):\n    if n <= 0:\n        return\n    if n == 1:\n        d.append((l, 1, l))\n        return\n    elif n % 2 == 1:\n        d.append((l, n, l + (n - 1) // 2))\n        generate(l, (n - 1) // 2)\n        generate(l + (n - 1) // 2 + 1, (n - 1) // 2)\n    else:\n        d.append((l, n, l + (n - 1) // 2))\n        generate(l, (n - 1) // 2)\n        generate(l + n // 2, (n - 1) // 2 + 1)\nt = int(input())\ncnt = 0\nwhile cnt < t:\n    cnt += 1\n    n = int(input())\n    a = [0] * n\n    d = []\n    generate(0, n)\n    d = sorted(d, key=lambda l: (l[1], -l[0]), reverse=True)\n    i = 1\n    for elem in d:\n        a[elem[2]] = i\n        i += 1\n    print(' '.join((str(i) for i in a)))", "import heapq\n\ndef solve(k):\n    stack = [(-k, 0, k - 1)]\n    heapq.heapify(stack)\n    res = ['x' for _ in range(k)]\n    cnt = 0\n    while stack:\n        cnt += 1\n        (length, start, end) = heapq.heappop(stack)\n        length = -length\n        if length % 2 == 1:\n            mid_point = (start + end) // 2\n            res[mid_point] = cnt\n            if not start == end:\n                heapq.heappush(stack, (-(mid_point - start), start, mid_point - 1))\n                heapq.heappush(stack, (-(mid_point - start), mid_point + 1, end))\n        else:\n            mid_point = (start + end - 1) // 2\n            res[mid_point] = cnt\n            if length == 2:\n                heapq.heappush(stack, (-1, end, end))\n            else:\n                heapq.heappush(stack, (-(length // 2 - 1), start, mid_point - 1))\n                heapq.heappush(stack, (-(length // 2), mid_point + 1, end))\n    return ' '.join([str(x) for x in res])\nstrr = input()\nfor _ in range(int(strr)):\n    k = int(input())\n    print(solve(k))", "import heapq\n\ndef fill_zero_array(num):\n    array = [0] * num\n    heap = [(-num, 0)]\n    for i in range(1, num + 1):\n        (length, l) = heapq.heappop(heap)\n        length = -length\n        r = l + length - 1\n        mid = (l + r) // 2\n        array[mid] = i\n        if mid > l:\n            heapq.heappush(heap, (-(mid - l), l))\n        if mid < r:\n            heapq.heappush(heap, (-(r - mid), mid + 1))\n    return array\nquant = int(input())\ninputs = list()\nfor i in range(quant):\n    inputs.append(int(input()))\nfor i in inputs:\n    print(*fill_zero_array(i))", "import heapq\n\ndef read_int():\n    return int(input().strip())\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\na = [0] * 500000\n\ndef solve():\n    n = read_int()\n    Q = [(-n, 0, n - 1)]\n    i = 1\n    while len(Q) != 0:\n        (length, l, r) = heapq.heappop(Q)\n        mid = (l + r) // 2\n        a[mid] = i\n        if mid - l > 0:\n            heapq.heappush(Q, (l - mid, l, mid - 1))\n        if r - mid > 0:\n            heapq.heappush(Q, (mid - r, mid + 1, r))\n        i += 1\n    return ' '.join(map(str, a[:n]))\nT = read_int()\nfor _ in range(T):\n    print(solve())", "import heapq\n\ndef solve(n):\n    a = [0] * n\n    q = [(-n, 0, n - 1)]\n    for i in range(n):\n        (_, l, r) = heapq.heappop(q)\n        m = (l + r) // 2\n        a[m] = i + 1\n        heapq.heappush(q, (-(m - l), l, m - 1))\n        heapq.heappush(q, (-(r - m), m + 1, r))\n    return ' '.join(map(str, a))\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        print(solve(n))\nmain()", "def solve(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    solve(l, m - 1)\n    solve(m + 1, r)\nt = int(input())\nfor w in range(t):\n    n = int(input())\n    a = b = [0] * (n + 1)\n    solve(1, n)\n    for (i, j) in enumerate(sorted(a[1:n + 1]), start=1):\n        b[j[1]] = i\n    print(*b[1:n + 1])", "a = [(0, 0)] * 200001\nb = [0] * 200001\n\ndef d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input())\n    d(1, n)\n    c = 1\n    for i in sorted(a[1:n + 1], key=lambda g: g[0]):\n        b[i[1]] = c\n        c += 1\n    print(*b[1:n + 1])", "def d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nk = int(input())\nfor _ in range(k):\n    n = int(input())\n    a = b = [0] * (n + 1)\n    d(1, n)\n    for (i, j) in enumerate(sorted(a[1:n + 1])):\n        b[j[1]] = i + 1\n    print(*b[1:n + 1])", "def d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input()) + 1\n    a = b = [0] * n\n    d(1, n - 1)\n    for (i, j) in enumerate(sorted(a[1:n])):\n        b[j[1]] = i + 1\n    print(*b[1:n])", "def d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input()) + 1\n    a = b = [0] * n\n    d(1, n - 1)\n    for (i, j) in enumerate(sorted(a[1:n])):\n        b[j[1]] = i + 1\n    print(*b[1:n])", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = [0] * n\n    wart = [[-n, 0, n - 1]]\n    for x in range(1, n + 1):\n        (curr_len, curr_beg, curr_end) = heapq.heappop(wart)\n        curr_mid = (curr_beg + curr_end) // 2\n        l[curr_mid] = x\n        if abs(curr_len) > 2:\n            heapq.heappush(wart, [-(curr_mid - curr_beg), curr_beg, curr_mid - 1])\n            heapq.heappush(wart, [-(curr_end - curr_mid), curr_mid + 1, curr_end])\n        elif abs(curr_len) == 2:\n            heapq.heappush(wart, [-1, curr_mid + 1, curr_mid + 1])\n    print(' '.join((str(x) for x in l)))", "import itertools\nimport heapq\n\ndef maxheappush(heap, length, left, right):\n    heapq.heappush(heap, (-length, left, right))\n\ndef maxheappop(heap):\n    (length, left, right) = heapq.heappop(heap)\n    return (-length, left, right)\n\ndef get_length(left, right):\n    return right - left + 1\n\ndef build_array(n):\n    counter = itertools.count(1)\n    answer = [0] * n\n    heap = []\n    maxheappush(heap, n, 1, n)\n    while heap:\n        (length, left, right) = maxheappop(heap)\n        middle = left + (right - left) // 2\n        answer[middle - 1] = next(counter)\n        if left == right:\n            continue\n        if left < middle:\n            length = get_length(left=left, right=middle - 1)\n            maxheappush(heap, length, left, middle - 1)\n        if middle < right:\n            length = get_length(left=middle + 1, right=right)\n            maxheappush(heap, length, middle + 1, right)\n    return answer\n\ndef main():\n    for _ in range(int(input().strip())):\n        n = int(input().strip())\n        print(' '.join(map(str, build_array(n))))\nmain()", "for i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print(1)\n        continue\n    step = 1\n    result = [0 for j in range(n + 1)]\n    recorder = {n: [[1, n]]}\n    max_value = n\n    while max_value > 0:\n        recorder[max_value].sort(key=lambda a: a[0])\n        while recorder[max_value]:\n            temp = recorder[max_value].pop(0)\n            result[(temp[0] + temp[1]) // 2] = step\n            step += 1\n            left_node = [temp[0], (temp[0] + temp[1]) // 2 - 1]\n            right_node = [(temp[0] + temp[1]) // 2 + 1, temp[1]]\n            if left_node[0] <= left_node[1]:\n                try:\n                    recorder[left_node[1] - left_node[0]].append(left_node)\n                except:\n                    recorder[left_node[1] - left_node[0]] = [left_node]\n            if right_node[0] <= right_node[1]:\n                try:\n                    recorder[right_node[1] - right_node[0]].append(right_node)\n                except:\n                    recorder[right_node[1] - right_node[0]] = [right_node]\n        recorder.pop(max_value)\n        max_value = max(recorder.keys())\n    for j in range(1, n + 1):\n        if result[j] == 0:\n            result[j] = step\n            step += 1\n    print(' '.join(map(str, result[1:])))", "import heapq\ntest_cases = int(input())\nfor _ in range(test_cases):\n    n = int(input())\n    queue = [(-n, 0)]\n    a = ['0' for _ in range(n)]\n    i = 1\n    while len(queue) > 0:\n        (currentLen, l) = heapq.heappop(queue)\n        currentLen = -currentLen\n        r = l + currentLen - 1\n        middle = (l + r) // 2\n        a[middle] = str(i)\n        i += 1\n        if middle - l > 0:\n            heapq.heappush(queue, (-(middle - l), l))\n        if r - middle > 0:\n            heapq.heappush(queue, (-(r - middle), middle + 1))\n    print(' '.join(a))", "a = [(0, 0)] * 200001\nb = [0] * 200001\n\ndef d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input())\n    d(1, n)\n    c = 1\n    for i in sorted(a[1:n + 1]):\n        b[i[1]] = c\n        c += 1\n    print(*b[1:n + 1])", "def func1(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    li1[m] = [l - r, m]\n    func1(l, m - 1)\n    func1(m + 1, r)\na = int(input())\nfor _ in range(a):\n    x = int(input())\n    (li1, li2) = ([0] * x, [0] * x)\n    func1(0, x - 1)\n    li1.sort()\n    i = 0\n    for j in li1:\n        li2[j[1]] = i + 1\n        i += 1\n    print(*li2)", "for i in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print(1)\n        continue\n    step = 1\n    result = [0 for j in range(n + 1)]\n    recorder = {n: [[1, n]]}\n    max_value = n\n    while max_value > 0:\n        recorder[max_value].sort(key=lambda a: a[0])\n        while recorder[max_value]:\n            temp = recorder[max_value].pop(0)\n            result[(temp[0] + temp[1]) // 2] = step\n            step += 1\n            left_node = [temp[0], (temp[0] + temp[1]) // 2 - 1]\n            right_node = [(temp[0] + temp[1]) // 2 + 1, temp[1]]\n            if left_node[0] <= left_node[1]:\n                try:\n                    recorder[left_node[1] - left_node[0]].append(left_node)\n                except:\n                    recorder[left_node[1] - left_node[0]] = [left_node]\n            if right_node[0] <= right_node[1]:\n                try:\n                    recorder[right_node[1] - right_node[0]].append(right_node)\n                except:\n                    recorder[right_node[1] - right_node[0]] = [right_node]\n        recorder.pop(max_value)\n        max_value = max(recorder.keys())\n    for j in range(1, n + 1):\n        if result[j] == 0:\n            result[j] = step\n            step += 1\n    print(' '.join(map(str, result[1:])))", "from heapq import *\nimport sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        n = II()\n        hp = []\n        ans = [-1] * n\n        heappush(hp, (-n + 1, 0, n - 1))\n        c = 1\n        while hp:\n            (d, l, r) = heappop(hp)\n            i = (l + r) // 2\n            ans[i] = c\n            c += 1\n            if l <= i - 1:\n                heappush(hp, (l - i + 1, l, i - 1))\n            if i + 1 <= r:\n                heappush(hp, (i + 1 - r, i + 1, r))\n        print(*ans)\nmain()", "import heapq\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    A = [0] * N\n    H = []\n    heapq.heappush(H, (-N, 0))\n    for i in range(1, N + 1):\n        el = heapq.heappop(H)\n        nb_blocks = -el[0]\n        ind_first = el[1]\n        M = (ind_first + (ind_first + nb_blocks - 1)) // 2\n        A[M] = i\n        if M > ind_first:\n            heapq.heappush(H, (-(M - ind_first), ind_first))\n        if M < ind_first + nb_blocks - 1:\n            heapq.heappush(H, (-(ind_first + nb_blocks - 1 - M), M + 1))\n    print(' '.join(map(str, A)))", "def action(n):\n\n    def order(l, r, index):\n        if l == r:\n            index.append((1, abs(l)))\n            return\n        if (l - r + 1) % 2 == 1:\n            mid = (l + r) // 2\n        else:\n            mid = (l + r - 1) // 2\n        index.append((r - l + 1, abs(mid)))\n        if l < mid:\n            order(l, mid - 1, index)\n        if mid < r:\n            order(mid + 1, r, index)\n    index = []\n    order(-n, -1, index)\n    index = sorted(index, reverse=True)\n    count = 1\n    arr = [0] * n\n    for (length, key) in index:\n        arr[-key] = count\n        count += 1\n    return arr\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = action(n)\n    for k in arr:\n        print(k, end=' ')\n    print('')", "import sys\nimport heapq\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return list(map(int, input().split()))\n\ndef solve(num):\n    res = [0] * num\n    count = 1\n    q = [(-num, (0, num - 1))]\n    while q:\n        item = heapq.heappop(q)\n        n = -item[0]\n        l = item[1][0]\n        r = item[1][1]\n        if l == r:\n            res[int(l)] = count\n            count += 1\n            continue\n        if r == l + 1:\n            res[int(l)] = count\n            count += 1\n            heapq.heappush(q, (-1, (r, r)))\n            continue\n        if (l + r) % 2 == 0:\n            m = (l + r) / 2\n            heapq.heappush(q, (-(m - l), (l, m - 1)))\n            heapq.heappush(q, (-(r - m), (m + 1, r)))\n        else:\n            m = (l + r - 1) / 2\n            heapq.heappush(q, (-(m - l), (l, m - 1)))\n            heapq.heappush(q, (-(r - m), (m + 1, r)))\n        res[int(m)] = count\n        count += 1\n    return res\nt = inp()\nfor i in range(t):\n    print(' '.join(map(str, solve(inp()))))", "for i in range(int(input())):\n    n = int(input())\n    a = [0] * (n + 1)\n    b = [[] for i in range(n + 1)]\n    b[n].append(1)\n    j = n\n    ccc = 1\n    for x in range(n, 0, -1):\n        if len(b[x]) > 0:\n            c = sorted(b[x])\n            for j in c:\n                x1 = j\n                x2 = x1 + x - 1\n                if x1 == x2:\n                    a[x1] = ccc\n                    ccc += 1\n                else:\n                    m = (x1 + x2) // 2\n                    a[m] = ccc\n                    ccc += 1\n                    if x1 < m:\n                        b[m - x1].append(x1)\n                    if m < x2:\n                        b[x2 - m].append(m + 1)\n    print(*a[1:n + 1])", "import heapq\n\ndef solve():\n    n = int(input())\n    if n == 1:\n        print(1)\n    else:\n        arr = [0 for _ in range(n)]\n        q = []\n        heapq.heappush(q, (-(n - 1), 0, n - 1))\n        for i in range(1, n + 1):\n            (_, l, r) = heapq.heappop(q)\n            m = (l + r) // 2\n            arr[m] = i\n            if l < m:\n                heapq.heappush(q, (-(m - l - 1), l, m - 1))\n            if r > m:\n                heapq.heappush(q, (-(r - m - 1), m + 1, r))\n        print(*arr)\nt = int(input())\nfor _ in range(t):\n    solve()", "import heapq\nfor _ in range(int(input())):\n    n = int(input())\n    I = iter(range(1, n + 1))\n    result = [0] * n\n    heap = [(-n, 1, n)]\n    while heap:\n        (_, left, right) = heapq.heappop(heap)\n        mid = left + (right - left) // 2\n        result[mid - 1] = str(next(I))\n        if left < mid:\n            heapq.heappush(heap, (left - mid, left, mid - 1))\n        if mid < right:\n            heapq.heappush(heap, (mid - right, mid + 1, right))\n    print(' '.join(result))", "def d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input()) + 1\n    a = b = [0] * n\n    d(1, n - 1)\n    for (i, j) in enumerate(sorted(a[1:n])):\n        b[j[1]] = i + 1\n    print(*b[1:n])", "import heapq\ntest = int(input())\nfor _ in range(0, test):\n    n = int(input())\n    ara = [0 for i in range(0, n)]\n    subara = [(n * -1, 1)]\n    heapq.heapify(subara)\n    for itr in range(1, n + 1):\n        (k, l) = heapq.heappop(subara)\n        k = k * -1\n        r = l + k - 1\n        if k % 2 == 1:\n            i = (l + r) // 2\n        else:\n            i = (l + r - 1) // 2\n        ara[i - 1] = itr\n        if i > l:\n            heapq.heappush(subara, ((i - l) * -1, l))\n        if i < r:\n            heapq.heappush(subara, ((r - i) * -1, i + 1))\n    ans = ' '.join(map(str, ara))\n    print(ans)", "def d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * (n + 1)\n    b = [0] * (n + 1)\n    d(1, n)\n    for (i, j) in enumerate(sorted(a[1:n + 1])):\n        b[j[1]] = i + 1\n    for i in b[1:n + 1]:\n        print(i, end=' ')\n    print()", "def d(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a[m] = (l - r, m)\n    d(l, m - 1)\n    d(m + 1, r)\nfor _ in range(int(input())):\n    n = int(input()) + 1\n    a = b = [0] * n\n    d(1, n - 1)\n    for (i, j) in enumerate(sorted(a[1:n])):\n        b[j[1]] = i + 1\n    print(*b[1:n])", "li = []\n\ndef add_element(left, right):\n    if right - left == 0:\n        return\n    if right - left == 1:\n        li.append([-1, left])\n        return\n    mid = (left + right) // 2\n    if (right - left) % 2 == 0:\n        mid = mid - 1\n    li.append([-(right - left), mid])\n    add_element(left, mid)\n    add_element(mid + 1, right)\nT = int(input())\nfor tc in range(T):\n    n = int(input())\n    arr = [0] * n\n    li = []\n    add_element(0, n)\n    li.sort()\n    val = 1\n    for i in range(n):\n        arr[li[i][1]] = val\n        val += 1\n    print(*arr)", "def recurse(start, end, log):\n    if start > end:\n        return\n    else:\n        mid = (start + end) // 2\n        log.append((start, mid, end))\n        recurse(mid + 1, end, log)\n        recurse(start, mid - 1, log)\nfor _ in range(int(input())):\n    size = int(input())\n    memo = []\n    recurse(0, size - 1, memo)\n    memo = sorted(memo, key=lambda x: (x[2] - x[0], -x[0]), reverse=True)\n    ans = [0] * size\n    for i in range(len(memo)):\n        ans[memo[i][1]] = i + 1\n    print(*ans)", "def f(l, r):\n    if l > r:\n        return\n    mid = (l + r) // 2\n    a[mid] = [l - r, mid]\n    f(l, mid - 1)\n    f(mid + 1, r)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = b = [0] * (n + 1)\n    f(1, n)\n    i = 1\n    a.pop(0)\n    a = sorted(a)\n    for j in a:\n        b[j[1] - 1] = i\n        i += 1\n    print(*b)", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    res = [0] * (n + 1)\n    a = [(-n, 1, n)]\n    count = 1\n    while a:\n        (_, l, r) = heapq.heappop(a)\n        middle = (l + r) // 2\n        res[middle] = count\n        count += 1\n        if l < middle:\n            heapq.heappush(a, (l - middle, l, middle - 1))\n        if middle < r:\n            heapq.heappush(a, (middle - r, middle + 1, r))\n    print(*res[1:n + 1])", "def order(i_i, i_f):\n    m = i_i + i_f\n    if m % 2 == 0:\n        mid = (m - 1) // 2\n    else:\n        mid = m // 2\n    ord.append((i_f - i_i, i_i, mid))\n    if i_i < mid:\n        order(i_i, mid)\n    if mid + 1 < i_f:\n        order(mid + 1, i_f)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [0] * n\n    ord = []\n    order(0, n)\n    ord.sort(key=lambda x: (-x[0], x[1]))\n    for i in range(len(ord)):\n        arr[ord[i][2]] = i + 1\n    print(*arr)", "import heapq\n\ndef RA():\n    return list(map(int, input().split()))\n\ndef solve():\n    n = int(input())\n    q = [(-n, 0, n - 1)]\n    heapq.heapify(q)\n    ans = [0] * n\n    for i in range(1, n + 1):\n        (length, l, r) = heapq.heappop(q)\n        pos = (l + r) // 2\n        ans[pos] = i\n        if pos - 1 >= l:\n            heapq.heappush(q, (-(pos - l), l, pos - 1))\n        if pos + 1 <= r:\n            heapq.heappush(q, (-(r - pos), pos + 1, r))\n    print(*ans)\nt = int(input())\nfor i in range(t):\n    solve()", "def recurse(start, end, log):\n    if start > end:\n        return\n    else:\n        mid = (start + end) // 2\n        log.append((start, mid, end))\n        recurse(mid + 1, end, log)\n        recurse(start, mid - 1, log)\nfor _ in range(int(input())):\n    size = int(input())\n    memo = []\n    recurse(0, size - 1, memo)\n    memo = sorted(memo, key=lambda x: (x[2] - x[0], -x[0]), reverse=True)\n    ans = [0] * size\n    for i in range(len(memo)):\n        ans[memo[i][1]] = i + 1\n    print(*ans)", "from sys import stdin\nimport heapq\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    a = [0] * n\n    q = [(-1 * n, 0, n - 1)]\n    heapq.heapify(q)\n    i = 1\n    while q:\n        (siz, l, r) = heapq.heappop(q)\n        mid = l + r >> 1\n        a[mid] = i\n        i += 1\n        if r != mid:\n            heapq.heappush(q, (mid - r, mid + 1, r))\n        if l != mid:\n            heapq.heappush(q, (l - mid, l, mid - 1))\n    print(*a)", "import heapq as hp\n\ndef solve():\n    for _ in range(int(input())):\n        n = int(input())\n        pq = [(-n, 0, n - 1)]\n        hp.heapify(pq)\n        i = 1\n        rel = [0] * n\n        while len(pq) > 0:\n            (length, l, r) = hp.heappop(pq)\n            mid = (l + r) // 2\n            rel[mid] = i\n            i += 1\n            if l < mid:\n                hp.heappush(pq, (-(mid - l), l, mid - 1))\n            if r > mid:\n                hp.heappush(pq, (-(r - mid), mid + 1, r))\n        for i in rel:\n            print(i, end=' ')\n        print()\nsolve()", "import sys\nimport heapq as hq\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    a = [0] * n\n    q = [(-n, 0, n - 1)]\n    for i in range(n):\n        (v, l, r) = hq.heappop(q)\n        m = (l + r) // 2\n        a[m] = i + 1\n        hq.heappush(q, (-(m - l), l, m - 1))\n        hq.heappush(q, (-(r - m), m + 1, r))\n    print(*a)\nT = ni()\nfor _ in range(T):\n    solve()", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = []\n    d = []\n    q = deque()\n    q.append([1, n])\n    while q:\n        (l, r) = q.popleft()\n        if l <= r:\n            m = (l + r) // 2\n            d.append([-(r - l + 1), l, m])\n            if m - 1 >= l:\n                q.append([l, m - 1])\n            if r >= m + 1:\n                q.append([m + 1, r])\n    d = sorted(d, key=lambda x: (x[0], x[1]))\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        m = d[i - 1][2]\n        ans[m] = i\n    sys.stdout.write(' '.join(map(str, ans[1:])) + '\\n')", "import io, os\nfrom heapq import *\n\ndef ri():\n    return int(input().strip())\n\ndef rl():\n    return list(map(int, input().strip().split()))\n\ndef Solve():\n    n = ri()\n    a = [0] * (n + 1)\n    q = [(-n, 1, n)]\n    for i in range(n):\n        x = heappop(q)\n        (l, r) = (x[1], x[2])\n        if (r - l + 1) % 2 == 1:\n            mid = (l + r) // 2\n        else:\n            mid = (l + r - 1) // 2\n        a[mid] = i + 1\n        if l <= mid - 1:\n            heappush(q, (-(mid - 1 - l + 1), l, mid - 1))\n        if mid + 1 <= r:\n            heappush(q, (-(r - (mid + 1) + 1), mid + 1, r))\n    for i in range(1, n + 1):\n        print(a[i], end=' ')\n    print()\nT = ri()\nwhile T:\n    T -= 1\n    Solve()", "from sys import stdin, stdout\nimport math\nimport heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\n\ndef main():\n    for t in range(I()):\n        n = I()\n        arr = [0 for i in range(n)]\n        q = []\n        heapq.heappush(q, (-n, 0, n - 1))\n        i = 1\n        while len(q):\n            (x, l, r) = heapq.heappop(q)\n            m = (l + r) // 2\n            arr[m] = i\n            if l != m:\n                heapq.heappush(q, (l - m, l, m - 1))\n            if r != m:\n                heapq.heappush(q, (m - r, m + 1, r))\n            i += 1\n        print(*arr)\nmain()", "import heapq as heap\n\ndef solve():\n    n = int(input())\n    final = [0] * (n + 1)\n    li = []\n    heap.heapify(li)\n    heap.heappush(li, (n, 1, n))\n    count = 1\n    while count <= n:\n        (ll, l, r) = heap.heappop(li)\n        mid = (l + r) // 2\n        final[mid] = count\n        count += 1\n        if mid - l > 0:\n            heap.heappush(li, (-(mid - l), l, mid - 1))\n        if r - mid > 0:\n            heap.heappush(li, (-(r - mid), mid + 1, r))\n    print(*final[1:])\nt = int(input())\nfor i in range(t):\n    solve()", "import heapq as hq\n\ndef answer(n):\n    q = []\n    hq.heappush(q, (-n, 0, n - 1))\n    A = [0] * n\n    i = 1\n    while len(q) > 0:\n        (l, s, e) = hq.heappop(q)\n        x = (s + e) // 2\n        A[x] = i\n        i += 1\n        if x > s:\n            hq.heappush(q, (-(x - s), s, x - 1))\n        if x < e:\n            hq.heappush(q, (-(e - x), x + 1, e))\n    print(*A)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    answer(n)", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    res = [0] * (n + 1)\n    a = [(-n, 1, n)]\n    count = 1\n    while a:\n        (_, l, r) = heapq.heappop(a)\n        middle = (l + r) // 2\n        res[middle] = count\n        count += 1\n        if l < middle:\n            heapq.heappush(a, (l - middle, l, middle - 1))\n        if middle < r:\n            heapq.heappush(a, (middle - r, middle + 1, r))\n    print(*res[1:n + 1])", "import sys\nimport heapq as hq\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    a = [0] * n\n    q = [(-n, 0, n - 1)]\n    for i in range(n):\n        (v, l, r) = hq.heappop(q)\n        m = (l + r) // 2\n        a[m] = i + 1\n        hq.heappush(q, (-(m - l), l, m - 1))\n        hq.heappush(q, (-(r - m), m + 1, r))\n    print(*a)\nT = ni()\nfor _ in range(T):\n    solve()", "import heapq\nTT = int(input())\nfor _ in range(TT):\n    n = int(input())\n    ans = [0] * n\n    l = 0\n    r = n - 1\n    li = [(-(r - l + 1), l, r)]\n    heapq.heapify(li)\n    ctr = 1\n    while len(li):\n        (llen, l, r) = heapq.heappop(li)\n        if llen % 2 == 0:\n            sp = (l + r - 1) // 2\n        else:\n            sp = (l + r) // 2\n        llen = sp - 1 - l + 1\n        if llen > 0:\n            heapq.heappush(li, (-llen, l, sp - 1))\n        rlen = r - (sp + 1) + 1\n        if rlen > 0:\n            heapq.heappush(li, (-rlen, sp + 1, r))\n        ans[sp] = str(ctr)\n        ctr += 1\n    print(' '.join(ans))", "import heapq\ntest = int(input())\nfor _ in range(0, test):\n    n = int(input())\n    ara = [0 for i in range(0, n)]\n    subara = [(n * -1, 1)]\n    heapq.heapify(subara)\n    for itr in range(1, n + 1):\n        (k, l) = heapq.heappop(subara)\n        k = k * -1\n        r = l + k - 1\n        if k % 2 == 1:\n            i = (l + r) // 2\n        else:\n            i = (l + r - 1) // 2\n        ara[i - 1] = itr\n        if i > l:\n            heapq.heappush(subara, ((i - l) * -1, l))\n        if i < r:\n            heapq.heappush(subara, ((r - i) * -1, i + 1))\n    ans = ' '.join(map(str, ara))\n    print(ans)", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    (heap, ans, i) = ([(-n, 1, n)], [0 for _ in range(n + 1)], 1)\n    while heap:\n        (_, l, r) = heappop(heap)\n        if (r - l + 1) % 2:\n            mid = (l + r) // 2\n        else:\n            mid = (l + r - 1) // 2\n        ans[mid] = i\n        i += 1\n        if l <= mid - 1:\n            heappush(heap, (-(mid - 1 - l + 1), l, mid - 1))\n        if mid + 1 <= r:\n            heappush(heap, (-(r - (mid + 1) + 1), mid + 1, r))\n    print(*ans[1:])", "import heapq\n\ndef sol():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        A = [0] * n\n        max_heap = []\n        heapq.heappush(max_heap, (-n, 0, n - 1))\n        nth = 1\n        while max_heap:\n            (_, left, right) = heapq.heappop(max_heap)\n            mid = (left + right) // 2\n            A[mid] = nth\n            nth += 1\n            if left == right:\n                continue\n            if mid - 1 >= left:\n                heapq.heappush(max_heap, (-(mid - 1 - left + 1), left, mid - 1))\n            if mid + 1 <= right:\n                heapq.heappush(max_heap, (-(right - (mid + 1) + 1), mid + 1, right))\n        for num in A:\n            print(num, end=' ')\n        print()\nsol()", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    h = []\n    ans = [0 for i in range(n)]\n    i = 1\n    heappush(h, [-n, 0, n - 1])\n    while h:\n        (a, b, c) = heappop(h)\n        if b <= c:\n            m = (b + c) // 2\n            ans[m] = i\n            i += 1\n            if b <= m - 1:\n                heappush(h, [-m + b, b, m - 1])\n            if m + 1 <= c:\n                heappush(h, [-(c - (m + 1) + 1), m + 1, c])\n    print(*ans)", "from collections import defaultdict as dc\nfrom collections import Counter\nfrom heapq import *\nimport math\nfrom bisect import bisect_left, bisect\nimport sys\nfrom collections import deque as dq\nfrom heapq import heapify, heappush, heappop\nmod = 10 ** 9 + 7\n\ndef sinp():\n    p = str(input())\n    return p\n\ndef seive(n):\n    p = [0] * (n + 1)\n    for i in range(2, n):\n        if p[i] == 0:\n            for j in range(2 * i, n + 1, i):\n                p[i] = 1\n    return p\n\ndef inp():\n    p = int(input())\n    return p\n\ndef line():\n    p = list(map(int, input().split()))\n    return p\n\ndef read_mat():\n    n = inp()\n    a = []\n    for i in range(n):\n        a.append(line())\n    return a\n\ndef digit(n):\n    s = str(n)\n    p = 0\n    for i in s:\n        p += int(i) ** 2\n    return p\n\ndef solve(n):\n    z = 1\n    a = [0] * n\n    q = []\n    q.append([-n + 1, 0])\n    heapify(q)\n    while len(q):\n        (p, l) = heappop(q)\n        r = l - p\n        mid = (l + r) // 2\n        a[mid] = z\n        z += 1\n        if l <= mid - 1:\n            heappush(q, [l - mid + 1, l])\n        if r >= mid + 1:\n            heappush(q, [mid + 1 - r, mid + 1])\n    return a\nfor test in range(inp()):\n    n = inp()\n    l = solve(n)\n    print(*l)", "def solve(a, l, r):\n    if r < l:\n        return 0\n    mid = (l + r) // 2\n    a.append([mid, l, r])\n    solve(a, mid + 1, r)\n    solve(a, l, mid - 1)\n\ndef comp(x):\n    return 200000 * (x[2] - x[1] + 1) + 100005 - x[1]\nfor _ in range(int(input())):\n    n = int(input())\n    ans = []\n    solve(ans, 0, n - 1)\n    ans = sorted(ans, key=comp, reverse=True)\n    a = [0] * n\n    for i in range(len(ans)):\n        a[ans[i][0]] = i + 1\n    print(*a)", "import heapq\nfrom math import ceil\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * (n + 1)\n    h = []\n    heapq.heappush(h, (-n, 1, n))\n    for i in range(1, n + 1):\n        e = heapq.heappop(h)\n        (_, l, r) = e\n        if (r - l + 1) % 2 != 0:\n            a[(l + r) // 2] = i\n            new_ind = (l + r) // 2\n        else:\n            a[(l + r - 1) // 2] = i\n            new_ind = (l + r - 1) // 2\n        if new_ind != l:\n            heapq.heappush(h, (l - new_ind, l, new_ind - 1))\n        if new_ind != r:\n            heapq.heappush(h, (new_ind - r, new_ind + 1, r))\n    print(' '.join([str(x) for x in a[1:]]))", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * n\n    hq = [(-n, 0, n - 1)]\n    for i in range(1, n + 1):\n        (_, l, r) = heappop(hq)\n        m = (l + r) // 2\n        a[m] = i\n        if m > l:\n            heappush(hq, (l - m, l, m - 1))\n        if m < r:\n            heappush(hq, (m - r, m + 1, r))\n    print(*a)", "import sys\ninput = sys.stdin.readline\nimport heapq\nfor _ in range(int(input())):\n    n = int(input())\n    arr = [0] * (n + 1)\n    queue = []\n    heapq.heappush(queue, [-n, 1, n])\n    operation = 0\n    while queue:\n        (size, l, r) = heapq.heappop(queue)\n        operation += 1\n        mid = l + (r - l) // 2\n        arr[mid] = operation\n        if l <= mid - 1:\n            new_size = mid - l\n            heapq.heappush(queue, [-new_size, l, mid - 1])\n        if mid + 1 <= r:\n            new_size = r - mid\n            heapq.heappush(queue, [-new_size, mid + 1, r])\n    print(*arr[1:])", "from math import gcd\n\ndef r():\n    return map(int, input().split())\n\ndef l():\n    return list(map(int, input().split()))\n\ndef i():\n    return int(input())\n\ndef si():\n    return input()\n\ndef pYes():\n    print('YES')\n\ndef pNo():\n    print('NO')\n\ndef plist(l):\n    print(''.join(l))\n\ndef findm(a, b):\n    if a > b:\n        return\n    mid = (a + b) // 2\n    c.append([b - a, -1 * a])\n    findm(mid + 1, b)\n    findm(a, mid - 1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = [0] * n\n    c = []\n    findm(0, n - 1)\n    c = sorted(c, reverse=True)\n    for i in range(n):\n        d = c[i][0] // 2 - c[i][1]\n        arr[d] = i + 1\n    print(*arr)", "from collections import Counter, defaultdict, deque\nimport heapq as hq\nfrom math import *\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    h = [(-n, 0, n - 1)]\n    res = [0] * n\n    i = 1\n    while len(h):\n        nxt = hq.heappop(h)\n        mid = (nxt[1] + nxt[2]) // 2\n        res[mid] = i\n        i += 1\n        r1 = (nxt[1] - mid, nxt[1], mid - 1)\n        r2 = (mid - nxt[2], mid + 1, nxt[2])\n        if r1[0] < 0:\n            hq.heappush(h, r1)\n        if r2[0] < 0:\n            hq.heappush(h, r2)\n    print(*res)\ntt = int(input())\nfor test in range(tt):\n    solve()", "from heapq import heapify, heappop, heappush\n\ndef solver(n):\n    (result, lst, k) = ([0] * (n + 1), list(), 1)\n    heapify(lst)\n    heappush(lst, (n, 1, n))\n    while k <= n:\n        (ll, l, r) = heappop(lst)\n        mid = (l + r) // 2\n        result[mid] = k\n        k += 1\n        if mid - l > 0:\n            heappush(lst, (-(mid - l), l, mid - 1))\n        if r - mid > 0:\n            heappush(lst, (-(r - mid), mid + 1, r))\n    return result[1:]\nfor _ in range(int(input())):\n    m = int(input())\n    print(*solver(m))", "from queue import PriorityQueue\nt = int(input())\n\ndef sub(l, r):\n    if l > r:\n        return\n    m = (l + r) // 2\n    a.append((l - r, m))\n    sub(l, m - 1)\n    sub(m + 1, r)\nfor _ in range(t):\n    q = PriorityQueue()\n    n = int(input())\n    arr = [0] * n\n    a = []\n    sub(0, n - 1)\n    k = 1\n    a.sort()\n    for (i, j) in a:\n        arr[j] = k\n        k += 1\n    print(*arr)", "from heapq import heappush, heappop, heapify\n\ndef calc(n):\n    ll = []\n    heapify(ll)\n    c = 1\n    res = [0] * (n + 1)\n    heappush(ll, (-n, (1, n)))\n    while ll:\n        q = heappop(ll)\n        l = q[1][0]\n        r = q[1][1]\n        m = (l + r) // 2\n        res[m] = c\n        c += 1\n        if l == r:\n            continue\n        if l < m:\n            heappush(ll, (-(m - l), (l, m - 1)))\n        if r > m:\n            heappush(ll, (-(r - m), (m + 1, r)))\n    return res[1:]\nt = int(input())\nwhile t:\n    n = int(input())\n    print(*calc(n))\n    t -= 1", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    l = [0] * n\n    q = [(-n, 0, n - 1)]\n    heapify(q)\n    v = 1\n    while q:\n        (d, a, b) = heappop(q)\n        d *= -1\n        m = (a + b) // 2\n        l[m] = v\n        if m - 1 >= 0 and a <= m - 1:\n            d = m - a\n            heappush(q, (-d, a, m - 1))\n        if m + 1 < n and b >= m + 1:\n            d = b - m\n            heappush(q, (-d, m + 1, b))\n        v += 1\n    print(*l)", "import heapq\n\ndef func(n):\n    q = []\n    heapq.heappush(q, [-(n - 1 + 1), 1, n])\n    i = 1\n    q.append([1, n])\n    while i <= n:\n        y = heapq.heappop(q)\n        mid = (y[1] + y[2]) // 2\n        last = -y[0]\n        a[mid] = i\n        i += 1\n        if last == 1:\n            continue\n        if mid - 1 >= y[1]:\n            heapq.heappush(q, [-(mid - 1 - y[1] + 1), y[1], mid - 1])\n        if mid + 1 <= y[2]:\n            heapq.heappush(q, [-(y[2] - mid - 1 + 1), mid + 1, y[2]])\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * (n + 1)\n    func(n)\n    print(*a[1:])", "t = int(input())\nimport heapq\nfor i in range(t):\n    n = int(input())\n    a = [0 for j in range(n)]\n    ls = [-1, n]\n    hint = [(-n, -1, n)]\n    heapq.heapify(hint)\n    for j in range(n):\n        interval = heapq.heappop(hint)\n        if interval[0] % 2 == 0:\n            ind = (interval[2] + interval[1] - 1) // 2\n        else:\n            ind = (interval[2] + interval[1]) // 2\n        a[ind] = j + 1\n        heapq.heappush(hint, (-(ind - interval[1] - 1), interval[1], ind))\n        heapq.heappush(hint, (-(interval[2] - ind - 1), ind, interval[2]))\n    print(' '.join([str(j) for j in a]))", "import operator\nt = int(input())\n\ndef solve(l, r):\n    if r < l:\n        return\n    mid = (l + r) // 2\n    temp[mid] = (r - l, mid)\n    solve(l, mid - 1)\n    solve(mid + 1, r)\nfor i in range(t):\n    n = int(input())\n    temp = [None for j in range(n)]\n    output = [None for j in range(n)]\n    solve(0, n - 1)\n    temp.sort(key=lambda ts: (-ts[0], ts[1]))\n    for k in range(len(temp)):\n        output[temp[k][1]] = k + 1\n    for l in range(len(output)):\n        print(output[l], end=' ')\n    print('')", "import heapq\n\ndef func(n):\n    q = []\n    heapq.heappush(q, [-(n - 1 + 1), 1, n])\n    j = 1\n    q.append([1, n])\n    while j <= n:\n        x = heapq.heappop(q)\n        mid = (x[1] + x[2]) // 2\n        le = -x[0]\n        b[mid] = j\n        j += 1\n        if le == 1:\n            continue\n        if mid - 1 >= x[1]:\n            heapq.heappush(q, [-(mid - 1 - x[1] + 1), x[1], mid - 1])\n        if mid + 1 <= x[2]:\n            heapq.heappush(q, [-(x[2] - mid - 1 + 1), mid + 1, x[2]])\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    b = [0] * (n + 1)\n    func(n)\n    print(*b[1:])", "t = int(input())\nimport heapq\nfor i in range(t):\n    n = int(input())\n    a = [0 for j in range(n)]\n    ls = [-1, n]\n    hint = [(-n, -1, n)]\n    heapq.heapify(hint)\n    for j in range(n):\n        interval = heapq.heappop(hint)\n        if interval[0] % 2 == 0:\n            ind = (interval[2] + interval[1] - 1) // 2\n        else:\n            ind = (interval[2] + interval[1]) // 2\n        a[ind] = j + 1\n        heapq.heappush(hint, (-(ind - interval[1] - 1), interval[1], ind))\n        heapq.heappush(hint, (-(interval[2] - ind - 1), ind, interval[2]))\n    print(' '.join([str(j) for j in a]))", "from heapq import heappush, heapify, heappop\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * n\n    q = [[-n + 1, 0]]\n    heapify(q)\n    for i in range(1, n + 1):\n        (p, l) = heappop(q)\n        r = l - p\n        k = (r + l) // 2\n        a[k] = i\n        if k - 1 - l >= 0:\n            heappush(q, [l - k + 1, l])\n        if r - k - 1 >= 0:\n            heappush(q, [k + 1 - r, k + 1])\n    print(*a)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    dictionary = {}\n\n    def search_in_depth(l, r):\n        if l <= r:\n            if l == r:\n                if 1 not in dictionary:\n                    dictionary[1] = [[l]]\n                else:\n                    dictionary[1] += [[l]]\n                return\n            else:\n                if r - l + 1 not in dictionary:\n                    dictionary[r - l + 1] = [[l, r]]\n                else:\n                    dictionary[r - l + 1] += [[l, r]]\n                if (l + r) % 2 == 1:\n                    search_in_depth(l, (l + r - 1) // 2 - 1)\n                    search_in_depth((l + r - 1) // 2 + 1, r)\n                else:\n                    search_in_depth(l, (l + r) // 2 - 1)\n                    search_in_depth((l + r) // 2 + 1, r)\n    search_in_depth(1, n)\n    sorted_dictionary = {i: dictionary[i] for i in sorted(dictionary, reverse=True)}\n    indices = []\n    for key in sorted_dictionary:\n        for value in sorted_dictionary[key]:\n            if (value[0] + value[-1]) % 2 == 1:\n                indices += [(value[0] + value[-1] - 1) // 2 - 1]\n            else:\n                indices += [(value[0] + value[-1]) // 2 - 1]\n    answer = [0] * n\n    for (counter, ind) in enumerate(indices, 1):\n        answer[ind] = counter\n    print(*answer)", "import heapq as heap\n\ndef solve():\n    n = int(input())\n    final = [0] * (n + 1)\n    li = []\n    heap.heapify(li)\n    heap.heappush(li, (n, 1, n))\n    count = 1\n    while count <= n:\n        (ll, node_left, node_right) = heap.heappop(li)\n        final[(node_left + node_right) // 2] = count\n        count += 1\n        if (node_left + node_right) // 2 - node_left > 0:\n            heap.heappush(li, (-((node_left + node_right) // 2 - node_left), node_left, (node_left + node_right) // 2 - 1))\n        if node_right - (node_left + node_right) // 2 > 0:\n            heap.heappush(li, (-(node_right - (node_left + node_right) // 2), (node_left + node_right) // 2 + 1, node_right))\n    print(*final[1:])\nt = int(input())\nfor i in range(t):\n    solve()", "import heapq\n\ndef solve():\n    n = int(input())\n    final = [0] * (n + 1)\n    li = []\n    heapq.heapify(li)\n    heapq.heappush(li, (n, 1, n))\n    count = 1\n    while count <= n:\n        (ll, node_left, node_right) = heapq.heappop(li)\n        final[(node_left + node_right) // 2] = count\n        count += 1\n        if (node_left + node_right) // 2 - node_left > 0:\n            heapq.heappush(li, (-((node_left + node_right) // 2 - node_left), node_left, (node_left + node_right) // 2 - 1))\n        if node_right - (node_left + node_right) // 2 > 0:\n            heapq.heappush(li, (-(node_right - (node_left + node_right) // 2), (node_left + node_right) // 2 + 1, node_right))\n    print(*final[1:])\nt = int(input())\nfor i in range(t):\n    solve()", "def dfs(arr, ans, l, r):\n    if r - l < 0:\n        return\n    ans.append((l, r))\n    mid = l + (r - l) // 2\n    left = (l, mid - 1)\n    right = (mid + 1, r)\n    dfs(arr, ans, *left)\n    dfs(arr, ans, *right)\nfrom collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * n\n    (l, r) = (0, n - 1)\n    ans = []\n    dfs(a, ans, l, r)\n    ans.sort(key=lambda x: abs(x[0] - x[1]), reverse=True)\n    i = 1\n    for (l, r) in ans:\n        mid = l + (r - l) // 2\n        a[mid] = i\n        i += 1\n    print(*a)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * n\n    hq = [(-n, 0, n - 1)]\n    for i in range(1, n + 1):\n        (_, l, r) = heappop(hq)\n        m = (l + r) // 2\n        a[m] = i\n        if m > l:\n            heappush(hq, (l - m, l, m - 1))\n        if m < r:\n            heappush(hq, (m - r, m + 1, r))\n    print(*a)", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * n\n    h = [(-n, 0, n - 1)]\n    i = 1\n    while len(h) != 0:\n        (_, L, R) = heappop(h)\n        mid = (L + R) // 2\n        a[mid] = i\n        i += 1\n        if L < mid:\n            heappush(h, (L - mid, L, mid - 1))\n        if mid < R:\n            heappush(h, (mid - R, mid + 1, R))\n    print(*a)", "import heapq as heap\nfor _ in range(int(input())):\n    n = int(input())\n    ans = [0] * n\n    ar = []\n    heap.heappush(ar, (n, 0, n - 1))\n    for i in range(1, n + 1):\n        (size, l, h) = heap.heappop(ar)\n        if (h - l + 1) % 2 == 0:\n            mid = (l + h - 1) // 2\n            ans[mid] = i\n        else:\n            mid = (l + h) // 2\n            ans[mid] = i\n        if h - mid > 0:\n            heap.heappush(ar, (-(h - mid), mid + 1, h))\n        if mid - l > 0:\n            heap.heappush(ar, (-(mid - l), l, mid - 1))\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    d = {n: [0]}\n    (s, r) = ([n], [0] * n)\n    i = 1\n    while i <= n:\n        s = sorted(s)\n        n1 = s.pop()\n        for j in sorted(d[n1]):\n            (start, stop) = (j, j + n1)\n            if n1 % 2 == 0:\n                mid = (start + stop - 1) // 2\n            else:\n                mid = (start + stop) // 2\n            r[mid] = i\n            i += 1\n            if mid - j in d:\n                d[mid - j] += [j]\n            else:\n                d[mid - j] = [j]\n            if stop - 1 - mid in d:\n                d[stop - 1 - mid] += [mid + 1]\n            else:\n                d[stop - 1 - mid] = [mid + 1]\n            if mid - j not in s:\n                s += [mid - j]\n            if stop - 1 - mid not in s:\n                s += [stop - 1 - mid]\n        del d[n1]\n    print(*r)", "from heapq import *\nfor _ in range(int(input())):\n    n = int(input())\n    A = [0] * n\n    Q = [(-n, 0)]\n    num = 1\n\n    def push(l, start):\n        if l <= 0:\n            return\n        heappush(Q, (-l, start))\n    while Q:\n        (l, i) = heappop(Q)\n        l = -l\n        mid = i + (l - 1) // 2\n        A[mid] = num\n        h = l // 2\n        num += 1\n        push(mid - i, i)\n        push(i + l - mid - 1, mid + 1)\n    print(*A)", "from heapq import *\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h = [(-n, 0, n - 1)]\n    a = [0] * n\n    i = 1\n    while len(h) != 0:\n        (_, L, R) = heappop(h)\n        mid = (L + R) // 2\n        a[mid] = i\n        i += 1\n        if L < mid:\n            heappush(h, (L - mid, L, mid - 1))\n        if mid < R:\n            heappush(h, (mid - R, mid + 1, R))\n    print(*a)", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    q = []\n    lst = [0] * n\n    heapq.heappush(q, (-n, 0, n - 1))\n    counter = 1\n    while q:\n        (size, l, r) = heapq.heappop(q)\n        mid = (l + r) // 2\n        lst[mid] = counter\n        counter += 1\n        if mid - l != 0 or l <= mid - 1:\n            heapq.heappush(q, (-(mid - l), l, mid - 1))\n        if r - mid != 0 or mid + 1 <= r:\n            heapq.heappush(q, (-(r - mid), mid + 1, r))\n    print(*lst)", "import heapq\n\ndef tuplmk(a, b):\n    return (a - 1 - b, a, b)\nt = int(input())\nfor pset in range(t):\n    n = int(input())\n    h = []\n    ans = [0 for i in range(n)]\n    heapq.heappush(h, tuplmk(1, n))\n    for el in range(1, n + 1):\n        seq = heapq.heappop(h)\n        ind = (seq[1] + seq[2]) // 2\n        ans[ind - 1] = el\n        heapq.heappush(h, tuplmk(seq[1], ind - 1))\n        heapq.heappush(h, tuplmk(ind + 1, seq[2]))\n    print(' '.join([str(i) for i in ans]))", "def dfs(ans, l, r):\n    if r - l < 0:\n        return\n    ans.append((l, r))\n    mid = l + (r - l) // 2\n    left = (l, mid - 1)\n    right = (mid + 1, r)\n    dfs(ans, *left)\n    dfs(ans, *right)\nfor _ in range(int(input())):\n    n = int(input())\n    ans = [0] * n\n    a = []\n    dfs(a, 0, n - 1)\n    a.sort(key=lambda x: abs(x[0] - x[1]), reverse=True)\n    i = 1\n    for (l, r) in a:\n        mid = l + (r - l) // 2\n        ans[mid] = i\n        i += 1\n    print(*ans)", "import heapq\n\ndef bfs():\n    n = int(input())\n    a = [0 for i in range(0, n + 1)]\n    cnt = 1\n    subara = [(-n, 1)]\n    heapq.heapify(subara)\n    for itr in range(1, n + 1):\n        now = heapq.heappop(subara)\n        l = now[1]\n        r = now[1] + -now[0] - 1\n        f = -now[0] % 2 == 0\n        id = (l + r - f) // 2\n        a[id] = cnt\n        cnt += 1\n        if id != l:\n            heapq.heappush(subara, (-(id - l), l))\n        if id != r:\n            heapq.heappush(subara, (-(r - id), id + 1))\n    for i in range(1, n + 1):\n        print(a[i], end=' ')\n    print('')\nt = int(input())\nwhile t >= 1:\n    t -= 1\n    bfs()", "import heapq as hq\nfor _ in range(int(input())):\n    n = int(input())\n    h = [[-n, 1, n]]\n    a = [0] * (n + 1)\n    i = 1\n    while h:\n        (len, l, r) = hq.heappop(h)\n        mid = (l + r) // 2\n        if r > mid:\n            hq.heappush(h, [-(r - mid), mid + 1, r])\n        if l < mid:\n            hq.heappush(h, [-(mid - l), l, mid - 1])\n        a[mid] = i\n        i += 1\n    print(*a[1:n + 1])", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    a = [0] * n\n    h = [(-n, 0)]\n    num = 1\n\n    def push(l, start):\n        if l <= 0:\n            return\n        heappush(h, (-l, start))\n    while h:\n        (l, i) = heappop(h)\n        l = -l\n        mid = i + (l - 1) // 2\n        a[mid] = num\n        num += 1\n        push(mid - i, i)\n        push(i + l - mid - 1, mid + 1)\n    print(*a)", "import heapq as heap\nfor _ in range(int(input())):\n    n = int(input())\n    ans = [0] * n\n    ar = []\n    heap.heappush(ar, (n, 0, n - 1))\n    for i in range(1, n + 1):\n        (size, l, h) = heap.heappop(ar)\n        if (h - l + 1) % 2 == 0:\n            mid = (l + h - 1) // 2\n            ans[mid] = i\n        else:\n            mid = (l + h) // 2\n            ans[mid] = i\n        if h - mid > 0:\n            heap.heappush(ar, (-(h - mid), mid + 1, h))\n        if mid - l > 0:\n            heap.heappush(ar, (-(mid - l), l, mid - 1))\n    print(*ans)", "import heapq\nfor _ in [0] * int(input()):\n    n = int(input())\n    q = []\n    heapq.heappush(q, (-n, 0, n - 1))\n    a = [0] * n\n    i = 1\n    while len(q):\n        (x, l, r) = heapq.heappop(q)\n        m = l + r >> 1\n        a[m] = i\n        i += 1\n        if l != m:\n            heapq.heappush(q, (l - m, l, m - 1))\n        if r != m:\n            heapq.heappush(q, (m - r, m + 1, r))\n    print(*a)", "from heapq import heapify, heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    q = []\n    heappush(q, (-n, 0, n - 1))\n    a = [0] * n\n    i = 1\n    while len(q):\n        (x, l, r) = heappop(q)\n        m = (l + r) // 2\n        a[m] = i\n        i += 1\n        if l != m:\n            heappush(q, (l - m, l, m - 1))\n        if r != m:\n            heappush(q, (m - r, m + 1, r))\n    for i in a:\n        print(i, end=' ')\n    print()", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    action = 1\n    res = [0] * n\n    heap = [(-(n - 1), 0, n - 1)]\n    while heap:\n        (d, i, j) = heapq.heappop(heap)\n        ind = (i + j) // 2\n        res[ind] = action\n        if i <= ind - 1:\n            heapq.heappush(heap, (-(ind - 1 - i), i, ind - 1))\n        if ind + 1 <= j:\n            heapq.heappush(heap, (-(j - (ind + 1)), ind + 1, j))\n        action += 1\n    for i in range(n):\n        print(res[i], end=' ')\n    print()"]