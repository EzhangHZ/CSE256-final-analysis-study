["MOD = 10 ** 9 + 7\nN = 200001\nfact = [1]\nfor i in range(1, N + 1):\n    fact.append(fact[-1] * i % MOD)\n\ndef nCr(n, r):\n    if n <= r:\n        return n == r\n    a = fact[n]\n    b = fact[n - r] * fact[r] % MOD\n    b = pow(b, MOD - 2, MOD)\n    return a * b % MOD\nimport math\nimport bisect\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = 0\n    sequence = list(map(int, input().split()))\n    if sequence.count(sequence[0]) == len(sequence):\n        print(math.comb(len(sequence), m) % MOD)\n    else:\n        sequence.sort()\n        for j in range(n - m + 1):\n            last = bisect.bisect_right(sequence, sequence[j] + k)\n            ans += nCr(last - j - 1, m - 1)\n        print(ans % MOD)", "import sys\nfrom bisect import bisect_right\nr = sys.stdin.readline\nMOD = 10 ** 9 + 7\nN = 200001\nfact = [1]\nfor i in range(1, N + 1):\n    fact.append(fact[-1] * i % MOD)\n\ndef nCr(n, r):\n    if n <= r:\n        return n == r\n    a = fact[n]\n    b = fact[n - r] * fact[r] % MOD\n    b = pow(b, MOD - 2, MOD)\n    return a * b % MOD\nfor _ in range(int(r())):\n    (n, m, k) = map(int, r().split())\n    seq = list(map(int, r().split()))\n    seq.sort()\n    ans = 0\n    for i in range(n - m + 1):\n        j = bisect_right(seq, seq[i] + k, lo=i + 1)\n        idx = j - i - 1\n        ans += nCr(idx, m - 1)\n        ans %= MOD\n    print(ans)", "import sys\nfrom bisect import bisect_right\nr = sys.stdin.readline\nMOD = 10 ** 9 + 7\nN = 200001\nfact = [1]\nfor i in range(1, N + 1):\n    fact.append(fact[-1] * i % MOD)\n\ndef nCr(n, r):\n    if n <= r:\n        return n == r\n    a = fact[n]\n    b = fact[n - r] * fact[r] % MOD\n    b = pow(b, MOD - 2, MOD)\n    return a * b % MOD\nfor _ in range(int(r())):\n    (n, m, k) = map(int, r().split())\n    seq = list(map(int, r().split()))\n    seq.sort()\n    ans = 0\n    for i in range(n - m + 1):\n        j = bisect_right(seq, seq[i] + k, lo=i + 1)\n        idx = j - i - 1\n        ans += nCr(idx, m - 1)\n        ans %= MOD\n    print(ans)", "import bisect\nmod = 10 ** 9 + 7\nN = 200001\nfact = [1]\nfor i in range(1, N + 1):\n    fact.append(fact[-1] * i % mod)\n\ndef nCr(n, r):\n    if n <= r:\n        return n == r\n    a = fact[n]\n    b = fact[n - r] * fact[r] % mod\n    b = pow(b, mod - 2, mod)\n    return a * b % mod\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = 0\n    sequence = list(map(int, input().split()))\n    if sequence.count(sequence[0]) == len(sequence):\n        print(nCr(len(sequence), m) % mod)\n    else:\n        sequence.sort()\n        for j in range(n - m + 1):\n            last = bisect.bisect_right(sequence, sequence[j] + k)\n            ans += nCr(last - j - 1, m - 1)\n        print(ans % mod)", "import bisect\nmod = 10 ** 9 + 7\nN = 200001\nfact = [1]\nfor i in range(1, N + 1):\n    fact.append(fact[-1] * i % mod)\n\ndef nCr(n, r):\n    if n <= r:\n        return n == r\n    a = fact[n]\n    b = fact[n - r] * fact[r] % mod\n    b = pow(b, mod - 2, mod)\n    return a * b % mod\nfor i in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = 0\n    sequence = list(map(int, input().split()))\n    if sequence.count(sequence[0]) == len(sequence):\n        print(nCr(len(sequence), m) % mod)\n    else:\n        sequence.sort()\n        for j in range(n - m + 1):\n            last = bisect.bisect_right(sequence, sequence[j] + k)\n            ans += nCr(last - j - 1, m - 1)\n        print(ans % mod)", "import sys\nimport math, bisect, operator\n(inf, mod) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 5)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\nfact = [1]\nfor i in range(1, 2 * 10 ** 5 + 1):\n    fact += [fact[-1] * i % mod]\nfor _ in range(I()):\n    (n, m, k) = neo()\n    A = Neo()\n    A.sort()\n    Ans = 0\n    m -= 1\n    for i in range(n):\n        t = bisect.bisect_right(A, A[i] + k) - i - 1\n        if t >= m:\n            Ans += fact[t] * pow(fact[t - m] * fact[m] % mod, mod - 2, mod)\n            Ans = Ans % mod\n    print(Ans)", "import sys\ninput = sys.stdin.readline\nmod = MOD = 10 ** 9 + 7\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef printNcR(n, r):\n    if n < r:\n        return 0\n    a = fac[n]\n    b = fac[n - r] * fac[r] % MOD\n    b = pow(b, MOD - 2, MOD)\n    return a * b % MOD\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    lis = sorted(map(int, input().split()))\n    i = j = ans = 0\n    while i < n:\n        if lis[j] - lis[i] <= k:\n            j += 1\n        else:\n            ans = (printNcR(j - i - 1, m - 1) + ans) % mod\n            i += 1\n        if j == n:\n            break\n    while i < n:\n        ans = (printNcR(j - i - 1, m - 1) + ans) % mod\n        i += 1\n    print(ans)", "t = int(input())\nMOD = 10 ** 9 + 7\nlazyfac = [1, 1]\ninversfac = [1, 1]\n\ndef upfac(lazyfac, inversefac, n):\n    while len(lazyfac) < n + 1:\n        lazyfac.append(lazyfac[-1] * len(lazyfac) % MOD)\n        inversfac.append(pow(lazyfac[-1], -1, MOD))\n\ndef choose(n, m):\n    return lazyfac[n] * inversfac[n - m] * inversfac[m]\nfor test in range(t):\n    (n, m, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    a.sort()\n    upfac(lazyfac, inversfac, n + 20)\n    ans = 0\n    j = 0\n    if m == 1:\n        ans = n\n    else:\n        for i in range(n - m + 1):\n            if j < n:\n                while a[j] <= a[i] + k:\n                    j += 1\n                    if j == n:\n                        break\n            if j >= i + m:\n                ans += choose(j - i - 1, m - 1)\n                ans = ans % MOD\n    print(ans)", "import bisect\nimport sys\ninput = sys.stdin.readline\nm = 1000000007\nft = [1] * 200006\nfor i in range(1, 200006):\n    ft[i] = i * ft[i - 1] % m\n\ndef cb(a, b):\n    if b > a:\n        return 0\n    x = ft[b] * ft[a - b]\n    x = pow(x, m - 2, m) % m\n    x = ft[a] * x\n    x = x % m\n    return x\nfor _ in range(int(input())):\n    (n, j, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    ans = 0\n    for i in range(n):\n        y = arr[i] + k\n        id = bisect.bisect(arr, y)\n        ans += cb(id - i - 1, j - 1)\n        ans = ans % m\n    print(ans)", "import math\nT = int(input())\nr = 1\n\ndef decrease(m, n, pre):\n    pre = pre * (m - n)\n    pre = pre // m\n    return pre\n\ndef increase(m, n, pre):\n    pre = pre * (m + 1)\n    pre = pre // (m - n + 1)\n    return pre\nwhile r <= T:\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ans = 0\n    arr = sorted(arr)\n    temp = 1\n    front = -1\n    for i in range(n):\n        while arr[i] - arr[front + 1] > k:\n            if i - 1 - front > m:\n                temp = decrease(i - front - 2, m - 1, temp)\n            elif i - 1 - front == m:\n                temp = 1\n            front += 1\n        if i - front > m:\n            temp = increase(i - front - 2, m - 1, temp)\n        if i - front >= m:\n            ans += temp % (10 ** 9 + 7)\n        ans = ans % (10 ** 9 + 7)\n    print(ans)\n    r += 1", "t = int(input())\nfor tc in range(t):\n    l = input().split()\n    n = int(l[0])\n    m = int(l[1])\n    k = int(l[2])\n    v = input().split()\n    for i in range(n):\n        v[i] = int(v[i])\n    v.sort()\n    if n < m:\n        print(0)\n    else:\n        comb = []\n        for i in range(n):\n            comb.append(1)\n        for i in range(m, n):\n            comb[i] = comb[i - 1] * i // (i - m + 1)\n        j = m - 1\n        su = 0\n        for i in range(0, n - m + 1):\n            while j < n and v[j] - v[i] <= k:\n                j = j + 1\n            if j - i >= m:\n                su = (su + comb[j - i - 1]) % 1000000007\n        print(su)", "import sys\ninput = sys.stdin.readline\nmod_ = 10 ** 9 + 7\nfactos = [1]\ninv_factos = []\nfor elem in range(1, 2 * 10 ** 5 + 1):\n    factos.append(factos[-1] * elem % mod_)\nfor val in factos:\n    inv_factos.append(pow(val, mod_ - 2, mod_))\n\ndef solution(n, m, k, arr):\n    left = 0\n    right = 0\n    sol = 0\n    arr.sort()\n\n    def c_C_r(c, r):\n        if c < r:\n            return 0\n        return factos[c] * inv_factos[r] * inv_factos[c - r] % mod_\n    while left < n:\n        while right <= n - 1 and arr[left] + k >= arr[right]:\n            right += 1\n        sol = (sol + c_C_r(right - left - 1, m - 1)) % mod_\n        left += 1\n    print(sol)\nT = int(input())\nfor t in range(T):\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    solution(n, m, k, arr)", "import sys\ninput = sys.stdin.readline\nmod_ = 10 ** 9 + 7\nfactos = [1 for _ in range(2 * 10 ** 5 + 1)]\ninv_factos = [1 for _ in range(2 * 10 ** 5 + 1)]\nfor elem in range(1, 2 * 10 ** 5 + 1):\n    factos[elem] = factos[elem - 1] * elem % mod_\nfor pos in range(2 * 10 ** 5 + 1):\n    inv_factos[pos] = pow(factos[pos], mod_ - 2, mod_)\n\ndef solution(n, m, k, arr):\n    left = 0\n    right = 0\n    sol = 0\n    arr.sort()\n\n    def c_C_r(c, r):\n        if c < r:\n            return 0\n        return factos[c] * inv_factos[r] * inv_factos[c - r] % mod_\n    while left < n:\n        while right <= n - 1 and arr[left] + k >= arr[right]:\n            right += 1\n        sol = (sol + c_C_r(right - left - 1, m - 1)) % mod_\n        left += 1\n    print(sol)\nT = int(input())\nfor t in range(T):\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    solution(n, m, k, arr)", "mod = 1000000007\nfact = [1]\n\ndef inv(a):\n    return pow(a, mod - 2, mod)\n\ndef C(n, k):\n    if k > n:\n        return 0\n    return fact[n] * inv(fact[k] * fact[n - k] % mod) % mod\n\ndef fac(n, p):\n    for i in range(p, n + 1):\n        fact.append(fact[i - 1] * i % mod)\n        p = p + 1\n    return p\n\ndef initialize(n, p):\n    if n > p:\n        return fac(n, p)\n    else:\n        return p\nt = int(input())\np = 1\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = initialize(n, p)\n    a.sort()\n    l = 0\n    s = 0\n    for j in range(n):\n        while a[j] - a[l] > k and l <= j:\n            l = l + 1\n        s = (s + C(j - l, m - 1)) % mod\n    print(s)", "import bisect\nimport math\nm = 1000000007\nft = [1] * 200006\nfor i in range(1, 200006):\n    ft[i] = i * ft[i - 1] % m\n\ndef cb(a, b):\n    if b > a:\n        return 0\n    x = ft[b] * ft[a - b]\n    x = pow(x, m - 2, m) % m\n    x = ft[a] * x\n    x = x % m\n    return x\nfor _ in range(int(input())):\n    (n, j, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort()\n    ans = 0\n    for i in range(n):\n        y = arr[i] + k\n        id = bisect.bisect(arr, y)\n        ans += cb(id - i - 1, j - 1)\n        ans = ans % m\n    print(ans)", "from bisect import bisect\nmod = 10 ** 9 + 7\n\ndef cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\nN = 5 * 10 ** 5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, N + 1):\n    g1.append(g1[-1] * i % mod)\n    inverse.append(-inverse[mod % i] * (mod // i) % mod)\n    g2.append(g2[-1] * inverse[-1] % mod)\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        b = bisect(a, a[i] + k)\n        ans += cmb(b - i - 1, m - 1, mod)\n        ans %= mod\n    print(ans)", "delta = 10 ** 9 + 7\nfactorial = [1] * 200001\ninverse = [1] * 200001\nfor i in range(1, 200001):\n    factorial[i] = factorial[i - 1] * i % delta\n    inverse[i] = pow(factorial[i], delta - 2, delta)\nt = int(input())\nflag = True\nfor _ in range(t):\n    (n, m, k) = tuple(map(int, input().split()))\n    if n < m:\n        input()\n        print(0)\n        continue\n    if m == 1:\n        input()\n        print(n)\n        continue\n    sequence = list(map(int, input().split()))\n    sequence.sort()\n    j = 1\n    ans = 0\n    for i in range(n):\n        while j < n and sequence[j] - sequence[i] <= k:\n            j += 1\n        ans += 0 if j - i < m else factorial[j - i - 1] * inverse[m - 1] * inverse[j - i - m] % delta\n    print(ans % delta)", "mod = pow(10, 9) + 7\nfact = [1]\nfor i in range(1, 200001):\n    fact.append(fact[i - 1] * i % mod)\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef c(n, r):\n    return fact[n] * modinv(fact[n - r] * fact[r] % mod, mod) % mod\n\ndef find(a, low, k, m):\n    ele = a[low]\n    j = low\n    high = len(a) - 1\n    (pl, ph) = (low, high)\n    while low < high:\n        mid = (low + high) // 2\n        if a[mid] - ele <= k:\n            low = mid\n        else:\n            high = mid - 1\n        if pl == low and ph == high:\n            break\n        (pl, ph) = (low, high)\n    if a[high] - ele <= k:\n        low = high\n    if low - j >= m - 1:\n        return c(low - j, m - 1)\n    else:\n        return 0\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    res = 0\n    for i in range(n - m + 1):\n        res += find(a, i, k, m)\n        res %= mod\n    print(res)", "import sys\nM = 10 ** 9 + 7\na = [1]\nfor i in range(1, 8 ** 6):\n    a += (a[-1] * i % M,)\nR = lambda : map(int, sys.stdin.readline().split())\nf = lambda x: x >= m and a[x] * pow(a[x - m], M - 2, M)\n(t,) = R()\nfor _ in [0] * t:\n    (n, m, k) = R()\n    c = [0] * n\n    for x in R():\n        c[x - 1] += 1\n    for i in range(n - 1):\n        c[i + 1] += c[i]\n    print(sum((f(z - x) - f(y - x) for (x, y, z) in zip([0] + [0] * k + c, [0] + c, c))) * pow(a[m], M - 2, M) % M)", "import sys\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\nI = lambda : list(map(int, input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\n\ndef solve():\n    (n, m, k) = I()\n    a = I()\n    a.sort()\n    ans = 0\n    (i, j) = (m - 1, 0)\n    while i < n:\n        while j < i and a[i] - a[j] > k:\n            j += 1\n        length = i - j\n        ans += nCk(length, m - 1)\n        ans %= MOD\n        i += 1\n    print(ans)\n(t,) = I()\nwhile t:\n    t -= 1\n    solve()", "MOD = 10 ** 9 + 7\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    (i, j) = (m - 1, 0)\n    while i < n:\n        while j < i and a[i] - a[j] > k:\n            j += 1\n        length = i - j\n        ans += nCk(length, m - 1)\n        ans %= MOD\n        i += 1\n    print(ans)", "def modInverse(a, m):\n    assert m > 0, 'Error'\n    (x, y) = (1, 0)\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        (x, y) = (y, x - q * y)\n        (a, m) = (m, a % m)\n    return x\n\ndef C(n, r, fact, inv, mod):\n    if r > n or r < 0:\n        return 0\n    res = fact[n] * inv[r] % mod\n    res = res * inv[n - r] % mod\n    return res\nM = 10 ** 9 + 7\n(fact, inv) = ([1], [1])\nfor i in range(200007):\n    fact.append(fact[-1] * (i + 1) % M)\n    inv.append((modInverse(fact[-1], M) + M) % M)\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n < m:\n        print(0)\n        continue\n    a.sort()\n    (p1, p2, tot) = (0, m - 1, 0)\n    while p1 < n - m + 1:\n        while p2 < n and a[p2] - a[p1] <= k:\n            p2 += 1\n        dif = p2 - p1 - 1\n        tot += C(dif, m - 1, fact, inv, M)\n        tot %= M\n        p1 += 1\n    print(tot)", "import sys, math, heapq, queue\nfrom collections import deque\nfrom functools import cmp_to_key\nfast_input = sys.stdin.readline\nMOD = 10 ** 9 + 7\nfor _ in range(int(fast_input())):\n    (n, m, k) = map(int, fast_input().split())\n    a = sorted(list(map(int, fast_input().split())))\n    high = 0\n    ans = 0\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = i * fact[i - 1] % MOD\n\n    def calc(t, c):\n        res = fact[t] * pow(fact[c], MOD - 2, MOD) % MOD\n        return res * pow(fact[t - c], MOD - 2, MOD) % MOD\n    for i in range(n):\n        while high < n and a[high] - a[i] <= k:\n            high += 1\n        if high - i >= m:\n            ans = (ans + calc(high - i - 1, m - 1)) % MOD\n    print(ans)", "import bisect\nn = 200005\nMOD = 10 ** 9 + 7\nfact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = i * fact[i - 1] % MOD\n\ndef calc(t, c):\n    res = fact[t] * pow(fact[c], MOD - 2, MOD) % MOD\n    return res * pow(fact[t - c], MOD - 2, MOD) % MOD\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        now = a[i] + k\n        val = bisect.bisect_right(a, now)\n        val -= i\n        if val >= m:\n            ans = (calc(val - 1, m - 1) + ans) % 1000000007\n    print(ans)", "MOD = 10 ** 9 + 7\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nfor iii in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = sorted(list(map(int, input().split())))\n    ans = 0\n    j = 0\n    for i in range(m - 1, n):\n        while j < i and a[i] - a[j] > k:\n            j += 1\n        length = i - j\n        ans += nCk(length, m - 1)\n        ans %= MOD\n    print(ans)", "mod = 1000000007\nnum = 3 * 10 ** 5\nfact = [1] * num\nfor i in range(1, num):\n    fact[i] = fact[i - 1] * i % mod\n\ndef choose(n, k):\n    if n >= k:\n        return fact[n] * pow(fact[n - k], mod - 2, mod) * pow(fact[k], mod - 2, mod) % mod\n    return 0\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    lis = list(map(int, input().split()))\n    lis = sorted(lis)\n    ans = 0\n    (i, j) = (m - 1, 0)\n    while i < n:\n        while j < i and lis[i] - lis[j] > k:\n            j += 1\n        ans += choose(i - j, m - 1)\n        ans %= mod\n        i += 1\n    print(ans)", "def modulo(n, prime, dp1):\n    dp1[0] = dp1[1] = 1\n    for j in range(2, n + 1):\n        dp1[j] = dp1[j - 1] * j % prime\nt = int(input())\nfor i in range(t):\n    (n, m, p) = map(int, input().split())\n    mod1 = int(1000000000.0 + 7)\n    a = list(map(int, input().split()))\n    a.sort()\n    val = 0\n    j = 0\n    k = 0\n    dp1 = [0] * (n + 1)\n    modulo(n, mod1, dp1)\n    while j < n:\n        while j + k < n and a[j + k] - a[j] <= p:\n            k += 1\n        if k >= m:\n            val = (val + dp1[k - 1] * (pow(dp1[m - 1], mod1 - 2, mod1) * pow(dp1[k - 1 - (m - 1)], mod1 - 2, mod1)) % mod1 % mod1) % mod1\n        k -= 1\n        j += 1\n    print(val)", "MOD = 10 ** 9 + 7\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nt = int(input())\nfor iii in range(t):\n    (n, m, k) = map(int, input().split())\n    a = sorted(list(map(int, input().split())))\n    ans = 0\n    (i, j) = (m - 1, 0)\n    while i < n:\n        while j < i and a[i] - a[j] > k:\n            j += 1\n        length = i - j\n        ans += nCk(length, m - 1)\n        ans %= MOD\n        i += 1\n    print(ans)", "MOD = 10 ** 9 + 7\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nfor iii in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = sorted(list(map(int, input().split())))\n    ans = 0\n    j = 0\n    for i in range(m - 1, n):\n        while j < i and a[i] - a[j] > k:\n            j += 1\n        length = i - j\n        ans += nCk(length, m - 1)\n        ans %= MOD\n    print(ans)", "MOD = 10 ** 9 + 7\nM = 3 * 10 ** 5\nfac = [1] * M\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nfor iii in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = sorted(list(map(int, input().split())))\n    ans = 0\n    j = 0\n    for i in range(m - 1, n):\n        while j < i and a[i] - a[j] > k:\n            j += 1\n        length = i - j\n        ans += nCk(length, m - 1)\n        ans %= MOD\n    print(ans)", "R = lambda : map(int, input().split())\nmod = 10 ** 9 + 7\nfac = [1] * (2 * 10 ** 5 + 7)\nfor i in range(2, len(fac)):\n    fac[i] = fac[i - 1] * i % mod\n\ndef cnk(nn, kk):\n    return fac[nn] * pow(fac[nn - kk], mod - 2, mod) * pow(fac[kk], mod - 2, mod) % mod\nfor _ in range(int(input())):\n    (n, m, k) = R()\n    arr = sorted(R())\n    i = 0\n    nck = [1] * (n + 1)\n    for j in range(m, n + 1):\n        nck[j] = nck[j - 1] * j // (j - m + 1) % mod\n    res = 0\n    for j in range(m - 1, n):\n        while i < j and arr[j] - arr[i] > k:\n            i += 1\n        if j - i + 1 >= m:\n            res = (res + cnk(j - i, m - 1)) % mod\n    print(res)", "M = 3 * 10 ** 5\nfac = [1] * M\nMOD = 1000000007\nfor i in range(1, M):\n    fac[i] = fac[i - 1] * i % MOD\n\ndef nCk(n, k):\n    if n < k:\n        return 0\n    return fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    c = 0\n    j = 0\n    i = 0\n    while i < n:\n        if j < n and arr[i] - arr[j] <= k:\n            j += 1\n        else:\n            if j - i > m - 1:\n                c = (c + nCk(j - i - 1, m - 1)) % MOD\n            i += 1\n    print(c)"]