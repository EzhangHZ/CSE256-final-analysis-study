["import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    e = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        e[u].append(v)\n        e[v].append(u)\n    dp = [n] * (n + 1)\n    s = [1]\n    vis = [0] * (n + 1)\n    order = []\n    parent = [-1] * (n + 1)\n    while len(s):\n        x = s.pop()\n        vis[x] = 1\n        order.append(x)\n        c = 0\n        for y in e[x]:\n            if vis[y]:\n                continue\n            c = 1\n            s.append(y)\n            vis[y] = 1\n            parent[y] = x\n        if c == 0:\n            dp[x] = 0\n    order.reverse()\n    order.pop()\n    for y in order:\n        x = parent[y]\n        dp[x] = min(dp[x], dp[y] + 1)\n    c = 0\n    res = 0\n    mx = 0\n    mx2 = 0\n    for y in e[1]:\n        mx = max(mx, dp[y] + 1)\n    for y in e[1]:\n        if dp[y] + 1 != mx:\n            mx2 = max(mx2, dp[y] + 1)\n    for y in e[1]:\n        c += dp[y] == mx - 1\n    if c > 1:\n        res = mx + 1\n    else:\n        res = max(mx, mx2 + 1)\n    for x in range(2, n + 1):\n        t = 0\n        c = len(e[x]) - 1\n        for y in e[x]:\n            if y != parent[x]:\n                t = max(t, dp[y] + 1)\n        if c > 1:\n            res = max(res, t + 1)\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    dic = [[] for _ in range(n + 1)]\n    gress = [0] * (n + 1)\n    gress[1] += 1\n    father = [0] * (n + 1)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        dic[u].append(v)\n        dic[v].append(u)\n    now = [1]\n    s = [[] for _ in range(n + 1)]\n    leaf = []\n    while now:\n        node = now.pop()\n        for child in dic[node]:\n            if child != father[node]:\n                gress[node] += 1\n                father[child] = node\n                now.append(child)\n        if gress[node] == 0:\n            leaf.append(node)\n    while leaf:\n        node = leaf.pop()\n        f = father[node]\n        if not s[node]:\n            s[f].append((1, 0))\n        elif len(s[node]) == 1:\n            (d, k) = s[node][0]\n            s[f].append((d + 1, k))\n        else:\n            d = min((p[0] for p in s[node])) + 1\n            k = max(max((p[1] for p in s[node])), max((p[0] for p in s[node])) + 1)\n            s[f].append((d, k))\n        gress[f] -= 1\n        if gress[f] == 0:\n            leaf.append(f)\n    node = 1\n    if len(s[node]) == 1:\n        print(max(s[node][0]))\n    else:\n        k = max((p[1] for p in s[node]))\n        tmp = [p[0] for p in s[node]]\n        m = max(tmp)\n        tmp.remove(m)\n        print(max(max(tmp) + 1, m, k))", "for _ in range(int(input())):\n    n = int(input())\n    dic = [[] for _ in range(n + 1)]\n    gress = [0] * (n + 1)\n    gress[1] += 1\n    father = [0] * (n + 1)\n    now = [1]\n    s = [[] for _ in range(n + 1)]\n    leaf = []\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        dic[u].append(v)\n        dic[v].append(u)\n    while now:\n        node = now.pop()\n        for child in dic[node]:\n            if child != father[node]:\n                gress[node] += 1\n                father[child] = node\n                now.append(child)\n        if gress[node] == 0:\n            leaf.append(node)\n    while leaf:\n        node = leaf.pop()\n        f = father[node]\n        if not s[node]:\n            s[f].append((1, 0))\n        elif len(s[node]) == 1:\n            (d, k) = s[node][0]\n            s[f].append((d + 1, k))\n        else:\n            d = min((p[0] for p in s[node])) + 1\n            k = max(max((p[1] for p in s[node])), max((p[0] for p in s[node])) + 1)\n            s[f].append((d, k))\n        gress[f] -= 1\n        if gress[f] == 0:\n            leaf.append(f)\n    node = 1\n    if len(s[node]) == 1:\n        print(max(s[node][0]))\n    else:\n        k = max((p[1] for p in s[node]))\n        tmp = [p[0] for p in s[node]]\n        m = max(tmp)\n        tmp.remove(m)\n        print(max(max(tmp) + 1, m, k))"]