["def bfs(adj, root):\n    q = [(root, 0)]\n    dist = [0] * len(adj)\n    vis = {root}\n    i = 0\n    while i < len(q):\n        (u, d) = q[i]\n        i += 1\n        dist[u] = d\n        for v in adj[u]:\n            if v not in vis:\n                vis.add(v)\n                q.append((v, d + 1))\n    return dist\n\ndef sol(n, sfs, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dista = bfs(adj, 1)\n    distb = bfs(adj, n)\n    orig = distb[1]\n    ans = 0\n    sfs.sort(key=lambda sf: dista[sf] - distb[sf])\n    maxdista = dista[sfs[0]]\n    for fs in sfs[1:]:\n        ans = max(ans, maxdista + distb[fs])\n        maxdista = max(maxdista, dista[fs])\n    return min(orig, ans + 1)\n(n, m, _) = map(int, input().split())\nsfs = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(sol(n, sfs, edges))", "import sys\nimport collections\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\n(n, m, k) = ints()\nspecial = ints()\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    (x, y) = ints()\n    graph[x].append(y)\n    graph[y].append(x)\nd1 = [-1 for _ in range(n + 1)]\nq = collections.deque([1])\ndepth = 1\nd1[1] = 0\nwhile q:\n    for _ in range(len(q)):\n        node = q.popleft()\n        for nb in graph[node]:\n            if d1[nb] == -1:\n                q.append(nb)\n                d1[nb] = depth\n    depth += 1\nd2 = [-1 for _ in range(n + 1)]\nq = collections.deque([n])\ndepth = 1\nd2[n] = 0\nwhile q:\n    for _ in range(len(q)):\n        node = q.popleft()\n        for nb in graph[node]:\n            if d2[nb] == -1:\n                q.append(nb)\n                d2[nb] = depth\n    depth += 1\nans = d2[1]\ns_distances = [(d1[i], d2[i]) for i in special]\ns_distances.sort(key=lambda x: x[1], reverse=True)\nmx = 0\nfor i in range(len(s_distances) - 1):\n    l = s_distances[i + 1][1] + 1 + s_distances[i][0]\n    mx = max(mx, l)\nprint(min(ans, mx))", "from collections import deque\nimport sys\n(n, m, k) = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\ng = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    (x, y) = map(int, sys.stdin.readline().split())\n    g[x].append(y)\n    g[y].append(x)\n\ndef bfs(start):\n    hold = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(start)\n    h = 0\n    while len(q) > 0:\n        for _ in range(len(q)):\n            node = q.popleft()\n            visited[node] = True\n            hold[node] = h\n            for child in g[node]:\n                if not visited[child]:\n                    visited[child] = True\n                    q.append(child)\n        h += 1\n    return hold\nx = bfs(1)\ny = bfs(n)\narr = sorted([(x[i] - y[i], i) for i in a])\n(pref, ans) = (-1000000000.0, -1000000000.0)\nfor (v, node) in arr:\n    ans = max(ans, pref + y[node])\n    pref = max(pref, x[node])\nprint(min(x[n], ans + 1))", "def main():\n    (n, m, k) = [int(s) for s in input().strip().split()]\n    A = [int(s) for s in input().strip().split()]\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (u, v) = [int(s) for s in input().strip().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def bfs(u):\n        result = [float('inf')] * (n + 1)\n        result[u] = 0\n        step = 0\n        q = [u]\n        while q:\n            step += 1\n            newq = []\n            for u in q:\n                for v in adj[u]:\n                    if result[v] == float('inf'):\n                        result[v] = step\n                        newq.append(v)\n            q = newq\n        return result\n    X = bfs(1)\n    Y = bfs(n)\n    A.sort(key=lambda a: X[a] - Y[a])\n    (result, maxx) = (float('-inf'), float('-inf'))\n    for a in A:\n        result = max(result, maxx + Y[a])\n        maxx = max(maxx, X[a])\n    result = min(X[n], result + 1)\n    print(result)\nmain()", "import sys\nfrom collections import deque\ninput = lambda : sys.stdin.readline().strip()\n(n, m, k) = map(int, input().split())\nbfs = deque()\nbfs.append(0)\nkol = list(map(int, input().split()))\nv = [[] for i in range(n)]\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    b -= 1\n    a -= 1\n    v[a].append(b)\n    v[b].append(a)\nlvl = [-1] * n\nlvl[0] = 0\nwhile bfs:\n    u = bfs.popleft()\n    for i in v[u]:\n        if lvl[i] == -1:\n            bfs.append(i)\n            lvl[i] = lvl[u] + 1\nbfs.append(n - 1)\nlvl1 = [-1] * n\nlvl1[n - 1] = 0\nwhile bfs:\n    u = bfs.popleft()\n    for i in v[u]:\n        if lvl1[i] == -1:\n            bfs.append(i)\n            lvl1[i] = lvl1[u] + 1\nkol.sort(key=lambda x: lvl[x - 1] - lvl1[x - 1])\nmins = [0]\nfor i in range(k):\n    mins.append(max(lvl1[kol[-i - 1] - 1], mins[-1]))\nmins.reverse()\nans = 0\nfor i in range(k - 1):\n    ans = max(ans, lvl[kol[i] - 1] + mins[i + 1] + 1)\nprint(min(lvl1[0], ans))", "from math import *\nfrom collections import deque\nINF = 1 << 60\n\ndef main():\n    (n, m, k) = map(int, input().split(' '))\n    spec = set(map(int, input().split(' ')))\n    adjl = [[] for _ in range(0, n + 1)]\n    for i in range(0, m):\n        (u, v) = map(int, input().split(' '))\n        adjl[u].append(v)\n        adjl[v].append(u)\n    srcdst = bfs(n, adjl, 1)\n    enddst = bfs(n, adjl, n)\n    diff = [[srcdst[i] - enddst[i], i] for i in range(1, n + 1) if i in spec]\n    diff.sort(key=lambda x: x[0])\n    mxsrc = -INF\n    res = 0\n    for x in range(0, len(diff)):\n        res = max(res, mxsrc + enddst[diff[x][1]] + 1)\n        mxsrc = max(mxsrc, srcdst[diff[x][1]])\n    print(min(srcdst[n], res))\n\ndef bfs(n, adjl, src):\n    q = deque()\n    q.append(src)\n    odist = [INF for _ in range(0, n + 1)]\n    vis = [False for _ in range(0, n + 1)]\n    odist[src] = 0\n    vis[src] = True\n    while len(q) > 0:\n        cur = q.popleft()\n        for adj in adjl[cur]:\n            if not vis[adj]:\n                vis[adj] = True\n                odist[adj] = odist[cur] + 1\n                q.append(adj)\n    return odist\nmain()", "import math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\ndef bfs(s, t, edges, dist):\n    dist[t] = 0\n    step = 0\n    q = [t]\n    while q:\n        step += 1\n        nq = []\n        for u in q:\n            for v in edges[u]:\n                if step < dist[v]:\n                    dist[v] = step\n                    nq.append(v)\n        q = nq\n\ndef solve(N, M, K, A, edges):\n    dista = [N + 1 for _ in range(N + 1)]\n    distb = [N + 1 for _ in range(N + 1)]\n    bfs(1, N, edges, dista)\n    bfs(N, 1, edges, distb)\n    xyd = [(dista[i] - distb[i], i) for i in range(1, N + 1) if A[i]]\n    xyd.sort()\n    maxx = float('-inf')\n    best = 0\n    for (d, i) in xyd:\n        best = max(best, distb[i] + maxx)\n        maxx = max(maxx, dista[i])\n    return min(dista[1], best + 1)\n(N, M, K) = map(int, input().split())\nspecials = [int(x) for x in input().split()]\nA = [False for _ in range(N + 1)]\nfor v in specials:\n    A[v] = True\nedges = [[] for _ in range(N + 1)]\nfor i in range(M):\n    (u, v) = map(int, input().split())\n    edges[u].append(v)\n    edges[v].append(u)\nprint(solve(N, M, K, A, edges))", "from collections import deque\n\ndef bfs(g, source):\n    n = len(g)\n    d = [-1] * n\n    q = deque()\n    q.append(source)\n    d[source] = 0\n    while q:\n        u = q.popleft()\n        for v in g[u]:\n            if d[v] == -1:\n                d[v] = d[u] + 1\n                q.append(v)\n    return d\n(n, m, k) = [int(_) for _ in input().split()]\nspecials = [int(_) - 1 for _ in input().split()]\ng = [[] for i in range(n)]\nfor i in range(m):\n    (x, y) = [int(_) - 1 for _ in input().split()]\n    g[x].append(y)\n    g[y].append(x)\ndist_src = bfs(g, source=0)\ndist_tar = bfs(g, source=n - 1)\nspecials = list(zip([dist_src[u] for u in specials], [dist_tar[u] for u in specials]))\nspecials.sort()\nmax_suff = [0] * k\nmax_suff[k - 1] = specials[k - 1][1]\nfor i in range(k - 2, -1, -1):\n    max_suff[i] = max(max_suff[i + 1], specials[i][1])\nres = 0\nfor (i, u) in enumerate(specials):\n    if i + 1 < k:\n        res = max(res, u[0] + max_suff[i + 1] + 1)\nprint(min(res, dist_src[n - 1]))", "from collections import deque\n\ndef bfs(graph, source):\n    n = len(graph)\n    dis = [-1] * n\n    que = deque()\n    que.append(source)\n    dis[source] = 0\n    while que:\n        u = que.popleft()\n        for v in graph[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    return dis\n(n, m, k) = [int(_) for _ in input().split()]\na = [int(_) - 1 for _ in input().split()]\na.sort()\ng = [[] for i in range(n)]\nfor i in range(m):\n    (u, v) = [int(_) - 1 for _ in input().split()]\n    g[u].append(v)\n    g[v].append(u)\ndis_st = bfs(g, 0)\ndis_en = bfs(g, n - 1)\nnom = [(0, 0)] * k\nfor i in range(k):\n    nom[i] = (dis_st[a[i]] - dis_en[a[i]], a[i])\nnom.sort()\nans = 0\nMax = -1000000007\nfor tmp in nom:\n    t = tmp[1]\n    ans = max(ans, Max + dis_en[t])\n    Max = max(Max, dis_st[t])\nres = min(dis_st[n - 1], ans + 1)\nprint(res)"]