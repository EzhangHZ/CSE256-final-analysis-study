["import sys\n\ndef main():\n    res = ''\n    input = sys.stdin.readline\n    print = sys.stdout.write\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        s = input()\n        zeros = []\n        k_zeros = 0\n        ones = []\n        k_ones = 0\n        nums = []\n        k = 0\n        for i in range(n):\n            if s[i] == '1':\n                k_ones += 1\n                if k_zeros != 0:\n                    k_zeros -= 1\n                    nums.append(str(zeros[-1]))\n                    ones.append(zeros[-1])\n                    del zeros[-1]\n                else:\n                    k += 1\n                    ones.append(k)\n                    nums.append(str(k))\n            else:\n                k_zeros += 1\n                if k_ones != 0:\n                    k_ones -= 1\n                    nums.append(str(ones[-1]))\n                    zeros.append(ones[-1])\n                    del ones[-1]\n                else:\n                    k += 1\n                    zeros.append(k)\n                    nums.append(str(k))\n        res += str(k) + '\\n' + ' '.join(nums) + '\\n'\n    print(res)\nmain()", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nfrom collections import deque\n\ndef gift():\n    for _ in range(t):\n        n = int(input())\n        arry = input()\n        zstk = deque()\n        ostk = deque()\n        ans = [0] * n\n        (len0, len1) = (0, 0)\n        if arry[0] == '1':\n            ostk.append(1)\n            len1 += 1\n        else:\n            zstk.append(1)\n            len0 += 1\n        ans[0] = 1\n        curr = 1\n        for i in range(1, n):\n            if arry[i] == '1':\n                if len0 == 0:\n                    curr += 1\n                    len1 += 1\n                    ostk.append(curr)\n                    ans[i] = curr\n                else:\n                    ele = zstk.popleft()\n                    len0 -= 1\n                    len1 += 1\n                    ostk.append(ele)\n                    ans[i] = ele\n            elif len1 == 0:\n                curr += 1\n                len0 += 1\n                zstk.append(curr)\n                ans[i] = curr\n            else:\n                ele = ostk.popleft()\n                len1 -= 1\n                len0 += 1\n                zstk.append(ele)\n                ans[i] = ele\n        yield curr\n        yield ' '.join((str(x) for x in ans))\nt = int(input())\nans = gift()\nprint(*ans, sep='\\n')", "import sys\nfrom math import sqrt, gcd, ceil, log\nfrom collections import defaultdict, Counter, deque\ninput = sys.stdin.readline\nread = lambda : list(map(int, input().strip().split()))\n\ndef main():\n    ans_ = []\n    for _ in range(int(input())):\n        n = int(input())\n        s = input().strip()\n        stk = defaultdict(list)\n        ans_list = [0] * n\n        ans_list[0] = 1\n        stk[s[0]].append(1)\n        opp = {'0': '1', '1': '0'}\n        c = 1\n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                if stk[opp[s[i]]]:\n                    v = stk[opp[s[i]]].pop()\n                    ans_list[i] = v\n                    stk[s[i]].append(v)\n                else:\n                    c += 1\n                    ans_list[i] = c\n                    stk[s[i]].append(c)\n            else:\n                ans_list[i] = ans_list[i - 1]\n                stk[s[i]].append(stk[s[i - 1]].pop())\n        ans_.append(str(c) + '\\n' + ' '.join(map(str, ans_list)))\n    print('\\n'.join(ans_))\nmain()", "import sys\n\ndef solve(n, s):\n    ans = []\n    (a, b) = ([], [])\n    tg = 0\n    for x in s:\n        if x == '0':\n            if not b:\n                tg += 1\n                a.append(tg)\n            else:\n                g = b.pop()\n                a.append(g)\n            ans.append(a[-1])\n        else:\n            if not a:\n                tg += 1\n                b.append(tg)\n            else:\n                g = a.pop()\n                b.append(g)\n            ans.append(b[-1])\n    return (tg, ans)\nt = int(input())\nfor _ in range(t):\n    ln1 = next(sys.stdin)\n    n = int(ln1)\n    ln2 = next(sys.stdin)\n    s = ln2.strip()\n    (k, a) = solve(n, s)\n    print(k)\n    print(' '.join(map(str, a)))", "import sys\ninput = sys.stdin.readline\n\ndef name(arr):\n    from collections import deque\n    o = deque([])\n    z = deque([])\n    ans = []\n    count = 0\n    for i in range(len(arr[:-1])):\n        if arr[i] == '0':\n            if len(o) > 0:\n                popped = o.popleft()\n                z.append(popped)\n                ans.append(str(popped))\n            else:\n                count += 1\n                z.append(count)\n                ans.append(str(count))\n        elif arr[i] == '1':\n            if len(z) > 0:\n                popped = z.popleft()\n                o.append(popped)\n                ans.append(str(popped))\n            else:\n                count += 1\n                o.append(count)\n                ans.append(str(count))\n    print(count)\n    print(' '.join(ans))\n\ndef solution():\n    n = int(input())\n    arr = list(input())\n    name(arr)\nt = int(input())\nfor i in range(0, t):\n    solution()", "def solve():\n    n = int(input())\n    bits = input()\n    carry_zero = []\n    carry_one = []\n    teams = []\n    counter = 0\n    for bit in bits:\n        if bit == '0':\n            if carry_one:\n                team = carry_one.pop()\n            else:\n                counter += 1\n                team = str(counter)\n            carry_zero.append(team)\n        if bit == '1':\n            if carry_zero:\n                team = carry_zero.pop()\n            else:\n                counter += 1\n                team = str(counter)\n            carry_one.append(team)\n        teams.append(team)\n    place = ' '.join(teams)\n    return '{}\\n{}'.format(counter, place)\nn = int(input())\nfor i in range(n):\n    result = solve()\n    print(result)", "import math, sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfor _ in range(I()):\n    n = I()\n    s = S()\n    o = []\n    z = []\n    ans = 0\n    res = [0] * n\n    for i in range(n):\n        if s[i] == '0':\n            if len(o) == 0:\n                z.append(ans + 1)\n                ans += 1\n            else:\n                z.append(o.pop())\n            res[i] = z[-1]\n        else:\n            if len(z) == 0:\n                o.append(ans + 1)\n                ans += 1\n            else:\n                o.append(z.pop())\n            res[i] = o[-1]\n    print(ans)\n    print(*res)", "def calc(s, n):\n    k = 0\n    r = []\n    zeros = []\n    ones = []\n    for a in s:\n        if a == '0':\n            src = ones\n            dst = zeros\n        else:\n            src = zeros\n            dst = ones\n        if src:\n            x = src.pop()\n        else:\n            k += 1\n            x = str(k)\n        r.append(x)\n        dst.append(x)\n    return (k, ' '.join(r))\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    s = input()\n    assert len(s) == n\n    (k, r) = calc(s, n)\n    print(k)\n    print(r)", "import sys\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    dic = {'1': [], '0': []}\n    count = 1\n    res = [None] * n\n    res[0] = 1\n    if s[0] == '0':\n        dic['1'].append(count)\n    else:\n        dic['0'].append(count)\n    for i in range(1, n):\n        if dic[s[i]]:\n            x = dic[s[i]].pop()\n            res[i] = x\n            if s[i] == '0':\n                dic['1'].append(x)\n            else:\n                dic['0'].append(x)\n        else:\n            count += 1\n            res[i] = count\n            if s[i] == '0':\n                dic['1'].append(count)\n            else:\n                dic['0'].append(count)\n    print(count)\n    sys.stdout.write(' '.join(map(str, res)) + '\\n')", "from sys import stdin\nfor _ in range(int(stdin.readline())):\n    stdin.readline()\n    s = stdin.readline().strip()\n    one_stack = []\n    z_stack = []\n    count = 0\n    res = []\n    for char in s:\n        if char == '1':\n            if len(z_stack) == 0:\n                count += 1\n                res.append(count)\n                one_stack.append(count)\n            else:\n                t = z_stack.pop()\n                res.append(t)\n                one_stack.append(t)\n        elif len(one_stack) == 0:\n            count += 1\n            res.append(count)\n            z_stack.append(count)\n        else:\n            t = one_stack.pop()\n            res.append(t)\n            z_stack.append(t)\n    print(count)\n    print(*res)", "def func(s):\n    find_0 = []\n    find_1 = []\n    latest = 1\n    output = []\n    if s[0] == '0':\n        find_1.append(latest)\n    else:\n        find_0.append(latest)\n    latest += 1\n    output.append(1)\n    for i in s[1:]:\n        if i == '0':\n            if len(find_0) == 0:\n                find_1.append(latest)\n                output.append(latest)\n                latest += 1\n            else:\n                x = find_0[-1]\n                output.append(x)\n                find_1.append(x)\n                find_0.pop()\n        elif len(find_1) == 0:\n            find_0.append(latest)\n            output.append(latest)\n            latest += 1\n        else:\n            x = find_1[-1]\n            output.append(x)\n            find_0.append(x)\n            find_1.pop()\n    return str(latest - 1) + '\\n' + ' '.join(list(map(str, output)))\n\ndef main():\n    for i in range(int(input())):\n        input()\n        print(func(input()))\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    l = []\n    zeros = []\n    ones = []\n    if s[0] == '1':\n        ones = [1]\n    else:\n        zeros = [1]\n    count = 1\n    for i in s:\n        if i == '0':\n            if len(zeros):\n                l.append(zeros.pop(-1))\n                ones.append(l[-1])\n            else:\n                count += 1\n                l.append(count)\n                ones.append(count)\n        elif len(ones):\n            l.append(ones.pop(-1))\n            zeros.append(l[-1])\n        else:\n            count += 1\n            l.append(count)\n            zeros.append(count)\n    print(count)\n    print(' '.join(map(str, l)))", "def check(a):\n    (lst0, lst1, l, k) = ([], [], [], 1)\n    for ele in a:\n        if ele == '0':\n            if len(lst1) == 0:\n                lst0.append(k)\n                l.append(k)\n                k += 1\n            else:\n                l.append(lst1[-1])\n                lst0.append(lst1[-1])\n                lst1.pop()\n        elif len(lst0) == 0:\n            lst1.append(k)\n            l.append(k)\n            k += 1\n        else:\n            l.append(lst0[-1])\n            lst1.append(lst0[-1])\n            lst0.pop()\n    print(k - 1)\n    print(' '.join(list(map(str, l))))\nfor _ in range(int(input())):\n    b = int(input())\n    a = input()\n    check(a)", "for _ in range(int(input())):\n    input()\n    arr_0 = []\n    arr_1 = []\n    ans_str = ''\n    MAX = 0\n    for i in input():\n        if i == '0':\n            if len(arr_1) == 0:\n                MAX += 1\n                arr_0.append(MAX)\n                ans_str += str(MAX) + ' '\n            else:\n                arr_0.append(arr_1.pop())\n                ans_str += str(arr_0[-1]) + ' '\n        if i == '1':\n            if len(arr_0) == 0:\n                MAX += 1\n                arr_1.append(MAX)\n                ans_str += str(MAX) + ' '\n            else:\n                arr_1.append(arr_0.pop())\n                ans_str += str(arr_1[-1]) + ' '\n    print(MAX)\n    print(ans_str)", "def check(a):\n    s0 = []\n    s1 = []\n    nump = 1\n    l = []\n    for ele in a:\n        if ele == '0':\n            if len(s1) == 0:\n                s0.append(nump)\n                l.append(nump)\n                nump += 1\n            else:\n                l.append(s1[-1])\n                s0.append(s1[-1])\n                s1.pop()\n        elif len(s0) == 0:\n            s1.append(nump)\n            l.append(nump)\n            nump += 1\n        else:\n            l.append(s0[-1])\n            s1.append(s0[-1])\n            s0.pop()\n    print(nump - 1)\n    print(' '.join(list(map(str, l))))\nt = int(input())\nfor i in range(t):\n    b = int(input())\n    a = input()\n    check(a)", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\nfor tc in range(int(input())):\n    (n,) = I()\n    s = list(input())\n    ans = [1] * n\n    x = s[0]\n    ct = 1\n    for i in range(n):\n        if s[i] == x:\n            ans[i] = ct\n            ct += 1\n        else:\n            ans[i] = ct - 1\n            ct -= 1\n    k = min(ans)\n    if k <= 0:\n        for i in range(n):\n            ans[i] = ans[i] + 1 - k\n    print(max(ans))\n    print(*ans)", "nnn = int(input())\nfor _ in range(nnn):\n    n = int(input())\n    s = input()\n    arr = [1]\n    ans = 1\n    mx = 1\n    st1 = set()\n    st0 = set()\n    if s[0] == '0':\n        st0.add(1)\n    else:\n        st1.add(1)\n    for i in range(1, n):\n        if s[i] == '0':\n            if len(st1) == 0:\n                mx += 1\n                arr.append(mx)\n                st0.add(mx)\n            else:\n                t = st1.pop()\n                arr.append(t)\n                st0.add(t)\n        if s[i] == '1':\n            if len(st0) == 0:\n                mx += 1\n                arr.append(mx)\n                st1.add(mx)\n            else:\n                t = st0.pop()\n                arr.append(t)\n                st1.add(t)\n    print(mx)\n    print(' '.join(map(str, arr)))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    num = 0\n    zeros = 0\n    ones = 0\n    d0 = set()\n    d1 = set()\n    a = []\n    for x in s:\n        if x == '1':\n            if zeros > 0:\n                temp = d0.pop()\n                d1.add(temp)\n                a.append(temp)\n                zeros -= 1\n            else:\n                num += 1\n                d1.add(num)\n                a.append(num)\n            ones += 1\n        else:\n            if ones > 0:\n                temp = d1.pop()\n                d0.add(temp)\n                a.append(temp)\n                ones -= 1\n            else:\n                num += 1\n                d0.add(num)\n                a.append(num)\n            zeros += 1\n    print(num)\n    print(' '.join(map(str, a)))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    c = 0\n    (s0, s1) = ([], [])\n    o = []\n    for ch in s:\n        if ch == '0':\n            if s0:\n                i = s0.pop()\n            else:\n                c += 1\n                i = c\n            s1.append(i)\n            o.append(str(i))\n        else:\n            if s1:\n                i = s1.pop()\n            else:\n                c += 1\n                i = c\n            s0.append(i)\n            o.append(str(i))\n    print(c)\n    print(' '.join(o))", "def split_to_subsequences(s):\n    seqs = {0: set(), 1: set()}\n    seqs_count = 0\n    result = []\n    for ch in map(int, s):\n        if seqs[1 - ch]:\n            cur_seq = seqs[1 - ch].pop()\n            result.append(cur_seq)\n            seqs[ch].add(cur_seq)\n        else:\n            seqs_count += 1\n            result.append(seqs_count)\n            seqs[ch].add(seqs_count)\n    return (seqs_count, result)\n\ndef main():\n    for _ in range(int(input())):\n        input()\n        (seqs_count, result) = split_to_subsequences(input())\n        print(seqs_count)\n        print(' '.join([str(item) for item in result]))\nmain()", "T = int(input())\nfor t in range(T):\n    N = input()\n    s = input()\n    zero_ends = []\n    one_ends = []\n    res = []\n    a = 0\n    for x in s:\n        if x == '0':\n            if one_ends:\n                ai = one_ends.pop()\n                zero_ends.append(ai)\n                res.append(ai)\n            else:\n                a += 1\n                res.append(a)\n                zero_ends.append(a)\n        elif zero_ends:\n            ai = zero_ends.pop()\n            one_ends.append(ai)\n            res.append(ai)\n        else:\n            a += 1\n            res.append(a)\n            one_ends.append(a)\n    print(a)\n    print(' '.join((str(a) for a in res)))", "import sys, math\nfrom collections import deque, defaultdict\nimport operator as op\nfrom functools import reduce\nI = sys.stdin.readline\n\ndef ii():\n    return int(I().strip())\n\ndef li():\n    return list(map(int, I().strip().split()))\n\ndef mi():\n    return map(int, I().strip().split())\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef main():\n    for _ in range(ii()):\n        n = ii()\n        s = I().strip()\n        s0 = []\n        s1 = []\n        cnt = 0\n        ans = []\n        for i in s:\n            if i == '1':\n                if len(s0) == 0:\n                    cnt += 1\n                    s1.append(cnt)\n                    ans.append(cnt)\n                else:\n                    tmp = s0.pop()\n                    ans.append(tmp)\n                    s1.append(tmp)\n            elif len(s1) == 0:\n                cnt += 1\n                s0.append(cnt)\n                ans.append(cnt)\n            else:\n                tmp = s1.pop()\n                ans.append(tmp)\n                s0.append(tmp)\n        print(cnt)\n        print(*ans)\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    countr = 0\n    segments = list()\n    for ch in s:\n        if ch == '1':\n            countr += 1\n        segments.append(countr)\n        if ch == '0':\n            countr -= 1\n    num_of_segments = max(segments) - min(segments) + 1\n    print(num_of_segments)\n    min_segment_number = min(segments) - 1\n    output = [x - min_segment_number for x in segments]\n    print(*output)", "from collections import deque\nt = int(input())\nwhile t > 0:\n    nextSubSeqIdToUse = 1\n    subSeqsWhichRequireZeroNext = deque()\n    subSeqsWhichRequireOneNext = deque()\n    n = int(input())\n    string = input()\n    charWiseSubSeqId = []\n    for char in string:\n        if char == '0':\n            if len(subSeqsWhichRequireZeroNext) > 0:\n                subSeqForChar = subSeqsWhichRequireZeroNext.popleft()\n                charWiseSubSeqId.append(subSeqForChar)\n                subSeqsWhichRequireOneNext.append(subSeqForChar)\n            else:\n                subSeqForChar = nextSubSeqIdToUse\n                nextSubSeqIdToUse += 1\n                charWiseSubSeqId.append(subSeqForChar)\n                subSeqsWhichRequireOneNext.append(subSeqForChar)\n        elif char == '1':\n            if len(subSeqsWhichRequireOneNext) > 0:\n                subSeqForChar = subSeqsWhichRequireOneNext.popleft()\n                charWiseSubSeqId.append(subSeqForChar)\n                subSeqsWhichRequireZeroNext.append(subSeqForChar)\n            else:\n                subSeqForChar = nextSubSeqIdToUse\n                nextSubSeqIdToUse += 1\n                charWiseSubSeqId.append(subSeqForChar)\n                subSeqsWhichRequireZeroNext.append(subSeqForChar)\n    print(nextSubSeqIdToUse - 1)\n    print(' '.join(map(str, charWiseSubSeqId)))\n    t -= 1", "for t in range(int(input())):\n    n = int(input())\n    s = input()\n    k = {'0': [], '1': []}\n    out = 0\n    ans = ''\n    for i in s:\n        if i == '0':\n            if not k['1']:\n                out += 1\n                k[i].append(out)\n                ans += ' ' + str(out)\n            else:\n                val = k['1'].pop()\n                ans += ' ' + str(val)\n                k[i].append(val)\n        elif not k['0']:\n            out += 1\n            k[i].append(out)\n            ans += ' ' + str(out)\n        else:\n            val = k['0'].pop()\n            ans += ' ' + str(val)\n            k[i].append(val)\n    print(out)\n    print(ans[1:])", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    n0 = []\n    n1 = []\n    cnt = 0\n    ans = []\n    for i in range(n):\n        if s[i] == '0':\n            if len(n1) > 0:\n                n0.append(n1.pop())\n                ans.append(n0[-1])\n            else:\n                cnt += 1\n                n0.append(cnt)\n                ans.append(cnt)\n        elif len(n0) > 0:\n            n1.append(n0.pop())\n            ans.append(n1[-1])\n        else:\n            cnt += 1\n            n1.append(cnt)\n            ans.append(cnt)\n    print(cnt)\n    print(' '.join(map(str, ans)))", "t = int(input())\n\ndef solve():\n    n = int(input())\n    s = input()\n    ones = []\n    zeros = []\n    assign = [None] * n\n    seq = 0\n    for (i, x) in enumerate(s):\n        if x == '1':\n            if len(zeros):\n                loc = zeros.pop()\n                assign[i] = loc\n                ones.append(loc)\n            else:\n                seq += 1\n                assign[i] = seq\n                ones.append(seq)\n        elif len(ones):\n            loc = ones.pop()\n            assign[i] = loc\n            zeros.append(loc)\n        else:\n            seq += 1\n            zeros.append(seq)\n            assign[i] = seq\n    print(seq)\n    print(*assign, sep=' ')\n    return\nwhile t:\n    solve()\n    t -= 1", "from sys import stdin, exit, setrecursionlimit\nfrom collections import deque\ninput = stdin.readline\nlmi = lambda : list(map(int, input().split()))\nmi = lambda : map(int, input().split())\nsi = lambda : input().strip('\\n')\nssi = lambda : input().strip('\\n').split()\nfor _ in range(int(input())):\n    n = int(input())\n    s = si()\n    ans = []\n    arr = [[] for j in range(2)]\n    nxt = 1\n    for i in range(n):\n        if s[i] == '1':\n            if arr[0]:\n                arr[1].append(arr[0].pop())\n            else:\n                arr[1].append(nxt)\n                nxt += 1\n            ans.append(arr[1][-1])\n        else:\n            if arr[1]:\n                arr[0].append(arr[1].pop())\n            else:\n                arr[0].append(nxt)\n                nxt += 1\n            ans.append(arr[0][-1])\n    print(max(ans))\n    print(*ans)", "import sys\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\nfor _ in range(II()):\n    n = II()\n    aa = [int(c) for c in SI()]\n    last = [[], []]\n    cnt = 1\n    now = 1\n    ans = [-1] * n\n    for i in range(n - 1):\n        ans[i] = now\n        if aa[i] == aa[i + 1]:\n            a = aa[i]\n            last[a].append(now)\n            if last[1 - a]:\n                now = last[1 - a].pop()\n            else:\n                cnt += 1\n                now = cnt\n    ans[n - 1] = now\n    print(cnt)\n    print(*ans)", "from sys import stdin\ninp = lambda : stdin.readline().strip()\nt = int(inp())\nfor _ in range(t):\n    n = int(inp())\n    s = inp()\n    zeroes = []\n    ones = []\n    groups = [0] * n\n    g = 2\n    flag = False\n    if s[0] == '0':\n        ones.append(1)\n    else:\n        zeroes.append(1)\n    groups[0] = 1\n    for i in range(1, n):\n        if s[i] == '0':\n            if zeroes:\n                groups[i] = zeroes[len(zeroes) - 1]\n                ones.append(zeroes.pop())\n            else:\n                flag = True\n        elif ones:\n            groups[i] = ones[len(ones) - 1]\n            zeroes.append(ones.pop())\n        else:\n            flag = True\n        if flag:\n            groups[i] = g\n            if s[i] == '0':\n                ones.append(g)\n            else:\n                zeroes.append(g)\n            g += 1\n            flag = False\n    print(g - 1)\n    print(*groups)", "def check(A, seq):\n    dict_a = dict()\n    for i in range(len(seq)):\n        if seq[i] not in dict_a.keys():\n            dict_a[seq[i]] = A[i]\n        elif A[i] == dict_a[seq[i]]:\n            print(A, seq, dict_a[seq[i]])\n            raise EOFError\n        else:\n            dict_a[seq[i]] = A[i]\nT = int(input())\nfor t in range(T):\n    N = input()\n    A = input()\n    state = A[0]\n    unresolved = 0\n    unresolved_state = A[0]\n    sub_string = []\n    sub_count = 0\n    for a in A:\n        if a == unresolved_state:\n            unresolved += 1\n            sub_string.append(unresolved)\n        elif unresolved >= 1:\n            sub_string.append(unresolved)\n            unresolved -= 1\n        else:\n            unresolved = max(sub_string) + 1\n            sub_string.append(unresolved)\n            unresolved_state = a\n    check(A, sub_string)\n    print(max(sub_string))\n    print(' '.join(list(map(str, sub_string))))", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\nimport threading\nthreading.stack_size(67108864)\n\ndef solution():\n    n = int(input())\n    s = list(map(int, list(input())))\n    answer = ['0'] * n\n    cnt = 0\n    seq = [[], []]\n    for i in range(n):\n        if len(seq[1 - s[i]]) == 0:\n            cnt += 1\n            seq[s[i]].append(cnt)\n            answer[i] = str(cnt)\n        else:\n            seq_id = seq[1 - s[i]][-1]\n            answer[i] = str(seq_id)\n            seq[s[i]].append(seq_id)\n            seq[1 - s[i]].pop()\n    print(f'{cnt}')\n    print(' '.join(answer))\nt = int(input())\nfor _ in range(t):\n    solution()", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    seq = []\n    one_ended = []\n    zero_ended = []\n    answer = ''\n    for bit in s:\n        if bit == '0':\n            if len(one_ended) == 0:\n                seq.append('0')\n                zero_ended.append(len(seq) - 1)\n                answer += str(len(seq)) + ' '\n            else:\n                seq[one_ended[-1]] += '0'\n                answer += str(one_ended[-1] + 1) + ' '\n                zero_ended.append(one_ended.pop())\n        elif len(zero_ended) == 0:\n            seq.append('1')\n            one_ended.append(len(seq) - 1)\n            answer += str(len(seq)) + ' '\n        else:\n            seq[zero_ended[-1]] += '1'\n            answer += str(zero_ended[-1] + 1) + ' '\n            one_ended.append(zero_ended.pop())\n    print(len(seq))\n    print(answer)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    ans = []\n    pos0 = []\n    pos1 = []\n    pre_pos = 0\n    for i in range(len(s)):\n        pre_pos = len(pos1) + len(pos0)\n        if s[i] == '0':\n            if len(pos1) == 0:\n                pos0.append(pre_pos)\n            else:\n                pre_pos = pos1.pop()\n                pos0.append(pre_pos)\n        elif len(pos0) == 0:\n            pos1.append(pre_pos)\n        else:\n            pre_pos = pos0.pop()\n            pos1.append(pre_pos)\n        ans.append(pre_pos + 1)\n    print(len(pos1) + len(pos0))\n    print(' '.join(map(str, ans)))", "import re\n\ndef binary(a):\n    (at_one, at_zero) = ([], [])\n    val = 0\n    ans = [0] * len(a)\n    for i in range(len(a)):\n        if a[i] == '0' and at_one:\n            ans[i] = at_one.pop()\n            at_zero.append(ans[i])\n        elif a[i] == '0':\n            val += 1\n            ans[i] = val\n            at_zero.append(val)\n        elif a[i] == '1' and at_zero:\n            ans[i] = at_zero.pop()\n            at_one.append(ans[i])\n        elif a[i] == '1':\n            val += 1\n            ans[i] = val\n            at_one.append(val)\n    ans.insert(0, max(ans))\n    return ans\nt = int(input())\nans = []\nfor i in range(t):\n    n = int(input())\n    a = input()\n    ans.append(binary(a))\nfor i in ans:\n    print(i[0])\n    print(*i[1:])", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    string = input()\n    ans = []\n    zeroq = []\n    oneq = []\n    for i in range(n):\n        counter = len(zeroq) + len(oneq)\n        if string[i] == '0':\n            if not oneq:\n                zeroq.append(counter)\n            else:\n                counter = oneq[-1]\n                zeroq.append(counter)\n                del oneq[-1]\n        elif not zeroq:\n            oneq.append(counter)\n        else:\n            counter = zeroq[-1]\n            oneq.append(counter)\n            del zeroq[-1]\n        ans.append(str(counter + 1))\n    print(len(zeroq) + len(oneq))\n    print(' '.join(ans))", "t = int(input())\nfor case in range(t):\n    n = int(input())\n    s = input().strip()\n    a = [[], []]\n    ret = ''\n    i = 1\n    a0 = 0\n    a1 = 0\n    for x in s:\n        if x == '1' and a0:\n            tmp = a[0][-1]\n            ret += tmp + ' '\n            a[0].pop(-1)\n            a[1].append(tmp)\n            a0 -= 1\n            a1 += 1\n        elif x == '1' and (not a0):\n            a[1].append(str(i))\n            a1 += 1\n            ret += str(i) + ' '\n            i += 1\n        elif a1:\n            tmp = a[1][-1]\n            ret += tmp + ' '\n            a[1].pop(-1)\n            a1 -= 1\n            a[0].append(tmp)\n            a0 += 1\n        else:\n            a[0].append(str(i))\n            a0 += 1\n            ret += str(i) + ' '\n            i += 1\n    print(i - 1)\n    print(ret)", "from collections import deque\nfor _ in range(int(input())):\n    a = int(input())\n    s = input()\n    s0 = deque()\n    s1 = deque()\n    ans = []\n    ln = 0\n    for i in range(a):\n        if s[i] == '1':\n            if not s0:\n                s1.append(i)\n                ln += 1\n                ans.append(ln)\n            else:\n                q = s0.popleft()\n                ans.append(ans[q])\n                s1.append(i)\n        elif not s1:\n            s0.append(i)\n            ln += 1\n            ans.append(ln)\n        else:\n            q = s1.popleft()\n            ans.append(ans[q])\n            s0.append(i)\n    print(ln)\n    print(*ans)", "from heapq import *\nfor _ in range(int(input())):\n    r = []\n    f = []\n    heapify(r)\n    heapify(f)\n    q = 0\n    w = 0\n    n = int(input())\n    l = [0] * n\n    k = 1\n    a = input()\n    for i in range(n):\n        if int(a[i]) == 1:\n            if f:\n                l[i] = heappop(f)\n                heappush(r, l[i])\n            else:\n                q += 1\n                heappush(r, q)\n                l[i] = q\n        elif r:\n            l[i] = heappop(r)\n            heappush(f, l[i])\n        else:\n            q += 1\n            heappush(f, q)\n            l[i] = q\n    print(len(set(l)))\n    print(*l)", "numberOfCases = int(input())\ni = 0\nt = 0\nwhile t < numberOfCases:\n    numberOfSequences = int(input())\n    sequence = input()\n    sequence = [int(k) for k in sequence]\n    uniqSeq = 0\n    zeros = 0\n    ones = 0\n    numberOfSeqEndWithZero = []\n    numberOfSeqEndWithOne = []\n    for i in range(len(sequence)):\n        if sequence[i] == 0:\n            if len(numberOfSeqEndWithOne) != 0:\n                s = numberOfSeqEndWithOne.pop()\n                sequence[i] = s\n                numberOfSeqEndWithZero.append(s)\n            else:\n                sequence[i] = uniqSeq + 1\n                uniqSeq += 1\n                numberOfSeqEndWithZero.append(uniqSeq)\n        elif len(numberOfSeqEndWithZero) != 0:\n            s = numberOfSeqEndWithZero.pop()\n            sequence[i] = s\n            numberOfSeqEndWithOne.append(s)\n        else:\n            sequence[i] = uniqSeq + 1\n            uniqSeq += 1\n            numberOfSeqEndWithOne.append(uniqSeq)\n    print(uniqSeq)\n    print(' '.join([str(k) for k in sequence]))\n    t += 1", "from collections import deque\nfor item in [0] * int(input()):\n    n = int(input())\n    s = input()\n    q0 = deque()\n    q1 = deque()\n    a = []\n    num = 1\n    for i in range(n):\n        if s[i] == '0':\n            if len(q0) == 0:\n                a.append(num)\n                q1.append(num)\n                num += 1\n            else:\n                q1.append(q0[len(q0) - 1])\n                a.append(q0.pop())\n        elif len(q1) == 0:\n            a.append(num)\n            q0.append(num)\n            num += 1\n        else:\n            q0.append(q1[len(q1) - 1])\n            a.append(q1.pop())\n    print(max(a))\n    print(' '.join((str(ele) for ele in a)))", "for _ in range(int(input())):\n    n = int(input())\n    (ls0, ls1) = ([], [])\n    ctr = 1\n    s = input()\n    an = 0\n    ans = ''\n    for i in range(n):\n        if s[i] == '1':\n            if len(ls0):\n                ls1.append(ls0[-1])\n                ls0.pop()\n                ans += str(ls1[-1]) + ' '\n            else:\n                ls1.append(ctr)\n                ans += str(ctr) + ' '\n                an = max(an, ctr)\n                ctr += 1\n        elif len(ls1):\n            ls0.append(ls1[-1])\n            ls1.pop()\n            ans += str(ls0[-1]) + ' '\n        else:\n            ls0.append(ctr)\n            ans += str(ctr) + ' '\n            an = max(an, ctr)\n            ctr += 1\n    print(an)\n    print(ans)", "from sys import stdin\nnii = lambda : map(int, stdin.readline().split())\nlnii = lambda : list(map(int, stdin.readline().split()))\nfrom collections import deque\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    s = input()\n    que0 = deque()\n    que1 = deque()\n    ans = []\n    cnt = 0\n    for i in s:\n        if i == '0':\n            if not que1:\n                cnt += 1\n                que0.append(cnt)\n                ans.append(cnt)\n            else:\n                num = que1.popleft()\n                que0.append(num)\n                ans.append(num)\n        elif not que0:\n            cnt += 1\n            que1.append(cnt)\n            ans.append(cnt)\n        else:\n            num = que0.popleft()\n            que1.append(num)\n            ans.append(num)\n    print(max(ans))\n    print(*ans)", "mod = 1000000007\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    s = input()\n    cnt = 1\n    sz = []\n    so = []\n    arr = [0] * n\n    for i in range(n):\n        if s[i] == '0':\n            if not so:\n                arr[i] = cnt\n                sz.append(cnt)\n                cnt += 1\n            else:\n                dd = so.pop()\n                sz.append(dd)\n                arr[i] = dd\n        elif not sz:\n            arr[i] = cnt\n            so.append(cnt)\n            cnt += 1\n        else:\n            dd = sz.pop()\n            so.append(dd)\n            arr[i] = dd\n    print(cnt - 1)\n    print(*arr)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    d = [0] * (n + 1)\n    for i in range(n):\n        d[i + 1] = d[i] + (1 if s[i] == '1' else -1)\n    for i in range(n):\n        if s[i] == '0':\n            d[i] -= 1\n    md = min(d)\n    for i in range(n):\n        d[i] -= md - 1\n    d.pop(n)\n    print(max(d))\n    print(*d)", "t = int(input())\nR = lambda : map(int, input().split())\nanswersNumbers = []\nanswersBelonging = []\nfor i in range(0, t):\n    n = int(input())\n    a = input()\n    maxNumber = 0\n    onePossiblesSub = []\n    zeroPossibleSub = []\n    numbers = []\n    for c in a:\n        if c == '1':\n            if not onePossiblesSub:\n                maxNumber = maxNumber + 1\n                onePossiblesSub.append(maxNumber)\n            popped = onePossiblesSub.pop()\n            numbers.append(popped)\n            zeroPossibleSub.append(popped)\n        if c == '0':\n            if not zeroPossibleSub:\n                maxNumber = maxNumber + 1\n                zeroPossibleSub.append(maxNumber)\n            popped = zeroPossibleSub.pop()\n            onePossiblesSub.append(popped)\n            numbers.append(popped)\n    answersBelonging.append(numbers)\n    answersNumbers.append(maxNumber)\nfor i in range(0, t):\n    print(answersNumbers[i])\n    for j in range(0, len(answersBelonging[i])):\n        print(answersBelonging[i][j], sep='', end=' ')\n    print()", "for ip in [*open(0)][2::2]:\n    a = list(map(int, ip.strip()))\n    n = len(a)\n    (p0, p1, ans) = ([], [], [])\n    for x in a:\n        np = len(p0) + len(p1)\n        if x == 0:\n            if p1:\n                np = p1.pop()\n                p0.append(np)\n            else:\n                p0.append(np)\n        elif p0:\n            np = p0.pop()\n            p1.append(np)\n        else:\n            p1.append(np)\n        ans.append(np + 1)\n    print(len(p0) + len(p1))\n    print(*ans)", "def arri():\n    return list(map(int, input().split()))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(input())\n    (haveZero, haveOne) = ([], [])\n    ans = [0] * n\n    val = 0\n    for i in range(n):\n        if arr[i] == '1' and haveZero:\n            ans[i] = haveZero.pop()\n            haveOne.append(ans[i])\n        elif arr[i] == '1':\n            val += 1\n            ans[i] = val\n            haveOne.append(val)\n        if arr[i] == '0' and haveOne:\n            ans[i] = haveOne.pop()\n            haveZero.append(ans[i])\n        elif arr[i] == '0':\n            val += 1\n            ans[i] = val\n            haveZero.append(val)\n    print(max(ans))\n    print(' '.join(map(str, ans)))", "def solve(s, n):\n    cur = [set(), set()]\n    used = 1\n    ans = [1]\n    if s[0] == '0':\n        cur[0].add(0)\n    else:\n        cur[1].add(0)\n    for c in s[1:]:\n        if c == '0' and len(cur[1]) != 0:\n            i = cur[1].pop()\n            cur[0].add(i)\n            ans.append(i + 1)\n        elif c == '1' and len(cur[0]) != 0:\n            i = cur[0].pop()\n            cur[1].add(i)\n            ans.append(i + 1)\n        else:\n            used += 1\n            ans.append(used)\n            if c == '0':\n                cur[0].add(used - 1)\n            else:\n                cur[1].add(used - 1)\n    print(used)\n    print(*ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    solve(s, n)", "import sys, os\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = lambda : sys.stdin.readline().strip()\nli = lambda : list(map(int, input().split()))\nI = lambda : int(input())\nfor _ in range(I()):\n    n = I()\n    s = list(map(int, list(input())))\n    l = [0 for i in range(n)]\n    zero = 0\n    last_zero_set = []\n    one = 0\n    last_one_set = []\n    for (index, i) in enumerate(s):\n        if i == 1:\n            if zero > 0:\n                zero -= 1\n                one += 1\n                last_one_set.append(last_zero_set.pop())\n            else:\n                one += 1\n                last_one_set.append(one)\n            l[index] = last_one_set[-1]\n        else:\n            if one > 0:\n                one -= 1\n                zero += 1\n                last_zero_set.append(last_one_set.pop())\n            else:\n                zero += 1\n                last_zero_set.append(zero)\n            l[index] = last_zero_set[-1]\n    print(zero + one)\n    print(*l)", "def inp():\n    return int(input())\n\ndef insr():\n    s = input()\n    return s\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef solve(l):\n    s1 = []\n    s0 = []\n    last = 0\n    ans = []\n    for i in range(len(l)):\n        if l[i] == '0':\n            if len(s1) == 0:\n                last += 1\n                s1.append(last)\n            ans.append(s1[-1])\n            s0.append(s1.pop())\n        if l[i] == '1':\n            if len(s0) == 0:\n                last += 1\n                s0.append(last)\n            ans.append(s0[-1])\n            s1.append(s0.pop())\n    return (last, ans)\n    return best\nr = inp()\nfor i in range(r):\n    a = inp()\n    l2 = insr()\n    (last, ans) = solve(l2)\n    print(last)\n    print(' '.join([str(i) for i in ans]))", "for _ in ' ' * int(input()):\n    n = int(input())\n    s = input()\n    ans = [-1] * n\n    st0 = []\n    st1 = []\n    stcnt = 1\n    for i in range(n):\n        if s[i] == '0':\n            if st1:\n                ans[i] = st1[-1]\n                st0.append(st1.pop())\n            else:\n                ans[i] = stcnt\n                st0.append(stcnt)\n                stcnt += 1\n        elif st0:\n            ans[i] = st0[-1]\n            st1.append(st0.pop())\n        else:\n            ans[i] = stcnt\n            st1.append(stcnt)\n            stcnt += 1\n    print(stcnt - 1)\n    print(*ans)", "from collections import deque\nZERO = '0'\nONE = '1'\n\ndef get_answer(s):\n    string_markup = []\n    subseqs_need_ones = deque()\n    subseqs_need_zeros = deque()\n    subseqs_n = 0\n    for bit in s:\n        if bit == ZERO:\n            subseqs_need = subseqs_need_zeros\n            subseqs_not_need = subseqs_need_ones\n        else:\n            subseqs_need = subseqs_need_ones\n            subseqs_not_need = subseqs_need_zeros\n        if subseqs_need:\n            curr_subseq = subseqs_need.popleft()\n        else:\n            curr_subseq = subseqs_n\n            subseqs_n += 1\n        string_markup.append(curr_subseq)\n        subseqs_not_need.append(curr_subseq)\n    return (subseqs_n, string_markup)\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        s = input()\n        (subseqs_count, string_markup) = get_answer(s)\n        print(subseqs_count)\n        print(*map(1 .__add__, string_markup))\nmain()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    ans = []\n    (a, b) = ([], [])\n    x = 0\n    for z in s:\n        if z == '0':\n            if not b:\n                x += 1\n                a.append(x)\n            else:\n                g = b.pop()\n                a.append(g)\n            ans.append(a[-1])\n        else:\n            if not a:\n                x += 1\n                b.append(x)\n            else:\n                g = a.pop()\n                b.append(g)\n            ans.append(b[-1])\n    print(x)\n    print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    res = []\n    ones = []\n    zeros = []\n    max_i = 0\n    for c in s:\n        if c == '1':\n            if zeros:\n                ones.append(zeros.pop())\n            else:\n                max_i += 1\n                ones.append(max_i)\n            res.append(ones[-1])\n        else:\n            if ones:\n                zeros.append(ones.pop())\n            else:\n                max_i += 1\n                zeros.append(max_i)\n            res.append(zeros[-1])\n    print(max(res))\n    print(*res)", "def solve():\n    for _ in range(ii()):\n        n = ii()\n        s = si()\n        p0 = []\n        p1 = []\n        c = [-1] * n\n        for i in range(n):\n            len0 = len(p0)\n            len1 = len(p1)\n            newpos = len0 + len1\n            if s[i] == '0':\n                if len1 == 0:\n                    p0.append(newpos)\n                else:\n                    newpos = p1.pop()\n                    p0.append(newpos)\n            elif len0 == 0:\n                p1.append(newpos)\n            else:\n                newpos = p0.pop()\n                p1.append(newpos)\n            c[i] = newpos + 1\n        print(len(p0) + len(p1))\n        print(*c)\nii = lambda : int(input())\nmi = lambda : map(int, input().split())\nli = lambda : list(mi())\nsi = lambda : input()\nsolve()", "from collections import deque\n\ndef findBinSS(s):\n    endsWith0 = deque()\n    endsWith1 = deque()\n    count = 0\n    N = len(s)\n    subseq = [0] * N\n    for i in range(N):\n        if s[i] == '0' and len(endsWith1) > 0:\n            curr = endsWith1.popleft()\n            endsWith0.append(curr)\n            subseq[i] = curr\n        elif s[i] == '0':\n            count += 1\n            endsWith0.append(count)\n            subseq[i] = count\n        elif s[i] == '1' and len(endsWith0) > 0:\n            curr = endsWith0.popleft()\n            endsWith1.append(curr)\n            subseq[i] = curr\n        else:\n            count += 1\n            endsWith1.append(count)\n            subseq[i] = count\n    return (count, subseq)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    (count, subseq) = findBinSS(s)\n    print(count)\n    print(*subseq)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nsys.setrecursionlimit(depth)\nfrom math import inf, gcd, log\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, s) = (int(input()), str(input()))\n    (zer, one, last) = ([], [], 0)\n    ans = [0 for _ in range(n)]\n    for i in range(n):\n        if s[i] == '1':\n            if len(zer):\n                val = zer.pop()\n                one.append(val)\n                ans[i] = val\n            else:\n                last = last + 1\n                one.append(last)\n                ans[i] = last\n        elif len(one):\n            val = one.pop()\n            zer.append(val)\n            ans[i] = val\n        else:\n            last = last + 1\n            zer.append(last)\n            ans[i] = last\n    print(last)\n    print(*ans)", "def doit(arr):\n    zero = []\n    one = []\n    for (i, val) in enumerate(arr):\n        if val == 0:\n            cur = one.pop() if one else []\n            cur.append(i)\n            zero.append(cur)\n        if val == 1:\n            cur = zero.pop() if zero else []\n            cur.append(i)\n            one.append(cur)\n    res = [0] * len(arr)\n    for (i, group) in enumerate(zero + one):\n        for idx in group:\n            res[idx] = i + 1\n    return res\nt = int(input())\nfor _ in range(t):\n    n = input()\n    arr = list(map(int, input()))\n    res = doit(arr)\n    print(len(set(res)))\n    for val in res:\n        print(val, end=' ')\n    print()", "import sys, os\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ninput = lambda : sys.stdin.readline().strip()\nli = lambda : list(map(int, input().split()))\nI = lambda : int(input())\nfor _ in range(I()):\n    n = I()\n    s = list(map(int, list(input())))\n    l = [0 for i in range(n)]\n    zero = 0\n    last_zero_set = []\n    one = 0\n    last_one_set = []\n    for (index, i) in enumerate(s):\n        if i == 1:\n            if zero > 0:\n                zero -= 1\n                one += 1\n                last_one_set.append(last_zero_set.pop())\n            else:\n                one += 1\n                last_one_set.append(one)\n            l[index] = last_one_set[-1]\n        else:\n            if one > 0:\n                one -= 1\n                zero += 1\n                last_zero_set.append(last_one_set.pop())\n            else:\n                zero += 1\n                last_zero_set.append(zero)\n            l[index] = last_zero_set[-1]\n    print(zero + one)\n    print(*l)", "n = int(input())\nfor _ in range(n):\n    nn = int(input())\n    ls = [[], []]\n    s = input()\n    last = 0\n    ans = [0 for x in range(nn)]\n    for (i, c) in enumerate(s):\n        c = int(c)\n        if len(ls[c ^ 1]) == 0:\n            last += 1\n            ls[c].append(last)\n            ans[i] = last\n        else:\n            ans[i] = ls[c ^ 1][-1]\n            del ls[c ^ 1][-1]\n            ls[c].append(ans[i])\n    print(last)\n    print(' '.join(map(str, ans)))", "from collections import deque\nt = int(input())\nwhile t:\n    n = int(input())\n    s = input()\n    ones = deque()\n    zeros = deque()\n    if s[0] == '0':\n        zeros.append(1)\n    else:\n        ones.append(1)\n    ans = [1]\n    for i in range(1, len(s)):\n        if s[i] == '0':\n            if ones:\n                j = ones.pop()\n                zeros.append(j)\n                ans.append(j)\n            else:\n                j = len(ones) + len(zeros)\n                zeros.append(j + 1)\n                ans.append(j + 1)\n        elif zeros:\n            j = zeros.pop()\n            ones.append(j)\n            ans.append(j)\n        else:\n            j = len(ones) + len(zeros)\n            ones.append(j + 1)\n            ans.append(j + 1)\n    print(len(ones) + len(zeros))\n    print(*ans)\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    pos_0 = []\n    pos_1 = []\n    a = [0] * n\n    count = 1\n    for i in range(n):\n        if s[i] == '0':\n            if pos_1 == []:\n                pos_0.append(count)\n                a[i] = count\n                count += 1\n            else:\n                x = pos_1.pop()\n                a[i] = x\n                pos_0.append(x)\n        elif pos_0 == []:\n            pos_1.append(count)\n            a[i] = count\n            count += 1\n        else:\n            x = pos_0.pop()\n            a[i] = x\n            pos_1.append(x)\n    print(max(pos_0 + pos_1))\n    print(*a)", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    s0 = []\n    s1 = []\n    c = 1\n    ans = []\n    for i in s:\n        if i == '1':\n            if len(s0) == 0:\n                s1.append(c)\n                ans.append(c)\n                c += 1\n            else:\n                a = s0.pop()\n                s1.append(a)\n                ans.append(a)\n        elif len(s1) == 0:\n            s0.append(c)\n            ans.append(c)\n            c += 1\n        else:\n            a = s1.pop()\n            s0.append(a)\n            ans.append(a)\n    print(c - 1)\n    print(*ans)", "ones = [0 for i in range(2 * 10 ** 5 + 1)]\nzeros = [0 for i in range(2 * 10 ** 5 + 1)]\nfor _ in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input()]\n    d = [0 for i in range(n)]\n    o = -1\n    z = -1\n    c = 1\n    for i in range(n):\n        if a[i] == 0:\n            if o == -1:\n                z += 1\n                zeros[z] = c\n                d[i] = c\n                c += 1\n            else:\n                k = ones[o]\n                d[i] = k\n                o -= 1\n                z += 1\n                zeros[z] = k\n        elif z == -1:\n            o += 1\n            ones[o] = c\n            d[i] = c\n            c += 1\n        else:\n            k = zeros[z]\n            d[i] = k\n            z -= 1\n            o += 1\n            ones[o] = k\n    print(c - 1)\n    print(*d)", "import bisect\nimport math\nfor xoxo in range(1):\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        (zero, one) = ([], [])\n        (z, o, x) = (0, 0, 1)\n        ans = []\n        for i in range(n):\n            if s[i] == '1':\n                if not o < len(one):\n                    ans.append(x)\n                    zero.append(x)\n                    x += 1\n                else:\n                    ans.append(one[o])\n                    zero.append(one[o])\n                    o += 1\n            elif not z < len(zero):\n                ans.append(x)\n                one.append(x)\n                x += 1\n            else:\n                ans.append(zero[z])\n                one.append(zero[z])\n                z += 1\n        print(max(ans))\n        print(*ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = []\n    b = 0\n    o = []\n    z = []\n    for x in input():\n        if '0' == x:\n            if o:\n                z += (o.pop(),)\n                a += (z[-1],)\n            else:\n                b += 1\n                z += (b,)\n                a += (b,)\n        elif z:\n            o += (z.pop(),)\n            a += (o[-1],)\n        else:\n            b += 1\n            o += (b,)\n            a += (b,)\n    print(b)\n    print(*a)", "from heapq import *\nfor i in range(int(input())):\n    n = int(input())\n    b1 = list(input())\n    b = [int(i) for i in b1]\n    ask0 = []\n    ask1 = []\n    ss = [0 for i in range(n)]\n    mxx = 1\n    for i in range(n):\n        e = b[i]\n        if e == 0:\n            if len(ask0) > 0:\n                giveTo = heappop(ask0)\n            else:\n                giveTo = mxx\n                mxx += 1\n            ss[i] = giveTo\n            heappush(ask1, giveTo)\n        else:\n            if len(ask1) > 0:\n                giveTo = heappop(ask1)\n            else:\n                giveTo = mxx\n                mxx += 1\n            ss[i] = giveTo\n            heappush(ask0, giveTo)\n    mx = max(ss)\n    print(mx)\n    print(' '.join([str(i) for i in ss]))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = map(int, input())\n    zeros = []\n    ones = []\n    count = 0\n    ans = []\n    for d in s:\n        if d == 0:\n            if zeros:\n                ans.append(zeros[-1])\n                ones.append(zeros.pop())\n            else:\n                count += 1\n                ans.append(count)\n                ones.append(count)\n        elif ones:\n            ans.append(ones[-1])\n            zeros.append(ones.pop())\n        else:\n            count += 1\n            ans.append(count)\n            zeros.append(count)\n    print(count)\n    print(*ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    pos_0 = []\n    pos_1 = []\n    a = [0] * n\n    count = 1\n    for i in range(n):\n        if s[i] == '0':\n            if pos_1 == []:\n                pos_0.append(count)\n                a[i] = count\n                count += 1\n            else:\n                x = pos_1.pop()\n                a[i] = x\n                pos_0.append(x)\n        elif pos_0 == []:\n            pos_1.append(count)\n            a[i] = count\n            count += 1\n        else:\n            x = pos_0.pop()\n            a[i] = x\n            pos_1.append(x)\n    print(count - 1)\n    print(*a)", "t = int(input())\nwhile t:\n    n = int(input())\n    s = input()\n    check = -1\n    count0 = []\n    count1 = []\n    if s[0] == '0':\n        check = 0\n        count0.append(1)\n    else:\n        check = 1\n        count1.append(1)\n    l2 = []\n    l2.append(1)\n    curr = 1\n    for i in range(1, n):\n        if s[i] == '0':\n            if len(count1) > 0:\n                a = count1.pop()\n                l2.append(a)\n                count0.append(a)\n            else:\n                curr = curr + 1\n                l2.append(curr)\n                count0.append(curr)\n        elif len(count0) > 0:\n            a = count0.pop()\n            l2.append(a)\n            count1.append(a)\n        else:\n            curr = curr + 1\n            l2.append(curr)\n            count1.append(curr)\n    print(curr)\n    print(*l2)\n    t = t - 1", "import sys\nfor _ in range(int(input())):\n    n = int(input())\n    a = input()\n    res = [-1] * n\n    k = 0\n    d = {0: [], 1: []}\n    t = 2\n    for i in range(n):\n        cur = int(a[i])\n        alt = 1 - cur\n        if len(d[alt]) > 0:\n            t = d[alt].pop()\n            d[cur].append(t)\n        else:\n            k += 1\n            d[cur].append(k)\n            t = k\n        res[i] = t\n    print(k)\n    print(*res)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    ans = []\n    zstack = []\n    ostack = []\n    pans = 0\n    curr = 0\n    for i in range(n):\n        if s[i] == '0':\n            if len(ostack) == 0:\n                zstack.append(curr)\n                ans.append(curr + 1)\n                curr += 1\n            else:\n                noice = ostack.pop()\n                ans.append(noice + 1)\n                zstack.append(noice)\n        elif len(zstack) == 0:\n            ostack.append(curr)\n            ans.append(curr + 1)\n            curr += 1\n        else:\n            noice = zstack.pop()\n            ans.append(noice + 1)\n            ostack.append(noice)\n        pans = max([pans, len(zstack), len(ostack)])\n    print(pans)\n    print(' '.join(list(map(str, ans))))", "t = int(input())\nfor _ in range(0, t):\n    n = int(input())\n    st = str(input())\n    if st[0] == '0':\n        k = 1\n        p = 1\n        c = 0\n    else:\n        k = 1\n        p = -1\n        c = 1\n    ans = 0\n    q = [1]\n    kmax = 0\n    for i in range(1, len(st)):\n        if st[i] == '0':\n            k += 1\n            if st[i - 1] == '1':\n                q.append(abs(p))\n            else:\n                p += 1\n                if p == 0:\n                    if c == 1:\n                        p = q[-1] + 1\n                    else:\n                        p = max(q) + 1\n                c = 0\n                q.append(abs(p))\n            kmax = max(kmax, k)\n        else:\n            k -= 1\n            if st[i - 1] == '0':\n                q.append(abs(p))\n            else:\n                p -= 1\n                if p == 0:\n                    if c == 0:\n                        p = -(q[-1] + 1)\n                    else:\n                        p = -(max(q) + 1)\n                c = 1\n                q.append(abs(p))\n            kmax = max(abs(kmax), abs(k))\n    print(max(q))\n    print(*q)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    s = input()\n    need_zero = set()\n    need_one = set()\n    subs_so_far = 0\n    ans = []\n    for c in s:\n        if c == '0':\n            if len(need_zero) > 0:\n                cur = need_zero.pop()\n            else:\n                subs_so_far += 1\n                cur = subs_so_far\n            ans.append(cur)\n            need_one.add(cur)\n        else:\n            if len(need_one) > 0:\n                cur = need_one.pop()\n            else:\n                subs_so_far += 1\n                cur = subs_so_far\n            ans.append(cur)\n            need_zero.add(cur)\n    print(subs_so_far)\n    print(*ans)", "t = int(input())\nwhile t:\n    n = int(input())\n    s = str(input())\n    ones = []\n    zeroes = []\n    count = 1\n    ans = [0] * n\n    for i in range(n):\n        if s[i] == '1':\n            if len(zeroes) == 0:\n                ones.append(count)\n                ans[i] = count\n                count += 1\n            else:\n                ones.append(zeroes[-1])\n                ans[i] = zeroes[-1]\n                zeroes.pop()\n        elif len(ones) == 0:\n            zeroes.append(count)\n            ans[i] = count\n            count += 1\n        else:\n            zeroes.append(ones[-1])\n            ans[i] = ones[-1]\n            ones.pop()\n    print(count - 1)\n    print(*ans)\n    t -= 1", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = input()\n    ans = []\n    ans.append(1)\n    cnt = {}\n    m = []\n    p = []\n    k = 1\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            if a[i] == '0' and len(p) > 0:\n                f = p.pop()\n                ans.append(f)\n                m.append(f)\n                continue\n            elif a[i] == '1' and len(m) > 0:\n                f = m.pop()\n                ans.append(f)\n                p.append(f)\n                continue\n            if a[i] == '0':\n                m.append(k)\n            if a[i] == '1':\n                p.append(k)\n            k += 1\n            ans.append(k)\n        else:\n            ans.append(k)\n    print(k)\n    for x in ans:\n        print(x, end=' ')\n    print()", "def solve(s):\n    zero = []\n    one = []\n    res = []\n    cnt = 1\n    for i in s:\n        if i == '1':\n            if len(zero) > 0:\n                res.append(zero[-1])\n                one.append(zero.pop())\n            else:\n                res.append(cnt)\n                one.append(cnt)\n                cnt += 1\n        elif len(one) > 0:\n            res.append(one[-1])\n            zero.append(one.pop())\n        else:\n            res.append(cnt)\n            zero.append(cnt)\n            cnt += 1\n    res.append(cnt - 1)\n    return res\nT = int(input())\nwhile T > 0:\n    T -= 1\n    n = int(input())\n    s = str(input())\n    res = solve(s)\n    print(res[-1])\n    for i in range(0, len(res) - 1):\n        print(res[i], end=' ')\n    print()", "for t in range(int(input())):\n    n = int(input())\n    s = input()\n    (sz, so, res) = ([], [], [0 for x in range(n)])\n    count = 0\n    for i in range(n):\n        if s[i] == '0':\n            if not so:\n                count += 1\n                res[i] = count\n                sz.append(count)\n            else:\n                c = so.pop()\n                res[i] = c\n                sz.append(c)\n        elif not sz:\n            count += 1\n            res[i] = count\n            so.append(count)\n        else:\n            c = sz.pop()\n            res[i] = c\n            so.append(c)\n    print(count)\n    print(*res)", "for _ in range(int(input())):\n    n = int(input())\n    st = input()\n    end0 = []\n    end1 = []\n    cnt = 1\n    arr = []\n    for (idx, s) in enumerate(st):\n        if s == '0':\n            if not end1:\n                end0.append(cnt)\n                arr.append(cnt)\n                cnt += 1\n            else:\n                num = end1.pop()\n                end0.append(num)\n                arr.append(num)\n        elif not end0:\n            end1.append(cnt)\n            arr.append(cnt)\n            cnt += 1\n        else:\n            num = end0.pop()\n            end1.append(num)\n            arr.append(num)\n    print(len(end0) + len(end1))\n    print(*arr)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    s = input()\n    i = 0\n    end = [[], []]\n    res = []\n    for c in s:\n        v = int(c)\n        if end[1 - v]:\n            end[v].append(end[1 - v].pop())\n        else:\n            i += 1\n            end[v].append(i)\n        res.append(end[v][-1])\n    print(i)\n    print(*res)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input()))\n    l1 = [[], []]\n    l1[abs(l[0] - 1)].append(1)\n    (r, a) = ([1], 1)\n    for i in l[1:]:\n        if l1[i]:\n            b = l1[i].pop()\n            r.append(b)\n            l1[abs(i - 1)].append(b)\n        else:\n            a += 1\n            r.append(a)\n            l1[abs(i - 1)].append(a)\n    print(a)\n    print(*r)", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    ones = [[], []]\n    ans = [0] * n\n    cnt = 0\n    for i in range(n):\n        x = int(s[i]) ^ 1\n        if not ones[x]:\n            cnt += 1\n            ans[i] = cnt\n        else:\n            ans[i] = ones[x][-1]\n            ones[x].pop()\n        ones[x ^ 1].append(ans[i])\n    print(cnt)\n    print(*ans)"]