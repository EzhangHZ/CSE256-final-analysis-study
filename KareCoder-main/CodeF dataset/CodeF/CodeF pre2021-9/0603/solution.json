["import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    from functools import lru_cache\n    n = int(input())\n    arr = list(map(int, input().split()))\n    odd = 0\n    even = 0\n    for (i, el) in enumerate(arr):\n        if el % 2:\n            odd += 1\n        else:\n            even += 1\n    odd = n // 2 + n % 2 - odd\n    even = n // 2 - even\n\n    @lru_cache(None)\n    def solve(i, o, prev):\n        if o < 0:\n            return float('inf')\n        if i == n:\n            if o:\n                return float('inf')\n            else:\n                return 0\n        else:\n            if prev == None:\n                if arr[i] != 0:\n                    ans = solve(i + 1, o, arr[i] % 2)\n                else:\n                    ans = min(solve(i + 1, o - 1, 1), solve(i + 1, o, 0))\n            elif arr[i] != 0:\n                ans = int(prev != arr[i] % 2) + solve(i + 1, o, arr[i] % 2)\n            else:\n                ans = min(int(prev != 1) + solve(i + 1, o - 1, 1), int(prev != 0) + solve(i + 1, o, 0))\n            return ans\n    print(solve(0, odd, None))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from functools import lru_cache\nn = int(input())\np = list(map(int, input().split()))\nc = [i % 2 for i in p].count(1)\nif n % 2 == 0:\n    t = n // 2 - c\nelse:\n    t = n // 2 - c + 1\n\n@lru_cache(None)\ndef dfs(i, t, q):\n    if t < 0 or t > n - i:\n        return float('inf')\n    elif i == n:\n        return 0 if t == 0 else float('inf')\n    if p[i] == 0:\n        if q == 0:\n            return min(dfs(i + 1, t, 0), dfs(i + 1, t - 1, 1) + 1)\n        else:\n            return min(dfs(i + 1, t - 1, 1), dfs(i + 1, t, 0) + 1)\n    else:\n        return abs(q - p[i] % 2) + dfs(i + 1, t, p[i] % 2)\nif p[0] == 0:\n    print(min(dfs(1, t - 1, 1), dfs(1, t, 0)))\nelse:\n    print(dfs(1, t, p[0] % 2))", "n = int(input())\nnums = list(map(int, input().split(' ')))\nif n == 1:\n    print(0)\n    exit()\nmemory = {}\n\ndef dp(i, j, k):\n    if i < k - 1:\n        return 100\n    if i < 0:\n        if j == 1 and k != 0 or (j == 0 and k != -1):\n            return 100\n        else:\n            return 0\n    if nums[i] != 0:\n        if nums[i] % 2 != j:\n            return 100\n        if j == 0:\n            return min(dp(i - 1, 0, k - 1), dp(i - 1, 1, k) + 1)\n        else:\n            return min(dp(i - 1, 0, k - 1) + 1, dp(i - 1, 1, k))\n    if (i, j, k) in memory:\n        return memory[i, j, k]\n    if j == 0:\n        res = min(dp(i - 1, 0, k - 1), dp(i - 1, 1, k) + 1)\n    else:\n        res = min(dp(i - 1, 0, k - 1) + 1, dp(i - 1, 1, k))\n    memory.setdefault((i, j, k), res)\n    return res\nres = min(dp(n - 1, 0, (n >> 1) - 1), dp(n - 1, 1, n >> 1))\nprint(res)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nb = list(map(int, input().split()))\ndum = n // 2 + 1\nnxtd_arr = [[[101, 101] for _ in range(dum)] for _ in range(n + 1)]\nnxtd_arr[0][0][0] = nxtd_arr[0][0][1] = 0\nfor i in range(1, n + 1):\n    if b[i - 1] == 0:\n        for j in range(1, dum):\n            nxtd_arr[i][j][0] = min(nxtd_arr[i - 1][j - 1][0], nxtd_arr[i - 1][j - 1][1] + 1)\n        for j in range(dum):\n            nxtd_arr[i][j][1] = min(nxtd_arr[i - 1][j][0] + 1, nxtd_arr[i - 1][j][1])\n    elif b[i - 1] % 2 == 0:\n        for j in range(1, dum):\n            nxtd_arr[i][j][0] = min(nxtd_arr[i - 1][j - 1][0], nxtd_arr[i - 1][j - 1][1] + 1)\n    else:\n        for j in range(dum):\n            nxtd_arr[i][j][1] = min(nxtd_arr[i - 1][j][0] + 1, nxtd_arr[i - 1][j][1])\nprint(min(nxtd_arr[-1][-1]))", "n = int(input())\nbulbs = list(map(int, input().split()))\nli = []\nodds = 0\nblanks = 0\nfor (i, e) in enumerate(bulbs):\n    if e != 0:\n        if e % 2 == 1:\n            li.append((i, 1))\n            odds += 1\n        else:\n            li.append((i, 0))\n    else:\n        blanks += 1\nodds = (n + 1) // 2 - odds\neven = blanks - odds\nans = 0\nspaces = []\nif len(li) > 0 and li[0][0] != 0:\n    li = [(-1, li[0][1])] + li\nif len(li) > 0 and li[-1][0] != n - 1:\n    li = li + [(n, li[-1][1])]\nfor i in range(len(li) - 1):\n    if li[i][1] == li[i + 1][1]:\n        temp = (li[i][0] == -1 or li[i + 1][0] == n, li[i + 1][0] - li[i][0] - 1, li[i][1])\n    else:\n        temp = None\n        ans += 1\n    if temp is not None and temp[1] > 0:\n        spaces.append(temp)\nspaces.sort()\nfor space in spaces:\n    if space[2] == 0:\n        if even < space[1]:\n            ans += 1 if space[0] else 2\n        else:\n            even -= space[1]\n    elif odds < space[1]:\n        ans += 1 if space[0] else 2\n    else:\n        odds -= space[1]\nif len(li) == 0:\n    ans = min(1, n - 1)\nprint(ans)", "def solve(bulbs, i, ec, oc, prev, memo={}):\n    if i == len(bulbs):\n        if min(ec, oc) != 0:\n            return float('inf')\n        return 0\n    if bulbs[i] != 0:\n        return (prev != bulbs[i] % 2) + solve(bulbs, i + 1, ec, oc, bulbs[i] % 2, memo)\n    if (i, ec, oc, prev) not in memo:\n        eit = (prev == 1) + solve(bulbs, i + 1, ec - 1, oc, 0, memo)\n        oit = (prev == 0) + solve(bulbs, i + 1, ec, oc - 1, 1, memo)\n        memo[i, ec, oc, prev] = min(eit, oit)\n    return memo[i, ec, oc, prev]\nn = int(input())\nbulbs = list(map(int, input().split()))\nbulbSet = set(bulbs)\n(ec, oc) = (0, 0)\nfor i in range(1, n + 1):\n    if i not in bulbSet:\n        if i % 2 == 0:\n            ec += 1\n        else:\n            oc += 1\n    memo = {}\nprint(min(solve(bulbs, 0, ec, oc, 0, memo), solve(bulbs, 0, ec, oc, 1, memo)))", "import sys\ninput = sys.stdin.readline\nn = int(input())\nA = list(map(int, input().split()))\nDP0 = [[200] * (n + 1) for i in range(n + 1)]\nDP1 = [[200] * (n + 1) for i in range(n + 1)]\nDP0[0][0] = 0\nDP1[0][0] = 0\nfor i in range(n):\n    SUM = i + 1\n    if A[i] != 0:\n        if A[i] % 2 == 1:\n            for j in range(1, SUM + 1):\n                DP1[j][SUM - j] = min(DP0[j - 1][SUM - j] + 1, DP1[j - 1][SUM - j])\n        else:\n            for j in range(1, SUM + 1):\n                DP0[SUM - j][j] = min(DP0[SUM - j][j - 1], DP1[SUM - j][j - 1] + 1)\n    else:\n        for j in range(1, SUM + 1):\n            DP1[j][SUM - j] = min(DP0[j - 1][SUM - j] + 1, DP1[j - 1][SUM - j])\n        for j in range(1, SUM + 1):\n            DP0[SUM - j][j] = min(DP0[SUM - j][j - 1], DP1[SUM - j][j - 1] + 1)\nANS = min(DP0[n - n // 2][n // 2], DP1[n - n // 2][n // 2])\nprint(ANS)", "import math\nn = int(input())\ny = n // 2\nx = n - y\na = [0]\ns = input().split(' ')\nfor i in range(1, n + 1):\n    a.append(int(s[i - 1]))\nif n == 1:\n    print(0)\n    exit()\ninf = 99999999\ndp = [[], []]\nfor i in range(y + 1):\n    dp[1].append([inf, inf])\nif a[1] > 0:\n    if a[1] % 2 == 0:\n        dp[1][1][0] = 0\n    else:\n        dp[1][0][1] = 0\nelse:\n    dp[1][1][0] = 0\n    dp[1][0][1] = 0\nfor i in range(2, n + 1):\n    dp.append([])\n    for j in range(y + 1):\n        dp[i].append([inf, inf])\n        if a[i] > 0:\n            if a[i] % 2 == 0:\n                if j > 0:\n                    dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\n            else:\n                dp[i][j][1] = min(dp[i - 1][j][1], dp[i - 1][j][0] + 1)\n        else:\n            if j > 0:\n                dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\n            dp[i][j][1] = min(dp[i - 1][j][1], dp[i - 1][j][0] + 1)\nprint(min(dp[n][y][0], dp[n][y][1]))", "n = int(input())\ns = list(map(int, input().split()))\ndp = [[[float('INF'), float('INF')] for i in range(n // 2 + 1)] for i in range(n + 1)]\ndp[0][0] = [0, 0]\nfor i in range(1, n + 1):\n    if s[i - 1] == 0:\n        for j in range(1, n // 2 + 1):\n            dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\n        for j in range(n // 2 + 1):\n            dp[i][j][1] = min(dp[i - 1][j][0] + 1, dp[i - 1][j][1])\n    elif s[i - 1] % 2 == 0:\n        for j in range(1, n // 2 + 1):\n            dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\n    else:\n        for j in range(n // 2 + 1):\n            dp[i][j][1] = min(dp[i - 1][j][0] + 1, dp[i - 1][j][1])\nprint(min(dp[-1][-1]))", "n = int(input())\ns = list(map(int, input().split()))\ndp = [[[float('INF'), float('INF')] for i in range(n // 2 + 1)] for i in range(n + 1)]\ndp[0][0] = [0, 0]\nfor i in range(1, n + 1):\n    if s[i - 1] == 0:\n        for j in range(1, n // 2 + 1):\n            dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\n        for j in range(n // 2 + 1):\n            dp[i][j][1] = min(dp[i - 1][j][0] + 1, dp[i - 1][j][1])\n    elif s[i - 1] % 2 == 0:\n        for j in range(1, n // 2 + 1):\n            dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\n    else:\n        for j in range(n // 2 + 1):\n            dp[i][j][1] = min(dp[i - 1][j][0] + 1, dp[i - 1][j][1])\nprint(min(dp[-1][-1]))", "from functools import lru_cache\nN = int(input())\nnums = list(map(int, input().strip().split()))\n\n@lru_cache(None)\ndef dp(a, b, last):\n    if a < 0 or b < 0:\n        return N\n    if a == 0 and b == 0:\n        return 0\n    i = N - a - b\n    if nums[i] != 0:\n        bit = nums[i] & 1\n        if bit == 0:\n            a -= 1\n        else:\n            b -= 1\n        return dp(a, b, bit) + (bit ^ last)\n    else:\n        return min(dp(a - 1, b, 0) + last, dp(a, b - 1, 1) + 1 - last)\n(b, a) = ((N + 1) // 2, N // 2)\nprint(min(dp(a, b, 0), dp(a, b, 1)))", "import sys\nimport math, bisect, operator\n(inf, mod) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 5)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\nn = I()\na = Neo()\ndp = [[[1000, 1000] for i in range(n + 1)] for j in range(n + 1)]\ndp[0][0][0] = dp[0][0][1] = 0\nfor i in range(1, n + 1):\n    k = a[i - 1]\n    for j in range(i + 1):\n        if k & 1 or k == 0:\n            dp[i][j][1] = min(dp[i - 1][j][0] + 1, dp[i - 1][j][1])\n        if k & 1 == 0:\n            dp[i][j][0] = min(dp[i - 1][j - 1][0], dp[i - 1][j - 1][1] + 1)\nprint(min(dp[n][n >> 1]))", "n = int(input())\na = list(map(int, input().split()))\nINF = 10 ** 5\ndp = [[[INF] * (n + 1) for i in range(n + 1)] for i in range(2)]\ndp[0][0][0] = 0\ndp[1][0][0] = 0\nfor i in range(n):\n    if a[i] != 0:\n        parity = a[i] % 2\n        if parity % 2 == 0:\n            for j in range(n + 1):\n                dp[0][i + 1][j] = min(dp[0][i][j], dp[0][i + 1][j])\n                dp[0][i + 1][j] = min(dp[1][i][j] + 1, dp[0][i + 1][j])\n        if parity % 2 == 1:\n            for j in range(n):\n                dp[1][i + 1][j + 1] = min(dp[1][i][j], dp[1][i + 1][j + 1])\n                dp[1][i + 1][j + 1] = min(dp[0][i][j] + 1, dp[1][i + 1][j + 1])\n    else:\n        for j in range(n + 1):\n            dp[0][i + 1][j] = min(dp[0][i][j], dp[0][i + 1][j])\n            dp[0][i + 1][j] = min(dp[1][i][j] + 1, dp[0][i + 1][j])\n        for j in range(n):\n            dp[1][i + 1][j + 1] = min(dp[1][i][j], dp[1][i + 1][j + 1])\n            dp[1][i + 1][j + 1] = min(dp[0][i][j] + 1, dp[1][i + 1][j + 1])\nodd_cnt = (n + 1) // 2\neven_cnt = n // 2\nprint(min(dp[1][n][odd_cnt], dp[0][n][odd_cnt]))"]