["def func():\n    n = int(input())\n    l = list(map(int, input().split()))\n    pois = 0\n    health = 0\n    neg_pos = []\n    for potion in l:\n        if potion >= 0:\n            pois += 1\n            health += potion\n        elif potion + health >= 0:\n            pois += 1\n            health += potion\n            neg_pos.append(potion)\n        elif neg_pos:\n            mn = min(neg_pos)\n            if potion > mn:\n                health = health - mn + potion\n                neg_pos.remove(mn)\n                neg_pos.append(potion)\n    return pois\nt = 1\nfor i in range(t):\n    print(func())", "from heapq import heappush, heappushpop\nn = int(input())\n(*arr,) = map(int, input().split())\n(H, sm) = ([], 0)\nfor x in arr:\n    sm += x\n    sm -= (heappushpop(H, x) if sm < 0 else heappush(H, x)) or 0\nprint(len(H))", "n = int(input())\nl1 = [int(a) for a in input().split()]\nnegs = []\n(ctr, sm) = (0, 0)\nfor i in range(n):\n    sm += l1[i]\n    ctr += 1\n    if l1[i] < 0:\n        negs.append(l1[i])\n        negs.sort(reverse=True)\n    while sm < 0:\n        sm -= negs[-1]\n        negs.pop()\n        ctr -= 1\nprint(ctr)", "import heapq\nn = int(input())\npotions = list(map(int, input().split()))\nhp = result = 0\npoisons = []\nfor potion in potions:\n    if potion >= 0:\n        hp += potion\n        result += 1\n    elif hp + potion >= 0:\n        hp += potion\n        result += 1\n        heapq.heappush(poisons, potion)\n    else:\n        if not poisons:\n            continue\n        if potion > poisons[0]:\n            hp += potion - heapq.heappushpop(poisons, potion)\nprint(result)", "from heapq import heapify, heappush, heappop\n\ndef T():\n    return int(input())\n\ndef S():\n    return str(input())\n\ndef A():\n    return list(map(int, input().split(' ')))\n\ndef M():\n    return map(int, input().split(' '))\nn = T()\nheap = []\nheapify(heap)\narr = A()\ntotal = 0\ncount = 0\nfor i in arr:\n    total += i\n    heappush(heap, i)\n    while total < 0:\n        total -= heappop(heap)\nprint(len(heap))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\ntemp = []\ntotal = 0\npotions = 0\nfor i in arr:\n    if i < 0:\n        heapq.heappush(temp, i)\n    total += i\n    potions += 1\n    while total < 0:\n        total -= heapq.heappop(temp)\n        potions -= 1\nprint(potions)", "import heapq\nn = int(input())\npotions = list(map(int, input().split()))\nminH = []\nhealth = 0\nres = 0\nfor p in potions:\n    health += p\n    if health >= 0:\n        res += 1\n    if p >= 0:\n        continue\n    heapq.heappush(minH, p)\n    if health < 0:\n        min_val = heapq.heappop(minH)\n        health -= min_val\nprint(res)", "import math\nimport bisect\nn = input()\nl = list(map(int, input().split()))\npot = []\ncurr = 0\ncnt = 0\nfor i in l:\n    if pot == []:\n        if curr + i > -1:\n            curr = curr + i\n            pot.append(i)\n            cnt += 1\n    elif curr + i > -1:\n        curr = curr + i\n        if i < 0:\n            pot.append(i)\n        cnt += 1\n    else:\n        minn = min(pot)\n        if minn < i:\n            pot.remove(minn)\n            if i < 0:\n                pot.append(i)\n            curr = curr + i - minn\nprint(cnt)", "from heapq import heappush, heappushpop\nn = int(input())\na = list(map(int, input().split()))\ncnt = 0\nx = 0\nh = []\nfor d in a:\n    if d >= 0:\n        x += d\n        cnt += 1\n        continue\n    if x + d >= 0:\n        x += d\n        cnt += 1\n        heappush(h, d)\n    elif h:\n        y = heappushpop(h, d)\n        x += d - y\nprint(cnt)", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq\npq = []\nheapq.heapify(pq)\nn = int(input())\nl = map(int, input().split())\nh = ans = 0\nfor i in l:\n    if h + i >= 0:\n        h += i\n        ans += 1\n        heapq.heappush(pq, i)\n    elif pq and heapq.nsmallest(1, pq)[0] < i:\n        h -= heapq.heappop(pq)\n        h += i\n        heapq.heappush(pq, i)\nprint(ans)", "import heapq\nneg = []\nheapq.heapify(neg)\nn = int(input())\nl = map(int, input().split())\nh = ans = 0\nfor i in l:\n    if i >= 0:\n        h += i\n        ans += 1\n    elif h + i >= 0:\n        h += i\n        ans += 1\n        heapq.heappush(neg, i)\n    elif neg and heapq.nsmallest(1, neg)[0] < i:\n        h -= heapq.heappop(neg)\n        h += i\n        heapq.heappush(neg, i)\nprint(ans)", "import sys\nimport heapq\nn = int(sys.stdin.readline())\nnums = list(map(int, sys.stdin.readline().split()))\nsu = 0\nh = []\nans = 0\nfor i in nums:\n    su += i\n    heapq.heappush(h, i)\n    if su < 0:\n        su -= heapq.heappop(h)\n    else:\n        ans += 1\nprint(ans)", "import math\nimport heapq\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().strip().split()))\n    for i in range(n):\n        if arr[i] >= 0:\n            arr = arr[i:n + 1]\n            n = len(arr)\n            break\n    heap = []\n    S = 0\n    ans = 0\n    for i in range(n):\n        if arr[i] < 0:\n            heapq.heappush(heap, arr[i])\n        S += arr[i]\n        ans += 1\n        while S < 0:\n            a = heapq.heappop(heap)\n            ans -= 1\n            S -= a\n    return ans\nprint(solve())", "from collections import deque\nimport heapq\nfrom math import sqrt\nimport operator\nfrom operator import itemgetter\nimport sys\nimport copy\ninf_var = 0\nif inf_var == 1:\n    inf = open('input.txt', 'r')\nelse:\n    inf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n    return int(input().rstrip('\\n'))\n\ndef read_one_float():\n    return float(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n    res = [int(val) for val in input().rstrip('\\n').split()]\n    return res\n\ndef read_list_of_ints_zero():\n    return [int(val) - 1 for val in input().rstrip('\\n').split()]\n\ndef read_str():\n    return input().rstrip()\n\ndef main():\n    n = read_one_int()\n    elements = read_list_of_ints()\n    cur_sum = 0\n    res = 0\n    q = []\n    heapq.heapify(q)\n    for el in elements:\n        if cur_sum + el >= 0:\n            res += 1\n            cur_sum += el\n            if el < 0:\n                heapq.heappush(q, el)\n        elif not q:\n            continue\n        elif el > q[0]:\n            popped = heapq.heappop(q)\n            cur_sum -= popped\n            cur_sum += el\n            heapq.heappush(q, el)\n    print(res)\nmain()", "import heapq\nn = int(input())\na = list(map(int, input().split()))\ns = 0\nh = []\nfor i in a:\n    s += i\n    heapq.heappush(h, i)\n    if s < 0:\n        s -= heapq.heappop(h)\nprint(len(h))", "n = int(input())\na = list(map(lambda x: int(x), input().split()))\ns = 0\nans = []\nfor i in range(n):\n    if s + a[i] >= 0:\n        s += a[i]\n        ans.append(a[i])\n        ans.sort()\n    elif ans and ans[0] < a[i]:\n        s += a[i] - ans[0]\n        ans.pop(0)\n        ans.append(a[i])\n        ans.sort()\nprint(len(ans))", "a = int(input())\narr = [int(arr) for arr in input().split()]\ntotal = 0\ncount = 0\nneg = []\nfor i in arr:\n    total = total + i\n    count = count + 1\n    if i < 0:\n        neg.append(i)\n    if total < 0:\n        total = total - min(neg)\n        neg.remove(min(neg))\n        count = count - 1\nprint(count)", "input()\nx = map(int, input().split())\nm = 0\nm1 = []\nc = 0\nfor i in x:\n    if m + i >= 0:\n        if i < 0:\n            m1 += [i]\n    elif m1:\n        if i > min(m1):\n            m = m - min(m1)\n            m1.remove(min(m1))\n            m1.append(i)\n            c -= 1\n    if m + i >= 0:\n        m += i\n        c += 1\nprint(c)", "n = int(input())\na = list(map(int, input().split()))\n(arr, x, ans) = ([], 0, 0)\nfor i in range(n):\n    if a[i] < 0:\n        arr.append(a[i])\n        arr = sorted(arr, reverse=True)\n    x = x + a[i]\n    if x < 0:\n        x -= arr.pop()\n    else:\n        ans = ans + 1\nprint(ans)", "import heapq\nn = int(input())\na = list(map(int, input().split()))\nans = 0\nsum_ = 0\nlst = []\nheapq.heapify(lst)\nfor i in range(n):\n    if a[i] >= 0:\n        sum_ += a[i]\n        ans += 1\n    elif sum_ + a[i] >= 0:\n        sum_ += a[i]\n        heapq.heappush(lst, a[i])\n        ans += 1\n    elif len(lst) != 0:\n        min_ = heapq.heappop(lst)\n        if min_ > a[i]:\n            heapq.heappush(lst, min_)\n        else:\n            heapq.heappush(lst, a[i])\n            sum_ += a[i] - min_\nprint(ans)", "n = input()\nl = list(map(int, input().split()))\npot = []\ncurr = 0\ncnt = 0\nfor i in l:\n    if pot == []:\n        if curr + i > -1:\n            curr = curr + i\n            pot.append(i)\n            cnt += 1\n    elif curr + i > -1:\n        curr = curr + i\n        if i < 0:\n            pot.append(i)\n        cnt += 1\n    else:\n        minn = min(pot)\n        if minn < i:\n            pot.remove(minn)\n            if i < 0:\n                pot.append(i)\n            curr = curr + i - minn\nprint(cnt)", "n = int(input())\nA = list(map(int, input().split()))\nimport heapq\ncur = 0\nprev = []\ncnt = 0\nfor x in A:\n    if x < 0:\n        if cur + x >= 0:\n            cur += x\n            heapq.heappush(prev, x)\n            cnt += 1\n        elif prev and prev[0] < x:\n            cur += x - prev[0]\n            heapq.heappop(prev)\n            heapq.heappush(prev, x)\n    else:\n        cur += x\n        cnt += 1\nprint(cnt)", "import heapq as h\nn = int(input())\nl = list(map(int, input().split()))\nk = 0\na = 0\nz = []\nfor i in l:\n    if i < 0:\n        h.heappush(z, i)\n    if k + i >= 0:\n        k += i\n        a += 1\n    else:\n        k -= h.heappop(z)\n        k += i\nprint(a)", "import heapq\nn = int(input())\nd = {}\na = list(map(int, input().split()))\none = 111\nans = []\ntwww00o = 2222\nheapq.heapify(ans)\nthreee = 21\ntot = 0\nf54rth = 0\nct = 0\nzkt = 54\nflag = True\nfor i in a:\n    th = 25\n    tot += i\n    z = 5\n    ct += 1\n    gh = 52\n    if i < 0:\n        ty = 10\n        heapq.heappush(ans, i)\n        k = 50\n    while tot < 0:\n        tr = 56\n        t = heapq.heappop(ans)\n        tot += abs(t)\n        tg = 41\n        ct -= 1\nthu = 10\nprint(ct)", "n = int(input())\narr = []\ninp = input().split()\nfor i in inp:\n    arr.append(int(i))\nsum1 = 0\nresult = []\ncount = 0\nimport heapq\narr1 = []\nfor i in arr:\n    sum1 += i\n    count += 1\n    if i < 0:\n        heapq.heappush(arr1, i)\n    if sum1 < 0:\n        while sum1 < 0:\n            s = heapq.heappop(arr1)\n            sum1 -= s\n            count -= 1\nprint(count)", "import heapq\n\ndef question3():\n    N = int(input())\n    arr = list(map(int, input().split()))\n    k1 = []\n    heapq.heapify(k1)\n    sum_upto = 0\n    count = 0\n    for i in range(N):\n        sum_upto += arr[i]\n        if arr[i] < 0:\n            heapq.heappush(k1, arr[i])\n        if sum_upto < 0:\n            m1 = heapq.heappop(k1)\n            sum_upto -= m1\n        else:\n            count += 1\n    return count\nremained_test_cases = 1\nwhile remained_test_cases > 0:\n    print(question3())\n    remained_test_cases -= 1", "import heapq as hp\nn = int(input())\narr = list(map(int, input().split()))\ns = 0\nres = []\nhp.heapify(res)\nfor i in arr:\n    if i < 0:\n        hp.heappush(res, i)\n    s += i\n    if s < 0:\n        s -= hp.heappop(res)\n        n -= 1\nprint(n)", "import heapq as h\nn = int(input())\nl = list(map(int, input().split()))\nk = 0\na = 0\nz = []\nfor i in l:\n    if i < 0:\n        h.heappush(z, i)\n    if k + i >= 0:\n        k += i\n        a += 1\n    else:\n        k -= h.heappop(z)\n        k += i\nprint(a)", "n = int(input())\nl = list(map(int, input().split()))\ns = 0\nc = 0\nst = []\nfor i in range(n):\n    s += l[i]\n    c += 1\n    if l[i] < 0:\n        st.append(l[i])\n        st = sorted(st, reverse=True)\n    if s < 0:\n        s -= st.pop()\n        c -= 1\nprint(c)", "n = int(input())\nli = list(map(int, input().split()))\nq = []\nc = 0\nv = 0\nfor i in range(0, n):\n    v += li[i]\n    c += 1\n    if li[i] < 0:\n        q.append(li[i])\n        q.sort()\n    if v < 0:\n        v -= q[0]\n        q.sort()\n        q.pop(0)\n        q.sort()\n        c = c - 1\nprint(c)", "import heapq\nh = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(h, i) if tot >= 0 else heapq.heappushpop(h, i)) or 0\nprint(len(h))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\npq = []\ncurr = 0\ncount = 0\nfor ele in arr:\n    if ele >= 0:\n        curr += ele\n        count += 1\n    elif curr + ele >= 0:\n        curr += ele\n        heapq.heappush(pq, ele)\n        count += 1\n    elif pq and pq[0] < ele:\n        curr -= heapq.heappop(pq)\n        heapq.heappush(pq, ele)\n        curr += ele\nprint(count)", "n = int(input())\narr = list(map(int, input().split()))\nheap = []\nfrom heapq import heappop, heappush\ncur = 0\nfor x in range(n):\n    cur += arr[x]\n    heappush(heap, arr[x])\n    while cur < 0:\n        k = heappop(heap)\n        cur += -k\nprint(len(heap))", "x = int(input())\na = list(map(int, input().split()))\nb = []\ns = 0\nc = 0\nfor i in a:\n    s = s + i\n    c = c + 1\n    if i < 0:\n        b.append(i)\n        b.sort()\n    if s < 0:\n        s = s - b[0]\n        b.sort()\n        b.pop(0)\n        b.sort()\n        c = c - 1\nprint(c)", "x = int(input())\na = list(map(int, input().split()))\nb = []\ns = 0\nc = 0\nfor i in a:\n    s = s + i\n    c = c + 1\n    if i < 0:\n        b.append(i)\n        b.sort()\n    if s < 0:\n        s = s - b[0]\n        b.pop(0)\n        c = c - 1\nprint(c)", "from heapq import heapify, heappush, heappop\nn = int(input())\narr = list(map(int, input().split()))\nheap = []\nheapify(heap)\nhealth = 0\ncount = 0\nfor i in range(n):\n    if health + arr[i] >= 0:\n        health += arr[i]\n        count += 1\n        heappush(heap, arr[i])\n    elif len(heap) > 0:\n        val = heap[0]\n        if val < 0 and val < arr[i]:\n            heappop(heap)\n            health += abs(val)\n            if health + arr[i] >= 0:\n                health += arr[i]\n                count += 1\n                heappush(heap, arr[i])\nprint(len(heap))", "from heapq import *\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\nlst = list(map(int, input().split()))\n(hp, arr) = (0, [])\nfor i in lst:\n    hp += i\n    heappush(arr, i)\n    if hp < 0:\n        hp -= heappop(arr)\nprint(len(arr))", "import sys\nimport heapq\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().rstrip().split(' ')))\nB = [0]\nheapq.heapify(B)\nhealth = 0\nfor a in A:\n    if health + a < 0:\n        b = heapq.heappop(B)\n        health -= b\n        a = max(a, b)\n    heapq.heappush(B, a)\n    health += a\nprint(len(B) - 1)", "import heapq\nn = int(input())\nl = list(map(int, input().split()))\nhp = []\nheapq.heapify(hp)\ncnt = 0\ncur = 0\nfor i in range(n):\n    if l[i] >= 0:\n        cur += l[i]\n        cnt += 1\n    elif cur + l[i] >= 0:\n        cur += l[i]\n        heapq.heappush(hp, l[i])\n    elif len(hp) > 0:\n        x = heapq.heappop(hp)\n        if x < l[i]:\n            cur += -x\n            cur += l[i]\n            heapq.heappush(hp, l[i])\n        else:\n            heapq.heappush(hp, x)\nprint(cnt + len(hp))", "def solve(n, a):\n    count = health = 0\n    i = 0\n    while i < len(a):\n        health += a[i]\n        count += 1\n        if health < 0:\n            min_dam = min(a[:i + 1])\n            a.remove(min_dam)\n            health -= min_dam\n            count -= 1\n            continue\n        i += 1\n    return count\nn = int(input())\na = list(map(int, input().strip().split()))[:n]\nprint(solve(n, a))", "from heapq import heapify, heappush, heappop\nn = int(input())\narr = list(map(int, input().split()))\nheap = []\nheapify(heap)\n_sum = 0\nans = 0\nfor i in range(n):\n    _sum += arr[i]\n    heappush(heap, arr[i])\n    ans += 1\n    while _sum < 0:\n        pop = heappop(heap)\n        _sum -= pop\n        ans -= 1\nprint(ans)", "from heapq import *\nn = int(input())\nl = list(map(int, input().split()))\nq = []\nheapify(q)\nt = 0\nres = 0\nbest = -99 ** 9\nneg_top = 0\nfor i in l:\n    if i >= 0:\n        res += i\n        t += 1\n        best = max(best, t)\n    elif res + i >= 0:\n        heappush(q, i)\n        res += i\n        t += 1\n        neg_top += i\n        best = max(best, t)\n    else:\n        res += i\n        heappush(q, i)\n        t += 1\n        neg_top += i\n        while res < 0:\n            h = heappop(q)\n            res -= h\n            t -= 1\n            neg_top -= h\n        best = max(best, t)\nprint(max(best, 0))", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import bisect\nI = input\nIN = lambda x: map(int, x.split())\nL = lambda x: list(IN(x))\nn = int(I())\na = L(I())\nj = 0\nd = []\ns = 0\nfor i in a:\n    if i < 0:\n        bisect.insort(d, -i)\n    s += i\n    if s < 0:\n        s += d.pop()\n        j += 1\nprint(n - j)", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq\nn = int(input())\nlis = list(map(int, input().split()))\nl = list()\nsum = 0\nfor i in lis:\n    sum += i\n    heapq.heappush(l, i)\n    while sum < 0:\n        sum -= heapq.heappop(l)\nprint(len(l))", "import heapq\n\ndef func(i, num):\n    count = 0\n    total = 0\n    heap = list()\n    for i in range(n):\n        count += a[i]\n        total += 1\n        heapq.heappush(heap, a[i])\n        while count < 0:\n            poison = heapq.heappop(heap)\n            count -= poison\n            total -= 1\n    print(total)\nn = int(input())\na = list(map(int, input().split()))\nfunc(n - 1, 0)", "import sys\nimport heapq\nN = int(sys.stdin.readline())\narr = list(map(int, sys.stdin.readline().strip().split()))\nans = []\nheapq.heapify(ans)\ntotal = 0\nfor item in arr:\n    total += item\n    if total < 0:\n        total -= heapq.heappushpop(ans, item)\n    else:\n        heapq.heappush(ans, item)\nprint(len(ans))", "import heapq\nn = int(input())\npotion = list(map(int, input().split()))\n(nowhp, ans) = (0, 0)\nminheap = []\nfor i in range(n):\n    if potion[i] >= 0:\n        nowhp = nowhp + potion[i]\n        ans = ans + 1\n        continue\n    elif nowhp + potion[i] >= 0:\n        nowhp = nowhp + potion[i]\n        ans = ans + 1\n        heapq.heappush(minheap, potion[i])\n        continue\n    elif len(minheap) == 0 or potion[i] < heapq.nsmallest(1, minheap)[0]:\n        continue\n    else:\n        nowhp = nowhp - heapq.nsmallest(1, minheap)[0] + potion[i]\n        heapq.heappop(minheap)\n        heapq.heappush(minheap, potion[i])\nprint(ans)", "from heapq import *\nn = int(input())\nheap = []\n(res, sumval) = (n, 0)\nfor i in map(int, input().split()):\n    sumval += i\n    heappush(heap, i)\n    while sumval < 0:\n        sumval -= heappop(heap)\n        res -= 1\nprint(res)", "import heapq\nn = int(input())\na = [*map(int, input().split())]\n(h, t) = ([], 0)\nfor i in a:\n    t += i\n    heapq.heappush(h, i)\n    while t < 0:\n        t -= heapq.heappop(h)\nprint(len(h))", "import sys\nimport heapq\nread = sys.stdin.readline\n\ndef run_case():\n    n = int(read())\n    ar = list(map(int, read().split()))\n    heap = []\n    i = 0\n    s = 0\n    res = 0\n    while i < n:\n        if ar[i] >= 0:\n            s += ar[i]\n            i += 1\n            res += 1\n        else:\n            j = i\n            while j < n and ar[j] < 0:\n                j += 1\n            tr = ar[i:j]\n            i = j\n            tr.sort(reverse=True)\n            for t in tr:\n                if s + t >= 0:\n                    s += t\n                    res += 1\n                    heapq.heappush(heap, t)\n                elif len(heap) > 0 and heap[0] < t:\n                    s -= heap[0]\n                    res -= 1\n                    heapq.heappop(heap)\n                    s += t\n                    res += 1\n                    heapq.heappush(heap, t)\n                else:\n                    break\n    print(res)\nrun_case()", "n = int(input())\npotions = tuple(map(int, input().split()))\nhealth = 0\nres = 0\nconsidered_harmful_potions = {}\nmost_harmful_potion = 0\nfor potion in potions:\n    res += 1\n    if potion < 0:\n        if potion in considered_harmful_potions:\n            considered_harmful_potions[potion] += 1\n        else:\n            considered_harmful_potions[potion] = 1\n        most_harmful_potion = min(most_harmful_potion, potion)\n    health += potion\n    if health < 0:\n        considered_harmful_potions[most_harmful_potion] -= 1\n        health -= most_harmful_potion\n        res -= 1\n        if considered_harmful_potions[most_harmful_potion] == 0:\n            del considered_harmful_potions[most_harmful_potion]\n        most_harmful_potion = min(considered_harmful_potions.keys(), default=0)\nprint(res)", "n = int(input())\nA = list(map(int, input().split()))\nsm = 0\ncnt = 0\nNeg = []\nfor i in range(n):\n    if sm + A[i] >= 0:\n        cnt += 1\n        sm += A[i]\n        if A[i] < 0:\n            Neg.append(A[i])\n    elif Neg:\n        if A[i] > min(Neg):\n            sm += A[i] - min(Neg)\n            Neg.remove(min(Neg))\n            Neg.append(A[i])\nprint(cnt)", "import sys\nimport heapq\n\ndef main():\n    size = int(sys.stdin.readline().split()[0])\n    a = [int(x) for x in sys.stdin.readline().split()]\n    heap = []\n    tot = 0\n    health = 0\n    for num in a:\n        if num >= 0:\n            tot += 1\n            health += num\n        else:\n            newHealth = health + num\n            if newHealth >= 0:\n                tot += 1\n                health = newHealth\n                heapq.heappush(heap, num)\n            elif len(heap) == 0 or num < heap[0]:\n                continue\n            else:\n                removed = heapq.heappop(heap)\n                heapq.heappush(heap, num)\n                health -= removed\n                health += num\n    print(tot)\nmain()", "import heapq\n\ndef sol(A):\n    li = []\n    h = 0\n    count = 0\n    for i in range(len(A)):\n        if h + A[i] >= 0:\n            count += 1\n            h += A[i]\n            if A[i] < 0:\n                heapq.heappush(li, A[i])\n        elif li and li[0] < A[i]:\n            h -= li[0]\n            h += A[i]\n            heapq.heapreplace(li, A[i])\n    return count\nx = int(input())\nA = list(map(int, input().split()))\nprint(sol(A))", "def solve(l):\n    (c, s) = (0, 0)\n    k = []\n    for i in range(len(l)):\n        if l[i] >= 0:\n            s = s + l[i]\n            c = c + 1\n        else:\n            k.append(l[i])\n            s = s + l[i]\n            c = c + 1\n            while s < 0:\n                k.sort()\n                s = s - k[0]\n                k.pop(0)\n                c = c - 1\n    return c\nn = int(input())\nl = list(map(int, input().split()))\nprint(solve(l))", "n = int(input())\nl = list(map(int, input().split()))\nst = []\nct = 0\nval = 0\nfor i in range(n):\n    val += l[i]\n    ct += 1\n    if l[i] < 0:\n        st.append(l[i])\n        st = sorted(st, reverse=True)\n    if val < 0:\n        val -= st[-1]\n        st.pop()\n        ct = ct - 1\nprint(ct)", "import heapq\nh = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(h, i) if tot >= 0 else heapq.heappushpop(h, i)) or 0\nprint(len(h))", "n = int(input())\narr = list(map(int, input().split()))\nq = []\nc = 0\nv = 0\nfor i in range(0, n):\n    v += arr[i]\n    c += 1\n    if arr[i] < 0:\n        q.append(arr[i])\n        q.sort()\n    if v < 0:\n        v -= q[0]\n        q.sort()\n        q.pop(0)\n        q.sort()\n        c = c - 1\nprint(c)", "import heapq\nn = int(input())\na = list(map(int, input().split()))\nserved = []\nsum_ = 0\nfor i in range(n):\n    heapq.heappush(served, a[i])\n    sum_ += a[i]\n    if sum_ < 0:\n        sum_ -= heapq.heappop(served)\nprint(len(served))", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\ninf = int(10 ** 20)\nmax_val = inf\nmin_val = -inf\nRW = lambda : sys.stdin.readline().strip()\nRI = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\nimport heapq\nlens = RI()\narrs = RMI()\nsum_now = 0\ndrop = []\nheapq.heapify(drop)\nfor i in arrs:\n    if i < 0:\n        heapq.heappush(drop, i)\n    sum_now += i\n    if sum_now < 0:\n        sum_now -= heapq.heappop(drop)\n        lens -= 1\nprint(lens)", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nH = []\ntot = 0\nfor i in arr:\n    tot += i\n    heapq.heappush(H, i)\n    while tot < 0:\n        tot -= H[0]\n        heapq.heappop(H)\nprint(len(H))", "from heapq import *\nn = int(input())\narr = list(map(int, input().split()))\nh = []\nheapify(h)\ns = 0\nfor i in arr:\n    s += i\n    heappush(h, i)\n    while s < 0:\n        s -= h[0]\n        heappop(h)\nprint(len(h))", "from heapq import heappop, heappush, heapify\nn = int(input())\na = list(map(int, input().split()))\nheap = []\ncnt = 0\nans = 0\nfor i in range(n):\n    ans += a[i]\n    cnt += 1\n    if a[i] < 0:\n        heappush(heap, a[i])\n    if ans < 0:\n        temp = -1 * heappop(heap)\n        cnt -= 1\n        ans += temp\nprint(cnt)", "import heapq\n\ndef solve():\n    heap = []\n    health = 0\n    potions = 0\n    for i in range(N):\n        if A[i] >= 0:\n            health += A[i]\n            potions += 1\n        elif health + A[i] >= 0:\n            heapq.heappush(heap, A[i])\n            health += A[i]\n            potions += 1\n        elif heap and heap[0] <= A[i]:\n            bad_potion = heapq.heappop(heap)\n            heapq.heappush(heap, A[i])\n            health += A[i] - bad_potion\n            assert health >= 0\n    return potions\nN = int(input())\nA = list(map(int, input().split()))\nprint(solve())", "x = int(input())\na = list(map(int, input().split()))\nb = []\ns = 0\nc = 0\nfor i in a:\n    s = s + i\n    c = c + 1\n    if i < 0:\n        b.append(i)\n        b.sort()\n    if s < 0:\n        s = s - b[0]\n        b.pop(0)\n        b.sort()\n        c = c - 1\nprint(c)", "n = int(input())\nlist1 = list(map(int, input().split()))\ns = 0\nc = 0\nb = []\nfor i in list1:\n    s += i\n    c += 1\n    if i < 0:\n        b.append(i)\n        b.sort()\n    if s < 0:\n        s -= b[0]\n        b.pop(0)\n        c -= 1\nprint(c)", "x = int(input())\na = list(map(int, input().split()))\nb = []\ns = 0\nc = x\nfor i in a:\n    s = s + i\n    if i < 0:\n        b.append(i)\n        b.sort()\n    if s < 0:\n        s = s - b[0]\n        b.pop(0)\n        c = c - 1\nprint(c)", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq\nn = int(input())\nl = [int(x) for x in input().split()]\nans = 0\ncount = 0\nx = []\nheapq.heapify(x)\nfor i in range(n):\n    ans += l[i]\n    heapq.heappush(x, l[i])\n    while ans < 0:\n        ans = ans - heapq.heappop(x)\nprint(len(x))", "import heapq\nI = input\nIN = lambda x: map(int, x.split())\nL = lambda x: list(IN(x))\nn = int(I())\na = L(I())\nj = 0\nd = []\ns = 0\nfor i in a:\n    s += i\n    if s < 0:\n        s -= heapq.heappushpop(d, i)\n        j += 1\n    elif i < 0:\n        heapq.heappush(d, i)\nprint(n - j)", "n = int(input())\npotions = list(map(int, input().split(' ')))\nres = []\ns = 0\nfor i in range(n):\n    s += potions[i]\n    res.append(potions[i])\n    if s < 0:\n        m = min(res)\n        res.remove(m)\n        s += abs(m)\nprint(len(res))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nans = 0\nq = []\ns = 0\nfor i in range(n):\n    if s + arr[i] >= 0:\n        ans += 1\n        s += arr[i]\n        if arr[i] < 0:\n            heapq.heappush(q, arr[i])\n    elif len(q) and q[0] < arr[i]:\n        value = heapq.heappop(q)\n        heapq.heappush(q, arr[i])\n        s -= value\n        s += arr[i]\nprint(ans)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nfrom math import inf, ceil, sqrt\nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nn = int(input())\na = list(map(int, input().split()))\nh = list()\nheapify(h)\n(s, r) = (0, 0)\nfor e in a:\n    if s + e >= 0:\n        (r, s) = (r + 1, s + e)\n        if e < 0:\n            heappush(h, e)\n    elif len(h) and h[0] < e:\n        s -= heappop(h)\n        heappush(h, e)\n        s += e\nprint(r)", "from functools import lru_cache\nfrom collections import deque, defaultdict\nfrom heapq import heappop, heappush\nI = lambda : map(int, input().split())\n\n@lru_cache(None)\ndef dp(x, curr, cnt):\n    if x == n:\n        return cnt\n    ans = 0\n    for i in range(x, n):\n        (op1, op2) = (0, 0)\n        if A[i] + curr >= 0:\n            op1 = dp(i + 1, curr + A[i], cnt + 1)\n        op2 = dp(i + 1, curr, cnt)\n        ans = max(ans, op1, op2)\n    return ans\n\ndef solve(A):\n    res = 0\n    H = []\n    (curr_sum, curr_len) = (0, 0)\n    for a in A:\n        curr_sum += a\n        curr_len += 1\n        heappush(H, a)\n        while H and curr_sum < 0:\n            x = heappop(H)\n            curr_sum -= x\n            curr_len -= 1\n        res = max(res, curr_len)\n    return res\nt = 1\nwhile t:\n    t -= 1\n    n = int(input())\n    A = list(I())\n    print(solve(A))", "def poisons(n: int, dr: list):\n    health = 0\n    amount_pois = 0\n    neg_pois = []\n    for i in range(n):\n        if dr[i] >= 0:\n            amount_pois += 1\n            health += dr[i]\n            continue\n        if health + dr[i] >= 0:\n            amount_pois += 1\n            health += dr[i]\n            neg_pois.append(dr[i])\n            continue\n        if neg_pois:\n            cur_min = min(neg_pois)\n            if dr[i] > cur_min:\n                health -= cur_min\n                health += dr[i]\n                neg_pois.remove(cur_min)\n                neg_pois.append(dr[i])\n    return amount_pois\nn = int(input())\narr = list(map(int, input().split(' ')))\nprint(poisons(n, arr))", "def put_into_list(num: int, arr: list):\n    if not arr:\n        arr.append(num)\n        return\n    for i in range(len(arr)):\n        if arr[i] > num:\n            arr.insert(i, num)\n            return\n    arr.append(num)\n\ndef poisons_simple(n: int, dr: list):\n    health = 0\n    amount_pois = 0\n    neg_pois = []\n    for i in range(n):\n        if dr[i] >= 0:\n            amount_pois += 1\n            health += dr[i]\n            continue\n        if health + dr[i] >= 0:\n            amount_pois += 1\n            health += dr[i]\n            put_into_list(dr[i], neg_pois)\n            continue\n        if neg_pois and dr[i] > neg_pois[0]:\n            health -= neg_pois[0]\n            health += dr[i]\n            neg_pois.pop(0)\n            put_into_list(dr[i], neg_pois)\n    return amount_pois\nn = int(input())\narr = list(map(int, input().split(' ')))\nprint(poisons_simple(n, arr))", "def solve(n, a):\n    count = health = 0\n    arr = []\n    for i in range(n):\n        health += a[i]\n        count += 1\n        arr.append(a[i])\n        if health < 0:\n            min_dam = min(arr)\n            arr.remove(min_dam)\n            health -= min_dam\n            count -= 1\n    return count\nn = int(input())\na = list(map(int, input().strip().split()))[:n]\nprint(solve(n, a))", "n = int(input())\nlis = list(map(int, input().split()))\nans = 0\narr = list()\nimport heapq\nfor i in lis:\n    ans += i\n    heapq.heappush(arr, i)\n    while ans < 0:\n        ans -= heapq.heappop(arr)\nprint(len(arr))", "from heapq import *\nn = int(input())\nheap = []\n(res, sumval) = (n, 0)\nfor i in map(int, input().split()):\n    sumval += i\n    if i < 0:\n        heappush(heap, i)\n    while sumval < 0:\n        sumval -= heappop(heap)\n        res -= 1\nprint(res)", "import sys\nimport math\nimport random\nfrom queue import PriorityQueue\n\ndef solve(arr, n):\n    count = 0\n    pos = 0\n    q = PriorityQueue()\n    for i in arr:\n        if i >= 0:\n            count += 1\n            pos += i\n        elif pos + i >= 0:\n            pos += i\n            q.put(i)\n            count += 1\n        elif q.qsize() > 0 and q.queue[0] < i:\n            val = q.get()\n            q.put(i)\n            pos = pos - val + i\n    print(count)\nn = int(input())\narr = list(map(int, input().split()))\nsolve(arr, n)", "n = int(input())\nl = list(map(int, input().split()))\ns = 0\nc = 0\na = []\nk = 0\nfor i in range(n):\n    s += l[i]\n    if l[i] < 0:\n        a.append(l[i])\n        a.sort(reverse=True)\n    if s < 0:\n        x = a.pop()\n        s = s - x\n        k += 1\nprint(n - k)", "n = int(input())\nl = list(map(int, input().split()))\ns = 0\nc = 0\na = []\nk = 0\nfor i in range(n):\n    s += l[i]\n    if l[i] < 0:\n        a.append(l[i])\n        a.sort(reverse=True)\n    if s < 0:\n        x = a.pop()\n        s = s - x\n        k += 1\nprint(n - k)", "n = int(input())\narr = list(map(int, input().split()))\ndp = []\nfor i in arr:\n    dp.append(i)\n    if i >= 0:\n        continue\n    dp.sort()\n    if sum(dp) < 0:\n        dp.pop(0)\nprint(len(dp))", "n = int(input())\nlis = list(map(int, input().split()))\nans = 0\narr = list()\nfor i in lis:\n    ans += i\n    arr.append(i)\n    arr.sort()\n    while ans < 0:\n        ans -= arr[0]\n        arr.pop(0)\nprint(len(arr))", "def potions(n):\n    lst = [int(i) for i in input().split()]\n    l = []\n    for potion in lst:\n        l.append(potion)\n        if potion < 0 and sum(l) < 0:\n            l = sorted(l)\n            l.pop(0)\n    print(len(l))\nn = int(input())\npotions(n)", "import sys\nfrom heapq import heappop, heappush\nn = int(sys.stdin.readline())\ndata = list(map(int, sys.stdin.readline().split()))\nans = []\ncnt = 0\nfor item in data:\n    cnt += item\n    heappush(ans, item)\n    if cnt < 0:\n        temp = heappop(ans)\n        cnt -= temp\nprint(len(ans))", "n = int(input())\ndrinkings = [int(item) for item in input().split(' ')]\nhealth = 0\ndrinks = []\nfor i in range(n):\n    health += drinkings[i]\n    drinks.append(drinkings[i])\n    if health < 0:\n        Min = min(drinks)\n        health -= Min\n        drinks.remove(Min)\nprint(len(drinks))", "n = int(input())\nls = list(map(int, input().split()))\n(drk, ans, hp) = ([], 0, 0)\nfor i in ls:\n    if i >= 0:\n        (ans, hp) = (ans + 1, hp + i)\n    elif hp + sum(drk) + i >= 0:\n        drk.append(i)\n    else:\n        try:\n            temp = min(drk)\n        except ValueError:\n            continue\n        if temp < i:\n            drk.remove(temp)\n            drk.append(i)\nprint(ans + len(drk))", "from queue import PriorityQueue\nn = int(input())\na = list(map(int, input().split()))\nQ = PriorityQueue()\ns = 0\nx = 0\nfor i in range(len(a)):\n    x += 1\n    Q.put(a[i])\n    if s + a[i] >= 0:\n        s += a[i]\n    else:\n        s += a[i]\n        while not Q.empty():\n            k = Q.get()\n            s -= k\n            x -= 1\n            if s >= 0:\n                break\nprint(x)", "x = int(input())\na = list(map(int, input().split()))\nb = []\ns = 0\nc = 0\nfor i in a:\n    s = s + i\n    c = c + 1\n    if i < 0:\n        b.append(i)\n        b.sort()\n    if s < 0:\n        s = s - b[0]\n        b.pop(0)\n        c = c - 1\nprint(c)", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "from heapq import heapify, heappush, heappop\nn = int(input())\nl = list(map(int, input().split()))\nheap = []\nheapify(heap)\nans = 0\na = 0\nfor i in range(n):\n    a += l[i]\n    ans += 1\n    heappush(heap, l[i])\n    while a < 0:\n        a -= heappop(heap)\n        ans -= 1\nprint(ans)", "import heapq as h\nn = input()\na = list(map(int, input().split()))\nsum = 0\nH = []\nfor x in a:\n    sum += x\n    h.heappush(H, x)\n    if sum < 0:\n        sum -= H[0]\n        h.heappop(H)\nprint(len(H))", "n = int(input())\ns = count = 0\ntaken = []\nncount = 0\nfor i in list(map(int, input().split())):\n    if i >= 0:\n        count += 1\n        ncount += 1\n        s += i\n    elif s + i >= 0:\n        s += i\n        count += 1\n        taken.append(i)\n    elif len(taken) > 0:\n        v = min(taken)\n        if s + i - v >= 0 and v < i:\n            s += i - v\n            taken.append(i)\n            del taken[taken.index(v)]\n        else:\n            pass\nprint(ncount + len(taken))", "n = int(input())\na = [int(x) for x in input().split()]\ns = 0\nk = 0\nb = []\nfor i in range(0, n):\n    s = s + a[i]\n    k = k + 1\n    if a[i] < 0:\n        b.append(a[i])\n    while s < 0:\n        p = min(b)\n        s = s - p\n        k = k - 1\n        b.remove(p)\nprint(k)", "n = int(input())\na = list(map(int, input().split()))\nimport heapq\nl = []\nheapq.heapify(l)\nans = 0\ns = 0\nfor i in range(0, len(a)):\n    if a[i] < 0:\n        heapq.heappush(l, a[i])\n    s += a[i]\n    if s < 0:\n        ans += 1\n        k = heapq.heappop(l)\n        s -= k\nprint(len(a) - ans)", "n = int(input())\na = list(map(int, input().split()))\nS = []\nfor i in range(n):\n    S.append(a[i])\n    if sum(S) < 0:\n        S.remove(min(S))\nprint(len(S))"]