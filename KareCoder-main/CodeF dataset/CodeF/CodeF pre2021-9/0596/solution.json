["(N, M) = list(map(int, input().split()))\nL = list(map(int, input().split()))\nif sum(L) < N:\n    print(-1)\nelif any([l + i > N for (i, l) in enumerate(L)]):\n    print(-1)\nelse:\n    S = [L[-1]]\n    for i in list(reversed(L))[1:]:\n        S.append(S[-1] + i)\n    S = list(reversed(S))\n    res = []\n    for (num, (s, l)) in enumerate(zip(S, L)):\n        if N - num >= s:\n            for ss in S[num:]:\n                res.append(N - ss + 1)\n            break\n        else:\n            res.append(num + 1)\n    print(' '.join(map(str, res)))", "def f():\n    n = int(input().split()[0])\n    l = [int(x) for x in input().split()]\n    s = 0\n    for i in l:\n        s += i\n    if s < n:\n        print(-1)\n        return\n    o = s - n\n    b = 0\n    u = '1'\n    p = 0\n    for i in range(0, len(l) - 1):\n        if l[i] - 1 < o:\n            p = b + 2\n            b += 1\n            o -= l[i] - 1\n        elif o == 0:\n            p = b + l[i] + 1\n            b += l[i]\n        else:\n            p = b + l[i] - o + 1\n            b += l[i] - o\n            o = 0\n        if b + l[i + 1] > n:\n            print(-1)\n            return\n        u += ' ' + str(p)\n    print(u)\nf()", "import sys\nfrom math import sqrt, floor, factorial\nfrom collections import deque, Counter\ninp = sys.stdin.readline\nread = lambda : list(map(int, inp().strip().split()))\n\ndef solve():\n    ans = ''\n    (n, m) = read()\n    arr = read()\n    d = sum(arr) - n\n    if d >= 0:\n        ind = 1\n        for i in arr:\n            if n - i + 1 >= ind:\n                ans += str(ind) + ' '\n                sub = max(1, i - d)\n                ind += sub\n                d -= i - sub\n            else:\n                ans = '-1'\n                break\n    else:\n        ans = '-1'\n    print(ans)\nsolve()", "(n, m) = list(map(int, input().split()))\np = list(map(int, input().split()))\nfor i1 in range(m):\n    if i1 > n - p[i1]:\n        print(-1)\n        exit()\nif sum(p) < n:\n    print(-1)\n    exit()\nposition = [-1] * m\ngreedy = 0\nfor i1 in range(m - 1, -1, -1):\n    greedy += p[i1]\n    position[i1] = max(i1 + 1, n - greedy + 1)\nprint(*position)", "(n, m) = list(map(int, input().split()))\np = list(map(int, input().split()))\nfor i1 in range(m):\n    if i1 > n - p[i1]:\n        print(-1)\n        exit()\nif sum(p) < n:\n    print(-1)\n    exit()\nposition = [-1] * m\ngreedy = 0\nfor i1 in range(m - 1, -1, -1):\n    greedy += p[i1]\n    position[i1] = max(i1 + 1, n - greedy + 1)\nprint(*position)", "def build(s, l):\n    for i in range(m - 1, -1, -1):\n        s[i] = s[i + 1] + l[i]\n\ndef process(s, l, ok):\n    ans = []\n    left = 1\n    for i in range(m):\n        ans.append(left)\n        nxt = max(left + 1, n - s[i + 1] + 1)\n        if nxt > left + l[i]:\n            ok = False\n            return []\n        left = nxt\n    return ans\n(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\ns = [0] * (m + 1)\nbuild(s, l)\nok = bool(False)\nfor i in range(m):\n    if n - l[i] < i:\n        ok = True\nif s[0] < n:\n    ok = True\nans = process(s, l, ok)\nif len(ans) == 0:\n    ok = True\nif ok:\n    print(-1)\nelse:\n    print(' '.join(map(str, ans)))", "def main():\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    ind = int()\n    for i in range(m):\n        if n - l[i] < i:\n            ind = 1\n            break\n    if ind or sum(l) < n:\n        print(-1)\n    else:\n        over = sum(l) - n\n        counter = int()\n        while over > 0:\n            if counter < m:\n                k = l[counter] - 1\n                l[counter] -= min(over, l[counter] - 1)\n                over -= min(over, k)\n                counter += 1\n        place = [1]\n        inc = 1 + l[0]\n        for i in range(1, m):\n            place.append(inc)\n            inc += l[i]\n        print(' '.join(map(str, place)))\nmain()", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\np = []\npaint_remaining = sum(l)\nif paint_remaining < n or len(l) + l[len(l) - 1] - 1 > n:\n    print(-1)\nelse:\n    firstindex = 1\n    p.append(1)\n    paint_remaining -= l[0]\n    failed = False\n    for paint_length in l[1:]:\n        if n - firstindex > paint_remaining:\n            firstindex = n - paint_remaining + 1\n        else:\n            firstindex += 1\n            if firstindex + paint_length - 1 > n:\n                print(-1)\n                failed = True\n                break\n        paint_remaining -= paint_length\n        p.append(firstindex)\n    if not failed:\n        print(*p)", "(n, m) = map(int, input().split())\nli = list(map(int, input().split()))\nsumli = sum(li)\nif sumli < n:\n    print(-1)\nelse:\n    deficiency = n - m\n    for i in range(m):\n        if i + li[i] > n:\n            print(-1)\n            break\n    else:\n        i = n - li[-1]\n        deficiency -= li[-1] - 1\n        output = [i]\n        z = m - 2\n        while deficiency > 0:\n            deficiency -= li[z] - 1\n            if deficiency >= 0:\n                output.append(output[-1] - li[z])\n            else:\n                output.append(output[-1] - deficiency - li[z])\n            z -= 1\n        for i in range(z, -1, -1):\n            output.append(i)\n        output.reverse()\n        output = list(map(lambda i: i + 1, output))\n        print(*output)", "(n, m) = map(int, input().split())\nlis = list(map(int, input().split()))\np = []\nfor i in range(m):\n    if lis[i] + i <= n:\n        p.append(i + 1)\n    else:\n        print('-1')\n        break\nelse:\n    var = 0\n    if p[-1] + lis[-1] < n + 1:\n        var = n + 1 - p[-1] - lis[-1]\n        las = n\n        for j in range(1, m):\n            p[-j] = las - lis[-j] + 1\n            las = p[-j] - 1\n            var -= lis[-j - 1] - 1\n            if var <= 0:\n                break\n    if sum(lis) < n:\n        print(-1)\n    elif var > 0:\n        print(-1)\n    else:\n        for j in p:\n            print(j, end=' ')\n        print()", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nif sum(l) < n:\n    print(-1)\nelse:\n    f = 0\n    i = 0\n    dif = sum(l) - n\n    end = 1\n    a = [1]\n    for i in range(m):\n        leg = l[i]\n        if leg > n - i:\n            f = 1\n            break\n        if dif >= leg:\n            end += 1\n            dif -= leg - 1\n        else:\n            end += leg - dif\n            dif = 0\n        a.append(end)\n    if f == 1:\n        print(-1)\n    else:\n        a.pop()\n        print(*a)", "(n, m) = map(int, input().split(' '))\na = list(map(int, input().split(' ')))\nok = True\nfor i in range(m):\n    if n - a[i] < i:\n        ok = False\ns = [0] * (m + 1)\nfor i in range(m - 1, -1, -1):\n    s[i] = s[i + 1] + a[i]\nif s[0] < n:\n    ok = False\nans = []\nleft = 1\nfor i in range(m):\n    ans.append(left)\n    nxt = max(left + 1, n - s[i + 1] + 1)\n    if nxt > left + a[i]:\n        ok = False\n        break\n    left = nxt\nif ok:\n    print(' '.join(map(str, ans)))\nelse:\n    print(-1)", "def solve(n, m, li):\n    pi = [0] * (m + 1)\n    if sum(li) < n:\n        print(-1)\n        return\n    for i in range(1, m + 1):\n        if i > n - li[i] + 1:\n            print(-1)\n            return\n        pi[i] = i\n    last_pos = n\n    for i in range(m, 0, -1):\n        while pi[i] + li[i] - 1 < last_pos:\n            pi[i] += 1\n        last_pos = pi[i] - 1\n    print(*pi[1:])\n    return\n(n, m) = [int(x) for x in input().split()]\nli = [0] + [int(x) for x in input().split()]\nsolve(n, m, li)", "(N, M) = input().split(' ')\n(N, M) = (int(N), int(M))\nL = input().split(' ')\nL = list((int(x) for x in L))\n\ndef answer(N, M, L):\n    offsets = [0]\n    for i in range(M - 1):\n        offsets += [1]\n    overhang = 0\n    for ii in range(M - 1):\n        i = M - 1 - ii\n        left_edge = i + 1\n        right_edge = left_edge + L[i] - 1 + overhang\n        if right_edge > N:\n            return '-1'\n        max_right_edge = right_edge + L[i - 1] - 1\n        if max_right_edge > N:\n            max_right_edge = N\n        offsets[i] += max_right_edge - right_edge\n        parent_right_edge = i + L[i - 1] - 1\n        overhang = max(0, max_right_edge - parent_right_edge)\n    if L[0] + overhang < N:\n        return '-1'\n    pos = 1\n    ret = [1]\n    for o in offsets[1:]:\n        pos += o\n        ret += [pos]\n    return ' '.join((str(r) for r in ret))\nprint(answer(N, M, L))", "import sys\n(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nif sum(l) < n:\n    print(-1)\n    sys.exit(0)\npre = [1] * (m + 1)\nmax = m + l[-1] - 1\nif max > n:\n    print(-1)\n    sys.exit(0)\nflag = False\nfor i in range(m):\n    if i + l[i] > n:\n        flag = True\n        break\nif flag:\n    print(-1)\n    sys.exit(0)\nfor i in range(m - 2, -1, -1):\n    if l[i] > 1:\n        if l[i] - 1 + max <= n:\n            max = max + l[i] - 1\n            pre[i + 1] += l[i] - 1\n        else:\n            pre[i + 1] += n - max\n            max = n\n    if max == n:\n        break\nprevious = 0\nfor i in range(m):\n    previous = previous + pre[i]\n    if pre[i] == 0:\n        previous += 1\n    print(previous, end=' ')\nprint()", "(n, m) = map(int, input().strip().split())\nops = list(map(int, input().strip().split()))\nif sum(ops) < n:\n    print(-1)\nelse:\n    ans = 1\n    pos = [0 for j in range(m)]\n    for j in range(m):\n        if n - j >= ops[j]:\n            pos[j] = j\n        else:\n            ans = 0\n            break\n    if ans == 0:\n        print(-1)\n    else:\n        max_end = n - 1\n        for j in range(m - 1, 0, -1):\n            en1 = pos[j] + ops[j] - 1\n            if en1 < max_end:\n                pos[j] = pos[j] + max_end - en1\n                max_end = pos[j] - 1\n            else:\n                break\n        for j in range(m):\n            print(pos[j] + 1, end=' ')", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\np = []\npaint_remaining = sum(l)\nif paint_remaining < n or len(l) + l[len(l) - 1] - 1 > n:\n    print(-1)\nelse:\n    firstindex = 1\n    p.append(1)\n    paint_remaining -= l[0]\n    failed = False\n    for paint_length in l[1:]:\n        if n - firstindex > paint_remaining:\n            firstindex = n - paint_remaining + 1\n        else:\n            firstindex += 1\n            if firstindex + paint_length - 1 > n:\n                print(-1)\n                failed = True\n                break\n        paint_remaining -= paint_length\n        p.append(firstindex)\n    if not failed:\n        print(*p)", "import sys\n(n, m) = map(int, input().split(' '))\nms = list(map(int, input().split(' ')))\ntotal = sum(ms)\nif total < n:\n    print(-1)\n    sys.exit(0)\nstart = 1\ns = [i for i in range(1, m + 1)]\nmi = m - 1\nneedr = n\nshift = 0\nwhile mi >= 0:\n    s[mi] -= shift\n    if s[mi] + ms[mi] - 1 > n or s[mi] <= 0:\n        print(-1)\n        sys.exit(0)\n    if s[mi] + ms[mi] - 1 < needr:\n        sh = needr - (s[mi] + ms[mi] - 1)\n        s[mi] += sh\n    needr = min(needr, s[mi] - 1)\n    mi -= 1\nprint(' '.join((str(x) for x in s)))", "R = lambda : map(int, input().split())\n(n, m) = R()\na = list(R())\n\ndef solve(a, n, m):\n    if m > n:\n        print(-1)\n    b = [0] * m\n    t = 0\n    for i in range(m - 1, -1, -1):\n        t += a[i]\n        b[i] = t\n    b.append(0)\n    ar = []\n    cur = 0\n    for i in range(m):\n        if b[i] < n - cur:\n            print(-1)\n            return\n        if a[i] > n - cur:\n            print(-1)\n            return\n        ar.append(cur)\n        cur += 1\n        while b[i + 1] < n - cur:\n            cur += 1\n    print(*[x + 1 for x in ar])\n    return\nsolve(a, n, m)", "(n, m) = list(map(int, input().split()))\np = list(map(int, input().split()))\nfor i1 in range(m):\n    if i1 > n - p[i1]:\n        print(-1)\n        exit()\nif sum(p) < n:\n    print(-1)\n    exit()\nposition = [-1] * m\ngreedy = 0\nfor i1 in range(m - 1, -1, -1):\n    greedy += p[i1]\n    position[i1] = max(i1 + 1, n - greedy + 1)\nprint(*position)", "(n, m) = list(map(int, input().split()))\np = list(map(int, input().split()))\nfor i1 in range(m):\n    if i1 > n - p[i1]:\n        print(-1)\n        exit()\nif sum(p) < n:\n    print(-1)\n    exit()\nposition = [-1] * m\ngreedy = 0\nfor i1 in range(m - 1, -1, -1):\n    greedy += p[i1]\n    position[i1] = max(i1 + 1, n - greedy + 1)\nprint(*position)", "(n, m) = map(int, input().split())\nlens = list(map(int, input().split()))\nif sum(lens) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - lens[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - lens[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "(n, m) = map(int, input().split())\nlens = list(map(int, input().split()))\nif sum(lens) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - lens[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - lens[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "(n, m) = map(int, input().split())\nlens = list(map(int, input().split()))\nif sum(lens) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - lens[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - lens[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nif sum(l) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - l[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - l[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\n\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef LS():\n    return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == '\\n':\n        return res[:-1]\n    return res\n\ndef IR(n):\n    return [I() for i in range(n)]\n\ndef LIR(n):\n    return [LI() for i in range(n)]\n\ndef SR(n):\n    return [S() for i in range(n)]\n\ndef LSR(n):\n    return [LS() for i in range(n)]\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    (n, m) = LI()\n    l = LI()\n    s = sum(l)\n    if s < n:\n        print(-1)\n        return\n    res = s - n\n    ans = [1]\n    j = 1\n    for i in range(1, m):\n        r = l[i - 1] - 1\n        if res >= r:\n            j += 1\n            res -= r\n        else:\n            j += r - res + 1\n            res = 0\n        if j + l[i] - 1 > n:\n            print(-1)\n            return\n        ans.append(j)\n    print(*ans)\n    return\nsolve()", "(n, m) = map(int, input().split())\nlens = list(map(int, input().split()))\nif sum(lens) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - lens[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - lens[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "(n, m) = map(int, input().split())\narr = [int(x) for x in input().split()]\nif sum(arr) < n:\n    print(-1)\n    exit(0)\nif m > n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - arr[i] < i:\n        print(-1)\n        exit(0)\nans = [0] * m\ntotal = n\nfor i in range(m - 1, -1, -1):\n    ans[i] = max(total - arr[i], i) + 1\n    total = ans[i] - 1\nprint(*ans)", "(n, m) = list(map(int, input().split()))\nl = list(map(int, input().split()))\nind = 0\nfor i in range(m):\n    if n - l[i] < i:\n        ind = 1\nif ind == 1:\n    print(-1)\nelif sum(l) < n:\n    print(-1)\nelse:\n    over = sum(l) - n\n    i = 0\n    while over > 0:\n        if i < m:\n            k = l[i] - 1\n            l[i] -= min(over, l[i] - 1)\n            over -= min(over, k)\n            i += 1\n    place = [1]\n    inc = 1 + l[0]\n    for i in range(1, m):\n        place.append(inc)\n        inc += l[i]\n    print(' '.join(list(map(str, place))))", "(n, m) = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\ns = sum(a)\nif s < n:\n    print(-1)\nelse:\n    r = []\n    diff = s - n\n    curr = 0\n    valid = True\n    for i in range(m):\n        r.append(curr + 1)\n        curr += a[i]\n        if curr > n:\n            valid = False\n        d = min(diff, a[i] - 1)\n        curr -= d\n        diff -= d\n    if valid:\n        print(*r)\n    else:\n        print(-1)", "(n, m, *l) = map(int, open(0).read().split())\nif sum(l) < n or any((i + x > n for (i, x) in enumerate(l))):\n    print(-1)\n    exit()\nfor i in range(m - 1):\n    l[-i - 2] += l[-i - 1]\nprint(*[max(i + 1, n - l[i] + 1) for i in range(m)])", "from math import ceil, sqrt, log, gcd\n\ndef ii():\n    return int(input())\n\ndef si():\n    return input()\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n(n, m) = mi()\na = li()\nif m > n:\n    print('-1')\n    exit()\nif sum(a) < n:\n    print('-1')\n    exit()\nfor i in range(m):\n    if a[i] > n - i:\n        print('-1')\n        exit()\np = [0] * (m + 1)\np[m] = n\nq = [0] * (m + 1)\nfor i in range(m - 1, -1, -1):\n    p[i] = max(i, p[i + 1] - a[i])\n    q[i] = p[i] + 1\nq = q[:m]\nprint(*q)", "(n, m) = map(int, input().split())\narr = [int(x) for x in input().split()]\nif sum(arr) < n:\n    print(-1)\n    exit(0)\nif m > n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - arr[i] < i:\n        print(-1)\n        exit(0)\nans = [0] * m\ntotal = n\nfor i in range(m - 1, -1, -1):\n    ans[i] = max(total - arr[i], i) + 1\n    total = ans[i] - 1\nprint(*ans)", "(n, m) = map(int, input().split())\nlens = list(map(int, input().split()))\nif sum(lens) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - lens[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - lens[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\npossible = 1\nt = 0\nfor i in range(m):\n    if l[i] + i > n:\n        possible = 0\n    t += l[i]\nif t < n:\n    possible = 0\nif possible == 0:\n    print(-1)\nelse:\n    d = t - n\n    s = [0] * m\n    s[0] = 1\n    for i in range(m - 1):\n        if d == 0:\n            s[i + 1] = s[i] + l[i]\n        elif d >= l[i]:\n            d -= l[i]\n            d += 1\n            s[i + 1] = s[i] + 1\n        else:\n            s[i + 1] = s[i] + l[i] - d\n            d = 0\n    print(*s)", "(n, m) = map(int, input().split())\nblocks = [int(x) for x in input().split()]\nb2 = [(blocks[i], i) for i in range(len(blocks))]\ns = sum(blocks)\nif s < n:\n    print(-1)\nelse:\n    p = [0] * len(b2)\n    rem = s\n    x = n\n    i = 0\n    br = 1\n    f = 0\n    while rem > x and i != n:\n        if b2[i][0] + i > n:\n            br = 0\n            break\n        rem -= b2[i][0]\n        p[b2[i][1]] = i + 1\n        x -= 1\n        i += 1\n    while rem > 0 and br:\n        f = 1\n        p[b2[i][1]] = n - rem + 1\n        rem -= b2[i][0]\n        i += 1\n    if f:\n        print(*p)\n    else:\n        print(-1)", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nif sum(l) < n:\n    print(-1)\nelse:\n    flag = False\n    for i in range(m):\n        if l[i] + i > n:\n            flag = True\n    if flag:\n        print(-1)\n    else:\n        ans = []\n        suff = []\n        s = 0\n        l.reverse()\n        for i in l:\n            s += i\n            suff.append(s)\n        suff.reverse()\n        for i in range(m):\n            ans.append(max(i + 1, n - suff[i] + 1))\n        for i in ans:\n            print(i, end=' ')\n        print()", "(n, m) = map(int, input().split())\narray = list(map(int, input().split()))\nans = 0\nif sum(array) < n:\n    ans = -1\nfor i in range(m):\n    if array[i] > n - i:\n        ans = -1\n        break\nif ans == -1:\n    print(-1)\nelse:\n    sufix_array = [0] * m\n    sufix_array[-1] = array[-1]\n    for i in range(m - 2, -1, -1):\n        sufix_array[i] = array[i] + sufix_array[i + 1]\n    for i in range(m):\n        print(max(i + 1, n - sufix_array[i] + 1), end=' ')\n    print()", "temp = input().split()\nn = int(temp[0])\nm = int(temp[1])\nl = input().split()\nfor i in range(m):\n    l[i] = int(l[i])\nvalid = True\ntotal = 0\nfor i in range(m):\n    if l[i] + i > n:\n        valid = False\n    total += l[i]\nif total < n:\n    valid = False\nif valid:\n    done = [x + 1 for x in range(m)]\n    final = m - 1\n    unfilled = n\n    last = m - 1 + l[m - 1]\n    while last < unfilled:\n        done[final] = unfilled - l[final] + 1\n        unfilled = unfilled - l[final]\n        final -= 1\n        last = final + l[final]\n    print(done[0], end='')\n    for i in range(1, len(done)):\n        print(' ' + str(done[i]), end='')\nelse:\n    print(-1)", "(n, m) = map(int, input().split())\nl = [int(x) for x in input().split()]\n(s, res, p) = ([], [], 0)\ns.append(l[-1])\nfor i in range(m - 2, -1, -1):\n    s.append(s[m - i - 2] + l[i])\ns.reverse()\nif s[0] < n:\n    print(-1)\nelse:\n    for i in range(m):\n        p = max(n - s[i] + 1, p + 1)\n        if not 1 <= p <= n - l[i] + 1:\n            p = 0\n            break\n        else:\n            res.append(p)\n    if p + l[-1] == n + 1:\n        print(*res)\n    else:\n        print(-1)", "import sys\nimport itertools\ninput = sys.stdin.readline\n\ndef main():\n    (N, M) = [int(x) for x in input().split()]\n    L = [int(x) for x in input().split()]\n    if sum(L) < N:\n        print(-1)\n        return\n    ruiseki = list(itertools.accumulate(L[::-1]))\n    ans = []\n    for (i, l) in enumerate(L):\n        if i == 0:\n            ans.append(1)\n            continue\n        elif i == M - 1:\n            x = N - ruiseki[-i - 1] + 1\n            ans.append(x)\n            if ans[i] - ans[i - 1] > L[i - 1]:\n                print(-1)\n                return\n            if ans[i] <= ans[i - 1]:\n                print(-1)\n                return\n        else:\n            x = N - ruiseki[-i - 1] + 1\n            x = max(ans[i - 1] + 1, x)\n            ans.append(x)\n            if N + 1 - x < l:\n                print(-1)\n                return\n            if ans[i] - ans[i - 1] > L[i - 1]:\n                print(-1)\n                return\n    print(*ans)\nmain()", "(n, m) = [int(s) for s in input().split()]\narr = [int(s) for s in input().split()]\nsuf = [0] * m\nsum = 0\nfor i in range(len(arr) - 1, -1, -1):\n    sum += arr[i]\n    suf[i] = sum\nans = [0] * m\nflag = True\nfor i in range(len(arr)):\n    if arr[i] + i > n:\n        flag = False\n        break\n    ans[i] = max(i + 1, n - suf[i] + 1)\n    if i != 0:\n        if ans[i] <= ans[i - 1]:\n            flag = False\n            break\nif flag and sum >= n:\n    for i in ans:\n        print(i, end=' ')\nelse:\n    print(-1)", "from sys import stdin\nimport copy\ninput = stdin.readline\n(n, m) = map(int, input().split())\nl = [int(x) for x in input().split()]\nll = copy.copy(l)\nres = [1]\nflag = 1\ns = sum(l)\nif s < n:\n    print(-1)\nelse:\n    k = s - n\n    start = 1\n    for x in range(m):\n        if l[x] > 1:\n            if l[x] - 1 >= k:\n                l[x] -= k\n                break\n            else:\n                k -= l[x] - 1\n                l[x] = 1\n    for x in l[:-1]:\n        res.append(start + x)\n        start += x\n    for x in range(m):\n        if res[x] + ll[x] - 1 > n:\n            flag = 0\n            break\n    if flag == 0:\n        print(-1)\n    else:\n        for x in res:\n            print(x, end=' ')", "line = input().split()\nn = int(line[0])\nm = int(line[1])\nline = [int(x) for x in input().split()]\nimpossible = False\ntotal_spaces = 0\nfor i in range(m):\n    curr = line[i]\n    if n - curr < i:\n        impossible = True\n        break\n    total_spaces += curr\nif impossible or total_spaces < n:\n    print(-1)\nelse:\n    index = 0\n    remaining_slots_to_retrocede = total_spaces - n\n    ans = []\n    for i in range(m):\n        ans.append(index)\n        index += line[i]\n        max_sots_to_retrocede = line[i] - 1\n        index -= min(max_sots_to_retrocede, remaining_slots_to_retrocede)\n        remaining_slots_to_retrocede -= min(max_sots_to_retrocede, remaining_slots_to_retrocede)\n    for starting_point in ans:\n        print(starting_point + 1, end=' ')\n    print()", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nans = [i + 1 for i in range(m)]\nans.append(n + 1)\nfor i in range(m - 1, -1, -1):\n    ans[i] += max(0, ans[i + 1] - ans[i] - l[i])\nres = True\nans[m] = 0\nl.append(1)\nfor i in range(m):\n    if not 1 <= ans[i] - ans[i - 1] <= l[i - 1]:\n        res = False\n        break\n    if ans[i] > n - l[i] + 1:\n        res = False\n        break\nif res:\n    print(*ans[:m])\nelse:\n    print(-1)", "(n, m) = map(int, input().split())\nl = [int(i) for i in input().split()]\npref = [0]\nfor i in range(m):\n    pref += [pref[-1] + l[i]]\nif pref[-1] < n:\n    print(-1)\nelse:\n    last_pos = 0\n    poss = 0\n    ans = [0]\n    for i in range(m):\n        if ans[-1] + l[i] > n:\n            print(-1)\n            exit()\n        poss = last_pos - ans[-1]\n        left = pref[-1] - pref[i] - (n - last_pos)\n        if left >= poss:\n            ans += [ans[-1] + 1]\n        else:\n            ans += [ans[-1] + poss - left + 1]\n        last_pos = max(last_pos, ans[-1] + l[i] - 1)\n    print(*ans[1:])", "(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\nif sum(l) < n:\n    print(-1)\n    exit(0)\nfor i in range(m):\n    if n - l[i] < i:\n        print(-1)\n        exit(0)\np = [0] * m\nfr = n\nfor i in range(m - 1, -1, -1):\n    p[i] = max(fr - l[i], i) + 1\n    fr = p[i] - 1\nprint(*p)", "import sys\n(n, m) = map(int, input().split())\nl = list(map(int, input().split()))\npos = [0 for i in range(m)]\nupd = [0 for i in range(m)]\ncur = 1\nfor i in range(m):\n    pos[i] = cur\n    cur += l[i]\ndiff = pos[m - 1] - (n - l[i] + 1)\nif diff < 0:\n    print(-1)\n    sys.exit()\nif diff > 0:\n    for i in range(1, m):\n        shift = pos[i] - pos[i - 1] - 1\n        upd[i] -= min(shift, diff)\n        diff -= min(shift, diff)\n        if diff == 0:\n            break\nval = 0\nfor i in range(m):\n    val += upd[i]\n    pos[i] += val\nfor i in range(m):\n    if pos[i] > n - l[i] + 1:\n        print(-1)\n        sys.exit()\nfor i in range(1, m):\n    if pos[i] == pos[i - 1]:\n        print(-1)\n        sys.exit()\nprint(*pos)"]