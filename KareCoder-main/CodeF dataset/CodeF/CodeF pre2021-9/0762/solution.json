["def comb(n, r):\n    return fact[n] * inv[r] % mod * inv[n - r] % mod if n >= r >= 0 else 0\nmod = pow(10, 9) + 7\nl = 200005\nfact = [1] * (l + 1)\nfor i in range(1, l + 1):\n    fact[i] = i * fact[i - 1] % mod\ninv = [1] * (l + 1)\ninv[l] = pow(fact[l], mod - 2, mod)\nfor i in range(l - 1, -1, -1):\n    inv[i] = (i + 1) * inv[i + 1] % mod\nt = int(input())\nfor _ in range(t):\n    (n, l, r) = map(int, input().split())\n    m = min(1 - l, r - n)\n    n0 = n // 2 + n % 2\n    ans = m * comb(n, n0) % mod * (n % 2 + 1) % mod\n    (c1, c2) = (0, 0)\n    (l0, r0) = (1, n)\n    for _ in range(n):\n        m += 1\n        if l0 - m < l:\n            c1 += 1\n        if r0 + m > r:\n            c2 += 1\n        x = n - c1 - c2\n        ans += comb(x, n0 - c1)\n        ans %= mod\n        if n % 2:\n            ans += comb(x, n0 - c2)\n            ans %= mod\n    print(ans)", "N = 200000 + 1\nMOD = 10 ** 9 + 7\nF = [1] * N\nG = [1] * N\n\ndef init():\n    for i in range(1, N):\n        F[i] = F[i - 1] * i % MOD\n    G[N - 1] = pow(F[N - 1], MOD - 2, MOD)\n    for i in range(N - 2, 0, -1):\n        G[i] = G[i + 1] * (i + 1) % MOD\n\ndef C(n, m):\n    if m > n or m < 0:\n        return 0\n    return F[n] * G[m] * G[n - m] % MOD\n\ndef solve():\n    (n, l, r) = list(map(int, input().split()))\n    answer = 0\n    common_offset = max(min(1 - l, r - n), 0)\n    if common_offset:\n        answer = common_offset * C(n, n // 2) % MOD\n        if n % 2:\n            answer += common_offset * C(n, n // 2 + 1) % MOD\n    for offset in range(common_offset + 1, min(r - 1, n - l) + 1):\n        u = min(r - offset, n) - max(l - offset, 1) + 1\n        v = min(r + offset, n) - max(l + offset, 1) + 1\n        if u + v < n:\n            break\n        answer += C(u + v - n, n // 2 - n + v) % MOD\n        if n % 2:\n            answer += C(u + v - n, n // 2 + 1 - n + v) % MOD\n        answer %= MOD\n    return answer\ninit()\nfor case in range(int(input())):\n    print(solve())", "def readline():\n    return map(int, input().split())\nMOD = 10 ** 9 + 7\nf = [1, 1]\n\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\n\ndef inv(x):\n    return pow(x, -1, MOD)\n\ndef comb(n, k):\n    return factorial(n) * inv(factorial(k)) % MOD * inv(factorial(n - k)) % MOD\n\ndef solve():\n    (n, l, r) = readline()\n    d = min(r - n, 1 - l)\n    h = n >> 1\n    partitions = ((h, h + 1), (h + 1, h)) if n & 1 else ((h, h),)\n    ans = sum((comb(n, p) for (p, __) in partitions)) * d % MOD\n    loop = True\n    while loop:\n        d += 1\n        plus = max(0, d - (1 - l))\n        minus = max(0, d - (r - n))\n        loop = False\n        for (p_, m_) in partitions:\n            p = p_ - plus\n            m = m_ - minus\n            if p >= 0 and m >= 0:\n                ans += comb(p + m, p)\n                ans %= MOD\n                loop = True\n    print(ans)\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve()\nmain()", "M = 10 ** 9 + 7\n\ndef choose(n, k):\n    p = 1\n    for i in range(k):\n        p = p * (n - i) * pow(i + 1, -1, M) % M\n    return p\nfor _ in range(int(input())):\n    (n, l, r) = map(int, input().split())\n    ud = [(n // 2, n // 2)] if n % 2 == 0 else [(n // 2 + 1, n // 2), (n // 2, n // 2 + 1)]\n    ans = 0\n    for (u, d) in ud:\n        (p, prev_n, prev_k) = (0, 0, 0)\n        a = min(r - n, 1 - l)\n        ans += choose(u + d, u) * a\n        ans %= M\n        for x in range(min(d + r - n, u + 1 - l), a, -1):\n            uu = max(0, min(d, d + r - n - x))\n            dd = max(0, min(u, u + 1 - l - x))\n            if p == 0:\n                p = choose(uu + dd, uu)\n            else:\n                for i in range(prev_n + 1, uu + dd + 1):\n                    p = p * i % M\n                for i in range(prev_k + 1, uu + 1):\n                    p = p * pow(i, -1, M) % M\n                for i in range(prev_n - prev_k + 1, dd + 1):\n                    p = p * pow(i, -1, M) % M\n            ans = (ans + p) % M\n            (prev_n, prev_k) = (uu + dd, uu)\n    print(ans)", "MOD = 10 ** 9 + 7\nf = [1, 1]\n\ndef factorial(x):\n    for l in range(len(f), x + 1):\n        f.append(f[l - 1] * l % MOD)\n    return f[x]\n\ndef inv(x):\n    return pow(x, -1, MOD)\n\ndef comb(n, k):\n    return factorial(n) * inv(factorial(k)) % MOD * inv(factorial(n - k)) % MOD\n\ndef solve():\n    (n, l, r) = map(int, input().split())\n    d = min(r - n, 1 - l)\n    h = n >> 1\n    partitions = ((h, h + 1), (h + 1, h)) if n & 1 else ((h, h),)\n    ans = sum((comb(n, p) for (p, __) in partitions)) * d % MOD\n    loop = True\n    while loop:\n        d += 1\n        plus = max(0, d - (1 - l))\n        minus = max(0, d - (r - n))\n        loop = False\n        for (p_, m_) in partitions:\n            p = p_ - plus\n            m = m_ - minus\n            if p >= 0 and m >= 0:\n                ans += comb(p + m, p)\n                ans %= MOD\n                loop = True\n    print(ans)\nfor __ in range(int(input())):\n    solve()", "MOD = 10 ** 9 + 7\nf = [1, 1]\n\ndef factorial(x):\n    for l in range(len(f), x + 1):\n        f.append(f[l - 1] * l % MOD)\n    return f[x]\n\ndef inv(x):\n    return pow(x, -1, MOD)\n\ndef comb(n, k):\n    return factorial(n) * inv(factorial(k)) % MOD * inv(factorial(n - k)) % MOD\n\ndef solve():\n    (n, l, r) = map(int, input().split())\n    d = min(r - n, 1 - l)\n    h = n >> 1\n    partitions = ((h, h + 1), (h + 1, h)) if n & 1 else ((h, h),)\n    ans = sum((comb(n, p) for (p, __) in partitions)) * d % MOD\n    loop = True\n    while loop:\n        d += 1\n        plus = max(0, d - (1 - l))\n        minus = max(0, d - (r - n))\n        loop = False\n        for (p_, m_) in partitions:\n            p = p_ - plus\n            m = m_ - minus\n            if p >= 0 and m >= 0:\n                ans += comb(p + m, p)\n                ans %= MOD\n                loop = True\n    print(ans)\nfor __ in range(int(input())):\n    solve()", "MOD = 10 ** 9 + 7\nf = [1, 1]\n\ndef factorial(x):\n    for l in range(len(f), x + 1):\n        f.append(f[l - 1] * l % MOD)\n    return f[x]\n\ndef inv(x):\n    return pow(x, -1, MOD)\n\ndef comb(n, k):\n    return factorial(n) * inv(factorial(k)) % MOD * inv(factorial(n - k)) % MOD\n\ndef solve():\n    (n, l, r) = map(int, input().split())\n    d = min(r - n, 1 - l)\n    h = n >> 1\n    partitions = ((h, h + 1), (h + 1, h)) if n & 1 else ((h, h),)\n    ans = sum((comb(n, p) for (p, __) in partitions)) * d % MOD\n    loop = True\n    while loop:\n        d += 1\n        plus = max(0, d - (1 - l))\n        minus = max(0, d - (r - n))\n        loop = False\n        for (p_, m_) in partitions:\n            p = p_ - plus\n            m = m_ - minus\n            if p >= 0 and m >= 0:\n                ans += comb(p + m, p)\n                ans %= MOD\n                loop = True\n    print(ans)\nfor __ in range(int(input())):\n    solve()", "MOD = 10 ** 9 + 7\nf = [1, 1]\n\ndef factorial(x):\n    for l in range(len(f), x + 1):\n        f.append(f[l - 1] * l % MOD)\n    return f[x]\n\ndef inv(x):\n    return pow(x, -1, MOD)\n\ndef comb(n, k):\n    return factorial(n) * inv(factorial(k)) % MOD * inv(factorial(n - k)) % MOD\n\ndef solve():\n    (n, l, r) = map(int, input().split())\n    d = min(r - n, 1 - l)\n    h = n >> 1\n    partitions = ((h, h + 1), (h + 1, h)) if n & 1 else ((h, h),)\n    ans = sum((comb(n, p) for (p, __) in partitions)) * d % MOD\n    loop = True\n    while loop:\n        d += 1\n        plus = max(0, d - (1 - l))\n        minus = max(0, d - (r - n))\n        loop = False\n        for (p_, m_) in partitions:\n            p = p_ - plus\n            m = m_ - minus\n            if p >= 0 and m >= 0:\n                ans += comb(p + m, p)\n                ans %= MOD\n                loop = True\n    print(ans)\nfor __ in range(int(input())):\n    solve()", "MOD = 10 ** 9 + 7\nf = [1, 1]\n\ndef factorial(x):\n    for l in range(len(f), x + 1):\n        f.append(f[l - 1] * l % MOD)\n    return f[x]\n\ndef inv(x):\n    return pow(x, -1, MOD)\n\ndef comb(n, k):\n    return factorial(n) * inv(factorial(k)) % MOD * inv(factorial(n - k)) % MOD\n\ndef solve():\n    (n, l, r) = map(int, input().split())\n    d = min(r - n, 1 - l)\n    h = n >> 1\n    partitions = ((h, h + 1), (h + 1, h)) if n & 1 else ((h, h),)\n    ans = sum((comb(n, p) for (p, __) in partitions)) * d % MOD\n    loop = True\n    while loop:\n        d += 1\n        plus = max(0, d - (1 - l))\n        minus = max(0, d - (r - n))\n        loop = False\n        for (p_, m_) in partitions:\n            p = p_ - plus\n            m = m_ - minus\n            if p >= 0 and m >= 0:\n                ans += comb(p + m, p)\n                ans %= MOD\n                loop = True\n    print(ans)\nfor __ in range(int(input())):\n    solve()"]