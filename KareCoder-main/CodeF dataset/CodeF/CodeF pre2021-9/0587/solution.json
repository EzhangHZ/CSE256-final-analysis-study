["import sys\nfrom collections import defaultdict\nfrom heapq import heapify, heappush, heappop\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split()))\nt = list(map(int, sys.stdin.readline().split()))\numap = defaultdict(list)\nfor i in range(n):\n    umap[a[i]].append(t[i])\npq = []\nheapify(pq)\nheapsum = 0\nans = 0\nfor num in sorted(set(a)):\n    if len(umap[num]) > 1 or len(pq) > 0:\n        for val in umap[num]:\n            heappush(pq, -1 * val)\n            heapsum += val\n        heapsum += pq[0]\n        heappop(pq)\n        temp = num\n        while len(pq) > 0:\n            temp += 1\n            ans += heapsum\n            if len(umap[temp]) > 0:\n                break\n            else:\n                heapsum += pq[0]\n                heappop(pq)\nprint(ans)", "import heapq\nn = int(input())\nA = [int(i) for i in input().split()]\nT = [int(i) for i in input().split()]\nAT = [A[i] * 10 ** 6 + T[i] for i in range(n)]\nAT.sort()\n(aa, tt) = (0, 0)\nans = 0\nH = []\nfor at in AT:\n    (a, t) = (at // 10 ** 6, at % 10 ** 6)\n    if a == aa:\n        heapq.heappush(H, -t)\n        tt += t\n    else:\n        while H and aa < a:\n            tm = heapq.heappop(H)\n            tt += tm\n            ans += tt\n            aa += 1\n        heapq.heappush(H, -t)\n        aa = a\n        tt += t\nwhile H:\n    tm = heapq.heappop(H)\n    tt += tm\n    ans += tt\nprint(ans)", "import heapq\nn = int(input())\nA = [int(i) for i in input().split()]\nT = [int(i) for i in input().split()]\nAT = [A[i] * 10 ** 6 + T[i] for i in range(n)]\nAT.sort()\n(aa, tt) = (0, 0)\nans = 0\nH = []\nfor at in AT:\n    (a, t) = (at // 10 ** 6, at % 10 ** 6)\n    if a == aa:\n        heapq.heappush(H, -t)\n        tt += t\n    else:\n        while H and aa < a:\n            tm = heapq.heappop(H)\n            tt += tm\n            ans += tt\n            aa += 1\n        heapq.heappush(H, -t)\n        aa = a\n        tt += t\nwhile H:\n    tm = heapq.heappop(H)\n    tt += tm\n    ans += tt\nprint(ans)", "from heapq import *\nimport sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    n = II()\n    aa = LI()\n    tt = LI()\n    at = [(a, t) for (a, t) in zip(aa, tt)]\n    heapify(at)\n    pen = []\n    a = 0\n    s = 0\n    ans = 0\n    while pen or at:\n        while not pen or (at and at[0][0] == a):\n            (na, nt) = heappop(at)\n            heappush(pen, -nt)\n            a = na\n            s += nt\n        t = -heappop(pen)\n        s -= t\n        ans += s\n        a += 1\n    print(ans)\nmain()", "n = int(input())\nA = list(map(int, input().split()))\nT = list(map(int, input().split()))\nimport heapq\nnums = list(zip(A, T))\nnums.sort(key=lambda x: (x[0], -x[1]))\ntotal = 0\nres = 0\ncur = -1\ni = 0\nheap = []\nwhile i < n or heap:\n    if not heap:\n        cur = nums[i][0]\n    while i < n and nums[i][0] == cur:\n        heapq.heappush(heap, -nums[i][1])\n        total += nums[i][1]\n        i += 1\n    total -= -heapq.heappop(heap)\n    res += total\n    cur += 1\nprint(res)", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\nfrom math import *\nfrom collections import defaultdict as dd, deque\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return map(int, data().split())\nn = int(data())\nA = list(mdata())\nT = list(mdata())\nAT = sorted(list(zip(A, T)), key=lambda x: (x[0], x[1]))\nH = []\na = ans = 0\ns = 0\nfor i in AT:\n    if i[0] == a:\n        heapq.heappush(H, -i[1])\n        s += i[1]\n    else:\n        if H:\n            t = heapq.heappop(H)\n            s += t\n            a += 1\n        while H and a != i[0]:\n            t = heapq.heappop(H)\n            ans += s\n            s += t\n            a += 1\n        ans += s\n        heapq.heappush(H, -i[1])\n        s += i[1]\n        a = i[0]\nif H:\n    t = heapq.heappop(H)\n    s += t\nwhile H:\n    t = heapq.heappop(H)\n    ans += s\n    s += t\nprint(ans)", "import heapq\nn = int(input())\na = [[] for _ in range(n)]\nj = 0\nfor i in input().strip().split(' '):\n    a[j].append(int(i))\n    j += 1\nj = 0\nfor i in input().strip().split(' '):\n    a[j].append(int(i))\n    j += 1\na.sort()\nq = []\ntotal = 0\ncount = 0\nlast = a[0][0]\nheapq.heappush(q, -a[0][1])\ncount += a[0][1]\nfor i in a[1:]:\n    if i[0] == last:\n        heapq.heappush(q, -i[1])\n        count += i[1]\n    else:\n        while q and last < i[0]:\n            count += heapq.heappop(q)\n            total += max(count, 0)\n            if count < 0:\n                count = 0\n            last += 1\n        last = i[0]\n        heapq.heappush(q, -i[1])\n        count += i[1]\nwhile q:\n    count += heapq.heappop(q)\n    total += max(count, 0)\n    if count < 0:\n        count = 0\nprint(total)", "import heapq\nn = int(input())\nl1 = [int(i) for i in input().split()]\nl2 = [int(i) for i in input().split()]\nl = list(zip(l1, l2))\nl.sort(key=lambda x: (x[0], -x[1]))\nh = []\ncurr = l[0][0]\ni = 1\nres = 0\nwhile i < n:\n    while h:\n        if curr >= l[i][0] - 1:\n            break\n        curr += 1\n        temp = heapq.heappop(h)\n        res += (curr - temp[1]) * -temp[0]\n    heapq.heappush(h, [-l[i][1], l[i][0]])\n    if curr < l[i][0]:\n        curr = l[i][0]\n        temp = heapq.heappop(h)\n        res += (curr - temp[1]) * -temp[0]\n    i += 1\nwhile h:\n    curr += 1\n    temp = heapq.heappop(h)\n    res += (curr - temp[1]) * -temp[0]\nprint(res)", "inf = float('inf')\nfrom heapq import heapify, heappop, heappush\nfrom collections import defaultdict\nn = int(input())\nlst = list(map(int, input().split(' ')))\ntm = list(map(int, input().split(' ')))\nl = []\nfor i in range(n):\n    l.append([lst[i], tm[i]])\nl.sort()\nl.append((10 ** 12, 0))\ncnt = 0\nprev = 0\nnow = []\nfor x in l:\n    (a, t) = x\n    for ai in range(prev, a):\n        if not now:\n            break\n        (tm, am) = heappop(now)\n        tm = 10 ** 5 - tm\n        cnt += (ai - am) * tm\n    heappush(now, (10 ** 5 - t, a))\n    prev = a\nprint(cnt)", "import collections\nunion_arr = collections.defaultdict(int)\n\ndef func():\n    n_cates = int(input())\n    cate_i = list(map(int, input().split()))\n    time_i = list(map(int, input().split()))\n    idx = [index for (index, value) in sorted(list(enumerate(time_i)), reverse=True, key=lambda x: x[1])]\n    cate_i = [cate_i[i] for i in idx]\n    time_i = [time_i[i] for i in idx]\n    ans = 0\n    for i in range(n_cates):\n        f = find(cate_i[i])\n        if f == cate_i[i]:\n            union(f, f + 1)\n        else:\n            union(f, f + 1)\n            ans += (f - cate_i[i]) * time_i[i]\n    print(ans)\n\ndef union(a, b):\n    rt_b = find(b)\n    if rt_b != a:\n        union_arr[a] = rt_b\n\ndef find(a):\n    if union_arr[a] == 0:\n        return a\n    union_arr[a] = find(union_arr[a])\n    return union_arr[a]\nfunc()", "from collections import deque, Counter\nimport array\nfrom itertools import combinations, permutations\nfrom math import sqrt\nfrom heapq import heappush as push, heappop as pop\n\ndef read_int():\n    return int(input().strip())\n\ndef read_int_array():\n    return [int(i) for i in input().strip().split(' ')]\nn = read_int()\na = read_int_array()\nt = read_int_array()\nsrt = list(sorted(((a[i], t[i]) for i in range(n))))\ncnt = [(-srt[0][1], 0)]\ni = 1\ncntValue = srt[0][0]\nans = 0\nwhile cnt or i < n:\n    if i < n and srt[i][0] == cntValue:\n        push(cnt, (-srt[i][1], i))\n        i += 1\n    elif any(cnt):\n        (ti, inx) = pop(cnt)\n        ti = -ti\n        ans += (cntValue - srt[inx][0]) * ti\n        cntValue += 1\n    else:\n        cntValue = srt[i][0]\nprint(ans)", "import sys\ninput = sys.stdin.readline\nimport heapq\nh = []\nn = int(input())\na = [int(x) for x in input().strip().split()]\nt = [int(x) for x in input().strip().split()]\nfor i in range(len(t)):\n    a[i] = [a[i], t[i]]\na.sort(key=lambda x: (x[0], -x[1]))\n(prev, i, ans) = (a[0][0], 1, 0)\nwhile i < len(a):\n    if h:\n        if a[i][0] == prev:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            i += 1\n        elif a[i][0] == prev + 1:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            p = heapq.heappop(h)\n            ans += -p[0] * (prev + 1 - p[1])\n            prev = prev + 1\n            i += 1\n        else:\n            p = heapq.heappop(h)\n            ans += -p[0] * (prev + 1 - p[1])\n            prev = prev + 1\n    elif a[i][0] != prev:\n        prev = a[i][0]\n        i += 1\n    else:\n        heapq.heappush(h, [-a[i][1], a[i][0]])\n        i += 1\nwhile h:\n    p = heapq.heappop(h)\n    ans += -p[0] * (prev + 1 - p[1])\n    prev = prev + 1\nprint(ans)", "import heapq\nh = []\nn = int(input())\na = [int(x) for x in input().strip().split()]\nt = [int(x) for x in input().strip().split()]\nfor i in range(len(t)):\n    a[i] = [a[i], t[i]]\na.sort(key=lambda x: (x[0], -x[1]))\n(prev, i, ans) = (a[0][0], 1, 0)\nwhile i < len(a):\n    if h:\n        if a[i][0] == prev:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            i += 1\n        elif a[i][0] == prev + 1:\n            heapq.heappush(h, [-a[i][1], a[i][0]])\n            p = heapq.heappop(h)\n            ans += -p[0] * (prev + 1 - p[1])\n            prev = prev + 1\n            i += 1\n        else:\n            p = heapq.heappop(h)\n            ans += -p[0] * (prev + 1 - p[1])\n            prev = prev + 1\n    elif a[i][0] != prev:\n        prev = a[i][0]\n        i += 1\n    else:\n        heapq.heappush(h, [-a[i][1], a[i][0]])\n        i += 1\nwhile h:\n    p = heapq.heappop(h)\n    ans += -p[0] * (prev + 1 - p[1])\n    prev = prev + 1\nprint(ans)", "import heapq\nn = int(input())\nl1 = [int(i) for i in input().split()]\nl2 = [int(i) for i in input().split()]\nl = list(zip(l1, l2))\nl.sort(key=lambda x: (x[0], -x[1]))\nh = []\ncurr = l[0][0]\ni = 1\nres = 0\nwhile i < n:\n    while h:\n        if curr >= l[i][0] - 1:\n            break\n        curr += 1\n        temp = heapq.heappop(h)\n        res += (curr - temp[1]) * -temp[0]\n    heapq.heappush(h, [-l[i][1], l[i][0]])\n    if curr < l[i][0]:\n        curr = l[i][0]\n        temp = heapq.heappop(h)\n        res += (curr - temp[1]) * -temp[0]\n    i += 1\nwhile h:\n    curr += 1\n    temp = heapq.heappop(h)\n    res += (curr - temp[1]) * -temp[0]\nprint(res)", "import sys\nfrom heapq import heappush, heappop\nn = int(input())\na = list(map(int, input().split()))\ncount = {}\nfor x in a:\n    if x in count:\n        count[x] = count[x] + 1\n    else:\n        count[x] = 1\ncount = sorted(list(count.items()))\ncost = list(map(int, input().split()))\nmax_cost = max(cost)\na = zip(a, cost)\na = sorted(a)\npriority = list(map(lambda x: max_cost - x, map(lambda x: x[1], a)))\na = list(zip(priority, a))\ni = 0\nqueue = []\nqueue_cost = 0\nresult = 0\nfor j in range(len(count)):\n    (x, c) = count[j]\n    while i < len(a) and a[i][1][0] == x:\n        queue_cost += a[i][1][1]\n        heappush(queue, a[i])\n        i += 1\n    y = x\n    while len(queue) > 0 and (j == len(count) - 1 or count[j + 1][0] != y):\n        popped = heappop(queue)\n        queue_cost -= popped[1][1]\n        result += queue_cost\n        y += 1\nprint(result)"]