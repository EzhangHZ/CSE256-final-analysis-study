["import sys\n(n, *ab) = map(int, sys.stdin.read().split())\ngraph = [[] for _ in range(n)]\nfor (a, b) in zip(*[iter(ab)] * 2):\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef main():\n    rank = [None] * n\n    rank[0] = 0\n    parent = [None] * n\n    leaves = []\n    stack = [0]\n    while stack:\n        u = stack.pop()\n        if not u == 0 and len(graph[u]) == 1:\n            leaves.append(u)\n            continue\n        for v in graph[u]:\n            if v == parent[u]:\n                continue\n            parent[v] = u\n            rank[v] = rank[u] + 1\n            stack.append(v)\n    if len(graph[0]) == 1:\n        leaves.append(0)\n        parent[0] = graph[0][0]\n        parent[graph[0][0]] = None\n    pars = set()\n    for leaf in leaves:\n        pars.add(parent[leaf])\n    ma = n - 1 - (len(leaves) - len(pars))\n    rs = set([rank[leaf] & 1 for leaf in leaves])\n    mi = 1 if len(rs) == 1 else 3\n    print(mi, ma)\nmain()", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n\n    def findmin():\n        p = dep[leaf[0]] & 1\n        for u in leaf[1:]:\n            if dep[u] & 1 != p:\n                return 3\n        return 1\n    n = II()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = MI1()\n        to[u].append(v)\n        to[v].append(u)\n    dep = [-1] * n\n    dep[0] = 0\n    pp = [-1] * n\n    stack = [0]\n    while stack:\n        u = stack.pop()\n        for v in to[u]:\n            if v == pp[u]:\n                continue\n            pp[v] = u\n            dep[v] = dep[u] + 1\n            stack.append(v)\n    leaf = []\n    for u in range(n):\n        if len(to[u]) == 1:\n            leaf.append(u)\n    mn = findmin()\n    st = set()\n    cnt = 0\n    for u in leaf:\n        p = to[u][0]\n        if p in st:\n            cnt += 1\n        else:\n            st.add(p)\n    mx = n - 1 - cnt\n    print(mn, mx)\nmain()", "import sys\nimport collections\nimport threading\n\ndef main():\n    input = sys.stdin.readline\n    n = int(input())\n    d = collections.defaultdict(list)\n    try:\n        for i in range(1, n):\n            (a, b) = map(int, input().split())\n            d[a].append(b)\n            d[b].append(a)\n        parents = set()\n        cnt = 0\n        for key in d:\n            if len(d[key]) == 1:\n                cnt += 1\n                parents.add(*d[key])\n                leave = key\n\n        def dfsmin(par, node, h, result):\n            for i in d[node]:\n                if i != par:\n                    dfsmin(node, i, h + 1, result)\n            if len(d[node]) == 1:\n                result[h % 2] += 1\n            return result\n        minans = 1\n        if dfsmin(-1, leave, 0, [0, 0])[1] > 0:\n            minans = 3\n        maxans = n - 1 - cnt + len(parents)\n        print(minans, maxans)\n    except RuntimeError as e:\n        print(e)\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "def solveAll():\n    case = readCase()\n    print(*solve(case))\n\ndef readCase():\n    treeSize = int(input())\n    graph = [[] for i in range(treeSize)]\n    for _ in range(1, treeSize):\n        (a, b) = (int(x) for x in input().split())\n        a -= 1\n        b -= 1\n        graph[a] += [b]\n        graph[b] += [a]\n    return graph\n\ndef solve(graph):\n    leafs = computeLeafs(graph)\n    return (minF(graph, leafs), maxF(graph, leafs))\n\ndef computeLeafs(graph):\n    leafs = [node for node in range(0, len(graph)) if len(graph[node]) == 1]\n    return leafs\n\ndef minF(graph, leafs):\n    color = [None] * len(graph)\n    queue = [0]\n    color[0] = 'a'\n    head = 0\n    while head < len(queue):\n        currentNode = queue[head]\n        head += 1\n        for neighbor in graph[currentNode]:\n            if color[neighbor] != None:\n                continue\n            color[neighbor] = 'b' if color[currentNode] == 'a' else 'a'\n            queue += [neighbor]\n    if all((color[leafs[0]] == color[leaf] for leaf in leafs)):\n        return 1\n    return 3\n\ndef maxF(graph, leafs):\n    group = [0] * len(graph)\n    for leaf in leafs:\n        parent = graph[leaf][0]\n        group[parent] += 1\n    ans = len(graph) - 1\n    for size in group:\n        if size >= 2:\n            ans -= size - 1\n    return ans\nsolveAll()", "from sys import stdin, stderr\n\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n(n,) = rl()\na = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (ai, bi) = rl()\n    a[ai - 1].append(bi - 1)\n    a[bi - 1].append(ai - 1)\nfor v in range(n):\n    if len(a[v]) == 1:\n        f = [(v, a[v][0])]\n        break\nd = 2\nf0 = 1\nf1 = 0\nwhile f:\n    nf = []\n    for (u, v) in f:\n        df1 = 1\n        for w in a[v]:\n            if w != u:\n                if len(a[w]) > 1:\n                    nf.append((v, w))\n                elif d > 2:\n                    df1 = 2\n                    if d % 2:\n                        f0 = 3\n        f1 += df1\n    f = nf\n    d += 1\nprint(f0, f1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (p1, p2) = map(lambda x: x - 1, map(int, input().split()))\n    l[p1].append(p2)\n    l[p2].append(p1)\nleaf = []\ne = [0] * n\nmaxans = n - 1\nfor i in range(n):\n    temp = l[i]\n    if len(temp) == 1:\n        if e[temp[0]] == 1:\n            maxans -= 1\n        else:\n            e[temp[0]] = 1\n        leaf.append(i)\nq = [0]\nvisited = [-1] * n\nvisited[0] = 0\nwhile q:\n    node = q.pop()\n    for i in l[node]:\n        if visited[i] == -1:\n            q.append(i)\n            visited[i] = 1 - visited[node]\nf = visited[leaf[0]]\nfor i in leaf:\n    if visited[i] != f:\n        minans = 3\n        break\nelse:\n    minans = 1\nprint(minans, maxans)", "n = int(input())\nls = [[] for x in range(n)]\nfor inp in range(n - 1):\n    (point1, point2) = [int(x) - 1 for x in input().split()]\n    ls[point1].append(point2)\n    ls[point2].append(point1)\nbottom = []\ne = [0] * n\nmax_res = n - 1\nfor i in range(n):\n    temp = ls[i]\n    if len(temp) == 1:\n        if e[temp[0]] == 1:\n            max_res -= 1\n        else:\n            e[temp[0]] = 1\n        bottom.append(i)\nqueue = [0]\nseen = [-1] * n\nseen[0] = 0\nwhile queue:\n    point = queue.pop()\n    for i in ls[point]:\n        if seen[i] == -1:\n            queue.append(i)\n            seen[i] = 1 - seen[point]\nf = seen[bottom[0]]\nfor i in bottom:\n    if seen[i] != f:\n        min_res = 3\n        break\nelse:\n    min_res = 1\nprint(min_res, max_res)", "I = lambda : list(map(int, input().split()))\n(n,) = I()\ng = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = I()\n    g[x].append(y)\n    g[y].append(x)\nleaf = []\nfor i in range(1, n + 1):\n    if len(g[i]) == 1:\n        leaf.append(i)\nst = [1]\nvisi = [-1] * (n + 1)\nvisi[1] = 0\nwhile st:\n    x = st.pop()\n    for y in g[x]:\n        if visi[y] == -1:\n            visi[y] = 1 - visi[x]\n            st.append(y)\nch = visi[leaf[0]]\nfl = 1\ntemp = 0\nfor i in leaf:\n    if visi[i] != ch:\n        fl = 0\nmi = 1\nif not fl:\n    mi = 3\nan = [0] * (n + 1)\nma = n - 1\nfor i in leaf:\n    for j in g[i]:\n        if an[j] == 1:\n            ma -= 1\n        else:\n            an[j] = 1\nprint(mi, ma)", "import sys\nlines = sys.stdin.readlines()\nn = int(lines[0].strip())\nedges = {}\nfor i in range(1, n):\n    (u, v) = map(int, lines[i].strip().split(' '))\n    if u not in edges:\n        edges[u] = []\n    if v not in edges:\n        edges[v] = []\n    edges[u].append(v)\n    edges[v].append(u)\nleaves = []\nparLeave = {}\nfor u in edges.keys():\n    if len(edges[u]) == 1:\n        leaves.append(u)\n        parLeave[u] = edges[u][0]\nmaxF = n - (len(leaves) - len(set(parLeave.values()))) - 1\nparity = {leaves[0]: 0}\nstack = [leaves[0]]\nseen = set(stack)\nwhile stack:\n    node = stack.pop()\n    for adj in edges[node]:\n        if adj not in seen:\n            parity[adj] = 1 - parity[node]\n            stack.append(adj)\n            seen.add(adj)\nparityOfLeaves = list(map(lambda x: parity[x], leaves))\nif min(parityOfLeaves) == max(parityOfLeaves):\n    minF = 1\nelse:\n    minF = 3\nprint('{} {}'.format(minF, maxF))", "n = int(input())\ngs = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    u -= 1\n    v -= 1\n    gs[u].append(v)\n    gs[v].append(u)\nfor (root, u) in enumerate(gs):\n    if len(u) > 1:\n        break\nleaves = []\nq = [root]\nds = [None] * n\nds[root] = 0\npar = [None] * n\nwhile q:\n    u = q.pop()\n    if len(gs[u]) == 1:\n        leaves.append(u)\n    for v in gs[u]:\n        if ds[v] is not None:\n            continue\n        q.append(v)\n        ds[v] = ds[u] + 1\n        par[v] = u\ndodd = False\ndeven = False\npars = [0] * n\nfor leave in leaves:\n    if ds[leave] % 2:\n        dodd = True\n    else:\n        deven = True\n    pars[par[leave]] += 1\nsamepar = 0\nfor p in pars:\n    if not p:\n        continue\n    samepar += p - 1\nansmin = 3 if dodd and deven else 1\nansmax = n - 1 - samepar\nprint(ansmin, ansmax)", "def solveAll():\n    case = readCase()\n    print(*solve(case))\n\ndef readCase():\n    treeSize = int(input())\n    graph = [[] for i in range(treeSize)]\n    for _ in range(1, treeSize):\n        (a, b) = (int(x) for x in input().split())\n        a -= 1\n        b -= 1\n        graph[a] += [b]\n        graph[b] += [a]\n    return graph\n\ndef solve(graph):\n    leafs = computeLeafs(graph)\n    return (minF(graph, leafs), maxF(graph, leafs))\n\ndef computeLeafs(graph):\n    leafs = [node for node in range(0, len(graph)) if len(graph[node]) == 1]\n    return leafs\n\ndef minF(graph, leafs):\n    color = [None] * len(graph)\n    queue = [0]\n    color[0] = 'a'\n    head = 0\n    while head < len(queue):\n        currentNode = queue[head]\n        head += 1\n        for neighbor in graph[currentNode]:\n            if color[neighbor] != None:\n                continue\n            color[neighbor] = 'b' if color[currentNode] == 'a' else 'a'\n            queue += [neighbor]\n    if all((color[leafs[0]] == color[leaf] for leaf in leafs)):\n        return 1\n    return 3\n\ndef maxF(graph, leafs):\n    group = [0] * len(graph)\n    for leaf in leafs:\n        parent = graph[leaf][0]\n        group[parent] += 1\n    ans = len(graph) - 1\n    for size in group:\n        if size >= 2:\n            ans -= size - 1\n    return ans\nsolveAll()", "import collections, sys\nn = int(sys.stdin.readline())\ng = []\nsys.setrecursionlimit(2 ** 20)\nfor i in range(n + 1):\n    g.append([])\nfor i in range(n - 1):\n    (a, b) = list(map(int, sys.stdin.readline().split(' ')))\n    g[a].append(b)\n    g[b].append(a)\nleaf = {}\nmx = n - 1\nfor i in range(1, n + 1, 1):\n    if len(g[i]) == 1:\n        leaf[i] = True\n    else:\n        s = i\nfor i in range(1, n + 1, 1):\n    l = 0\n    for v in g[i]:\n        if v in leaf:\n            l += 1\n    if l != 0:\n        mx = mx - l + 1\nmn = 1\nl = s\ndst = [0] * (n + 1)\na = collections.deque([])\nexp = {}\nexp[l] = True\na.append(l)\no = 0\ne = 0\nwhile a:\n    v = a.pop()\n    h = dst[v] + 1\n    for u in g[v]:\n        if u not in exp:\n            dst[u] = h\n            exp[u] = True\n            a.append(u)\n            if u in leaf:\n                if h % 2 == 1:\n                    o += 1\n                else:\n                    e += 1\nif o == 0 or e == 0:\n    mn = 1\nelse:\n    mn = 3\nprint(mn, mx)", "from collections import Counter, defaultdict, deque\nfrom math import factorial as fact\nimport math\n\ndef BFS(cmap, v):\n    visited = [False] * len(cmap)\n    q = deque([v])\n    level = 0\n    groups = 0\n    blue = 0\n    red = 0\n    while len(q) != 0:\n        for i in range(len(q)):\n            vertex = q.popleft()\n            if not visited[vertex]:\n                pos = False\n                for nei in cmap[vertex]:\n                    if len(cmap[nei]) == 1:\n                        if pos:\n                            groups += 1\n                        pos = True\n                        if level % 2 == 0:\n                            blue += 1\n                        else:\n                            red += 1\n                visited[vertex] = True\n                q.extend(cmap[vertex])\n        level += 1\n    return (groups, blue, red)\nn = int(input())\nconnections = [[] for x in range(n)]\nfor i in range(n - 1):\n    (a, b) = [int(x) - 1 for x in input().split()]\n    connections[a].append(b)\n    connections[b].append(a)\n(g, b, r) = BFS(connections, 0)\nif b == 0 or r == 0:\n    print(1, end=' ')\nelse:\n    print(3, end=' ')\nprint(n - 1 - g)", "from collections import defaultdict\nfrom collections import deque\nN = int(input())\nedges = [[] for i in range(N)]\nfor i in range(N - 1):\n    (u, v) = [int(_) for _ in input().split()]\n    edges[u - 1].append(v - 1)\n    edges[v - 1].append(u - 1)\nleafs = set()\nleaf_count_that_touch_node = defaultdict(int)\nfor (node_id, neighbours) in enumerate(edges):\n    if len(neighbours) == 1:\n        leafs.add(node_id)\n        leaf_count_that_touch_node[neighbours[0]] += 1\nmmax = N - 1\nfor (n, leaf_count) in leaf_count_that_touch_node.items():\n    mmax -= leaf_count - 1\nQ = deque()\nroot = next(iter(leafs))\nQ.append(root)\nD = {root: 0}\nvisited = [False] * N\nvisited[root] = True\nwhile Q:\n    node = Q.pop()\n    for neighbour in edges[node]:\n        if visited[neighbour]:\n            continue\n        visited[neighbour] = True\n        Q.append(neighbour)\n        D[neighbour] = D[node] + 1\nfor leaf in leafs:\n    if D[leaf] % 2:\n        mmin = 3\n        break\nelse:\n    mmin = 1\nprint(mmin, mmax)", "n = int(input())\ngraph = [[] for i in range(n + 1)]\ndeg = [0] * (n + 1)\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    graph[x].append(y)\n    graph[y].append(x)\n    deg[x] += 1\n    deg[y] += 1\nroot = -1\nleavs = []\nfor i in range(n + 1):\n    if deg[i] == 1:\n        root = i\n        break\nfor i in range(n + 1):\n    if deg[i] == 1:\n        leavs.append(i)\nstack = []\ndepth = [0] * (n + 1)\nstack.append(root)\nvisi = set()\nvisi.add(root)\ncnt = 0\ngg = 0\nnod = graph[root][0]\nwhile len(stack) != 0:\n    x = stack.pop()\n    fn = 0\n    for nodes in graph[x]:\n        if nodes not in visi:\n            stack.append(nodes)\n            visi.add(nodes)\n            depth[nodes] = depth[x] + 1\n            if deg[nodes] == 1:\n                fn = 1\n    if fn:\n        cnt += 1\n    if x == nod and fn == 1:\n        gg = 1\nfl = 0\nfor i in leavs:\n    if depth[i] % 2:\n        fl = 1\nif fl:\n    print(3, end=' ')\nelse:\n    print(1, end=' ')\nif gg == 0:\n    cnt += 1\nprint(n + cnt - 1 - len(leavs))", "n = int(input())\nl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (p1, p2) = map(lambda x: x - 1, map(int, input().split()))\n    l[p1].append(p2)\n    l[p2].append(p1)\nleaf = []\ne = [0] * n\nmaxans = n - 1\nfor i in range(n):\n    temp = l[i]\n    if len(temp) == 1:\n        if e[temp[0]] == 1:\n            maxans -= 1\n        else:\n            e[temp[0]] = 1\n        leaf.append(i)\nq = [0]\nvisited = [-1] * n\nvisited[0] = 0\nwhile q:\n    node = q.pop()\n    for i in l[node]:\n        if visited[i] == -1:\n            q.append(i)\n            visited[i] = 1 - visited[node]\nf = visited[leaf[0]]\nfor i in leaf:\n    if visited[i] != f:\n        minans = 3\n        break\nelse:\n    minans = 1\nprint(minans, maxans)", "n = int(input())\nl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (p1, p2) = map(lambda x: x - 1, map(int, input().split()))\n    l[p1].append(p2)\n    l[p2].append(p1)\nleaf = []\ne = [0] * n\nmaxans = n - 1\nfor i in range(n):\n    temp = l[i]\n    if len(temp) == 1:\n        if e[temp[0]] == 1:\n            maxans -= 1\n        else:\n            e[temp[0]] = 1\n        leaf.append(i)\nq = [0]\nvisited = [-1] * n\nvisited[0] = 0\nwhile q:\n    node = q.pop()\n    for i in l[node]:\n        if visited[i] == -1:\n            q.append(i)\n            visited[i] = 1 - visited[node]\nf = visited[leaf[0]]\nfor i in leaf:\n    if visited[i] != f:\n        minans = 3\n        break\nelse:\n    minans = 1\nprint(minans, maxans)", "import collections\nn1 = input()\nn = int(n1)\nif n == 2:\n    print(1, 1)\n    exit()\nedges = [set() for _ in range(n)]\nfor i in range(n - 1):\n    x = input()\n    (a, b) = x.split(' ')\n    (a, b) = (int(a), int(b))\n    edges[a - 1].add(b - 1)\n    edges[b - 1].add(a - 1)\nocnt = collections.deque()\nfor i in range(n):\n    if len(edges[i]) == 1:\n        ocnt.append(i)\nnl = set()\nfor i in ocnt:\n    for j in edges[i]:\n        nl.add(j)\nx = ocnt[0]\n(que, l) = (collections.deque([(-1, x)]), 1)\nlo = 1\nwhile que:\n    size = len(que)\n    for _ in range(size):\n        (p, top) = que.popleft()\n        if len(edges[top]) == 1 and l % 2 == 0:\n            lo = 3\n            break\n        for j in edges[top]:\n            if j != p:\n                que.append((top, j))\n    l += 1\nhi = n - len(ocnt) + len(nl) - 1\nprint(lo, hi)", "import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\nN = int(input())\nG = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    (u, v) = map(int, input().split())\n    G[u].append(v)\n    G[v].append(u)\nleafs = [i for i in range(1, N + 1) if len(G[i]) == 1]\nleafNeibs = set()\nfor u in leafs:\n    for v in G[u]:\n        leafNeibs.add(v)\nmaxv = N - 1 - len(leafs) + len(leafNeibs)\nminv = 1\nq = [leafs[0]]\ndist = [N + 1 for _ in range(N + 1)]\nd = 0\ndist[leafs[0]] = 0\nwhile q:\n    nq = []\n    d += 1\n    for u in q:\n        for v in G[u]:\n            if dist[v] == N + 1:\n                dist[v] = d\n                nq.append(v)\n    q = nq\nif any([dist[v] % 2 != 0 for v in leafs]):\n    minv = 3\nprint('{} {}'.format(minv, maxv))", "size = int(input())\ngraph = [[] for i in range(size)]\nfor _ in range(1, size):\n    (a, b) = (int(x) for x in input().split())\n    a -= 1\n    b -= 1\n    graph[a] += [b]\n    graph[b] += [a]\nleafs = [node for node in range(0, len(graph)) if len(graph[node]) == 1]\ncolor = [None] * len(graph)\nqueue = [0]\ncolor[0] = 'a'\nhead = 0\nwhile head < len(queue):\n    currentNode = queue[head]\n    head += 1\n    for neighbor in graph[currentNode]:\n        if color[neighbor] != None:\n            continue\n        color[neighbor] = 'b' if color[currentNode] == 'a' else 'a'\n        queue += [neighbor]\nif all((color[leafs[0]] == color[leaf] for leaf in leafs)):\n    minF = 1\nelse:\n    minF = 3\ngroup = [0] * len(graph)\nfor leaf in leafs:\n    parent = graph[leaf][0]\n    group[parent] += 1\nmaxF = len(graph) - 1\nfor size in group:\n    if size >= 2:\n        maxF -= size - 1\nprint(str(minF) + ' ' + str(maxF))", "n = int(input())\ntree = [[] for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    tree[a - 1].append(b - 1)\n    tree[b - 1].append(a - 1)\nd = dict()\nfor i in range(n):\n    if len(tree[i]) == 1:\n        x = tree[i][0]\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n        st = i\nma = n - 1\nfor i in d:\n    ma -= d[i] - 1\ninf = 10000000000000000\ndep = [inf for i in range(n)]\ndep[st] = 0\nfrom collections import deque\nd = deque()\nd.append(st)\ndep_sub = 0\nwhile len(d):\n    dep_sub += 1\n    l = len(d)\n    for _ in range(l):\n        p = d.popleft()\n        for i in tree[p]:\n            if dep[i] == inf:\n                dep[i] = dep_sub\n                d.append(i)\nif any((dep[i] % 2 and len(tree[i]) == 1 for i in range(n))):\n    mi = 3\nelse:\n    mi = 1\nprint(mi, ma)", "n = int(input().strip())\nconns = [set() for i in range(n + 1)]\nfor i in range(n - 1):\n    (a, b) = [int(d) for d in input().strip().split()]\n    conns[a].add(b)\n    conns[b].add(a)\neven = False\nodd = False\nfor i in range(1, n + 1):\n    if len(conns[i]) > 1:\n        first = i\n        break\nq = [(first, -1, 0)]\nindex = 0\nwhile index < len(q):\n    (node, parent, dist) = q[index]\n    index += 1\n    if len(conns[node]) == 1:\n        if dist % 2 == 0:\n            even = True\n        else:\n            odd = True\n    for c in conns[node]:\n        if c != parent:\n            q += [(c, node, dist + 1)]\nnum_leaves = [0 for i in range(n + 1)]\nfor i in range(1, n + 1):\n    if len(conns[i]) == 1:\n        for c in conns[i]:\n            num_leaves[c] += 1\nma = n - 1\nfor val in num_leaves:\n    if val > 0:\n        ma -= val - 1\nif even and odd:\n    mi = 3\nelse:\n    mi = 1\nprint(mi, ma)", "import sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input().strip())\nconns = [set() for i in range(n + 1)]\nfor i in range(n - 1):\n    (a, b) = [int(d) for d in input().strip().split()]\n    conns[a].add(b)\n    conns[b].add(a)\neven = False\nodd = False\nfor i in range(1, n + 1):\n    if len(conns[i]) > 1:\n        first = i\n        break\nq = [(first, -1, 0)]\nindex = 0\nwhile index < len(q):\n    (node, parent, dist) = q[index]\n    index += 1\n    if len(conns[node]) == 1:\n        if dist % 2 == 0:\n            even = True\n        else:\n            odd = True\n    for c in conns[node]:\n        if c != parent:\n            q += [(c, node, dist + 1)]\nnum_leaves = [0 for i in range(n + 1)]\nfor i in range(1, n + 1):\n    if len(conns[i]) == 1:\n        for c in conns[i]:\n            num_leaves[c] += 1\nma = n - 1\nfor val in num_leaves:\n    if val > 0:\n        ma -= val - 1\nif even and odd:\n    mi = 3\nelse:\n    mi = 1\nprint(mi, ma)", "n = int(input())\ng = [[] for i in range(n)]\nL = [-1] * n\nfor i in range(n - 1):\n    (a, b) = map(int, input().split(' '))\n    a -= 1\n    b -= 1\n    g[a] += [b]\n    g[b] += [a]\nL[0] = 0\nq = [0]\ni = 0\nodd = 0\neven = 0\nx = 0\nwhile i < len(q):\n    a = q[i]\n    if len(g[a]) == 1:\n        if L[a]:\n            odd += 1\n        else:\n            even += 1\n    i += 1\n    for b in g[a]:\n        if L[b] != -1:\n            continue\n        L[b] = 1 - L[a]\n        q += [b]\nfor a in range(n):\n    s = 0\n    for b in g[a]:\n        if len(g[b]) == 1:\n            s += 1\n    if s:\n        x += s - 1\nprint(1 + 2 * (odd * even > 0), n - x - 1)", "n = int(input())\ng = [[] for i in range(n)]\nL = [-1] * n\nfor i in range(n - 1):\n    (a, b) = map(int, input().split(' '))\n    a -= 1\n    b -= 1\n    g[a] += [b]\n    g[b] += [a]\nL[0] = 0\nq = [0]\ni = 0\nodd = 0\neven = 0\nx = 0\nwhile i < len(q):\n    a = q[i]\n    if len(g[a]) == 1:\n        if L[a]:\n            odd += 1\n        else:\n            even += 1\n    i += 1\n    for b in g[a]:\n        if L[b] != -1:\n            continue\n        L[b] = 1 - L[a]\n        q += [b]\nfor a in range(n):\n    s = 0\n    for b in g[a]:\n        if len(g[b]) == 1:\n            s += 1\n    if s:\n        x += s - 1\nprint(1 + 2 * (odd * even > 0), n - x - 1)", "n = int(input())\nE = [[int(x) - 1 for x in input().split()] for i in range(n - 1)]\nG = [[] for i in range(n)]\nfor (u, v) in E:\n    G[u].append(v)\n    G[v].append(u)\nroot = next((i for i in range(n) if len(G[i]) > 1))\npa = [None] * n\nd = [None] * n\nuseless = [0] * n\nq = [(root, 0, root)]\nwhile q:\n    (parent, depth, i) = q.pop()\n    pa[i] = parent\n    d[i] = depth\n    G[i].sort(key=lambda j: len(G[j]))\n    for j in G[i]:\n        if pa[j] == None:\n            q.append((i, depth + 1, j))\n        if len(G[j]) == 1 and j != G[i][0]:\n            useless[j] = 1\nleaves = [i for i in range(n) if len(G[i]) == 1]\nans_min = 1 if len(set((d[i] % 2 for i in leaves))) == 1 else 3\nans_max = n - 1 - sum(useless)\nprint(ans_min, ans_max)", "n = int(input())\ng = [[] for i in range(n)]\nL = [-1] * n\nfor i in range(n - 1):\n    (a, b) = map(int, input().split(' '))\n    a -= 1\n    b -= 1\n    g[a] += [b]\n    g[b] += [a]\nL[0] = 0\nq = [0]\ni = 0\nodd = 0\neven = 0\nx = 0\nwhile i < len(q):\n    a = q[i]\n    if len(g[a]) == 1:\n        if L[a]:\n            odd += 1\n        else:\n            even += 1\n    i += 1\n    for b in g[a]:\n        if L[b] != -1:\n            continue\n        L[b] = 1 - L[a]\n        q += [b]\nfor a in range(n):\n    s = 0\n    for b in g[a]:\n        if len(g[b]) == 1:\n            s += 1\n    if s:\n        x += s - 1\nprint(1 + 2 * (odd * even > 0), n - x - 1)", "n = int(input())\ndic = {}\ndicle = {}\nfor i in range(n):\n    dic[i + 1] = []\n    dicle[i + 1] = 0\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    dic[x].append(y)\n    dic[y].append(x)\n    dicle[x] += 1\n    dicle[y] += 1\nroot = 0\nleafcount = 0\nse = set({})\nfor i in dicle:\n    if dicle[i] == 1:\n        leafcount += 1\n        root = i\n        se.add(dic[i][0])\nmaxans = n - 1 - leafcount + len(se)\nflag = True\nse = {root}\ntem = {root}\ndis = [0] * (n + 1)\nlevel = 0\nwhile tem:\n    level += 1\n    tem1 = set({})\n    for i in tem:\n        xx = dic[i]\n        for j in xx:\n            if not j in se:\n                if level % 2 != 0 and dicle[j] == 1:\n                    flag = False\n                se.add(j)\n                tem1.add(j)\n                dis[j] = level\n    tem = tem1.copy()\nif flag:\n    print(1, maxans)\nelse:\n    print(3, maxans)", "import random\n\ndef getVal(used):\n    x = random.randint(1, 10 ** 40)\n    while x in used:\n        x = random.randint(1, 10 ** 40)\n    return x\n\ndef solve(edges, n, leaf):\n    stack = [leaf]\n    dp = [0] * (n + 1)\n    dp2 = [0] * (n + 1)\n    one = True\n    visited = set()\n    used = set()\n    while stack:\n        curr = stack.pop()\n        if curr not in visited:\n            visited.add(curr)\n            if len(edges[curr]) == 1 and dp2[curr] != 0:\n                one = False\n            for kid in edges[curr]:\n                if kid not in visited:\n                    dp2[kid] = dp2[curr] ^ 1\n                    stack.append(kid)\n                    val = getVal(used)\n                    if len(edges[kid]) == 1:\n                        used.add(dp[curr])\n                        dp[kid] = 0\n                    else:\n                        dp[kid] = dp[curr] ^ val\n                        used.add(val)\n    if one:\n        min_val = 1\n    else:\n        min_val = 3\n    print(min_val, len(used))\n\ndef main():\n    n = int(input())\n    edges = {}\n    for i in range(1, n + 1):\n        edges[i] = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        edges[a].append(b)\n        edges[b].append(a)\n    for i in edges.keys():\n        if len(edges[i]) == 1:\n            leaf = i\n            break\n    solve(edges, n, leaf)\nmain()", "from collections import deque\n\ndef readTree(v):\n    adj = [set() for i in range(v + 1)]\n    for i in range(v - 1):\n        (v1, v2) = [int(x) for x in input().split()]\n        adj[v1].add(v2)\n        adj[v2].add(v1)\n    return adj\n\ndef bfs(adj):\n    visited = [True] + [False] * v\n    q = deque()\n    for i in range(1, v + 1):\n        if len(adj[i]) > 1:\n            root = i\n            break\n    q.append(root)\n    visited[root] = True\n    edges = [0] * (v + 1)\n    parent = [0] * (v + 1)\n    depth = [0] * (v + 1)\n    depth_leaf = deque()\n    while q:\n        ele = q.pop()\n        leaf = False\n        for a in adj[ele]:\n            if visited[a] == False:\n                depth[a] = depth[ele] + 1\n                if adj[a] == {ele}:\n                    if leaf == False:\n                        edges[ele] += 1\n                        leaf = True\n                    depth_leaf.append(depth[a])\n                else:\n                    edges[ele] += 1\n                parent[a] = ele\n                q.append(a)\n                visited[a] = True\n    return (edges, depth_leaf)\nv = int(input())\nadj = readTree(v)\n(edges, depth_leaf) = bfs(adj)\nfor i in range(1, len(depth_leaf)):\n    if (depth_leaf[i] + depth_leaf[i - 1]) % 2 != 0:\n        minn = 3\n        break\nelse:\n    minn = 1\nprint(minn, sum(edges))", "from collections import defaultdict\nn = int(input())\nd = defaultdict(list)\nleaves = defaultdict(int)\nfor i in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    d[a].append(b)\n    d[b].append(a)\n    leaves[a] += 1\n    leaves[b] += 1\nleaf = {}\nnon_leaves = {}\nfor (l, i) in leaves.items():\n    if i == 1:\n        leaf[l] = 1\n        u = d[l][0]\n        non_leaves[u] = 1\nmx = n - 1 - (len(leaf) - len(non_leaves))\nmn = 1\nroot = list(leaf.keys())[0]\nqueue = [(root, 0)]\nvisited = [False] * (n + 1)\nwhile queue:\n    (p, dist) = queue.pop(0)\n    if leaf.get(p, 0):\n        if dist % 2 != 0:\n            mn = 3\n            break\n    visited[p] = True\n    for i in d[p]:\n        if visited[i] == False:\n            visited[i] = True\n            queue.append((i, dist + 1))\nprint(mn, mx)"]