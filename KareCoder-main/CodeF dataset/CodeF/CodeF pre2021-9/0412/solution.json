["import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    c = [[] for i in range(n + 1)]\n    a = list(map(int, input().split()))\n    z = 0\n    for i in range(n):\n        if len(c[a[i]]) < k:\n            c[a[i]].append(i)\n            z += 1\n    b = z // k\n    d = b * k\n    r = [0] * n\n    j = 0\n    for v in c:\n        for w in v:\n            r[w] = j % k + 1\n            j += 1\n            if j == d:\n                print(' '.join(map(str, r)))\n                return\n    print(' '.join(map(str, r)))\nfor i in range(int(input())):\n    solve()", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_list_string():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_print_int(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef get_print(x):\n    sys.stdout.write(x + '\\n')\n\ndef get_print_int_same(x):\n    sys.stdout.write(str(x) + ' ')\n\ndef get_print_same(x):\n    sys.stdout.write(x + ' ')\nfrom sys import maxsize\n\ndef solve():\n    for _ in range(get_int()):\n        (n, k) = get_ints()\n        arr = get_list()\n        d = dict()\n        maxx = 0\n        for i in range(n):\n            if arr[i] not in d:\n                d[arr[i]] = [i]\n                maxx += 1\n            elif len(d[arr[i]]) <= k - 1:\n                d[arr[i]].append(i)\n                maxx += 1\n        ans = [0] * n\n        start = 1\n        mul = maxx // k\n        upper = mul * k\n        for (key, v) in d.items():\n            if upper == 0:\n                break\n            for ind in v:\n                if upper == 0:\n                    break\n                ans[ind] = start\n                start += 1\n                upper -= 1\n                if start > k:\n                    start = 1\n        get_print(' '.join(map(str, ans)))\nsolve()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    c = [[] for i in range(n + 1)]\n    a = list(map(int, input().split()))\n    z = 0\n    for i in range(n):\n        if len(c[a[i]]) < k:\n            c[a[i]].append(i)\n            z += 1\n    b = z // k\n    d = b * k\n    r = [0] * n\n    j = 0\n    for v in c:\n        for w in v:\n            r[w] = j % k + 1\n            j += 1\n            if j == d:\n                print(' '.join(map(str, r)))\n                return\nfor i in range(int(input())):\n    solve()", "def solve():\n    (n, k) = map(int, input().split())\n    c = [[] for i in range(n + 1)]\n    a = list(map(int, input().split()))\n    z = 0\n    for i in range(n):\n        if len(c[a[i]]) < k:\n            c[a[i]].append(i)\n            z += 1\n    b = z // k\n    d = b * k\n    r = [0] * n\n    j = 0\n    for v in c:\n        for w in v:\n            r[w] = j % k + 1\n            j += 1\n            if j == d:\n                print(' '.join(map(str, r)))\n                return\nfor i in range(int(input())):\n    solve()", "def solve():\n    (n, k) = map(int, input().split())\n    c = [[] for i in range(n + 1)]\n    a = list(map(int, input().split()))\n    z = 0\n    for i in range(n):\n        if len(c[a[i]]) < k:\n            c[a[i]].append(i)\n            z += 1\n    b = z // k\n    d = b * k\n    r = [0] * n\n    j = 0\n    for v in c:\n        for w in v:\n            r[w] = j % k + 1\n            j += 1\n            if j == d:\n                print(' '.join(map(str, r)))\n                return\nfor i in range(int(input())):\n    solve()", "import sys\nI = lambda x=' ': map(int, sys.stdin.readline().split(x))\npr = lambda *x, sep=' ', end='\\n': sys.stdout.write(f'{sep.join(map(str, x))}{end}')\n\ndef solve():\n    (n, k) = I()\n    a = [*I()]\n    d = dict()\n    for (i, x) in enumerate(a):\n        if x in d:\n            if len(d[x]) < k:\n                d[x].append(i)\n        else:\n            d[x] = [i]\n    m = sum(map(lambda x: len(x[1]), d.items()))\n    m -= m % k\n    (ans, c) = ([0] * n, 0)\n    for e in d:\n        for i in d[e]:\n            ans[i] = c + 1\n            c = (c + 1) % k\n            m -= 1\n            if not m:\n                return ans\n\ndef main():\n    (t,) = I()\n    for _ in range(t):\n        pr(*solve())\nmain()", "def solve():\n    (n, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    d = {}\n    for (i, b) in enumerate(a):\n        if b in d:\n            if len(d[b]) == k:\n                continue\n            d[b].append(i)\n        else:\n            d[b] = [i]\n    s = []\n    ans = [0 for _ in range(n)]\n    for b in d:\n        if len(d[b]) == k:\n            c = 1\n            for i in d[b]:\n                ans[i] = c\n                c += 1\n        else:\n            s += d[b]\n    l = len(s)\n    l = l // k * k\n    c = 1\n    for i in range(l):\n        ans[s[i]] = c\n        c += 1\n        if c == k + 1:\n            c = 1\n    print(' '.join((str(x) for x in ans)))\nfor _ in range(int(input())):\n    solve()", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef solve(n, k, arr):\n    store = {}\n    final = [0 for i in range(n)]\n    for (i, ele) in enumerate(arr):\n        if ele not in store:\n            store[ele] = [i]\n        else:\n            store[ele].append(i)\n    rem = []\n    for ele in store:\n        length = len(store[ele])\n        if length >= k:\n            current = 1\n            for i in range(k):\n                final[store[ele][i]] = current\n                current += 1\n        else:\n            present = len(rem)\n            req = k - present\n            if length <= req:\n                rem.extend(store[ele])\n                newArr = []\n            else:\n                newArr = store[ele][req:]\n                rem.extend(store[ele][:req])\n            if len(rem) == k:\n                current = 1\n                for j in rem:\n                    final[j] = current\n                    current += 1\n                rem = newArr\n    if len(rem) == k:\n        current = 1\n        for j in rem:\n            final[j] = current\n            current += 1\n    sys.stdout.write(' '.join(map(str, final)) + '\\n')\n    return\nT = int(input())\nwhile T:\n    (n, k) = get_ints()\n    arr = list(get_ints())\n    solve(n, k, arr)\n    T -= 1", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef solve(n, k, arr):\n    store = {}\n    final = [0 for i in range(n)]\n    for (i, ele) in enumerate(arr):\n        if ele not in store:\n            store[ele] = [i]\n        else:\n            store[ele].append(i)\n    rem = []\n    for ele in store:\n        length = len(store[ele])\n        if length >= k:\n            current = 1\n            for i in range(k):\n                final[store[ele][i]] = current\n                current += 1\n        else:\n            present = len(rem)\n            req = k - present\n            if length <= req:\n                rem.extend(store[ele])\n                newArr = []\n            else:\n                newArr = store[ele][req:]\n                rem.extend(store[ele][:req])\n            if len(rem) == k:\n                current = 1\n                for j in rem:\n                    final[j] = current\n                    current += 1\n                rem = newArr\n    if len(rem) == k:\n        current = 1\n        for j in rem:\n            final[j] = current\n            current += 1\n    sys.stdout.write(' '.join(map(str, final)) + '\\n')\n    return\nT = int(input())\nwhile T:\n    (n, k) = get_ints()\n    arr = get_list()\n    solve(n, k, arr)\n    T -= 1", "from collections import Counter\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = list(map(int, input().split()))\n    tmp = [[] for i in range(n + 1)]\n    num = 0\n    for i in range(n):\n        if len(tmp[s[i]]) < k:\n            tmp[s[i]].append(i)\n            num += 1\n    group = num // k\n    end = group * k\n    z = 0\n    res = [0] * n\n    for i in tmp:\n        for j in i:\n            res[j] = z % k + 1\n            z += 1\n            if z == end:\n                print(' '.join((str(i) for i in res)))", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    pos = defaultdict(list)\n    for (i, val) in enumerate(a):\n        pos[val].append(i)\n    c = [0 for _ in range(n)]\n    leftovers = []\n    for indices in pos.values():\n        if len(indices) >= k:\n            for i in range(k):\n                c[indices[i]] = i + 1\n        else:\n            leftovers.extend(indices)\n    for i in range(len(leftovers) // k * k):\n        c[leftovers[i]] = i % k + 1\n    print(' '.join(map(str, c)))", "from sys import stdin\nfrom collections import defaultdict as dict, Counter\ninput = lambda : stdin.readline().strip()\nlinput = lambda : [*map(int, input().split())]\noutput = []\n\ndef lprint(*x):\n    output.append(' '.join(map(str, x)))\n\ndef main():\n    (n, k) = linput()\n    a = linput()\n    d = dict(list)\n    for (i, x) in enumerate(a):\n        d[x].append(i)\n    ans = [0] * n\n    c = 0\n    for x in d:\n        s = c + k\n        while d[x] and c != s:\n            ans[d[x].pop()] = c % k + 1\n            c += 1\n    c = Counter(ans)\n    m = min([c[x] for x in c if x])\n    for i in range(n):\n        if ans[i] and c[ans[i]] > m:\n            c[ans[i]] -= 1\n            ans[i] = 0\n    lprint(*ans)\nfor _ in ' ' * int(input()):\n    main()\nprint(*output, sep='\\n')", "t = int(input())\nwhile t:\n    (s, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    color = [0] * s\n    d = {}\n    for i in range(s):\n        if a[i] not in d:\n            d[a[i]] = []\n        d[a[i]].append(i)\n    leftover = []\n    for i in d:\n        if len(d[i]) >= k:\n            for j in range(k):\n                color[d[i][j]] = j + 1\n        else:\n            leftover.extend(d[i])\n    m = len(leftover)\n    leftover = leftover[:m - m % k]\n    m = len(leftover)\n    c = 1\n    for i in range(m):\n        if c > k:\n            c = 1\n        color[leftover[i]] = c\n        c = c + 1\n    print(' '.join(list(map(str, color))))\n    t = t - 1", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    pos = defaultdict(list)\n    for (i, val) in enumerate(a):\n        pos[val].append(i)\n    c = [0 for _ in range(n)]\n    leftovers = []\n    for (_, indices) in pos.items():\n        if len(indices) >= k:\n            for i in range(k):\n                c[indices[i]] = i + 1\n        else:\n            leftovers.extend(indices)\n    for i in range(len(leftovers) // k * k):\n        c[leftovers[i]] = i % k + 1\n    print(' '.join(map(str, c)))", "t = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = list(map(int, input().split()))\n    tmp = [[] for i in range(n + 1)]\n    num = 0\n    for i in range(n):\n        if len(tmp[s[i]]) < k:\n            tmp[s[i]].append(i)\n            num += 1\n    group = num // k\n    end = group * k\n    z = 0\n    res = [0] * n\n    for i in tmp:\n        for j in i:\n            res[j] = z % k + 1\n            z += 1\n            if z == end:\n                print(' '.join(map(str, res)))", "t = int(input())\nfor _ in range(t):\n    from collections import Counter\n    (n, k) = tuple(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    ans = [0] * n\n    y = {}\n    d = {}\n    for (i, x) in enumerate(arr):\n        if x in d:\n            if d[x] < k:\n                y[x].append(i)\n                d[x] += 1\n        elif k > 0:\n            y[x] = [i]\n            d[x] = 1\n    a = sum(d.values())\n    a -= a % k\n    for r in y.values():\n        for (i, j) in enumerate(r):\n            ans[j] = 1 + a % k\n            a -= 1\n            if a == 0:\n                break\n        else:\n            continue\n        break\n    print(' '.join(map(str, ans)))", "def solve():\n    (n, k) = map(int, input().split())\n    cnt = [0] * (n + 1)\n    a = []\n    for (i, x) in enumerate(map(int, input().split())):\n        if cnt[x] < k:\n            a.append((x, i))\n        cnt[x] += 1\n    a.sort()\n    cc = 0\n    color = [0] * n\n    m = len(a) - len(a) % k\n    for (x, i) in a[:m]:\n        color[i] = cc + 1\n        cc = (cc + 1) % k\n    print(*color)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    tab = list(map(int, input().split()))\n    freq = dict()\n    res = [0] * n\n    positions = defaultdict(list)\n    nb_element_can_be_colored = 0\n    for (i, val) in enumerate(tab):\n        if len(positions[val]) < k:\n            positions[val].append(i)\n            nb_element_can_be_colored += 1\n    max_element_to_color = nb_element_can_be_colored - nb_element_can_be_colored % k\n    current_color = 0\n    solve = False\n    for pos in positions.values():\n        if solve:\n            break\n        for index in pos:\n            res[index] = current_color + 1\n            current_color = (current_color + 1) % k\n            max_element_to_color -= 1\n            if max_element_to_color == 0:\n                solve = True\n                break\n    print(' '.join(list(map(str, res))))", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom itertools import chain\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    el_idx = {}\n    for (i, ai) in enumerate(a):\n        el_ai = el_idx.setdefault(ai, [])\n        if len(el_ai) < k:\n            el_ai.append(i)\n    cnt = {el: len(el_idx[el]) for el in el_idx.keys()}\n    pos_el = sum(cnt.values())\n    pos_col = pos_el // k\n    res = ['0' for _ in range(n)]\n    col_iter = chain(*[range(1, k + 1) for _ in range(pos_col)])\n    idx_iter = chain(*el_idx.values())\n    for (idx, col) in zip(idx_iter, col_iter):\n        res[idx] = str(col)\n    print(' '.join(res))", "from collections import defaultdict\nt = int(input())\nwhile t > 0:\n    t -= 1\n    line = input().split()\n    (n, k) = (int(line[0]), int(line[1]))\n    d = defaultdict(list)\n    line = input().split()\n    for i in range(n):\n        x = line[i]\n        if len(d[x]) < k:\n            d[x].append(i)\n    res = ['0'] * n\n    color = 0\n    cnt = sum([len(x) for x in d.values()])\n    cnt -= cnt % k\n    for (_, v) in d.items():\n        for i in v:\n            color += 1\n            res[i] = str(color)\n            color = color % k\n            cnt -= 1\n            if cnt == 0:\n                break\n        if cnt == 0:\n            break\n    print(' '.join(res))", "for i in range(int(input())):\n    (c, b) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ind = [[] for i in range(c + 1)]\n    p = {}\n    num = 0\n    for i in range(c):\n        if len(ind[a[i]]) < b:\n            ind[a[i]].append(i)\n            num += 1\n    m = int(num / b)\n    s = m * b\n    i = 0\n    f = False\n    j = 0\n    p = ['0' for i in range(c)]\n    for i in ind:\n        if f == True:\n            break\n        for q in i:\n            p[q] = str(j % b + 1)\n            j += 1\n            if j == s:\n                print(' '.join(p))\n                f = True\n                break\n    if f == False:\n        print(' '.join(p))", "def getint():\n    return [int(i) for i in input().split()]\n\ndef solve():\n    (n, k) = getint()\n    a = getint()\n    ans = []\n    cnt = [0] * (n + 1)\n    for (i, x) in enumerate(a):\n        if cnt[x] < k:\n            ans.append((x, i))\n        cnt[x] += 1\n    ans.sort()\n    cc = 0\n    color = [0] * n\n    m = len(ans) - len(ans) % k\n    for (x, i) in ans[:m]:\n        color[i] = cc + 1\n        cc = (cc + 1) % k\n    print(*color)\nfor _ in range(int(input())):\n    solve()", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    d = {}\n    for i in nums:\n        d[i] = d.get(i, 0) + 1\n    d = {x: k for (x, y) in d.items() if y >= k}\n    lst = [i for i in nums if i not in d]\n    lst.sort()\n    dp = {i: [] for i in lst}\n    temp = 0\n    for i in lst:\n        dp[i].append(temp % k + 1)\n        temp += 1\n    ans = nums.copy()\n    for i in range(len(nums)):\n        if nums[i] not in d:\n            ans[i] = dp[nums[i]].pop()\n        elif d[nums[i]] > 0:\n            ans[i] = d[nums[i]]\n            d[nums[i]] -= 1\n        else:\n            ans[i] = 0\n    if temp % k != 0:\n        s = {i for i in range(1, temp % k + 1)}\n        for i in range(len(ans)):\n            if ans[i] in s:\n                s.remove(ans[i])\n                ans[i] = 0\n    print(' '.join(map(str, ans)))", "from collections import Counter\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = list(map(int, input().split()))\n    tmp = [[] for i in range(n + 1)]\n    num = 0\n    for i in range(n):\n        if len(tmp[s[i]]) < k:\n            tmp[s[i]].append(i)\n            num += 1\n    group = num // k\n    end = group * k\n    z = 0\n    res = [0] * n\n    for i in tmp:\n        for j in i:\n            res[j] = z % k + 1\n            z += 1\n            if z == end:\n                print(' '.join((str(i) for i in res)))", "from collections import defaultdict as dd\n\ndef findColors():\n    t = int(input())\n    while t != 0:\n        t = t - 1\n        (n, k) = map(int, input().split())\n        d = list(map(int, input().split()))\n        def_dic = dd(list)\n        for i in range(n):\n            def_dic[d[i]].append(i)\n        ans_arr = [0] * n\n        residue = []\n        for i in def_dic:\n            if len(def_dic[i]) >= k:\n                for m in range(k):\n                    ans_arr[def_dic[i][m]] = m + 1\n            else:\n                residue += def_dic[i]\n        ll = len(residue) // k * k\n        for i in range(ll):\n            ans_arr[residue[i]] = i % k + 1\n        print(*ans_arr)\nfindColors()", "t = int(input())\nresults = []\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    s = [(int(c), j) for (j, c) in enumerate(input().split())]\n    s.sort(key=lambda x: x[0])\n    counts = {}\n    for (c, j) in s:\n        counts[c] = counts.get(c, 0) + 1\n    new_counts = {}\n    total = 0\n    for c in counts:\n        if counts[c] <= k:\n            new_counts[c] = 'reg'\n            total += counts[c]\n        else:\n            new_counts[c] = k\n    total //= k\n    total *= k\n    seq = [0] * n\n    current = 1\n    for (c, j) in s:\n        if new_counts[c] == 'reg':\n            if total > 0:\n                seq[j] = current\n                current = current % k + 1\n                total -= 1\n            else:\n                seq[j] = 0\n        elif new_counts[c] > 0:\n            seq[j] = new_counts[c]\n            new_counts[c] -= 1\n        else:\n            seq[j] = 0\n    results.append(' '.join([str(num) for num in seq]))\nfor i in range(t):\n    print(results[i])", "from math import *\nimport heapq as h\nfrom collections import Counter\nmod = 1000000007\n\ndef pro(arr, k):\n    freq = {}\n    n = len(arr)\n    ans = [0] * n\n    for i in range(n):\n        if arr[i] in freq:\n            if len(freq[arr[i]]) == k:\n                ans[i] = 0\n                continue\n            freq[arr[i]].append(i)\n        else:\n            freq[arr[i]] = [i]\n    tot = 0\n    for (i, j) in freq.items():\n        tot = tot + len(j)\n    tot = tot - tot % k\n    c = 1\n    for (i, j) in freq.items():\n        if tot == 0:\n            break\n        for p in j:\n            if tot == 0:\n                break\n            ans[p] = c\n            tot -= 1\n            if c == k:\n                c = 1\n            else:\n                c += 1\n    print(*ans)\nt = int(input())\nfor i in range(t):\n    (n, k) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    pro(arr, k)", "from collections import Counter\n\ndef wonderfulcoloring(n, k):\n    tempSol = []\n    solution = []\n    numDict = {}\n    counters = Counter(k)\n    colorNum = 0\n    for (num, count) in counters.items():\n        numDict[num] = [colorNum, min(count + colorNum, n + colorNum)]\n        colorNum += min(count, n)\n        if colorNum > n:\n            colorNum = colorNum % n\n            tempSol = []\n            tempSol.append(num)\n        elif colorNum == n:\n            colorNum = colorNum % n\n            tempSol = []\n        else:\n            tempSol.append(num)\n    if tempSol:\n        for num in tempSol:\n            if numDict[num][0] <= n <= numDict[num][1]:\n                numDict[num][1] = n\n            else:\n                numDict[num] = [0, 0]\n    for num in k:\n        color = numDict[num][0]\n        if color >= numDict[num][1]:\n            solution.append(0)\n        else:\n            solution.append(color % n + 1)\n            numDict[num][0] += 1\n    solution = [str(x) for x in solution]\n    print(' '.join(solution))\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    sequence = [int(x) for x in input().split()]\n    wonderfulcoloring(k, sequence)", "def solve(n, k, a):\n    indices = [[] for i in range(n + 1)]\n    colours = [0] * n\n    cur_col = 0\n    max_painted = 0\n    for i in range(n):\n        if len(indices[a[i]]) < k:\n            indices[a[i]] += [i]\n            max_painted += 1\n    max_painted = max_painted - max_painted % k\n    for arr in indices:\n        for x in arr:\n            colours[x] = cur_col % k + 1\n            cur_col += 1\n            if cur_col >= max_painted:\n                print(*colours)\n                return\n    print(*colours)\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    solve(n, k, a)", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef solve(n, k, arr):\n    store = {}\n    final = [0 for i in range(n)]\n    for (i, ele) in enumerate(arr):\n        if ele not in store:\n            store[ele] = [i]\n        else:\n            store[ele].append(i)\n    rem = []\n    for ele in store:\n        length = len(store[ele])\n        if length >= k:\n            current = 1\n            for i in range(k):\n                final[store[ele][i]] = current\n                current += 1\n        else:\n            present = len(rem)\n            req = k - present\n            if length <= req:\n                rem.extend(store[ele])\n                newArr = []\n            else:\n                newArr = store[ele][req:]\n                rem.extend(store[ele][:req])\n            if len(rem) == k:\n                current = 1\n                for j in rem:\n                    final[j] = current\n                    current += 1\n                rem = newArr\n    if len(rem) == k:\n        current = 1\n        for j in rem:\n            final[j] = current\n            current += 1\n    print(*final)\n    return\nT = int(input())\nwhile T:\n    (n, k) = get_ints()\n    arr = list(get_ints())\n    solve(n, k, arr)\n    T -= 1", "T = int(input())\nwhile T > 0:\n    T -= 1\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    indices = {}\n    p = [0] * n\n    sb = 0\n    for i in range(n):\n        if a[i] not in indices:\n            indices[a[i]] = []\n        if len(indices[a[i]]) == k:\n            continue\n        indices[a[i]].append(i)\n        sb += 1\n    sb -= sb % k\n    for idx in indices:\n        for i in indices[idx]:\n            p[i] = sb % k + 1\n            sb -= 1\n            if sb == 0:\n                break\n        if sb == 0:\n            break\n    print(' '.join(map(str, p)))", "from math import *\nfrom collections import *\nfrom functools import *\nfrom bisect import *\nfrom itertools import *\nfrom heapq import *\nimport sys\ninf = float('inf')\nninf = -float('inf')\nip = sys.stdin.readline\nalphal = 'abcdefghijklmnopqrstuvwxyz'\nalphau = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nmod = 10 ** 9 + 7\n\ndef ipl():\n    return list(map(int, ip().split()))\n\ndef ipn():\n    return int(ip())\n\ndef ipf():\n    return float(ip())\n\ndef solve():\n    (n, k) = ipl()\n    a = ipl()\n    c = defaultdict(int)\n    d = 0\n    l = []\n    for (_, i) in enumerate(a):\n        if c[i] < k:\n            l.append((a[_], _))\n        c[i] += 1\n    r = [0] * n\n    l.sort()\n    t = 1\n    ra = len(l) - len(l) % k\n    for (_, v) in l[:ra]:\n        r[v] = t % k + 1\n        t += 1\n    print(*r)\nt = ipn()\nfor _ in range(t):\n    solve()", "from math import floor, gcd, sqrt, ceil\nfrom collections import Counter, defaultdict\n\ndef main():\n    for _ in range(int(input())):\n        (n, k) = map(int, input().split())\n        a = list(map(int, input().split()))\n        color = [0] * n\n        faaltu = []\n        d = defaultdict(list)\n        for i in range(n):\n            d[a[i]].append(i)\n        for i in d:\n            if len(d[i]) >= k:\n                k1 = 1\n                for j in d[i][:k]:\n                    color[j] = k1\n                    k1 += 1\n            else:\n                faaltu.extend(d[i])\n        k1 = 1\n        for i in faaltu[:k * (len(faaltu) // k)]:\n            color[i] = k1\n            k1 = (k1 + 1) % k\n            if k1 == 0:\n                k1 = k\n        print(*color)\nmain()", "import sys\nlnn = len\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef solve(n, k, arr):\n    store = {}\n    final = [0 for i in range(n)]\n    for (i, ele) in enumerate(arr):\n        if ele not in store:\n            store[ele] = [i]\n        else:\n            store[ele].append(i)\n    rem = []\n    for ele in store:\n        length = lnn(store[ele])\n        if length >= k:\n            current = 1\n            for i in range(k):\n                final[store[ele][i]] = current\n                current += 1\n        else:\n            present = lnn(rem)\n            req = k - present\n            if length <= req:\n                rem.extend(store[ele])\n                newArr = []\n            else:\n                newArr = store[ele][req:]\n                rem.extend(store[ele][:req])\n            if lnn(rem) == k:\n                current = 1\n                for j in rem:\n                    final[j] = current\n                    current += 1\n                rem = newArr\n    if lnn(rem) == k:\n        current = 1\n        for j in rem:\n            final[j] = current\n            current += 1\n    print(*final)\n    return\nT = int(input())\nwhile T:\n    (n, k) = get_ints()\n    arr = list(get_ints())\n    solve(n, k, arr)\n    T -= 1", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    (a, z) = ({}, 0)\n    for i in range(n):\n        if x[i] in a:\n            if len(a[x[i]]) < k:\n                a[x[i]].append(i)\n        else:\n            a[x[i]] = [i]\n    b = []\n    for c in a.values():\n        for i in c:\n            b.append(i)\n    (ans, kol) = ([0] * n, len(b) // k * k)\n    for i in range(kol):\n        ans[b[i]] = i % k + 1\n    print(*ans)", "import sys\nN = int(200000.0 + 5)\nsys.setrecursionlimit(N)\n\ndef charming():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(zip(a, range(n)))\n    b.sort(key=lambda x: x[0])\n    cnt = 0\n    color = [0] * n\n    c = 1\n    stk = list()\n    for i in range(n):\n        if i == 0 or b[i - 1][0] != b[i][0]:\n            cnt = 1\n        else:\n            cnt += 1\n        if cnt > k:\n            continue\n        else:\n            color[b[i][1]] = (c - 1) % k + 1\n            c += 1\n            stk.append(i)\n    c = (c - 1) % k + 1\n    siz = len(stk)\n    for i in range(siz - (c - 1), siz):\n        color[b[stk[i]][1]] = 0\n    for i in color:\n        print(i, end=' ')\n    print()\nfor t in range(int(input())):\n    charming()", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    di = {}\n    for i in range(len(arr)):\n        if arr[i] not in di:\n            di[arr[i]] = [i]\n        elif len(di[arr[i]]) < k:\n            di[arr[i]].append(i)\n    s = []\n    for ar in di.values():\n        for ind in ar:\n            s.append(ind)\n    r = len(s) // k * k\n    ans = [0] * n\n    for i in range(r):\n        ans[s[i]] = i % k + 1\n    print(*ans)", "import sys\n\ndef process(n, k, a):\n    counts = {}\n    indices = {}\n    for i in range(len(a)):\n        if a[i] in counts:\n            counts[a[i]] += 1\n        else:\n            counts[a[i]] = 1\n        if a[i] in indices:\n            indices[a[i]].append(i)\n        else:\n            indices[a[i]] = [i]\n    counter = 0\n    to_sort = []\n    for i in counts:\n        counter += min(counts[i], k)\n        to_sort.append((i, min(counts[i], k)))\n    to_sort.sort(key=lambda x: x[1], reverse=True)\n    to_return = [0] * n\n    paint_number = 0\n    paint_max = int(counter / k) * k\n    for (i, j) in to_sort:\n        painted = 0\n        while painted < j:\n            if paint_number == paint_max:\n                return to_return\n            to_return[indices[i][painted]] = paint_number % k + 1\n            paint_number += 1\n            painted += 1\n    return to_return\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    sys.stdout.write(' '.join(map(str, process(n, k, a))) + '\\n')", "mini = 100000\ntests = int(input())\nmod = 10 ** 9 + 7\nwhile tests:\n    tests -= 1\n    arr = list(map(int, input().split()))\n    (n, k) = (arr[0], arr[1])\n    arr = list(map(int, input().split()))\n    d = {}\n    distinct = 0\n    stri = ''\n    ct = 1\n    loc = -1\n    for i in arr:\n        loc += 1\n        if i in d:\n            if len(d[i]) < k:\n                d[i].append(loc)\n                distinct += 1\n            else:\n                arr[loc] = 0\n        else:\n            d[i] = [loc]\n            distinct += 1\n    ct = 1\n    stri = ''\n    can_be_colored = distinct - int(distinct % k)\n    for i in d:\n        for j in d[i]:\n            if can_be_colored > 0:\n                can_be_colored -= 1\n                col = ct % k + 1\n                arr[j] = col\n                ct += 1\n            else:\n                arr[j] = 0\n    ans = ''\n    for i in arr:\n        ans += str(i) + ' '\n    print(ans)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = [[] for _ in r]\n    i = 0\n    for x in R():\n        a[x - 1] += (i,)\n        i += 1\n    for j in (a := [i for x in a for i in x[:k]])[:len(a) // k * k]:\n        i = i % k + 1\n        r[j] = i\n    print(*r)", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    x = list(map(int, input().split()))\n    (a, z) = ({}, 0)\n    for i in range(n):\n        if x[i] in a:\n            if len(a[x[i]]) < k:\n                a[x[i]].append(i)\n        else:\n            a[x[i]] = [i]\n    b = []\n    for c in a.values():\n        for i in c:\n            b.append(i)\n    (ans, kol) = ([0] * n, len(b) // k * k)\n    for i in range(kol):\n        ans[b[i]] = i % k + 1\n    print(*ans)", "_ = int(input())\nfor __ in range(_):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    out = [0] * n\n    d = {}\n    d_bigger = {}\n    d_pos = {}\n    curr_col = 1\n    for x in range(0, n):\n        if arr[x] not in d:\n            d[arr[x]] = 1\n            d_pos[arr[x]] = [x]\n        else:\n            d[arr[x]] += 1\n            d_pos[arr[x]].append(x)\n    tot_num = 0\n    for x in d:\n        if d[x] < k:\n            tot_num += d[x]\n    m = tot_num // k\n    tot_num = m * k\n    for x in d_pos:\n        if d[x] >= k:\n            pos = d_pos[x]\n            for y in range(k):\n                out[pos[y]] = y + 1\n        else:\n            pos = d_pos[x]\n            for y in pos:\n                if tot_num:\n                    out[y] = curr_col\n                    curr_col += 1\n                    if curr_col > k:\n                        curr_col = 1\n                    tot_num -= 1\n                else:\n                    out[y] = 0\n    print(' '.join([str(x) for x in out]))", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = []\n    p = 0\n    for (x, i) in sorted(zip(R(), range(n))):\n        n *= x == p\n        a += [i][:n < k]\n        p = x\n        n += 1\n    for i in a[len(a) % k:]:\n        n = n % k + 1\n        r[i] = n\n    print(*r)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    cnt = [0] * (n + 1)\n    a = []\n    for (i, x) in enumerate(map(int, input().split())):\n        if cnt[x] < k:\n            a.append((x, i))\n        cnt[x] += 1\n    a.sort()\n    ans = [0] * n\n    color = 0\n    ra = len(a) - len(a) % k\n    for (v, i) in a[:ra]:\n        color = color % k + 1\n        ans[i] = color\n    print(*ans)", "def solve(n, k, arr):\n    store = {}\n    final = [0 for i in range(n)]\n    for (i, ele) in enumerate(arr):\n        if ele not in store:\n            store[ele] = [i]\n        else:\n            store[ele].append(i)\n    rem = []\n    for ele in store:\n        length = len(store[ele])\n        if length >= k:\n            current = 1\n            for i in range(k):\n                final[store[ele][i]] = current\n                current += 1\n        else:\n            present = len(rem)\n            req = k - present\n            if length <= req:\n                rem.extend(store[ele])\n                newArr = []\n            else:\n                newArr = store[ele][req:]\n                rem.extend(store[ele][:req])\n            if len(rem) == k:\n                current = 1\n                for j in rem:\n                    final[j] = current\n                    current += 1\n                rem = newArr\n    if len(rem) == k:\n        current = 1\n        for j in rem:\n            final[j] = current\n            current += 1\n    print(*final)\n    return\nT = int(input())\nwhile T:\n    (n, k) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    solve(n, k, arr)\n    T -= 1", "t = int(input())\nwhile t > 0:\n    t -= 1\n    a = input().split()\n    n = int(a[0])\n    k = int(a[1])\n    a = input().split()\n    a = [int(x) for x in a]\n    li = []\n    ans = []\n    le = 0\n    for x in range(n):\n        li.append([])\n        ans.append(0)\n    for i in range(n):\n        va = li[a[i] - 1]\n        va.append(i)\n        if len(va) <= k:\n            le += 1\n    ki = k\n    le = le // k * k\n    for i in range(n):\n        va = li[i]\n        if len(va) >= k:\n            for ii in range(k):\n                ans[va[ii]] = ii + 1\n            li[i] = []\n            le -= k\n    rk = 1\n    for i in range(n):\n        va = li[i]\n        if len(va) > 0:\n            for xx in va:\n                if le > 0:\n                    ans[xx] = rk\n                    rk = rk % k + 1\n                    le -= 1\n    ans = [str(x) for x in ans]\n    ans = ' '.join(ans)\n    print(ans)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = [[] for _ in r]\n    i = 0\n    for x in R():\n        a[x - 1] += (i,)\n        i += 1\n    for j in (a := [i for x in a for i in x[:k]])[len(a) % k:]:\n        i = i % k + 1\n        r[j] = i\n    print(*r)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = []\n    p = 0\n    for (x, i) in sorted(zip(R(), range(n))):\n        n *= x == p\n        a += [i][:n < k]\n        p = x\n        n += 1\n    for i in a[len(a) % k:]:\n        n = n % k + 1\n        r[i] = n\n    print(*r)", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split(' '))\n    nums = list(map(int, input().split(' ')))\n    d = defaultdict(list)\n    for i in range(n):\n        if len(d[nums[i]]) < k:\n            d[nums[i]].append(i)\n    count = 0\n    for (key, v) in d.items():\n        count += len(v)\n    count = count - count % k\n    color = 0\n    ans = [0 for i in range(n)]\n    for key in sorted(d.keys()):\n        for x in d[key]:\n            color += 1\n            ans[x] = color\n            color %= k\n            count -= 1\n            if count == 0:\n                break\n        if count == 0:\n            break\n    print(' '.join((str(x) for x in ans)))", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    idx = [[] for i in range(n + 1)]\n    col = [0 for i in range(n)]\n    for i in range(n):\n        idx[arr[i]].append(i)\n    less_k_idx = []\n    for id in idx:\n        if len(id) >= k:\n            for i in range(k):\n                col[id[i]] = i + 1\n        elif len(id) > 0:\n            less_k_idx += id\n    z = len(less_k_idx) // k * k\n    for i in range(z):\n        col[less_k_idx[i]] = i % k + 1\n    print(*col)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = []\n    p = 0\n    for (x, i) in sorted(zip(R(), range(n))):\n        n *= x == p\n        a += [i][:n < k]\n        p = x\n        n += 1\n    for i in a[len(a) % k:]:\n        n = n % k + 1\n        r[i] = n\n    print(*r)", "R = lambda : map(int, input().split())\np = print\nt = 1\n(t,) = R()\nalpali = list(map(chr, range(97, 123)))\n\ndef solve():\n    (n, k) = R()\n    li = list(enumerate(list(R())))\n    li.sort(key=lambda x: x[1])\n    di = {}\n    lia = [0] * len(li)\n    cnt = 1\n    for i in range(len(li)):\n        if di.get(li[i][1], 0) < k:\n            lia[li[i][0]] = cnt\n            di[li[i][1]] = di.get(li[i][1], 0) + 1\n            cnt += 1\n            if cnt == k + 1:\n                cnt = 1\n        if i == len(li) - 1:\n            j = i\n            while j >= 0 and lia[li[j][0]] != k:\n                lia[li[j][0]] = 0\n                j -= 1\n    for a in lia:\n        p(a, end=' ')\n    p()\nwhile t:\n    t -= 1\n    solve()", "from collections import defaultdict\nT = int(input())\nfor t in range(T):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    count = defaultdict(int)\n    for element in a:\n        count[element] += 1\n    index_a = []\n    for (index, element) in enumerate(a):\n        index_a.append([count[element], element, index])\n    index_a.sort(reverse=True)\n    colors = [0 for i in range(n)]\n    i = 0\n    while i < n:\n        (c, _, index) = index_a[i]\n        if c > k:\n            for i_tmp in range(i, i + k):\n                (c_tmp, _, index_tmp) = index_a[i_tmp]\n                colors[index_tmp] = i_tmp - i + 1\n            for i_tmp in range(k, c):\n                (c_tmp, _, index_tmp) = index_a[i_tmp]\n                colors[index_tmp] = 0\n            i += c\n            continue\n        for i_tmp in range(i, i + (n - i) // k * k):\n            (c_tmp, _, index_tmp) = index_a[i_tmp]\n            colors[index_tmp] = (i - i_tmp) % k + 1\n        for i_tmp in range(i + (n - i) // k * k, n):\n            (c_tmp, _, index_tmp) = index_a[i_tmp]\n            colors[index_tmp] = 0\n        break\n    print(' '.join(map(str, colors)))", "t = int(input())\nfor i in range(t):\n    (length, colors_num) = map(int, input().split())\n    numbers = list(map(int, input().split()))\n    numbers_dict = {}\n    counter = 0\n    for number in numbers:\n        if number not in numbers_dict:\n            numbers_dict[number] = [counter]\n        else:\n            numbers_dict[number].append(counter)\n        counter += 1\n    stock = []\n    for number in numbers_dict:\n        if len(numbers_dict[number]) < colors_num:\n            stock += numbers_dict[number]\n        else:\n            stock += numbers_dict[number][:colors_num]\n    painting = [0] * length\n    stock = stock[:len(stock) - len(stock) % colors_num]\n    color = 0\n    for index in stock:\n        if color == colors_num:\n            color = 1\n        else:\n            color += 1\n        painting[index] = color\n    print(*painting)", "from collections import defaultdict\naa = int(input())\nwhile aa:\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    hs = defaultdict(list)\n    for (ind, num) in enumerate(lst):\n        hs[num].append(ind)\n    new = []\n    for i in hs:\n        if len(hs[i]) >= k:\n            new += hs[i][:k]\n        else:\n            new += hs[i]\n    res = [0] * n\n    col = 1\n    tot = len(new) - len(new) % k\n    for i in range(tot):\n        if col > k:\n            col = 1\n        res[new[i]] = col\n        col += 1\n    aa -= 1\n    print(*res)", "import collections\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    c = {}\n    for (j, i) in enumerate(l):\n        if i in c:\n            if len(c[i]) < k:\n                c[i].append(j)\n        else:\n            c[i] = [j]\n    d = 0\n    res = [0] * n\n    for i in c:\n        d += len(c[i])\n    (op, d) = (0, d - d % k)\n    for i in c:\n        for j in c[i]:\n            if op >= d:\n                break\n            res[j] = op % k + 1\n            op += 1\n    print(*res)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = []\n    j = p = 0\n    for (x, i) in sorted(zip(R(), range(n))):\n        j *= x == p\n        a += [i][:j < k]\n        p = x\n        j += 1\n    for i in a[len(a) % k:]:\n        j = j % k + 1\n        r[i] = j\n    print(*r)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    r = [0] * n\n    a = []\n    p = 0\n    for (x, i) in sorted(zip(R(), range(n))):\n        n *= x == p\n        a += [i][:n < k]\n        p = x\n        n += 1\n    for i in a[len(a) % k:]:\n        n = n % k + 1\n        r[i] = n\n    print(*r)", "def find_colors(arr, k):\n    answer = [0 for i in range(arr.__len__())]\n    ocr = dict()\n    for i in range(arr.__len__()):\n        if arr[i] in ocr:\n            ocr[arr[i]].append(i)\n        else:\n            ocr[arr[i]] = [i]\n    ocrk = dict()\n    ocr_ = dict()\n    s = 0\n    for i in ocr:\n        if ocr[i].__len__() >= k:\n            ocrk[i] = ocr[i]\n        else:\n            ocr_[i] = ocr[i]\n            s += ocr_[i].__len__()\n    for i in ocrk:\n        paint = k\n        for j in range(k, 0, -1):\n            index = ocrk[i][k - j]\n            answer[index] = j\n    index_arr = []\n    for i in ocr_:\n        index_arr += ocr_[i]\n    for i in range(s - s % k):\n        index = index_arr[i]\n        answer[index] = k - i % k\n    return answer\n\ndef main():\n    answers = []\n    n = int(input())\n    for i in range(n):\n        (l, k) = map(int, input().split())\n        arr = input().split()\n        answers.append(find_colors(arr, k))\n    for i in answers:\n        print(*i)\nmain()", "def wonderfulColoring(n, colors, array):\n    d = {}\n    ans = {}\n    for x in array:\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n        ans[x] = []\n    for x in d:\n        if d[x] > colors:\n            d[x] = colors\n    s = 0\n    for x in d:\n        s += d[x]\n    r = s % colors\n    for x in d:\n        if d[x] > r:\n            d[x] -= r\n            r = 0\n            break\n        else:\n            r -= d[x]\n            d[x] = 0\n            if r == 0:\n                break\n    c = 1\n    for x in d:\n        i = 0\n        while i < d[x]:\n            i += 1\n            ans[x].append(c)\n            c += 1\n            c = c % k\n            if c == 0:\n                c = colors\n    res = []\n    for x in range(n):\n        if not ans[array[x]]:\n            res.append(0)\n        else:\n            p = ans[array[x]].pop()\n            res.append(p)\n    return res\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    ans = wonderfulColoring(n, k, l)\n    for x in ans:\n        print(x, end=' ')\n    print()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    d = {}\n    r = [0] * n\n    i = j = 0\n    for x in R():\n        l = d.setdefault(x, [])\n        l += ([], [i])[len(l) < k]\n        i += 1\n    for i in (a := [i for x in d for i in d[x]])[:len(a) // k * k]:\n        j = j % k + 1\n        r[i] = j\n    print(*r)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = {}\n    all = [0] * n\n    temp = []\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]] += 1\n        else:\n            d[a[i]] = 1\n        if d[a[i]] <= k:\n            temp.append((a[i], i))\n    for i in range(len(temp) % k):\n        temp.pop()\n    temp.sort()\n    idx = 1\n    for i in temp:\n        all[i[1]] = idx\n        idx += 1\n        if idx == k + 1:\n            idx = 1\n    for i in all:\n        print(i, end=' ')\n    print('')", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    d = {}\n    r = [0] * n\n    i = 0\n    for x in R():\n        l = d.setdefault(x, [])\n        l += (i,)\n        i += 1\n    for j in (a := [i for x in d for i in d[x][:k]])[:len(a) // k * k]:\n        i = i % k + 1\n        r[j] = i\n    print(*r)", "def cf_734B(numbers: list, k: int):\n    counts = {}\n    answer = [0] * len(numbers)\n    for (index, num) in enumerate(numbers):\n        if num in counts:\n            counts[num][0] += 1\n            counts[num][1].append(index)\n        else:\n            counts[num] = [1, [index]]\n    extras = []\n    for (count, indices) in counts.values():\n        if count >= k:\n            for i in range(k):\n                answer[indices[i]] = i + 1\n        else:\n            for i in indices:\n                extras.append(i)\n    while len(extras) >= k:\n        for i in range(k):\n            answer[extras.pop()] = i + 1\n    return answer\nfor _ in range(int(input())):\n    (_, k) = map(int, input().split())\n    print(*cf_734B(list(map(int, input().split())), k))", "T = int(input())\nfrom collections import defaultdict\nfor _ in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    ans = [0] * N\n    dic = defaultdict(lambda : [])\n    for (i, a) in enumerate(A):\n        dic[a].append(i)\n    stack = []\n    for v in dic.values():\n        if len(v) < K:\n            for i in v:\n                stack.append(i)\n        else:\n            for (j, i) in enumerate(v[:K]):\n                ans[i] = j + 1\n    while len(stack) % K:\n        stack.pop()\n    for (j, i) in enumerate(stack):\n        ans[i] = j % K + 1\n    print(*ans)", "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef S():\n    return input()\n\ndef I():\n    return int(S())\n\ndef M():\n    return map(int, S().split())\n\ndef L():\n    return list(M())\nt = int(input())\nfor p in range(t):\n    (n, k) = M()\n    l = L()\n    d = defaultdict(list)\n    ans = [0] * n\n    for i in range(n):\n        d[l[i]].append(i)\n    for i in d:\n        d[i] = d[i][:k]\n    z = 1\n    k_freq = [0] * (k + 1)\n    for i in d:\n        for j in d[i]:\n            ans[j] = z\n            k_freq[z] += 1\n            z += 1\n            if z > k:\n                z = 1\n    mini = min(k_freq[1:])\n    maxi = max(k_freq)\n    if mini == maxi:\n        print(*ans)\n    else:\n        for i in range(k + 1):\n            if k_freq[i] > mini:\n                diff = k_freq[i] - mini\n                j = 0\n                while j < n and diff > 0:\n                    if ans[j] == i:\n                        ans[j] = 0\n                        diff -= 1\n                    j += 1\n        print(*ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    cnt = [[] for i in range(n)]\n    num = 0\n    a = list(map(int, input().split()))\n    for i in range(len(a)):\n        if len(cnt[a[i] - 1]) < k:\n            cnt[a[i] - 1].append(i)\n            num += 1\n    group = num // k\n    group_end = k * group\n    colors = [0 for i in range(n)]\n    d = 0\n    n = 0\n    for i in cnt:\n        if n == group_end:\n            break\n        for j in i:\n            colors[j] = d + 1\n            d = (d + 1) % k\n            n += 1\n            if n == group_end:\n                break\n    print(*colors)", "MULTIPLE_CASE = True\n\ndef solve():\n    (n, k) = [int(i) for i in input().split(' ')]\n    data = [[] for _ in range(n)]\n    a = [int(i) - 1 for i in input().split(' ')]\n    colors = [0] * n\n    for pos in range(n):\n        data[a[pos]].append(pos)\n    not_enough = 0\n    for pos in data:\n        if len(pos) >= k:\n            for j in range(k):\n                colors[pos[j]] = j + 1\n        elif 0 < len(pos) < k:\n            not_enough += len(pos)\n    not_enough -= not_enough % k\n    for pos in data:\n        if 0 < len(pos) < k:\n            for i in pos:\n                if not_enough > 0:\n                    colors[i] = not_enough % k + 1\n                    not_enough -= 1\n                else:\n                    break\n    for i in colors:\n        print('{} '.format(i), end='')\n    print()\nT = 1\nif MULTIPLE_CASE:\n    T = int(input())\nwhile T > 0:\n    T -= 1\n    solve()", "t = int(input())\nfrom collections import Counter\n\ndef solve():\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    cnt = {elem: [0, []] for elem in lst}\n    for (i, elem) in enumerate(lst):\n        cnt[elem][0] += 1\n        cnt[elem][1].append(i)\n    less = []\n    col = 0\n    coloring = [0 for _ in range(n)]\n    color = 1\n    for (key, (occ, indices)) in cnt.items():\n        if occ >= k:\n            for (i, idx) in enumerate(indices[:k]):\n                coloring[idx] = i + 1\n        else:\n            less += indices\n    extra = len(less) % k\n    for (i, idx) in enumerate(less[extra:]):\n        coloring[idx] = i % k + 1\n    print(*coloring)\nfor _ in range(t):\n    solve()", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = list(input().split())\n    count = {}\n    ans = [0] * n\n    tempb = 0\n    for i in s:\n        if i not in count:\n            count[i] = 0\n        count[i] += 1\n    temp = {}\n    for (i, j) in count.items():\n        if j >= k:\n            temp[i] = 1\n        else:\n            tempb += j\n    cur = 0\n    for i in sorted([(j, i) for (i, j) in enumerate(s)]):\n        if i[0] in temp:\n            if temp[i[0]] <= k:\n                ans[i[1]] = temp[i[0]]\n                temp[i[0]] += 1\n        elif tempb // k * k > cur:\n            ans[i[1]] = cur % k + 1\n            cur += 1\n    print(*ans)", "from collections import defaultdict\nT = int(input())\nfor _ in range(T):\n    (n, k) = [int(i) for i in input().split()]\n    nums = [int(i) for i in input().split()]\n    x = defaultdict(set)\n    for (i, xx) in enumerate(nums):\n        if len(x[xx]) < k:\n            x[xx].add(i)\n    ans = [0] * n\n    for (i, v) in x.items():\n        if len(v) == k:\n            for (ii, j) in enumerate(v):\n                ans[j] = ii + 1\n    items = []\n    l = 0\n    for (_, xxx) in x.items():\n        for nnn in xxx:\n            ans[nnn] = l + 1\n            l += 1\n            items.append(nnn)\n            if l % k == 0:\n                l = 0\n                items = []\n    for i in items:\n        ans[i] = 0\n    print(' '.join((str(i) for i in ans)))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = [[] for z in range(n + 1)]\n    ans = [0 for z in range(n)]\n    for z in range(n):\n        d[a[z]].append(z)\n    c = 0\n    temp = []\n    for z in range(1, n + 1):\n        num = 1\n        for y in d[z]:\n            temp.append(y)\n            num += 1\n            c += 1\n            ans[y] = c\n            c = c % k\n            l = len(temp)\n            if k == l:\n                temp.clear()\n            if num > k:\n                break\n    l = len(temp)\n    for z in range(l):\n        ans[temp[z]] = 0\n    print(*ans)", "import typing\nfrom collections import Counter\n\ndef solve(n: int, k: int, a: typing.List[int]) -> typing.NoReturn:\n    c = Counter(a)\n    for x in a:\n        c[x] = min(c[x], k)\n    b = []\n    for i in range(n):\n        x = a[i]\n        if not c[x]:\n            continue\n        c[x] -= 1\n        b.append(i)\n    b.sort(key=lambda i: a[i])\n    b = b[:len(b) // k * k]\n    color = [0] * n\n    c = 1\n    for i in b:\n        color[i] = c\n        c = c % k + 1\n    print(*color)\n\ndef main() -> typing.NoReturn:\n    t = int(input())\n    for _ in range(t):\n        (n, k) = map(int, input().split())\n        (*a,) = map(int, input().split())\n        solve(n, k, a)\nmain()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, k) = R()\n    d = {}\n    r = [0] * n\n    i = j = 0\n    for x in R():\n        l = d.setdefault(x, [])\n        l += (i,)\n        i += 1\n    for i in (a := [i for x in d for i in d[x][:k]])[:len(a) // k * k]:\n        j = j % k + 1\n        r[i] = j\n    print(*r)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    index = {}\n    for i in range(n):\n        if arr[i] in index:\n            index[arr[i]].append(i)\n        else:\n            index[arr[i]] = [i]\n    brr = list(index.values())\n    (group, temp) = ([], [])\n    for i in range(len(brr)):\n        if len(brr[i]) < k:\n            temp += brr[i]\n            if len(temp) >= k:\n                group.append(temp[:k])\n                temp = temp[k:]\n        else:\n            group.append(brr[i])\n    ans = [0] * n\n    for num in group:\n        for i in range(k):\n            ans[num[i]] = i + 1\n    for num in ans:\n        print(num, end=' ')\n    print()", "from collections import defaultdict\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    f = defaultdict(int)\n    a = list(map(int, input().split()))\n    for nn in a:\n        f[nn] += 1\n        if f[nn] > k:\n            f[nn] = k\n    pl = {}\n    curr = 0\n    legal_sum = sum(f.values()) - sum(f.values()) % k\n    sum_ = 0\n    halfway = 0\n    bads = []\n    for (j, v) in f.items():\n        sum_ += v\n        pl[j] = curr\n        if sum_ > legal_sum:\n            if curr + v > k:\n                halfway = j\n            bads.append(j)\n        curr = (curr + v) % k\n    kk = {kk_: 0 for kk_ in f.keys()}\n    c = [0] * n\n    for j in range(n):\n        if a[j] not in bads:\n            if kk[a[j]] < k:\n                c[j] = (pl[a[j]] + kk[a[j]]) % k + 1\n                kk[a[j]] += 1\n        elif halfway == a[j]:\n            if pl[a[j]] + kk[a[j]] < k:\n                c[j] = (pl[a[j]] + kk[a[j]]) % k + 1\n                kk[a[j]] += 1\n    s = ''\n    for c_ in c:\n        s += '{} '.format(c_)\n    print(s[:-1])", "def Solve():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dic = {}\n    for i in a:\n        if dic.get(i) == None:\n            dic[i] = 1\n        else:\n            dic[i] += 1\n    lst = list(dic.values())\n    b = [0 for i in a]\n    dic2 = {}\n    s = 0\n    for i in range(len(a)):\n        if dic[a[i]] >= k:\n            if dic2.get(a[i]) == None:\n                b[i] = k\n                dic2[a[i]] = k - 1\n            else:\n                b[i] = dic2[a[i]]\n                if dic2[a[i]] > 0:\n                    dic2[a[i]] -= 1\n        else:\n            s += 1\n    dic3 = {}\n    for i in range(len(a)):\n        if dic[a[i]] < k:\n            if dic3.get(a[i]) == None:\n                dic3[a[i]] = [i]\n            else:\n                dic3[a[i]].append(i)\n    lst = list(dic3.values())\n    p = k\n    r = 1\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if r * k <= s:\n                b[lst[i][j]] = p\n                p -= 1\n                if p == 0:\n                    p = k\n                    r += 1\n            else:\n                b[lst[i][j]] = 0\n    for i in b:\n        print(i, end=' ')\n    print()\nq = int(input())\nwhile q > 0:\n    Solve()\n    q -= 1", "from sys import stdin\nfrom collections import defaultdict\ninput = stdin.readline\n\ndef func():\n    index_dic = defaultdict(list)\n    for (ind, val) in enumerate(s):\n        index_dic[val].append(ind)\n    ans = [0 for x in range(n)]\n    rem = set()\n    for val in index_dic:\n        if len(index_dic[val]) >= k:\n            for ind in range(k):\n                ans[index_dic[val][ind]] = ind + 1\n        else:\n            rem.add(val)\n    total = 0\n    for i in rem:\n        total += len(index_dic[i])\n    to_color = total - total % k\n    color = 1\n    done = 0\n    flag = True if to_color else False\n    for val in index_dic:\n        if val in rem:\n            if not flag:\n                break\n            for ind in range(len(index_dic[val])):\n                if flag:\n                    ans[index_dic[val][ind]] = color\n                    color += 1\n                    done += 1\n                if done >= to_color:\n                    flag = False\n                if color > k:\n                    color = 1\n    print(*ans)\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = list(map(int, input().split()))\n    func()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    arr = list(map(int, input().split(' ')))\n    dt = {}\n    temp = []\n    for x in range(n):\n        if arr[x] in dt:\n            dt[arr[x]] += 1\n        else:\n            dt[arr[x]] = 1\n        if dt[arr[x]] <= k:\n            temp.append([arr[x], x])\n    for x in range(len(temp) % k):\n        temp.pop()\n    temp.sort()\n    all = [0 for x in range(n)]\n    idx = 1\n    for x in temp:\n        all[x[1]] = idx\n        idx += 1\n        if idx == k + 1:\n            idx = 1\n    for x in all:\n        print(x, end=' ')\n    print()", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    final_ans = [0] * n\n    d = {}\n    for i in range(n):\n        if d.get(a[i]) is None:\n            d[a[i]] = [1, i]\n        else:\n            d[a[i]][0] += 1\n            d[a[i]].append(i)\n    h = []\n    for (key, v) in d.items():\n        if v[0] >= k:\n            for i in range(1, k + 1):\n                final_ans[v[i]] = i\n        else:\n            for i in range(1, v[0] + 1):\n                h.append(v[i])\n    count = 0\n    l = len(h) // k * k\n    for i in range(l):\n        final_ans[h[i]] = count % k + 1\n        count = count + 1\n    print(*final_ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    store = [0 for i in range(n + 1)]\n    stack = [[] for i in range(n + 1)]\n    counted = [0 for i in range(n + 1)]\n    for i in range(n):\n        if counted[arr[i]] < k:\n            counted[arr[i]] += 1\n            stack[arr[i]].append(i)\n    queue = []\n    for i in range(n + 1):\n        for j in stack[i]:\n            queue.append(j)\n    l = len(queue)\n    r = l // k * k\n    i = 0\n    ans = [0 for i in range(n)]\n    for i in range(0, r, k):\n        count = 0\n        for j in range(i, i + k):\n            ans[queue[j]] = count + 1\n            count += 1\n    print(*ans)", "import collections as cc\nimport bisect as bi\nimport heapq as hp\nimport math as mt\nimport itertools as it\nimport sys\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\nfor tc in range(int(input())):\n    (n, k) = I()\n    ar = I()\n    last = []\n    temp = cc.defaultdict(list)\n    ans = [0] * n\n    for i in range(n):\n        temp[ar[i]].append(i)\n\n    def chh(i, j):\n        if ar[i][j] == 1:\n            return 0\n        for (dx, dy) in dr:\n            newi = i + dx\n            newj = j + dy\n            if 0 <= newi < n and 0 <= newj < m and (ar[newi][newj] == 1):\n                return 0\n        return 1\n    for now in temp:\n        then = temp[now]\n        if len(then) >= k:\n            for i in range(k):\n                ans[then[i]] = i + 1\n        else:\n            last += then\n    cur = len(last) // k\n    i = 0\n\n    def ch(i):\n        ans = i * 4 // 3\n        if ans % 4 == 0:\n            ans -= 1\n        return ans\n    while i < cur * k:\n        for j in range(k):\n            ans[last[i]] = j + 1\n            i += 1\n    print(*ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    index = {}\n    for i in range(n):\n        if arr[i] in index:\n            index[arr[i]].append(i)\n        else:\n            index[arr[i]] = [i]\n    brr = list(index.values())\n    brr.sort(key=lambda x: len(x))\n    (group, temp) = ([], [])\n    for i in range(len(brr)):\n        if len(brr[i]) < k:\n            temp += brr[i]\n            if len(temp) >= k:\n                group.append(temp[:k])\n                temp = temp[k:]\n        else:\n            group.append(brr[i])\n    ans = [0] * n\n    for num in group:\n        for i in range(k):\n            ans[num[i]] = i + 1\n    for num in ans:\n        print(num, end=' ')\n    print()", "from sys import *\nfrom math import floor\ninput = lambda : stdin.readline()\nint_arr = lambda : list(map(int, stdin.readline().strip().split()))\nstr_arr = lambda : list(map(str, stdin.readline().split()))\nget_str = lambda : map(str, stdin.readline().strip().split())\nget_int = lambda : map(int, stdin.readline().strip().split())\nget_float = lambda : map(float, stdin.readline().strip().split())\nmod = 1000000007\nsetrecursionlimit(1000)\nfor _ in range(int(input())):\n    (n, k) = get_int()\n    arr = int_arr()\n    ans = [0] * n\n    dic = {}\n    for i in range(n):\n        if arr[i] in dic:\n            dic[arr[i]] += [i]\n        else:\n            dic[arr[i]] = [i]\n    rem = []\n    for val in dic.values():\n        if len(val) >= k:\n            for i in range(k):\n                ans[val[i]] = i + 1\n        else:\n            rem += val\n    extra = len(rem) // k * k\n    ind = 0\n    while ind < extra:\n        for i in range(k):\n            ans[rem[ind]] = i + 1\n            ind += 1\n    print(*ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        x = l[i]\n        if d.get(x, -1) == -1:\n            d[x] = [i]\n        elif len(d[x]) != k:\n            d[x].append(i)\n    c = 0\n    for i in d:\n        c += len(d[i])\n    c = c // k * k\n    res = [0] * n\n    j = 1\n    for index in d:\n        for i in d[index]:\n            res[i] = j\n            j += 1\n            c -= 1\n            if c == 0:\n                break\n            if j == k + 1:\n                j = 1\n        if c == 0:\n            break\n    print(*res)", "import sys\nfrom collections import defaultdict\n_DEBUG = False\nif _DEBUG:\n    fd = open('input.txt', 'r')\n    sys.stdin = fd\n\ndef process(color, s):\n    for l in indices.values():\n        for i in l:\n            color += 1\n            res[i] = color\n            color %= k\n            s -= 1\n            if s == 0:\n                return\nfor t in range(int(sys.stdin.readline())):\n    (n, k) = map(int, sys.stdin.readline().split())\n    arr = list(map(int, sys.stdin.readline().split()))\n    indices = defaultdict(list)\n    for i in range(n):\n        if len(indices[arr[i]]) < k:\n            indices[arr[i]].append(i)\n    s = 0\n    for l in indices.values():\n        s += len(l)\n    s -= s % k\n    res = [0] * n\n    color = 0\n    process(color, s)\n    print(*res)", "tt = int(input())\nfor _ in range(tt):\n    (n, k) = map(int, input().split())\n    m = {}\n    seq = list(map(int, input().split()))\n    for c in seq:\n        if c in m:\n            m[c] += 1\n        else:\n            m[c] = 1\n    p = 0\n    base = {}\n    shift = {}\n    for c in m:\n        if m[c] >= k:\n            base[c] = 0\n            shift[c] = 0\n        else:\n            shift[c] = 0\n            base[c] = p\n            p += m[c]\n    p_limit = p - p % k\n    for c in seq:\n        if shift[c] < k and (m[c] >= k or shift[c] + base[c] < p_limit):\n            print((shift[c] + base[c]) % k + 1, end=' ')\n            shift[c] += 1\n        else:\n            print(0, end=' ')\n    print()", "from collections import Counter, defaultdict\nimport sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    data = list(map(int, input().split()))\n    counter = Counter(data)\n    idx = defaultdict(list)\n    answer = [-1] * n\n    for i in range(n):\n        idx[data[i]].append(i)\n    li = list(counter.items())\n    li = sorted(li, reverse=True, key=lambda x: (x[1], x[0]))\n    temp_idx = 0\n    remain = 0\n    for key in counter.keys():\n        if counter[key] >= k:\n            pass\n        else:\n            remain += counter[key]\n    for (val, cnt) in li:\n        if cnt >= k:\n            for (cnt2, id) in enumerate(idx[val]):\n                if cnt2 < k:\n                    answer[id] = cnt2 + 1\n                else:\n                    answer[id] = 0\n        else:\n            for (cnt2, id) in enumerate(idx[val]):\n                if temp_idx >= remain - remain % k:\n                    answer[id] = 0\n                else:\n                    answer[id] = temp_idx % k + 1\n                temp_idx += 1\n    print(' '.join(map(str, answer)))", "import typing\nfrom collections import Counter\n\ndef solve(n: int, k: int, a: typing.List[int]) -> typing.NoReturn:\n    c = Counter(a)\n    for x in a:\n        c[x] = min(c[x], k)\n    b = []\n    for i in range(n):\n        x = a[i]\n        if not c[x]:\n            continue\n        c[x] -= 1\n        b.append(i)\n    b.sort(key=lambda i: -a[i])\n    b = b[:len(b) // k * k]\n    color = [0] * n\n    c = 1\n    for i in b:\n        color[i] = c\n        c = c % k + 1\n    print(*color)\n\ndef main() -> typing.NoReturn:\n    t = int(input())\n    for _ in range(t):\n        (n, k) = map(int, input().split())\n        (*a,) = map(int, input().split())\n        solve(n, k, a)\nmain()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    arr = list(map(int, input().split(' ')))\n    dt = {}\n    temp = []\n    for x in range(n):\n        if arr[x] in dt:\n            dt[arr[x]] += 1\n        else:\n            dt[arr[x]] = 1\n        if dt[arr[x]] <= k:\n            temp.append([arr[x], x])\n    for x in range(len(temp) % k):\n        temp.pop()\n    temp.sort()\n    all = [0 for x in range(n)]\n    idx = 1\n    for x in temp:\n        all[x[1]] = idx\n        idx += 1\n        if idx == k + 1:\n            idx = 1\n    for x in all:\n        print(x, end=' ')\n    print()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    arr = list(map(int, input().split(' ')))\n    dt = {}\n    temp = []\n    for x in range(n):\n        if arr[x] in dt:\n            dt[arr[x]] += 1\n        else:\n            dt[arr[x]] = 1\n        if dt[arr[x]] <= k:\n            temp.append([arr[x], x])\n    for x in range(len(temp) % k):\n        temp.pop()\n    temp.sort()\n    all = [0 for x in range(n)]\n    idx = 1\n    for x in temp:\n        all[x[1]] = idx\n        idx += 1\n        if idx == k + 1:\n            idx = 1\n    for x in all:\n        print(x, end=' ')\n    print()", "def magika(nums, cores):\n    dic = {}\n    temp = []\n    for i in range(len(nums)):\n        if nums[i] in dic:\n            dic[nums[i]].append(i)\n        else:\n            dic[nums[i]] = [i]\n    ans = [0] * len(nums)\n    for k in dic.keys():\n        if len(dic[k]) >= cores:\n            for j in range(cores):\n                ans[dic[k][j]] = j + 1\n        elif len(dic[k]) >= 1:\n            for x in range(len(dic[k])):\n                temp.append(dic[k][x])\n    count = len(temp) // cores\n    p = 1\n    maxi = 0\n    for y in range(len(temp)):\n        if maxi == count:\n            break\n        ans[temp[y]] = p\n        if p == cores:\n            maxi += 1\n        p += 1\n        if p == cores + 1:\n            p = 1\n    return ans\nn = int(input())\nr = [0] * n\nfor i in range(n):\n    (elementos, cores) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    r[i] = magika(nums, cores)\nfor c in r:\n    for j in range(len(c)):\n        if j == len(c) - 1:\n            print(c[j])\n        else:\n            print(c[j], end=' ')", "from collections import *\nfrom math import *\nTT = int(input())\nfor y in range(TT):\n    (n, m) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    d1 = defaultdict(int)\n    d2 = defaultdict(list)\n    ans = [0] * n\n    for i in range(n):\n        d1[lst[i]] += 1\n        d2[lst[i]].append(i)\n    cur = []\n    cl = 0\n    for i in d1:\n        if d1[i] >= m:\n            for j in range(m):\n                ans[d2[i][j]] = j + 1\n        else:\n            for j in d2[i]:\n                cur.append(j)\n                cl += 1\n                if cl == m:\n                    for lp in range(m):\n                        ans[cur[lp]] = lp + 1\n                    cur = []\n                    cl = 0\n    print(*ans)", "from sys import stdin\n\ndef sortt(aa):\n    return arr[aa]\nfor _ in range(int(stdin.readline())):\n    (n, k) = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n    d = [[] for i in range(n + 1)]\n    ans = [0 for i in range(n)]\n    el = []\n    s = 0\n    j = 0\n    for i in arr:\n        if len(d[i]) < k:\n            d[i].append(j)\n            el.append(j)\n            s += 1\n        j += 1\n    a = s // k\n    t = a * k\n    el.sort(key=sortt)\n    cl = 1\n    for i in range(t):\n        ans[el[i]] = cl\n        cl += 1\n        if cl == k + 1:\n            cl = 1\n    print(*ans)", "import sys\ninput = lambda : sys.stdin.readline()\nint_arr = lambda : list(map(int, input().split()))\nstr_arr = lambda : list(map(str, input().split()))\nget_str = lambda : map(str, input().split())\nget_int = lambda : map(int, input().split())\nget_flo = lambda : map(float, input().split())\nmod = 1000000007\n\ndef solve(n, k, a):\n    ans = [0] * n\n    d = {}\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = []\n        d[a[i]].append(i)\n    tmp = []\n    for c in d.keys():\n        for i in range(min(len(d[c]), k)):\n            tmp.append(d[c][i])\n            if len(tmp) == k:\n                for j in range(k):\n                    ans[tmp[j]] = j + 1\n                tmp = []\n    print(*ans)\nfor _ in range(int(input())):\n    (n, k) = get_int()\n    arr = int_arr()\n    solve(n, k, arr)", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = {}\n    ans = [0] * n\n    ex = []\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = []\n            d[a[i]].append(i)\n    for i in d:\n        if len(d[i]) >= k:\n            for x in range(1, k + 1):\n                ans[d[i][x - 1]] = x\n        else:\n            ex += d[i]\n        if len(ex) >= k:\n            for x in range(1, k + 1):\n                ans[ex[x - 1]] = x\n            ex = ex[k:]\n    for i in ans:\n        print(i, end=' ')\n    print()\n    t -= 1"]