["from pickletools import read_uint1\n\ndef GetRightInds(n, m, s, t):\n    r_inds = list()\n    cur_ind = n - 1\n    for q_ind in range(m - 1, 0, -1):\n        while s[cur_ind] != t[q_ind]:\n            cur_ind -= 1\n        r_inds.append(cur_ind)\n        cur_ind -= 1\n    return r_inds\n\ndef Sol(n, m, s, t):\n    r_inds = GetRightInds(n, m, s, t)\n    r1 = 0\n    max_w = 0\n    for i in range(m - 1):\n        while s[r1] != t[i]:\n            r1 += 1\n        l2 = r_inds[-1]\n        r_inds.pop()\n        max_w = max(max_w, l2 - r1)\n        r1 += 1\n    return max_w\n(n, m) = map(int, input().split())\ns = input().strip()\nt = input().strip()\nmax_w = Sol(n, m, s, t)\nprint(max_w)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m) = map(int, input().split())\n    s = input().strip()\n    t = input().strip()\n    leftmost = [0] * m\n    rightmost = [0] * m\n    curr = 0\n    for i in range(n):\n        if s[i] == t[curr]:\n            leftmost[curr] = i\n            curr += 1\n            if curr == m:\n                break\n    curr = m - 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == t[curr]:\n            rightmost[curr] = i\n            curr -= 1\n            if curr < 0:\n                break\n    ans = 0\n    for j in range(m - 1):\n        ans = max(ans, rightmost[j + 1] - leftmost[j])\n    return ans\nprint(solve())", "input()\ns = input()\nt = input()\nn = len(s)\nm = len(t)\nls = []\ni = 0\nfor c in t:\n    while s[i] != c:\n        i += 1\n    ls.append(i)\n    i += 1\nrs = []\ni = n - 1\nfor c in t[::-1]:\n    while s[i] != c:\n        i -= 1\n    rs.append(i)\n    i -= 1\nrs = rs[::-1]\nprint(max((rs[i] - ls[i - 1] for i in range(1, m))))", "def solution():\n    (n, m) = map(int, input().split())\n    (s, t) = (input(), input())\n    ans = 0\n    (left, right) = ([-1] * m, [-1] * m)\n    index = 0\n    for i in range(m):\n        while s[index] != t[i]:\n            index += 1\n        left[i] = index\n        index += 1\n    index = n - 1\n    for j in range(m - 1, -1, -1):\n        while s[index] != t[j]:\n            index -= 1\n        right[j] = index\n        index -= 1\n    for a in range(m - 1):\n        ans = max(ans, right[a + 1] - left[a])\n    print(ans)\nsolution()", "def find():\n    (n, m) = map(int, input().split())\n    s = input()\n    t = input()\n    ind = 0\n    left = []\n    right = [0] * m\n    for j in range(m):\n        while s[ind] != t[j]:\n            ind += 1\n        left.append(ind)\n        ind += 1\n    ind = n - 1\n    for j in range(m - 1, -1, -1):\n        while s[ind] != t[j]:\n            ind -= 1\n        right[j] = ind\n        ind -= 1\n    ans = 1\n    for j in range(m - 1):\n        ans = max(ans, right[j + 1] - left[j])\n    print(ans)\nfind()", "from functools import lru_cache\nfrom collections import defaultdict\n\ndef solution():\n    (n, m) = map(int, input().split())\n    s = input()\n    t = input()\n    leftMost = [None] * len(t)\n    j = 0\n    for i in range(len(s)):\n        if j < len(t) and s[i] == t[j]:\n            leftMost[j] = i\n            j += 1\n    rightMost = [None] * len(t)\n    j = len(t) - 1\n    for i in range(len(s))[::-1]:\n        if j >= 0 and s[i] == t[j]:\n            rightMost[j] = i\n            j -= 1\n    mx = 0\n    for i in range(1, len(leftMost)):\n        ans = rightMost[i] - leftMost[i - 1]\n        mx = max(mx, ans)\n    print(mx)\nsolution()", "def int_fn():\n    return int(input())\n\ndef str_fn():\n    return input()\n\ndef int_list_fn():\n    return [int(val) for val in input().split(' ')]\n\ndef solve(source: str, n: int, target: str, m: int):\n    (min_list, max_list) = ([-1] * m, [-1] * m)\n    i = 0\n    for (idx, ch) in enumerate(source):\n        if target[i] == ch:\n            min_list[i] = idx\n            i += 1\n        if i == m:\n            break\n    i = m - 1\n    for last_idx in range(n - 1, -1, -1):\n        ch = source[last_idx]\n        if ch == target[i]:\n            max_list[i] = last_idx\n            i -= 1\n        if i < 0:\n            break\n    max_diff = 1\n    for idx in range(1, m):\n        max_diff = max(max_diff, max_list[idx] - min_list[idx - 1])\n    print(max_diff)\n    return\n(n, m) = int_list_fn()\nsource = str_fn()\ntarget = str_fn()\nsolve(source, n, target, m)\npass", "from collections import Counter, defaultdict, deque\nimport math\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    (a, b) = [int(x) for x in input().split()]\n    s1 = input().strip()\n    s2 = input().strip()\n    mn = []\n    p = 0\n    for i in range(a):\n        if s1[i] == s2[p]:\n            p += 1\n            mn.append(i)\n        if p == b:\n            break\n    p = b - 1\n    mx = []\n    for i in range(a - 1, -1, -1):\n        if s1[i] == s2[p]:\n            p -= 1\n            mx.append(i)\n        if p == -1:\n            break\n    mx = mx[::-1]\n    rec = 0\n    for i in range(1, b):\n        rec = max(mx[i] - mn[i - 1], rec)\n    print(rec)\ntt = 1\nfor test in range(tt):\n    solve()", "from collections import deque, Counter\nfrom math import sqrt, ceil, factorial\nfrom sys import stdin, stdout\nimport sys\nsys.setrecursionlimit(10 ** 7)\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef inp():\n    return int(input())\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readfl():\n    return list(map(float, input().strip().split()))\n\ndef st():\n    return input().strip()\n\ndef solve():\n    (n, m) = read()\n    s = input()\n    t = input()\n    c = 0\n    fir = [0 for x in range(m)]\n    sec = [0 for x in range(m)]\n    for i in range(m):\n        while s[c] != t[i]:\n            c += 1\n        fir[i] = c\n        c += 1\n    c = n - 1\n    for i in range(m - 1, -1, -1):\n        while s[c] != t[i]:\n            c -= 1\n        sec[i] = c\n        c -= 1\n    val = -1\n    for i in range(m - 1):\n        val = max(val, sec[i + 1] - fir[i])\n    ans_.append(val)\nsolve()\nfor i in ans_:\n    print(i)", "def find_good_chain(s, t):\n    x = 0\n    y = 0\n    ind = []\n    while x < len(t):\n        while s[y] != t[x]:\n            y = y + 1\n        ind.append(y)\n        x = x + 1\n        y = y + 1\n    return ind\n\ndef find_reversed_chain(s, t):\n    x = len(t) - 1\n    y = len(s) - 1\n    ind = []\n    while x >= 0:\n        while s[y] != t[x]:\n            y = y - 1\n        ind.append(y)\n        x = x - 1\n        y = y - 1\n    return list(reversed(ind))\n\ndef get_max(ind1, ind2):\n    curr_max = 0\n    for i in range(1, len(ind1)):\n        if ind2[i] - ind1[i - 1] > curr_max:\n            curr_max = ind2[i] - ind1[i - 1]\n    return curr_max\nfrom sys import stdin as f\n(m, n) = [int(i) for i in f.readline().strip().split()]\ns = f.readline().strip()\nt = f.readline().strip()\nind1 = find_good_chain(s, t)\nind2 = find_reversed_chain(s, t)\ncurr_max = get_max(ind1, ind2)\nprint(curr_max)", "def other(n, m, s, t):\n    d = [0] * m\n    i = 0\n    j = 0\n    while j < m:\n        if s[i] == t[j]:\n            d[j] = i\n            j += 1\n        i += 1\n    e = [0] * m\n    i = n - 1\n    j = m - 1\n    while j >= 0:\n        if s[i] == t[j]:\n            e[j] = i\n            j -= 1\n        i -= 1\n    mm = 0\n    for i in range(m - 1):\n        if e[i + 1] - d[i] > mm:\n            mm = e[i + 1] - d[i]\n    return mm\n(n, m) = map(int, input().split())\ns = list(str(input()))\nt = list(str(input()))\nprint(other(n, m, s, t))", "import bisect\nimport collections\nimport functools\nimport itertools\nimport math\nimport heapq\nimport random\nimport string\n\ndef repeat(_func=None, *, times=1):\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                func(*args, **kwargs)\n        return wrapper\n    if _func is None:\n        return decorator\n    else:\n        return decorator(_func)\n\ndef unpack(func=int):\n    return map(func, input().split())\n\ndef l_unpack(func=int):\n    return list(map(func, input().split()))\n\ndef getint():\n    return int(input())\n\ndef getmatrix(rows):\n    return [list(map(int, input().split())) for _ in range(rows)]\n\ndef display_matrix(mat):\n    for i in range(len(mat)):\n        print(mat[i])\n\ndef main():\n    (n, m) = unpack()\n    s = input()\n    t = input()\n    left = [0] * m\n    right = [0] * m\n    pos = 0\n    for (i, c) in enumerate(t):\n        while s[pos] != c:\n            pos += 1\n        left[i] = pos\n        pos += 1\n    pos = n - 1\n    for i in range(m - 1, -1, -1):\n        while s[pos] != t[i]:\n            pos -= 1\n        right[i] = pos\n        pos -= 1\n    ans = 1\n    for i in range(m - 1):\n        ans = max(ans, right[i + 1] - left[i])\n    print(ans)\nMOD = 10 ** 9 + 7\nmain()", "def width(a, b):\n    m = len(b)\n    idx = 0\n    l = [0] * (2 * 10 ** 5 + 5)\n    r = [0] * (2 * 10 ** 5 + 5)\n    for i in range(len(a)):\n        if a[i] == b[idx]:\n            l[idx] = i\n            idx += 1\n            if idx == m:\n                break\n    idx = m - 1\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == b[idx]:\n            r[idx] = i\n            idx -= 1\n            if idx < 0:\n                break\n    ans = 0\n    for i in range(len(b) - 1):\n        ans = max(ans, r[i + 1] - l[i])\n    return ans\nn = input()\na = input()\nb = input()\nprint(width(a, b))", "def answer():\n    (l, r) = ([0] * (n + 1), [0] * (n + 1))\n    ind = 0\n    for i in range(n):\n        if s1[i] == s2[ind]:\n            l[ind] = i\n            ind += 1\n            if ind == m:\n                break\n    ind = m - 1\n    for i in range(n - 1, -1, -1):\n        if s1[i] == s2[ind]:\n            r[ind] = i\n            ind -= 1\n            if ind < 0:\n                break\n    ans = 0\n    for i in range(n):\n        ans = max(ans, r[i + 1] - l[i])\n    return ans\n(n, m) = map(int, input().split())\ns1 = input()\ns2 = input()\nprint(answer())", "def answer():\n    (l, r) = ([0] * (n + 1), [0] * (n + 1))\n    ind = 0\n    for i in range(n):\n        if s1[i] == s2[ind]:\n            l[ind] = i\n            ind += 1\n            if ind == m:\n                break\n    ind = m - 1\n    for i in range(n - 1, -1, -1):\n        if s1[i] == s2[ind]:\n            r[ind] = i\n            ind -= 1\n            if ind < 0:\n                break\n    ans = 0\n    for i in range(n):\n        ans = max(ans, r[i + 1] - l[i])\n    return ans\n(n, m) = map(int, input().split())\ns1 = input()\ns2 = input()\nprint(answer())", "(N, M) = map(int, input().split())\nS = input()\nT = input()\nA = []\nB = []\nsi = 0\nfor t in T:\n    while S[si] != t:\n        si += 1\n    A.append(si)\n    si += 1\nsi = N - 1\nfor t in T[::-1]:\n    while S[si] != t:\n        si -= 1\n    B.append(si)\n    si -= 1\nB.reverse()\nans = 0\nfor (a, b) in zip(A, B[1:]):\n    ans = max(ans, b - a)\nprint(ans)", "class Solution:\n\n    def solution(self, str1, str2):\n        (n, m) = (len(str1), len(str2))\n        first_position = [0] * m\n        last_position = [0] * m\n        i = 0\n        for j in range(m):\n            while i < n and str1[i] != str2[j]:\n                i += 1\n            if i >= n:\n                break\n            first_position[j] = i\n            i += 1\n        i = n - 1\n        for j in range(m - 1, -1, -1):\n            while i > -1 and str1[i] != str2[j]:\n                i -= 1\n            if i < 0:\n                break\n            last_position[j] = i\n            i -= 1\n        result = 1\n        for i in range(m - 1):\n            result = max(result, last_position[i + 1] - first_position[i])\n        return result\n(n, m) = map(int, input().split())\nstr1 = input()\nstr2 = input()\nsol = Solution()\nprint(sol.solution(str1, str2))", "def solve():\n    (n, m) = list(map(int, input().split()))\n    s = list(input())\n    t = list(input())\n    (e, l) = ([0] * m, [0] * m)\n    (j, i) = (0, 0)\n    while j < m:\n        if t[j] == s[i]:\n            e[j] = i\n            j += 1\n        i += 1\n    (j, i) = (m - 1, n - 1)\n    while j >= 0:\n        if t[j] == s[i]:\n            l[j] = i\n            j -= 1\n        i -= 1\n    best = 0\n    for i in range(m - 1):\n        best = max(l[i + 1] - e[i], best)\n    return best\nprint(solve())", "(_, s, t) = open(0)\nr = i = j = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\nfor x in t[-2:0:-1]:\n    j = s.rfind(x, 0, j)\n    r = max(r, j - a.pop())\nprint(r)", "def findmax(s, t):\n    l_indexies = []\n    start = 0\n    for c in t:\n        idx = s.find(c, start)\n        l_indexies.append(idx)\n        start = idx + 1\n    r_indexies = []\n    end = len(s)\n    for c in reversed(t):\n        idx = s.rfind(c, 0, end)\n        r_indexies.append(idx)\n        end = idx\n    r_indexies = r_indexies[::-1]\n    diff1 = (r - l for (l, r) in zip(l_indexies[:-1], l_indexies[1:]))\n    diff2 = (r - l for (l, r) in zip(l_indexies[:-1], r_indexies[1:]))\n    maxwidth = max(*diff1, *diff2)\n    return maxwidth\n(n, m) = list(map(int, input().split(' ')))\ns = input()\nt = input()\nstart = s.find(t[0])\nend = s.rfind(t[-1])\ns = s[start:end + 1]\nprint(findmax(s, t))", "def findmax(s, t):\n    l_indexies = []\n    start = 0\n    for c in t:\n        idx = s.find(c, start)\n        l_indexies.append(idx)\n        start = idx + 1\n    r_indexies = []\n    end = len(s)\n    for c in reversed(t):\n        idx = s.rfind(c, 0, end)\n        r_indexies.append(idx)\n        end = idx\n    r_indexies = r_indexies[::-1]\n    diff1 = (r - l for (l, r) in zip(l_indexies[:-1], l_indexies[1:]))\n    diff2 = (r - l for (l, r) in zip(l_indexies[:-1], r_indexies[1:]))\n    maxwidth = max(*diff1, *diff2)\n    return maxwidth\n(n, m) = list(map(int, input().split(' ')))\ns = input()\nt = input()\nprint(findmax(s, t))", "def process(s, t):\n    n = len(s)\n    m = len(t)\n    first = []\n    j1 = 0\n    for i in range(n):\n        if s[i] == t[j1]:\n            j1 += 1\n            first.append(i)\n        if j1 == m:\n            break\n    last = []\n    j1 = m - 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == t[j1]:\n            j1 -= 1\n            last.append(i)\n        if j1 == -1:\n            break\n    answer = 0\n    for i in range(m - 1):\n        a1 = first[i]\n        a2 = last[m - (i + 1) - 1]\n        answer = max(answer, a2 - a1)\n    return answer\n(n, m) = [int(x) for x in input().split()]\ns = input()\nt = input()\nprint(process(s, t))", "def sol(s, t):\n    n = len(s)\n    m = len(t)\n    first = []\n    j1 = 0\n    for i in range(n):\n        if s[i] == t[j1]:\n            j1 += 1\n            first.append(i)\n        if j1 == m:\n            break\n    last = []\n    j1 = m - 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == t[j1]:\n            j1 -= 1\n            last.append(i)\n        if j1 == -1:\n            break\n    answer = 0\n    for i in range(m - 1):\n        a1 = first[i]\n        a2 = last[m - (i + 1) - 1]\n        answer = max(answer, a2 - a1)\n    return answer\n(n, m) = map(int, input().split())\ns = input()\nt = input()\nprint(sol(s, t))", "def main():\n    (n, m) = map(int, input().split())\n    s = input()\n    t = input()\n    a = ['' for i in range(m)]\n    b = ['' for i in range(m)]\n    i = 0\n    j = 0\n    while i < m:\n        while t[i] != s[j]:\n            j += 1\n        a[i] = j\n        i += 1\n        j += 1\n    t = t[::-1]\n    s = s[::-1]\n    j = 0\n    i = 0\n    while i < m:\n        while t[i] != s[j]:\n            j += 1\n        b[i] = n - 1 - j\n        i += 1\n        j += 1\n    b = b[::-1]\n    print(max((b[i + 1] - a[i] for i in range(m - 1))))\nmain()", "from collections import deque\nfrom typing import List\n\nclass ContestParser:\n\n    def __init__(self):\n        self.buffer = deque()\n\n    def next_token(self) -> str:\n        if len(self.buffer) == 0:\n            self.buffer.extend(input().split())\n        return self.buffer.popleft()\n\n    def next_int(self) -> int:\n        return int(self.next_token())\n\ndef find_greedily(haystack: str, needle: str) -> List[int]:\n    result = []\n    index = 0\n    for c in needle:\n        while haystack[index] != c:\n            index += 1\n        result.append(index)\n        index += 1\n    return result\n\ndef solve(s: str, t: str) -> int:\n    n = len(s)\n    m = len(t)\n    first_indexes: List[int] = find_greedily(s, t)\n    last_indexes: List[int] = list(reversed([n - idx - 1 for idx in find_greedily(list(reversed(s)), list(reversed(t)))]))\n    result: int = 0\n    for (idx, first_pos) in enumerate(first_indexes[:-1]):\n        last_pos = last_indexes[idx + 1]\n        result = max(result, last_pos - first_pos)\n    return result\nparser = ContestParser()\nn = parser.next_int()\nm = parser.next_int()\ns = parser.next_token()\nt = parser.next_token()\nprint(solve(s, t))", "(n, m) = map(int, input().split())\ns = input()\nt = input()\ni = 0\nls = []\nfor c in t:\n    while s[i] != c:\n        i = i + 1\n    ls.append(i)\n    i = i + 1\nrs = []\ni = n - 1\nfor c in t[::-1]:\n    while s[i] != c:\n        i = i - 1\n    rs.append(i)\n    i = i - 1\nmaxi = 0\nrs = rs[::-1]\nfor i in range(0, m):\n    maxi = max(maxi, rs[i] - ls[i - 1])\nprint(maxi)", "(_, s, t) = open(0)\nr = i = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\ni = 8 ** 6\nfor x in t[-2:0:-1]:\n    i = s.rfind(x, 0, i)\n    r = max(r, i - a.pop())\nprint(r)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\n(min_ind, max_ind) = ([-1] * m, [-1] * m)\nindex = 0\nfor i in range(n):\n    if index < m and s[i] == t[index]:\n        min_ind[index] = i\n        index += 1\nindex = m - 1\nfor i in range(n - 1, -1, -1):\n    if index >= 0 and s[i] == t[index]:\n        max_ind[index] = i\n        index -= 1\nprint(max((max_ind[i] - min_ind[i - 1] for i in range(1, m))))", "(n, m) = [int(v) for v in input().split()]\ns = input()\nt = input()\nminSeq = [-1] * m\nmaxSeq = [-1] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        minSeq[j] = i\n        if j == m - 1:\n            break\n        j += 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        maxSeq[j] = i\n        if j == 0:\n            break\n        j -= 1\nprint(max([maxSeq[i] - minSeq[i - 1] for i in range(1, m)]))", "(n, m) = map(int, input().split())\ns = input()\nt = input()\n(right, left) = ([], [])\nj = 0\nfor i in range(m):\n    while s[j] != t[i]:\n        j += 1\n    left.append(j)\n    j += 1\nj = n - 1\nfor i in range(m - 1, -1, -1):\n    while s[j] != t[i]:\n        j -= 1\n    right.append(j)\n    j -= 1\nright = right[::-1]\nans = []\nfor i in range(m - 1):\n    ans.append(right[i + 1] - left[i])\nprint(max(ans))", "def arrIn():\n    return list(map(int, input().split()))\n\ndef mapIn():\n    return map(int, input().split())\n(n, m) = mapIn()\ns = input()\nt = input()\nminrr = [0] * m\nmaxrr = [0] * m\ni = 0\nfor j in range(m):\n    while s[i] != t[j] and i < n:\n        i += 1\n    minrr[j] = i\n    i += 1\ni = n - 1\nfor j in range(m - 1, -1, -1):\n    while s[i] != t[j] and i > 0:\n        i -= 1\n    maxrr[j] = i\n    i -= 1\nx = 0\nfor i in range(1, m):\n    y = maxrr[i] - minrr[i - 1]\n    if y > x:\n        x = y\nprint(x)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\na = []\nans = 0\ni = -1\nfor x in t[:-1]:\n    i = s.find(x, i + 1)\n    a += [i]\ni = n\nfor x in t[:0:-1]:\n    i = s.rfind(x, 0, i)\n    ans = max(ans, i - a.pop())\nprint(ans)", "def solution():\n    (n, m) = map(int, input().split())\n    s = input()\n    t = input()\n    rev_s = ''.join(reversed(s))\n    rev_t = ''.join(reversed(t))\n    last_pos = len(t) * [0]\n    start = 0\n    for i in range(len(t)):\n        idx = rev_s.find(rev_t[i], start)\n        last_pos[i] = len(s) - idx - 1\n        start = idx + 1\n    last_pos.reverse()\n    result = 1\n    cur_pos = -1\n    for i in range(len(t) - 1):\n        cur_pos = s.find(t[i], cur_pos + 1)\n        result = max(result, last_pos[i + 1] - cur_pos)\n    print(result)\nsolution()", "def findMaxWidth():\n    (n, m) = input().split(' ')\n    big = input()\n    small = input()\n    posdict = {}\n    for letter in small:\n        posdict[letter] = []\n    for index in range(len(big)):\n        if big[index] in posdict.keys():\n            posdict[big[index]].append(index)\n    maxi = 0\n    if len(posdict.keys()) > 1:\n        print(posdict)\n        for i in range(len(small) - 1):\n            while posdict[small[i]][-1] > posdict[small[i + 1]][-1]:\n                posdict[small[i]].pop()\n        print(posdict)\n        for i in range(len(small) - 1):\n            width = posdict[small[i + 1]][-1] - posdict[small[i]][0]\n            if width > maxi:\n                maxi = width\n    else:\n        maxi = posdict[small[0]][-(len(small) - 1)] - posdict[small[0]][0]\n    print(maxi)\n\ndef ans():\n    (n, m) = map(int, input().split())\n    s = list(input())\n    t = list(input())\n    pre = [0] * m\n    suf = [0] * m\n    j = 0\n    for i in range(m):\n        while s[j] != t[i]:\n            j += 1\n        pre[i] = j\n        j += 1\n    j = n - 1\n    for i in range(m - 1, -1, -1):\n        while s[j] != t[i]:\n            j -= 1\n        suf[i] = j\n        j -= 1\n    ans = 0\n    for i in range(m - 1):\n        ans = max(ans, suf[i + 1] - pre[i])\n    print(ans)\nans()", "(n, m) = map(int, input().split())\ns = input()\nt = input()\na = []\nans = 0\ni = -1\nfor x in t[:-1]:\n    i = s.find(x, i + 1)\n    a += [i]\ni = n\nfor x in t[:0:-1]:\n    i = s.rfind(x, 0, i)\n    ans = max(ans, i - a.pop())\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nif n == m:\n    print(1)\nelse:\n    left = [0] * m\n    (i, j) = (0, 0)\n    while j < m:\n        if s[i] == t[j]:\n            left[j] = i\n            j += 1\n        i += 1\n    (i, j) = (n - 1, m - 1)\n    res = 0\n    while j > 0:\n        if s[i] == t[j]:\n            res = max(res, i - left[j - 1])\n            j -= 1\n        i -= 1\n    print(res)", "(_, s, t) = open(0)\nr = i = j = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\nfor x in t[-2:0:-1]:\n    j = s.rfind(x, 0, j)\n    r = max(r, j - a.pop())\nprint(r)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\ns1 = []\ns2 = []\nj = 0\nfor i in range(m):\n    while t[i] != s[j]:\n        j += 1\n    s1.append(j)\n    j += 1\nj = 0\ns = s[::-1]\nt = t[::-1]\nfor i in range(m):\n    while t[i] != s[j]:\n        j += 1\n    s2.append(n - j - 1)\n    j += 1\nans = 0\ns2 = s2[::-1]\nfor i in range(m - 1):\n    ans = max(ans, s2[i + 1] - s1[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nearliestMatchingIndices = []\nj = 0\nfor c in t:\n    while s[j] != c:\n        j += 1\n    earliestMatchingIndices.append(j)\n    j += 1\nlatestMatchingIndices = [0] * m\nj = n - 1\nfor i in range(m - 1, -1, -1):\n    while s[j] != t[i]:\n        j -= 1\n    latestMatchingIndices[i] = j\n    j -= 1\nmaxWidth = 0\nfor i in range(0, m - 1):\n    maxWidth = max(latestMatchingIndices[i + 1] - earliestMatchingIndices[i], maxWidth)\nprint(maxWidth)", "(_, s, t) = open(0)\ni = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\ni = 8 ** 6\nr = 0\nfor x in t[-2:0:-1]:\n    i = s.rfind(x, 0, i)\n    r = max(r, i - a.pop())\nprint(r)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nminSeq = [-1] * m\nmaxSeq = [-1] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        minSeq[j] = i\n        if j == m - 1:\n            break\n        j += 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        maxSeq[j] = i\n        if j == 0:\n            break\n        j -= 1\nprint(max((maxSeq[i] - minSeq[i - 1] for i in range(1, m))))", "(n, m) = [int(x) for x in input().split()]\ns = input()\nt = input()\nn = len(s)\nm = len(t)\np = []\nj = 0\nwidth = 0\nfor (i, x) in enumerate(t):\n    j0 = j\n    while s[j] != x:\n        j += 1\n    p += [j]\n    j += 1\nwidth = 0\nfor i in range(m - 1):\n    if p[i + 1] - p[i] > width:\n        width = p[i + 1] - p[i]\nnewpos = n - 1\nfor i in range(m - 1, 0, -1):\n    oldpos = p[i]\n    element = t[i]\n    while True:\n        if newpos == oldpos:\n            newpos -= 1\n            break\n        if s[newpos] == element:\n            p[i] = newpos\n            if width < newpos - p[i - 1]:\n                width = newpos - p[i - 1]\n            newpos -= 1\n            break\n        else:\n            newpos -= 1\nprint(width)", "(n, m) = map(int, input().split(' '))\ns = input()\nt = input()\nminm = [0] * m\ni = 0\nfor j in range(n):\n    if i == m:\n        break\n    if s[j] == t[i]:\n        minm[i] = j\n        i += 1\nmaxm = [0] * m\ni = m - 1\nfor j in range(n - 1, -1, -1):\n    if i == -1:\n        break\n    if s[j] == t[i]:\n        maxm[i] = j\n        i -= 1\nmx = -1\nfor i in range(1, m):\n    if maxm[i] - minm[i - 1] > mx:\n        mx = maxm[i] - minm[i - 1]\nprint(mx)", "(n, m) = map(int, input().split())\ns1 = input()\ns2 = input()\nleft = dict()\nright = dict()\nl = 0\nr = n - 1\nfor i in range(m):\n    while s1[l] != s2[i]:\n        l = l + 1\n    left[i] = l\n    l = l + 1\nfor i in range(m - 1, -1, -1):\n    while s1[r] != s2[i]:\n        r = r - 1\n    right[i] = r\n    r = r - 1\nres = 0\nfor i in range(m - 1):\n    res = max(res, right[i + 1] - left[i])\nprint(res)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m) = map(int, input().split())\n    p = [[] for i in range(26)]\n    p1 = [None] * 26\n    A = ord('a')\n    j = 0\n    for i in input().strip():\n        p[ord(i) - A].append(j)\n        j += 1\n    for i in range(26):\n        p1[i] = p[i].copy()\n        p1[i].reverse()\n    t = input().strip()\n    a = []\n    prev = -1\n    for i in range(0, len(t)):\n        c = ord(t[i]) - A\n        while True:\n            v = p1[c].pop()\n            if v > prev:\n                break\n        a.append(v)\n        prev = v\n    b = []\n    prev = int(1000000000.0)\n    for i in range(len(t) - 1, -1, -1):\n        c = ord(t[i]) - A\n        while True:\n            v = p[c].pop()\n            if v < prev:\n                break\n        b.append(v)\n        prev = v\n    b.reverse()\n    res = 0\n    for i in range(1, len(t)):\n        res = max(res, b[i] - a[i - 1])\n    print(res)\nsolve()", "(n, m) = (int(v) for v in input().split())\ns = input()\nt = input()\nminSeq = [-1] * m\nmaxSeq = [-1] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        minSeq[j] = i\n        if j == m - 1:\n            break\n        j += 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        maxSeq[j] = i\n        if j == 0:\n            break\n        j -= 1\nprint(max((maxSeq[i] - minSeq[i - 1] for i in range(1, m))))", "(n, m) = [int(v) for v in input().split()]\ns = input()\nt = input()\nminSeq = [-1] * m\nmaxSeq = [-1] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        minSeq[j] = i\n        if j == m - 1:\n            break\n        j += 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        maxSeq[j] = i\n        if j == 0:\n            break\n        j -= 1\nprint(max((maxSeq[i] - minSeq[i - 1] for i in range(1, m))))", "from collections import defaultdict\n(a, b) = list(map(int, input().split()))\ns = input()\nt = input()\nmini = [-1] * a\nmaxi = [-1] * a\nind = 0\nfor i in range(a):\n    if ind < b and s[i] == t[ind]:\n        mini[ind] = i\n        ind += 1\nind = b - 1\nfor i in range(a - 1, -1, -1):\n    if ind >= 0 and s[i] == t[ind]:\n        maxi[ind] = i\n        ind -= 1\nprint(max([maxi[i] - mini[i - 1] for i in range(1, a)]))", "(_, s, t) = open(0)\ni = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\nr = i = -1\nfor x in t[-2:0:-1]:\n    i = s.rfind(x, 0, i)\n    r = max(r, i - a.pop())\nprint(r)", "(n, m) = map(int, input().split())\n(a, b, q, w, e) = (input(), input(), [], [], 0)\nfor i in range(n):\n    if b[e] == a[i]:\n        q += [i]\n        e += 1\n    if e == m:\n        break\ne -= 1\nfor i in range(n - 1, -1, -1):\n    if b[e] == a[i]:\n        w += [i]\n        e -= 1\n    if e == -1:\n        break\nw = w[::-1]\nprint(max((w[i + 1] - q[i] for i in range(m - 1))))", "(n, m) = map(int, input().split())\ns = input()\nt = input()\na = []\nans = 0\ni = -1\nfor x in t[:-1]:\n    i = s.find(x, i + 1)\n    a += [i]\ni = n\nfor x in t[:0:-1]:\n    i = s.rfind(x, 0, i)\n    ans = max(ans, i - a.pop())\nprint(ans)", "(n, m) = map(int, input().split())\ns = list(input())\nt = list(input())\npre = [0] * m\nsuf = [0] * m\nj = 0\nfor i in range(m):\n    while s[j] != t[i]:\n        j += 1\n    pre[i] = j\n    j += 1\nj = n - 1\nfor i in range(m - 1, -1, -1):\n    while s[j] != t[i]:\n        j -= 1\n    suf[i] = j\n    j -= 1\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, suf[i + 1] - pre[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nlow = []\npointer = 0\nfor (index, char) in enumerate(s):\n    if char == t[pointer]:\n        low.append(index)\n        pointer += 1\n        if pointer == m:\n            break\nelse:\n    raise RuntimeError(\"Shouldn't reach here\")\nhigh = []\npointer = m - 1\nfor (index, char) in reversed(tuple(enumerate(s))):\n    if char == t[pointer]:\n        high.append(index)\n        pointer -= 1\n        if pointer < 0:\n            break\nelse:\n    raise ValueError\nhigh.reverse()\nprint(max((high[i] - low[i - 1] for i in range(1, m))))", "def fill(s, t, f):\n    j = 0\n    i = 0\n    l = [0] * len(t)\n    while i < m:\n        while t[i] != s[j]:\n            j += 1\n        if not f:\n            l[i] = n - 1 - j\n        else:\n            l[i] = j\n        i += 1\n        j += 1\n    return l\n(n, m) = list(map(int, input().split()))\ns = input()\nt = input()\nforward = fill(s, t, True)\nbackward = fill(s[::-1], t[::-1], False)[::-1]\nm = 0\nfor i in range(1, len(t)):\n    m = max(m, backward[i] - forward[i - 1])\nprint(m)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\na = []\nb = []\nk = 0\nfor i in range(n):\n    if s[i] == t[k]:\n        a.append(i)\n        k += 1\n    if k == m:\n        break\nk = m - 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[k]:\n        b.append(i)\n        k -= 1\n    if k == -1:\n        break\nb.reverse()\nk = 0\nfor i in range(m):\n    if i < m - 1:\n        if b[i + 1] - a[i] > k:\n            k = b[i + 1] - a[i]\nprint(k)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nleft = [-1] * m\nright = [-1] * m\nx = 0\nfor i in range(m):\n    while s[x] != t[i]:\n        x += 1\n    left[i] = x\n    x += 1\nx = n - 1\nfor i in range(m - 1, -1, -1):\n    while s[x] != t[i]:\n        x -= 1\n    right[i] = x\n    x -= 1\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, right[i + 1] - left[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nr = [0] * m\nl = [0] * m\n(i, j) = (0, 0)\nwhile j < m and i < n:\n    if s[i] == t[j]:\n        l[j] = i\n        j += 1\n    i += 1\n(j, i) = (m - 1, n - 1)\nwhile j >= 0 and n >= 0:\n    if s[i] == t[j]:\n        r[j] = i\n        j -= 1\n    i -= 1\nprint(max((r[i + 1] - l[i] for i in range(m - 1))))", "(n, m) = map(int, input().split())\ns = input()\nt = input()\np = [0 for i in range(m)]\n(i, j) = (0, 0)\nwhile j < m:\n    while s[i] != t[j]:\n        i += 1\n    p[j] = i\n    i += 1\n    j += 1\nsol = 0\ni = n - 1\nwhile j > 1:\n    j -= 1\n    while s[i] != t[j]:\n        i -= 1\n    sol = max(sol, i - p[j - 1])\n    i -= 1\nprint(sol)", "def solve(n, m):\n    l = []\n    r = []\n    (i1, i2) = (0, 0)\n    while i1 < n and i2 < m:\n        if s[i1] == t[i2]:\n            l.append(i1)\n            i2 += 1\n        i1 += 1\n    (i1, i2) = (n - 1, m - 1)\n    while i1 > -1 and i2 > -1:\n        if s[i1] == t[i2]:\n            r.append(i1)\n            i2 -= 1\n        i1 -= 1\n    maxx = 0\n    r = r[::-1]\n    for i in range(m - 1):\n        maxx = max(maxx, r[i + 1] - l[i])\n    print(maxx)\n(n, m) = map(int, input().split())\ns = input()\nt = input()\nsolve(n, m)", "import sys\n\ndef solve(s, t):\n    left_indexs = []\n    right_indexs = []\n    counter = 0\n    ans = 0\n    for (i, c) in enumerate(s):\n        if counter + 1 == len(t):\n            break\n        if t[counter] == c:\n            left_indexs.append(i)\n            counter += 1\n    counter = len(t) - 1\n    for (i, c) in enumerate(s[::-1]):\n        if counter == 0:\n            break\n        if t[counter] == c:\n            right_indexs.append(len(s) - i - 1)\n            counter -= 1\n    for i in range(len(left_indexs)):\n        ans = max(ans, right_indexs[i] - left_indexs[len(left_indexs) - i - 1])\n    return ans\nn = sys.stdin.readline().strip()\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\nprint(solve(s, t))", "(n, m) = map(int, input().split())\ns = input()\nt = input()\na = []\nans = 0\ni = -1\nfor x in t[:-1]:\n    i = s.find(x, i + 1)\n    a += [i]\ni = n\nfor x in t[:0:-1]:\n    i = s.rfind(x, 0, i)\n    ans = max(ans, i - a.pop())\nprint(ans)", "(_, s, t) = open(0)\nr = i = j = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\nfor x in t[-2:0:-1]:\n    j = s.rfind(x, 0, j)\n    r = max(r, j - a.pop())\nprint(r)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nfast_substring = [0] * m\nlast_substring = [0] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        fast_substring[j] = i\n        j += 1\n    if j == m:\n        break\nj = m - 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        last_substring[j] = i\n        j -= 1\n    if j < 0:\n        break\nans = -1\nfor i in range(m - 1):\n    ans = max(ans, last_substring[i + 1] - fast_substring[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = list(input())\nt = list(input())\nstart = []\nend = []\nj = 0\nk = n - 1\nfor i in range(m):\n    while s[j] != t[i]:\n        j += 1\n    start.append(j)\n    j += 1\n    while s[k] != t[m - 1 - i]:\n        k -= 1\n    end.append(k)\n    k -= 1\nend = end[::-1]\nans = 0\nfor i in range(1, m):\n    ans = max(ans, end[i] - start[i - 1])\nprint(ans)", "(n, m) = map(int, input().split())\ns1 = input()\ns2 = input()\nleft = dict()\nright = dict()\nl = 0\nr = n - 1\nfor i in range(m):\n    while s1[l] != s2[i]:\n        l = l + 1\n    left[i] = l\n    l = l + 1\nfor i in range(m - 1, -1, -1):\n    while s1[r] != s2[i]:\n        r = r - 1\n    right[i] = r\n    r = r - 1\nres = 0\nfor i in range(m - 1):\n    res = max(res, right[i + 1] - left[i])\nprint(res)", "(n, m) = [int(x) for x in input().split()]\ns = input()\nt = input()\nL = 1\nR = n - m + 1\nhead = 0\nindices1 = []\nindices2 = []\nfor i in range(n):\n    if s[i] == t[head]:\n        head += 1\n        indices1.append(i)\n    if head == m:\n        break\ntail = m - 1\nfor i in range(n):\n    if s[n - 1 - i] == t[tail]:\n        tail -= 1\n        indices2.append(n - 1 - i)\n    if tail == -1:\n        break\nindices2.reverse()\nans = max([indices2[i + 1] - indices1[i] for i in range(m - 1)])\nprint(ans)", "(n, m) = map(int, input().split())\ns = list(input())\nt = list(input())\nleft = []\ni = 0\nj = 0\nwhile i < n and j < m:\n    if s[i] == t[j]:\n        left.append(i)\n        i += 1\n        j += 1\n    else:\n        i += 1\nright = []\ni = n - 1\nj = m - 1\nwhile i >= 0 and j >= 0:\n    if s[i] == t[j]:\n        right.append(i)\n        i -= 1\n        j -= 1\n    else:\n        i -= 1\nright.reverse()\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, right[i + 1] - left[i])\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef lcm(a, b, curr, mx):\n    if len(b) == 0:\n        return max(mx, curr)\n    if len(a) == 0:\n        return 0\n    v = 0\n    if a[0] == b[0]:\n        v = lcm(a[1:], b[1:], 0, max(curr, mx))\n    return max(v, lcm(a[1:], b, curr + 1, mx))\n(n, m) = list(map(int, input().split()))\ns = input()\nt = input()\n(a, b) = ([], [])\nl = 0\nfor i in range(m):\n    while s[l] != t[i]:\n        l += 1\n    a.append(l)\n    l += 1\nl = n - 1\nfor i in range(m)[::-1]:\n    while s[l] != t[i]:\n        l -= 1\n    b.append(l)\n    l -= 1\nb = b[::-1]\nx = 0\nfor i in range(len(a) - 1):\n    x = max(x, b[i + 1] - a[i])\nprint(x)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nl_idx = []\nr_idx = []\n(l, r) = (0, m - 1)\nfor i in range(n):\n    if s[i] == t[l]:\n        l_idx.append(i)\n        l += 1\n    if l == m:\n        break\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[r]:\n        r_idx.append(i)\n        r -= 1\n    if r < 0:\n        break\nr_idx.reverse()\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, r_idx[i + 1] - l_idx[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns1 = input()\ns2 = input()\na = []\nb = []\nc = 0\nfor j in range(n):\n    if s1[j] == s2[c]:\n        a.append(j)\n        c = c + 1\n        if c == m:\n            break\nc = m - 1\nfor j in range(n - 1, -1, -1):\n    if s1[j] == s2[c]:\n        b.append(j)\n        c = c - 1\n        if c == -1:\n            break\nmaxo = 0\nfor j in range(m - 1):\n    if maxo < b[m - 2 - j] - a[j]:\n        maxo = b[m - 2 - j] - a[j]\nprint(maxo)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nminSeq = [-1] * m\nmaxSeq = [-1] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        minSeq[j] = i\n        if j == m - 1:\n            break\n        j += 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        maxSeq[j] = i\n        if j == 0:\n            break\n        j -= 1\nprint(max([maxSeq[i] - minSeq[i - 1] for i in range(1, m)]))", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nr = [0] * m\nl = [0] * m\n(i, j) = (0, 0)\nwhile j < m and i < n:\n    if s[i] == t[j]:\n        l[j] = i\n        j += 1\n    i += 1\n(j, i) = (m - 1, n - 1)\nwhile j >= 0 and n >= 0:\n    if s[i] == t[j]:\n        r[j] = i\n        j -= 1\n    i -= 1\nprint(max((r[i + 1] - l[i] for i in range(m - 1))))", "ch = input()\nL = [int(i) for i in ch.split()]\n(n, m) = (L[0], L[1])\nc = input()\ns = input()\ng = [-1] * m\nj = 0\nfor i in range(n):\n    if c[i] == s[j]:\n        g[j] = i\n        j += 1\n        if j >= m:\n            break\nd = [-1] * m\nj = m - 1\nfor i in range(n - 1, -1, -1):\n    if c[i] == s[j]:\n        d[j] = i\n        j -= 1\n        if j < 0:\n            break\nmaxx = 0\nfor i in range(1, m):\n    maxx = max(maxx, d[i] - g[i - 1])\nprint(maxx)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nans = 0\nf = [0] * m\nl = [0] * m\nq = 0\nfor i in range(n):\n    if t[q] == s[i]:\n        f[q] = i\n        q += 1\n    if q == m:\n        break\nq = m - 1\nfor i in range(n - 1, -1, -1):\n    if t[q] == s[i]:\n        l[q] = i\n        q -= 1\n    if q == -1:\n        break\nfor i in range(1, m):\n    ans = max(ans, l[i] - f[i - 1])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nl = [m] * m\nr = [0] * m\nj = 0\nfor i in range(n):\n    if s[i] == t[j]:\n        l[j] = i\n        j += 1\n    if j >= m:\n        break\nj = m - 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[j]:\n        r[j] = i\n        j -= 1\n    if j < 0:\n        break\nans = 0\nfor i in range(m - 1):\n    ans = max(r[i + 1] - l[i], ans)\nprint(ans)", "import sys\nfrom sys import stdin, stdout\nfrom math import ceil, floor, sqrt, log, log2, log10\nfrom collections import Counter\nint_max = float('inf')\nint_min = -float('inf')\nANS = []\ninput = stdin.readline\n\ndef solve():\n    pass\nt = 1\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    s = input()\n    t = input()\n    prefix = [0] * m\n    suffix = [0] * m\n    i = 0\n    st = 0\n    while st < m:\n        if s[i] == t[st]:\n            prefix[st] = i\n            st += 1\n        i += 1\n    st = m - 1\n    i = n - 1\n    while st >= 0:\n        if s[i] == t[st]:\n            suffix[st] = i\n            st -= 1\n        i -= 1\n    maxx = -1\n    for i in range(m - 1):\n        maxx = max(maxx, suffix[i + 1] - prefix[i])\n    ANS.append(str(maxx))\nprint('\\n'.join(ANS))", "import sys\nimport math\nimport random\nfrom queue import PriorityQueue as PQ\nfrom bisect import bisect_left as BSL\nfrom bisect import bisect_right as BSR\nfrom collections import OrderedDict as OD\nfrom collections import Counter\nfrom itertools import permutations\nfrom decimal import Decimal as BIGFLOAT\nmod = 1000000007\nMOD = mod\ntry:\n    sys.stdin = open('actext.txt', 'r')\n    OPENFILE = 1\nexcept:\n    pass\n\ndef get_ints():\n    return map(int, input().split())\n\ndef palindrome(s):\n    mid = len(s) // 2\n    for i in range(mid):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True\n\ndef check(i, n):\n    if 0 <= i < n:\n        return True\n    else:\n        return False\n(n, m) = get_ints()\ns = input()\nt = input()\nmi = []\ni = 0\nj = 0\nwhile j < m:\n    if s[i] == t[j]:\n        mi.append(i)\n        j += 1\n    i += 1\nmx = []\ni = n - 1\nj = m - 1\nwhile j >= 0:\n    if t[j] == s[i]:\n        mx.append(i)\n        j -= 1\n    i -= 1\nmx.reverse()\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, mx[i + 1] - mi[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nleft = [0 for i in range(m)]\nright = [0 for i in range(m)]\nj = 0\ni = 0\nwhile j < m:\n    while s[i] != t[j]:\n        i += 1\n    left[j] = i\n    i += 1\n    j += 1\nj = m - 1\ni = n - 1\nwhile j >= 0:\n    while s[i] != t[j]:\n        i -= 1\n    right[j] = i\n    i -= 1\n    j -= 1\nans = 0\nfor i in range(1, m):\n    ans = max(right[i] - left[i - 1], ans)\nprint(ans)", "(n, m) = [int(k) for k in input().split()]\ns = input()\nt = input()\nc = -1\nres = []\nfor j in range(n):\n    if s[-j - 1] == t[c]:\n        res.append(n - j - 1)\n        c -= 1\n        if c < -m:\n            break\nmx = 0\nc = 0\nres = res[::-1]\nfor j in range(n):\n    if s[j] == t[c]:\n        mx = max(res[c + 1] - j, mx)\n        c += 1\n        if c == m - 1:\n            break\nprint(mx)", "(n, m) = map(int, input().strip().split())\ns = input()\np = input()\nx = []\ny = []\nj = 0\nfor i in range(n):\n    if s[i] == p[j]:\n        x.append(i)\n        j += 1\n    if j == m:\n        break\nj = m - 1\ni = n - 1\nwhile i >= 0 and j >= 0:\n    if s[i] == p[j]:\n        y.append(i)\n        j -= 1\n    i -= 1\ny.reverse()\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, y[i + 1] - x[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\n\ndef a_to_i(x):\n    return ord(x) - ord('a')\ncur = 0\nl = []\nfor i in range(n):\n    if t[cur] == s[i]:\n        l.append(i)\n        cur += 1\n    if cur == m:\n        break\ncur = m - 1\nr = []\nfor i in range(n - 1, -1, -1):\n    if t[cur] == s[i]:\n        r.append(i)\n        cur -= 1\n    if cur == -1:\n        break\nr.reverse()\nans = 0\nfor i in range(m - 1):\n    ans = max(ans, r[i + 1] - l[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nans = 0\nf = [0] * m\nl = [0] * m\nq = 0\nfor i in range(n):\n    if t[q] == s[i]:\n        f[q] = i\n        q += 1\n    if q == m:\n        break\nq = m - 1\nfor i in range(n - 1, -1, -1):\n    if t[q] == s[i]:\n        l[q] = i\n        q -= 1\n    if q == -1:\n        break\nfor i in range(1, m):\n    ans = max(ans, l[i] - f[i - 1])\nprint(ans)", "answers = []\n\ndef solve(n, m, s, t):\n    if n == m:\n        print(1)\n        return\n    first = []\n    second = []\n    current = 0\n    for i in range(n):\n        if s[i] == t[current]:\n            first.append(i)\n            current += 1\n            if current == m:\n                break\n    current = m - 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == t[current]:\n            second.append(i)\n            current -= 1\n            if current == -1:\n                break\n    second.reverse()\n    ans = 0\n    for i in range(1, m):\n        current = max(first[i] - first[i - 1], first[i] - second[i - 1], second[i] - second[i - 1], second[i] - first[i - 1])\n        ans = max(ans, current)\n    print(ans)\n(n, m) = [int(x) for x in input().split()]\ns = input()\nt = input()\nsolve(n, m, s, t)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nnxt = [0 for i in range(m)]\nlst = [0 for i in range(m)]\nj = 0\nfor i in range(n):\n    if j < m and s[i] == t[j]:\n        nxt[j] = i\n        j = j + 1\nj = m - 1\nfor i in range(n - 1, -1, -1):\n    if j >= 0 and s[i] == t[j]:\n        lst[j] = i\n        j = j - 1\nmx = 0\nfor i in range(m - 1):\n    mx = max(mx, lst[i + 1] - nxt[i])\nprint(mx)", "(*jjj, s, t) = open(0)\nr = i = j = -1\na = []\nfor x in t[:-2]:\n    i = s.find(x, i + 1)\n    a += (i,)\nfor x in t[-2:0:-1]:\n    j = s.rfind(x, 0, j)\n    r = max(r, j - a.pop())\nprint(r)", "import math\nimport heapq\n\ndef S():\n    return input()\n\ndef M():\n    return map(int, input().split())\n\ndef I():\n    return int(S())\n\ndef L():\n    return list(M())\n(n, m) = M()\ns = S()\nt = S()\n(l, r) = ([0] * m, [0] * m)\n(i, j) = (0, 0)\nwhile j < m and i < n:\n    if s[i] == t[j]:\n        l[j] = i\n        j += 1\n    i += 1\n(i, j) = (n - 1, m - 1)\nwhile j >= 0 and i >= 0:\n    if s[i] == t[j]:\n        r[j] = i\n        j -= 1\n    i -= 1\na = []\nfor i in range(m - 1):\n    a.append(r[i + 1] - l[i])\nprint(max(a))", "(bl, sl) = map(int, input().split())\n(b, s) = (input(), input())\nc = 0\n(i, cind) = (0, 0)\nst = []\nen = []\nwhile 1:\n    if b[cind] == s[i]:\n        st.append(cind)\n        i += 1\n        if i == sl:\n            break\n    cind += 1\n(i, cind) = (0, 0)\nwhile 2:\n    if b[bl - cind - 1] == s[sl - i - 1]:\n        en.append(bl - cind - 1)\n        i += 1\n        if i == sl:\n            break\n    cind += 1\nen = en[::-1]\nfor i in range(len(st) - 1):\n    c = max(c, en[i + 1] - st[i])\nprint(max(c, en[-1] - st[-1]))", "import math\nimport collections\nimport sys\nsys.setrecursionlimit(100000000)\n\ndef read_list() -> list:\n    return [int(i) for i in input().strip().split()]\n\ndef read_num() -> int:\n    return int(input().strip())\n(n, m) = read_list()\ns = input()\nt = input()\n(st, ed) = ([], [])\np = 0\nfor i in range(n):\n    if s[i] == t[p]:\n        st.append(i)\n        p += 1\n    if p == m:\n        break\np = m - 1\nfor i in range(n - 1, -1, -1):\n    if s[i] == t[p]:\n        ed.append(i)\n        p -= 1\n    if p < 0:\n        break\ned.reverse()\nans = 0\nfor i in range(1, m):\n    ans = max(ans, ed[i] - st[i - 1])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nl = []\nr = []\nfor i in range(n):\n    l.append(0)\n    r.append(0)\ni = 0\nj = 0\nfor j in range(m):\n    while s[i] != t[j]:\n        i += 1\n    l[j] = i\n    i += 1\ni = n - 1\nj = m - 1\nfor j in range(m - 1, -1, -1):\n    while s[i] != t[j]:\n        i -= 1\n    r[j] = i\n    i -= 1\nm = 1\nfor i in range(1, n):\n    m = max(m, r[i] - l[i - 1])\nprint(m)", "from collections import defaultdict\nimport bisect\nfor _ in range(1):\n    (n, m) = map(int, input().split())\n    s = input().strip()\n    t = input().strip()\n    f = 0\n    left = []\n    for i in range(n):\n        if s[i] == t[f]:\n            left.append(i)\n            f += 1\n        if f == m:\n            break\n    f = m - 1\n    right = []\n    for i in range(n - 1, -1, -1):\n        if s[i] == t[f]:\n            right.append(i)\n            f -= 1\n        if f == -1:\n            break\n    right.reverse()\n    ans = 0\n    for i in range(1, m):\n        ans = max(ans, right[i] - left[i - 1])\n    print(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nptr = 0\nfirst = [0] * m\nfor i in range(n):\n    if t[ptr] == s[i]:\n        first[ptr] = i\n        ptr += 1\n    if ptr == m:\n        break\nlast = [0] * m\nptr = m - 1\nfor j in range(n - 1, -1, -1):\n    if t[ptr] == s[j]:\n        last[ptr] = j\n        ptr -= 1\n    if ptr == -1:\n        break\nans = 0\nfor i in range(1, m):\n    ans = max(ans, last[i] - first[i - 1])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nans = 0\nf = [0] * m\nl = [0] * m\nq = 0\nfor i in range(n):\n    if t[q] == s[i]:\n        f[q] = i\n        q += 1\n    if q == m:\n        break\nq = m - 1\nfor i in range(n - 1, -1, -1):\n    if t[q] == s[i]:\n        l[q] = i\n        q -= 1\n    if q == -1:\n        break\nfor i in range(1, m):\n    ans = max(ans, l[i] - f[i - 1])\nprint(ans)", "(n, m) = map(int, input().split())\nval1 = input()\nval2 = input()\nleft = []\nright = []\nnum = m\nfor i in range(n - 1, -1, -1):\n    vari = val1[i]\n    if val2[num - 1] == vari:\n        right.append(i)\n        num = num - 1\n    if num == 0:\n        break\nnum = 0\nfor i in range(n):\n    vari = val1[i]\n    if val2[num] == vari:\n        left.append(i)\n        num += 1\n    if num == m:\n        break\nresult = 0\nright.reverse()\nfor j in range(m - 1):\n    result = max(right[j + 1] - left[j], result)\nprint(result)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nl = []\nr = []\nj = 0\nfor i in range(n):\n    if j == len(t):\n        break\n    if s[i] == t[j]:\n        l.append(i)\n        j += 1\nj = len(t) - 1\nfor i in range(n - 1, -1, -1):\n    if j == -1:\n        break\n    if s[i] == t[j]:\n        r.append(i)\n        j -= 1\nr.reverse()\nmax = 0\nfor i in range(1, m):\n    if int(r[i]) - int(l[i - 1]) > max:\n        max = int(r[i]) - int(l[i - 1])\nprint(max)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\nS = []\nT = []\nj = 0\ni = 0\nwhile i < n and j < m:\n    if s[i] == t[j]:\n        S.append(i)\n        j += 1\n    i += 1\ni = n - 1\nj = m - 1\nwhile i >= 0 and j >= 0:\n    if s[i] == t[j]:\n        T.append(i)\n        j -= 1\n    i -= 1\nT = T[::-1]\nans = 0\nfor i in range(1, len(S)):\n    ans = max(ans, T[i] - S[i - 1])\nprint(ans)", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\n(s, t) = (input().strip(), input().strip())\n(forward_index, reverse_index, i, j, ans) = ([], [], 0, 0, 0)\nwhile i < n and j < m:\n    if s[i] == t[j]:\n        forward_index.append(i)\n        (i, j) = (i + 1, j + 1)\n    else:\n        i += 1\n(i, j) = (n - 1, m - 1)\nwhile i > -1 and j > -1:\n    if s[i] == t[j]:\n        reverse_index.append(i)\n        (i, j) = (i - 1, j - 1)\n    else:\n        i -= 1\nreverse_index = reverse_index[0:len(reverse_index) - 1][::-1]\nfor i in range(len(forward_index) - 1):\n    ans = max(ans, reverse_index[i] - forward_index[i])\nprint(ans)", "(n, m) = map(int, input().split())\ns = input()\nt = input()\n\ndef findFirstOption(n, m, s, t):\n    firstOccurrence = [0 for _ in range(m)]\n    cur = 0\n    for i in range(n):\n        if cur == m:\n            break\n        chS = ord(s[i]) - ord('a')\n        chT = ord(t[cur]) - ord('a')\n        if chT == chS:\n            firstOccurrence[cur] = i\n            cur += 1\n    return firstOccurrence\na = findFirstOption(n, m, s, t)\nb = [n - 1 - x for x in findFirstOption(n, m, s[::-1], t[::-1])[::-1]]\nprint(max([b[i + 1] - a[i] for i in range(m - 1)]))"]