["def smallest_winner(matrix):\n    starting_x = 1\n    x = 1\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p):\n    maxi = matrix[-1]\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        maxi = min(maxi, matrix[i + p - 1] - i)\n    return maxi\n\ndef solve(n, p, matrix):\n    return [i for i in range(smallest_winner(matrix), biggest_winner(matrix, p))]\n(n, p) = map(int, input().split())\nres = solve(n, p, sorted(list(map(int, input().split()))))\nprint(len(res))\nprint(' '.join(map(str, res)))", "def smallest_winner(matrix, starting_x, x):\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p, maxi):\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        maxi = min(maxi, matrix[i + p - 1] - i)\n    return maxi\n(n, p) = map(int, input().split())\nmatrix = sorted(list(map(int, input().split())))\nres = [i for i in range(smallest_winner(matrix, 1, 1), biggest_winner(matrix, p, matrix[-1]))]\nprint(len(res))\nprint(' '.join(map(str, res)))", "(n, p) = map(int, input().split())\narr = list(map(int, input().split()))\n(l, r) = (0, float('inf'))\narr.sort()\nfor i in range(len(arr)):\n    l = max(l, arr[i] - i)\n    if i + 1 >= p:\n        r = min(r, arr[i] - i + p - 1)\nprint(max(0, r - l))\nres = []\nfor i in range(l, r):\n    res.append(i)\nprint(*res)", "(n, p) = map(int, input().split())\narr = list(map(int, input().split()))\n(l, r) = (0, float('inf'))\narr.sort()\nfor i in range(len(arr)):\n    l = max(l, arr[i] - i)\n    if i + 1 >= p:\n        r = min(r, arr[i] - i + p - 1)\nprint(max(0, r - l))\nres = []\nfor i in range(l, r):\n    res.append(i)\nprint(*res)", "(n, p) = [int(i) for i in input().split()]\nlst = [int(i) for i in input().split()]\n(m, r) = (0, float('inf'))\nlst.sort()\nfor i in range(n):\n    m = max(m, lst[i] - i)\n    if i + 1 >= p:\n        r = min(r, lst[i] - i + p - 1)\nprint(max(0, r - m))\nprint(*list(range(m, r)))", "def smallest_winner(matrix):\n    starting_x = 1\n    x = 1\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p):\n    maxi = matrix[-1]\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        temp = matrix[i + p - 1] - i\n        maxi = min(maxi, temp)\n    return maxi\n\ndef check_multiple(matrix):\n    count = 0\n    maxi = 0\n    for i in range(1, len(matrix)):\n        if matrix[i] == matrix[i - 1]:\n            count += 1\n        else:\n            count = 1\n        maxi = max(maxi, count)\n    return maxi\n\ndef solve(n, p, matrix):\n    matrix = sorted(matrix)\n    min_x = smallest_winner(matrix)\n    max_x = biggest_winner(matrix, p) - 1\n    return [i for i in range(min_x, max_x + 1)]\n(n, p) = map(int, input().split())\nmatrix = map(int, input().split())\nres = solve(n, p, matrix)\nprint(len(res))\nprint(' '.join(map(str, res)))", "def smallest_winner(matrix):\n    starting_x = 1\n    x = 1\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p):\n    maxi = matrix[-1]\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        maxi = min(maxi, matrix[i + p - 1] - i)\n    return maxi\n\ndef check_multiple(matrix):\n    count = 0\n    maxi = 0\n    for i in range(1, len(matrix)):\n        count = count + 1 if matrix[i] == matrix[i - 1] else 1\n        maxi = max(maxi, count)\n    return maxi\n\ndef solve(n, p, matrix):\n    return [i for i in range(smallest_winner(matrix), biggest_winner(matrix, p))]\n(n, p) = map(int, input().split())\nres = solve(n, p, sorted(list(map(int, input().split()))))\nprint(len(res))\nprint(' '.join(map(str, res)))", "def smallest_winner(matrix, starting_x, x):\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p, maxi):\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        maxi = min(maxi, matrix[i + p - 1] - i)\n    return maxi\n\ndef solve(n, p, matrix):\n    return [i for i in range(smallest_winner(matrix, 1, 1), biggest_winner(matrix, p, matrix[-1]))]\n(n, p) = map(int, input().split())\nmatrix = sorted(list(map(int, input().split())))\nres = [i for i in range(smallest_winner(matrix, 1, 1), biggest_winner(matrix, p, matrix[-1]))]\nprint(len(res))\nprint(' '.join(map(str, res)))", "lis = input().split()\n(n, p) = (int(lis[0]), int(lis[1]))\nlis = input().split()\na = [0] * n\nfor i in range(n):\n    a[i] = int(lis[i])\na.sort()\nxminn = a[0]\nfor i in range(1, n):\n    xminn = max(a[i] - i, xminn)\nfor i in range(n):\n    a[i] = min(xminn - a[i] + 1 + i, i + 1)\nlenn = n\ni = p\nwhile i <= n:\n    lenn = min(i - a[i - 1], lenn)\n    i += p\nif lenn == 0:\n    print(0)\nelse:\n    notAllowed = [False] * lenn\n    for i in range(n):\n        uplim = min(a[i] + lenn - 1, i + 1)\n        val = ((a[i] - 1) // p + 1) * p\n        if val <= uplim:\n            notAllowed[val - a[i]] = True\n    good = []\n    for i in range(lenn):\n        if not notAllowed[i]:\n            good.append(xminn + i)\n    print(len(good))\n    for i in good:\n        print(i, end=' ')\n    print()", "import sys\nimport math\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef SI():\n    return sys.stdin.readline().strip()\n(n, p) = MI()\na = sorted(LI())\nfor i in range(n):\n    a[i] -= i\nmi = max(a)\nfor i in range(n):\n    a[i] += p - 1\nma = min(a[p - 1:])\nprint(max(ma - mi, 0))\nprint(*list(range(mi, ma)))", "(n, p) = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ncur_pass = 0\nfor i in range(n):\n    cur_pass = max(a[i] - i, cur_pass)\nmin_pass = cur_pass\nans = []\ndone = True\nl = cur_pass\nr = a[-1]\nwhile l <= r:\n    mid = (l + r) // 2\n    cur_pass = mid\n    i = 0\n    while i < n and a[i] <= cur_pass:\n        i += 1\n    candies = cur_pass\n    options = i\n    while options:\n        if options >= p:\n            r = mid - 1\n            break\n        candies += 1\n        options -= 1\n        while i < n and a[i] <= candies:\n            i += 1\n            options += 1\n    if r == mid - 1:\n        pass\n    else:\n        l = mid + 1\nfor i in range(min_pass, r + 1):\n    ans += [str(i)]\nprint(len(ans))\nprint(' '.join(ans))", "import math\nimport collections\nfrom sys import stdin, stdout, setrecursionlimit\nfrom bisect import bisect_left as bsl\nfrom bisect import bisect_right as bsr\nimport heapq as hq\nsetrecursionlimit(2 ** 20)\nt = 1\nd = {}\n\ndef bin(a, k):\n    cnt = bsr(a, k)\n    for i in range(n):\n        if cnt >= p:\n            return True\n        cnt -= 1\n        k += 1\n        if k in d:\n            cnt += d[k]\n    return False\ndp = [1] * 100001\nfor _ in range(t):\n    (n, p) = list(map(int, stdin.readline().rstrip().split()))\n    a = list(map(int, stdin.readline().rstrip().split()))\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    mi = max(a)\n    for i in range(n):\n        a[i] += p - 1\n    ma = min(a[p - 1:])\n    print(max(ma - mi, 0))\n    print(*list(range(mi, ma)))", "from bisect import bisect_right as br\nimport sys\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n(n, p) = MI()\naa = LI()\naa.sort()\n\ndef low(x):\n    for i in range(n):\n        if br(aa, i + x) - i < 1:\n            return False\n    return True\nl = min(aa) - 1\nr = max(aa) + 1\nwhile l + 1 < r:\n    x = (l + r) // 2\n    if low(x):\n        r = x\n    else:\n        l = x\nmn = r\n\ndef high(x):\n    for i in range(n):\n        if br(aa, i + x) - i >= p:\n            return False\n    return True\nl = mn - 1\nr = max(aa) + 1\nwhile l + 1 < r:\n    x = (l + r) // 2\n    if high(x):\n        l = x\n    else:\n        r = x\nmx = l\nans = list(range(mn, mx + 1))\nprint(len(ans))\nprint(*ans)", "def func(length, prime):\n    nums = sorted(map(int, input().split()))\n    mini = max(nums[0], nums[-1] - length + 1)\n    xs = list(range(mini, min(mini + length, nums[-1] + 1)))\n    L = len(xs)\n    idxs = [0] * length\n    for i in range(L - 1, -1, -1):\n        if xs[i] == nums[-1]:\n            idxs[-1] = length - i\n            break\n    for i in range(length - 2, -1, -1):\n        diff = nums[i + 1] - nums[i]\n        idxs[i] = min(length, idxs[i + 1] + diff)\n    for i in range(length):\n        idxs[i] -= length - 1 - i\n    from collections import defaultdict\n    num2i = defaultdict(set)\n    flag = False\n    for (i, n) in enumerate(idxs):\n        if n == i + 1:\n            if n % prime == 0:\n                flag = True\n                break\n        else:\n            num2i[n].add(i)\n    res = []\n    for x in xs:\n        if flag:\n            break\n        if all((x % prime != 0 for x in num2i)):\n            res.append(x)\n        num2i = {n + 1: s for (n, s) in num2i.items()}\n        for k in list(num2i.keys()):\n            v = num2i[k]\n            if k - 1 in v:\n                v.remove(k - 1)\n                if k % prime == 0:\n                    flag = True\n                    break\n                if not v:\n                    num2i.pop(k)\n    print(len(res))\n    print(' '.join(map(str, res)) if res else '')\nfor i in range(1):\n    (n, k) = map(int, input().split())\n    func(n, k)", "def func(length, prime):\n    nums = sorted(map(int, input().split()))\n    mini = max(nums[0], nums[-1] - length + 1)\n    xs = list(range(mini, min(mini + length, nums[-1] + 1)))\n    L = len(xs)\n    idxs = [0] * length\n    for i in range(L - 1, -1, -1):\n        if xs[i] == nums[-1]:\n            idxs[-1] = length - i\n            break\n    for i in range(length - 2, -1, -1):\n        diff = nums[i + 1] - nums[i]\n        idxs[i] = min(length, idxs[i + 1] + diff)\n    for i in range(length):\n        idxs[i] -= length - 1 - i\n    res = []\n    for x in xs:\n        flag = any((op % prime == 0 for op in idxs))\n        idxs = [n + 1 if n != i + 1 else n for (i, n) in enumerate(idxs)]\n        if flag:\n            continue\n        res.append(x)\n    print(len(res))\n    print(' '.join(map(str, res)) if res else '')\nfor i in range(1):\n    (n, k) = map(int, input().split())\n    func(n, k)"]