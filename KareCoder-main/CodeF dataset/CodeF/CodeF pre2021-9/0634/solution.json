["import sys\ninput = sys.stdin.readline\n(n, q) = map(int, input().split())\nadj = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nparent = {1: 1}\nin_time = [0] * (n + 1)\nout_time = [0] * (n + 1)\nstack = [(1, 0)]\ncnt = 0\nwhile stack:\n    (node, visited) = stack.pop()\n    if not visited:\n        cnt += 1\n        in_time[node] = cnt\n        stack.append((node, 1))\n        for v in adj[node]:\n            if v not in parent:\n                parent[v] = node\n                stack.append((v, 0))\n    else:\n        out_time[node] = cnt\nfor i in range(q):\n    query = list(map(int, input().split()))[1:]\n    (low, high) = (1, n)\n    for i in query:\n        (low, high) = (max(low, in_time[parent[i]]), min(high, out_time[parent[i]]))\n    print('YES' if low <= high else 'NO')", "import sys\ninput = sys.stdin.readline\n(n, q) = map(int, input().split())\nadj = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nparent = {1: 1}\nin_time = [0] * (n + 1)\nout_time = [0] * (n + 1)\nstack = [(1, 0)]\ncnt = 0\nwhile stack:\n    (node, visited) = stack.pop()\n    if not visited:\n        cnt += 1\n        in_time[node] = cnt\n        stack.append((node, 1))\n        for v in adj[node]:\n            if v not in parent:\n                parent[v] = node\n                stack.append((v, 0))\n    else:\n        out_time[node] = cnt\nfor i in range(q):\n    query = list(map(int, input().split()))[1:]\n    (low, high) = (1, n)\n    for i in query:\n        (low, high) = (max(low, in_time[parent[i]]), min(high, out_time[parent[i]]))\n    print('YES' if low <= high else 'NO')", "from collections import defaultdict, Counter, deque\nimport threading\nimport sys\ninput = sys.stdin.readline\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    (n, m) = rl()\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = rl()\n        g[u].append(v)\n        g[v].append(u)\n    global T\n    T = 0\n    tin = [-1] * (n + 1)\n    tou = [-1] * (n + 1)\n    dep = [-1] * (n + 1)\n    par = [-1] * (n + 1)\n\n    def dfs(cn, p, d):\n        global T\n        tin[cn] = T\n        dep[cn] = d\n        par[cn] = p\n        T += 1\n        for nn in g[cn]:\n            if nn != p:\n                dfs(nn, cn, d + 1)\n        tou[cn] = T\n        T += 1\n    dfs(1, -1, 0)\n    for q in range(m):\n        a = rl()\n        a = a[1:]\n        og = a[0]\n        for i in a:\n            if dep[i] > dep[og]:\n                og = i\n        for i in range(len(a)):\n            if a[i] == og:\n                continue\n            if par[a[i]] != -1:\n                a[i] = par[a[i]]\n        pos = True\n        for i in a:\n            pos &= tin[i] <= tin[og] and tou[i] >= tou[og]\n        print(['NO', 'YES'][pos])\n    pass\nthreading.Thread(target=main).start()", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\npre_tree = {1: 0}\ntin = [0] * (n + 1)\nom = [0] * (n + 1)\nee = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    ee[b].add(a)\n    ee[a].add(b)\nsk = [(1, 1)]\ncnt = 0\nwhile sk:\n    (ne, se) = sk.pop()\n    if se:\n        cnt += 1\n        tin[ne] = cnt\n        sk.append((ne, 0))\n        for child in ee[ne]:\n            if child not in pre_tree:\n                pre_tree[child] = ne\n                sk.append((child, 1))\n    else:\n        om[ne] = cnt\nfor _ in range(m):\n    (l, r) = (1, n)\n    q = list(map(int, input().split()))[1:]\n    for qy in q:\n        if qy != 1:\n            qy = pre_tree[qy]\n        (l, r) = (max(l, tin[qy]), min(r, om[qy]))\n    print('YES' if l <= r else 'NO')", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\nparent = {1: 0}\ninVertex = [0] * (n + 1)\noutVertex = [0] * (n + 1)\ngraph = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    graph[b].add(a)\n    graph[a].add(b)\nstack = [(1, 1)]\ncount = 0\nwhile stack:\n    (node, state) = stack.pop()\n    if state:\n        inVertex[node] = count = count + 1\n        stack.append((node, 0))\n        for nextnode in graph[node]:\n            if nextnode not in parent:\n                parent[nextnode] = node\n                stack.append((nextnode, 1))\n    else:\n        outVertex[node] = count\nfor _ in range(m):\n    (left, right) = (1, n)\n    querylist = list(map(int, input().split()))[1:]\n    for query in querylist:\n        if query != 1:\n            query = parent[query]\n        (left, right) = (max(left, inVertex[query]), min(right, outVertex[query]))\n    print('YES' if left <= right else 'NO')", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\npre = {1: 0}\ninnum = [0] * (n + 1)\noutnum = [0] * (n + 1)\nedge = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    edge[b].add(a)\n    edge[a].add(b)\nstack = [(1, 1)]\ncount = 0\nwhile stack:\n    (node, state) = stack.pop()\n    if state:\n        innum[node] = count = count + 1\n        stack.append((node, 0))\n        for nextnode in edge[node]:\n            if nextnode not in pre:\n                pre[nextnode] = node\n                stack.append((nextnode, 1))\n    else:\n        outnum[node] = count\nfor _ in range(m):\n    (left, right) = (1, n)\n    querylist = list(map(int, input().split()))[1:]\n    for query in querylist:\n        if query != 1:\n            query = pre[query]\n        (left, right) = (max(left, innum[query]), min(right, outnum[query]))\n    print('YES' if left <= right else 'NO')", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\npre = {1: 0}\ninnum = [0] * (n + 1)\noutnum = [0] * (n + 1)\nedge = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    edge[b].add(a)\n    edge[a].add(b)\nstack = [(1, 1)]\ncount = 0\nwhile stack:\n    (node, state) = stack.pop()\n    if state:\n        innum[node] = count = count + 1\n        stack.append((node, 0))\n        for nextnode in edge[node]:\n            if nextnode not in pre:\n                pre[nextnode] = node\n                stack.append((nextnode, 1))\n    else:\n        outnum[node] = count\nfor _ in range(m):\n    (left, right) = (1, n)\n    querylist = list(map(int, input().split()))[1:]\n    for query in querylist:\n        if query != 1:\n            query = pre[query]\n        (left, right) = (max(left, innum[query]), min(right, outnum[query]))\n    print('YES' if left <= right else 'NO')", "import sys\ninput = sys.stdin.readline\n(n, m) = map(int, input().split())\npre = {1: 0}\ninnum = [0] * (n + 1)\noutnum = [0] * (n + 1)\nedge = [set() for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    edge[b].add(a)\n    edge[a].add(b)\nstack = [(1, 1)]\ncount = 0\nwhile stack:\n    (node, state) = stack.pop()\n    if state:\n        innum[node] = count = count + 1\n        stack.append((node, 0))\n        for nextnode in edge[node]:\n            if nextnode not in pre:\n                pre[nextnode] = node\n                stack.append((nextnode, 1))\n    else:\n        outnum[node] = count\nfor _ in range(m):\n    (left, right) = (1, n)\n    querylist = list(map(int, input().split()))[1:]\n    for query in querylist:\n        if query != 1:\n            query = pre[query]\n        (left, right) = (max(left, innum[query]), min(right, outnum[query]))\n    print('YES' if left <= right else 'NO')", "import sys\ninput = sys.stdin.readline\n(n, m) = [int(i) for i in input().split()]\ngraph = [[] for i in range(n)]\nfor j in range(n - 1):\n    (v, u) = [int(i) - 1 for i in input().split()]\n    graph[v].append(u)\n    graph[u].append(v)\nparent = [0] * n\ntin = [0] * n\ntout = [0] * n\ntime = 0\nqueue = [(0, 0)]\nwhile queue:\n    (current, visit) = queue.pop()\n    if visit == 0:\n        queue.append((current, 1))\n        time += 1\n        tin[current] = time\n        for child in graph[current]:\n            if child != parent[current]:\n                parent[child] = current\n                queue.append((child, 0))\n    else:\n        tout[current] = time\nfor j in range(m):\n    q = [int(i) - 1 for i in input().split()]\n    q = q[1:]\n    cin = 1\n    cout = n\n    for i in range(len(q)):\n        q[i] = parent[q[i]]\n        cin = max(cin, tin[q[i]])\n        cout = min(cout, tout[q[i]])\n    if cin > cout:\n        print('NO')\n    else:\n        print('YES')", "import sys\ninput = sys.stdin.readline\n(n, m) = [int(i) for i in input().split()]\ngraph = [[] for i in range(n)]\nfor j in range(n - 1):\n    (v, u) = [int(i) - 1 for i in input().split()]\n    graph[v].append(u)\n    graph[u].append(v)\nparent = [0] * n\ntin = [0] * n\ntout = [0] * n\ntime = 0\nqueue = [(0, 0)]\nwhile queue:\n    (current, visit) = queue.pop()\n    if visit == 0:\n        queue.append((current, 1))\n        time += 1\n        tin[current] = time\n        for child in graph[current]:\n            if child != parent[current]:\n                parent[child] = current\n                queue.append((child, 0))\n    else:\n        tout[current] = time\nfor j in range(m):\n    q = [int(i) - 1 for i in input().split()]\n    q = q[1:]\n    for i in range(len(q)):\n        q[i] = parent[q[i]]\n    cin = 1\n    cout = n\n    for i in q:\n        cin = max(cin, tin[i])\n        cout = min(cout, tout[i])\n    if cin > cout:\n        print('NO')\n    else:\n        print('YES')", "import sys\ninput = sys.stdin.readline\n(n, m) = [int(i) for i in input().split()]\ngraph = [[] for i in range(n)]\ntemp = 0\nfor j in range(n - 1):\n    (uu, vv) = [int(i) - 1 for i in input().split()]\n    graph[uu].append(vv)\n    graph[vv].append(uu)\nparent = [0] * n\ntin = [0] * n\ntout = [0] * n\nstack = [(0, 0)]\ncnt = 0\nwhile stack:\n    (curr, state) = stack.pop()\n    if state == 0:\n        stack.append((curr, 1))\n        cnt += 1\n        tin[curr] = cnt\n        for child in graph[curr]:\n            if child != parent[curr]:\n                parent[child] = curr\n                stack.append((child, 0))\n    else:\n        tout[curr] = cnt\nfor j in range(m):\n    q = [int(i) - 1 for i in input().split()]\n    q = q[1:]\n    for i in range(len(q)):\n        q[i] = parent[q[i]]\n    cin = 1\n    cout = n\n    for i in q:\n        cin = max(cin, tin[i])\n        cout = min(cout, tout[i])\n    if cin > cout:\n        print('NO')\n    else:\n        print('YES')", "(n, m) = map(int, input().split())\nedges = (map(int, input().split()) for _ in range(n - 1))\ng = [[] for _ in range(n + 1)]\nfor (u, v) in edges:\n    g[u].append(v)\n    g[v].append(u)\ndepths = [-1] * (n + 1)\ndepths[1] = 0\npar = [-1] * (n + 1)\ntin = [-1] * (n + 1)\ntout = [-1] * (n + 1)\nstack = [1]\ncnt = 0\nwhile stack:\n    node = stack.pop()\n    if node < 0:\n        tout[-node] = cnt\n        cnt += 1\n        continue\n    stack.append(-node)\n    tin[node] = cnt\n    cnt += 1\n    for v in g[node]:\n        if depths[v] == -1:\n            depths[v] = depths[node] + 1\n            par[v] = node\n            stack.append(v)\nans = []\nfor _ in range(m):\n    ks = map(int, input().split())\n    p = 1\n    next(ks)\n    for u in sorted(set(map(par.__getitem__, ks)) - {-1, 1}, key=depths.__getitem__):\n        if not (tin[p] < tin[u] and tout[p] > tout[u]):\n            ans.append('NO')\n            break\n        p = u\n    else:\n        ans.append('YES')\nprint('\\n'.join(ans))"]