["import heapq\n\ndef func():\n    n = int(input())\n    l = list(map(int, input().split()))\n    pois = 0\n    health = 0\n    neg_pos = []\n    heapq.heapify(neg_pos)\n    for potion in l:\n        if potion >= 0:\n            pois += 1\n            health += potion\n        elif potion + health >= 0:\n            pois += 1\n            health += potion\n            heapq.heappush(neg_pos, potion)\n        elif neg_pos:\n            mn = neg_pos[0]\n            if potion > mn:\n                health = health - mn + potion\n                heapq.heapreplace(neg_pos, potion)\n    return pois\nt = 1\nfor i in range(t):\n    print(func())", "import heapq\nn = int(input())\npotions = list(map(int, input().split()))\nhp = result = 0\npoisons = []\nfor potion in potions:\n    if potion >= 0:\n        hp += potion\n        result += 1\n    elif hp + potion >= 0:\n        hp += potion\n        result += 1\n        heapq.heappush(poisons, potion)\n    else:\n        if not poisons:\n            continue\n        if potion > poisons[0]:\n            hp += potion - heapq.heappushpop(poisons, potion)\nprint(result)", "import sys\nimport heapq\n\ndef main():\n    size = int(sys.stdin.readline().split()[0])\n    a = [int(x) for x in sys.stdin.readline().split()]\n    heap = []\n    tot = 0\n    health = 0\n    for num in a:\n        if num >= 0:\n            tot += 1\n            health += num\n        else:\n            newHealth = health + num\n            if newHealth >= 0:\n                tot += 1\n                health = newHealth\n                heapq.heappush(heap, num)\n            elif len(heap) == 0 or num < heap[0]:\n                continue\n            else:\n                removed = heapq.heappop(heap)\n                heapq.heappush(heap, num)\n                health -= removed\n                health += num\n    print(tot)\nmain()", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nfrom math import inf, ceil, sqrt\nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nn = int(input())\na = list(map(int, input().split()))\nh = list()\nheapify(h)\n(s, r) = (0, 0)\nfor e in a:\n    if s + e >= 0:\n        (r, s) = (r + 1, s + e)\n        if e < 0:\n            heappush(h, e)\n    elif len(h) and h[0] < e:\n        s -= heappop(h)\n        heappush(h, e)\n        s += e\nprint(r)", "from collections import deque\nimport heapq\nfrom math import sqrt\nimport operator\nfrom operator import itemgetter\nimport sys\nimport copy\ninf_var = 0\nif inf_var == 1:\n    inf = open('input.txt', 'r')\nelse:\n    inf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n    return int(input().rstrip('\\n'))\n\ndef read_one_float():\n    return float(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n    res = [int(val) for val in input().rstrip('\\n').split()]\n    return res\n\ndef read_list_of_ints_zero():\n    return [int(val) - 1 for val in input().rstrip('\\n').split()]\n\ndef read_str():\n    return input().rstrip()\n\ndef main():\n    n = read_one_int()\n    elements = read_list_of_ints()\n    cur_sum = 0\n    res = 0\n    q = []\n    heapq.heapify(q)\n    for el in elements:\n        if cur_sum + el >= 0:\n            res += 1\n            cur_sum += el\n            if el < 0:\n                heapq.heappush(q, el)\n        elif not q:\n            continue\n        elif el > q[0]:\n            popped = heapq.heappop(q)\n            cur_sum -= popped\n            cur_sum += el\n            heapq.heappush(q, el)\n    print(res)\nmain()", "import heapq\nH = []\nn = int(input())\ntot = 0\nfor i in list(map(int, input().split())):\n    tot += i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq\ninput()\nH = []\ntotal = 0\nfor i in list(map(int, input().split())):\n    total += i\n    total -= (heapq.heappush(H, i) if total >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "from heapq import heappush, heappushpop\nn = int(input())\na = list(map(int, input().split()))\ncnt = 0\nx = 0\nh = []\nfor d in a:\n    if d >= 0:\n        x += d\n        cnt += 1\n        continue\n    if x + d >= 0:\n        x += d\n        cnt += 1\n        heappush(h, d)\n    elif h:\n        y = heappushpop(h, d)\n        x += d - y\nprint(cnt)", "import sys\nimport heapq\nN = int(sys.stdin.readline())\narr = list(map(int, sys.stdin.readline().strip().split()))\nans = []\nheapq.heapify(ans)\ntotal = 0\nfor item in arr:\n    total += item\n    if total < 0:\n        total -= heapq.heappushpop(ans, item)\n    else:\n        heapq.heappush(ans, item)\nprint(len(ans))", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nfrom math import inf, ceil, sqrt\nfrom collections import defaultdict\nfrom heapq import heappush, heappop, heapify\nn = int(input())\na = list(map(int, input().split()))\nh = list()\nheapify(h)\n(s, r) = (0, 0)\nfor e in a:\n    if s + e >= 0:\n        (r, s) = (r + 1, s + e)\n        if e < 0:\n            heappush(h, e)\n    elif len(h) and h[0] < e:\n        s -= heappop(h)\n        heappush(h, e)\n        s += e\nprint(r)", "import sys\nimport heapq\nread = sys.stdin.readline\n\ndef run_case():\n    n = int(read())\n    ar = list(map(int, read().split()))\n    heap = []\n    i = 0\n    s = 0\n    res = 0\n    while i < n:\n        if ar[i] >= 0:\n            s += ar[i]\n            i += 1\n            res += 1\n        else:\n            j = i\n            while j < n and ar[j] < 0:\n                j += 1\n            tr = ar[i:j]\n            i = j\n            tr.sort(reverse=True)\n            for t in tr:\n                if s + t >= 0:\n                    s += t\n                    res += 1\n                    heapq.heappush(heap, t)\n                elif len(heap) > 0 and heap[0] < t:\n                    s -= heap[0]\n                    res -= 1\n                    heapq.heappop(heap)\n                    s += t\n                    res += 1\n                    heapq.heappush(heap, t)\n                else:\n                    break\n    print(res)\nrun_case()", "import heapq\n\ndef solve():\n    heap = []\n    health = 0\n    potions = 0\n    for i in range(N):\n        if A[i] >= 0:\n            health += A[i]\n            potions += 1\n        elif health + A[i] >= 0:\n            heapq.heappush(heap, A[i])\n            health += A[i]\n            potions += 1\n        elif heap and heap[0] <= A[i]:\n            bad_potion = heapq.heappop(heap)\n            heapq.heappush(heap, A[i])\n            health += A[i] - bad_potion\n            assert health >= 0\n    return potions\nN = int(input())\nA = list(map(int, input().split()))\nprint(solve())", "import heapq\nn = int(input())\nw = [int(k) for k in input().split()]\nc = []\nres = 0\neta = 0\nfor j in range(n):\n    if w[j] >= 0:\n        eta += w[j]\n        res += 1\n    elif eta + w[j] >= 0:\n        eta += w[j]\n        res += 1\n        heapq.heappush(c, w[j])\n    elif c and w[j] > c[0]:\n        eta -= heapq.heappop(c)\n        eta += w[j]\n        heapq.heappush(c, w[j])\nprint(res)", "import heapq\nn = int(input())\nlis = list(map(int, input().split()))\nsumi = 0\nneg = []\ncount = 0\nfor i in range(n):\n    if sumi + lis[i] >= 0:\n        count += 1\n        sumi += lis[i]\n        if lis[i] < 0:\n            heapq.heappush(neg, lis[i])\n    elif len(neg) != 0 and neg[0] < lis[i]:\n        sumi -= heapq.heappop(neg)\n        sumi += lis[i]\n        heapq.heappush(neg, lis[i])\nprint(count)", "n = int(input())\nA = list(map(int, input().split()))\nimport heapq\ncur = 0\nprev = []\ncnt = 0\nfor x in A:\n    if x < 0:\n        if cur + x >= 0:\n            cur += x\n            heapq.heappush(prev, x)\n            cnt += 1\n        elif prev and prev[0] < x:\n            cur += x - prev[0]\n            heapq.heappop(prev)\n            heapq.heappush(prev, x)\n    else:\n        cur += x\n        cnt += 1\nprint(cnt)", "import heapq\nI = input\nIN = lambda x: map(int, x.split())\nL = lambda x: list(IN(x))\nn = int(I())\na = L(I())\nj = 0\nd = []\ns = 0\nfor i in a:\n    s += i\n    if s < 0:\n        s -= heapq.heappushpop(d, i)\n        j += 1\n    elif i < 0:\n        heapq.heappush(d, i)\nprint(n - j)", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq as hq\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    h = 0\n    arr = []\n    for i in range(n):\n        h += a[i]\n        hq.heappush(arr, a[i])\n        while h < 0:\n            h -= hq.heappop(arr)\n    print(len(arr))\nfor _ in range(1):\n    solve()", "import sys, heapq\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\ns = 0\nl = []\nans = 0\nfor i in range(n):\n    if a[i] >= 0:\n        s += a[i]\n        ans += 1\n    elif s + a[i] >= 0:\n        heapq.heappush(l, a[i])\n        s += a[i]\n        ans += 1\n    elif len(l) > 0:\n        if a[i] > l[0]:\n            s += a[i] - l[0]\n            heapq.heappop(l)\n            heapq.heappush(l, a[i])\n        else:\n            continue\nprint(ans)", "from heapq import heapify, heappush, heappop\n\ndef T():\n    return int(input())\n\ndef S():\n    return str(input())\n\ndef A():\n    return list(map(int, input().split(' ')))\n\ndef M():\n    return map(int, input().split(' '))\nn = T()\nheap = []\nheapify(heap)\narr = A()\ntotal = 0\ncount = 0\nfor i in arr:\n    total += i\n    heappush(heap, i)\n    while total < 0:\n        total -= heappop(heap)\nprint(len(heap))", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "from collections import defaultdict\nimport heapq\nfrom sys import stdin\ninput = stdin.readline\n\ndef f(a):\n    s = 0\n    q = []\n    for i in a:\n        s += i\n        heapq.heappush(q, i)\n        if s < 0:\n            l = heapq.heappop(q)\n            s -= l\n    return len(q)\na = input()\nlst = list(map(int, input().strip().split()))\nprint(f(lst))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\npq = []\ncurr = 0\ncount = 0\nfor ele in arr:\n    if ele >= 0:\n        curr += ele\n        count += 1\n    elif curr + ele >= 0:\n        curr += ele\n        heapq.heappush(pq, ele)\n        count += 1\n    elif pq and pq[0] < ele:\n        curr -= heapq.heappop(pq)\n        heapq.heappush(pq, ele)\n        curr += ele\nprint(count)", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nans = 0\nq = []\ns = 0\nfor i in range(n):\n    if s + arr[i] >= 0:\n        ans += 1\n        s += arr[i]\n        if arr[i] < 0:\n            heapq.heappush(q, arr[i])\n    elif len(q) and q[0] < arr[i]:\n        value = heapq.heappop(q)\n        heapq.heappush(q, arr[i])\n        s -= value\n        s += arr[i]\nprint(ans)", "import heapq\n\ndef get_max_potions(potions):\n    taken_potions = []\n    total = 0\n    for p in potions:\n        total += p\n        heapq.heappush(taken_potions, p)\n        while total < 0:\n            total -= heapq.heappop(taken_potions)\n    return len(taken_potions)\nn = int(input())\npotions = list(map(int, input().split()))\nresult = get_max_potions(potions)\nprint(result)", "import heapq\n\ndef sol(A):\n    li = []\n    h = 0\n    count = 0\n    for i in range(len(A)):\n        if h + A[i] >= 0:\n            count += 1\n            h += A[i]\n            if A[i] < 0:\n                heapq.heappush(li, A[i])\n        elif li and li[0] < A[i]:\n            h -= li[0]\n            h += A[i]\n            heapq.heapreplace(li, A[i])\n    return count\nx = int(input())\nA = list(map(int, input().split()))\nprint(sol(A))", "import heapq\nh = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(h, i) if tot >= 0 else heapq.heappushpop(h, i)) or 0\nprint(len(h))", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "from heapq import *\nfrom sys import stdin\ninput = stdin.readline\nn = int(input())\nlst = list(map(int, input().split()))\n(hp, arr) = (0, [])\nfor i in lst:\n    hp += i\n    heappush(arr, i)\n    if hp < 0:\n        hp -= heappop(arr)\nprint(len(arr))", "import heapq\nn = int(input())\na = list(map(int, input().split()))\ns = 0\nh = []\nfor i in a:\n    s += i\n    heapq.heappush(h, i)\n    if s < 0:\n        s -= heapq.heappop(h)\nprint(len(h))", "import heapq\nn = int(input())\npotions = list(map(int, input().split()))\nminH = []\nhealth = 0\nres = 0\nfor p in potions:\n    health += p\n    if health >= 0:\n        res += 1\n    if p >= 0:\n        continue\n    heapq.heappush(minH, p)\n    if health < 0:\n        min_val = heapq.heappop(minH)\n        health -= min_val\nprint(res)", "import heapq\na = []\nn = int(input())\nar = list(map(int, input().split()))\nhealth = 0\ncnt = 0\nfor v in ar:\n    if v >= 0:\n        cnt += 1\n        health += v\n    elif health + v >= 0:\n        cnt += 1\n        heapq.heappush(a, v)\n        health += v\n    elif a:\n        t = heapq.heappop(a)\n        if t < v:\n            health -= t\n            health += v\n            heapq.heappush(a, v)\n        else:\n            heapq.heappush(a, t)\nprint(cnt)", "import heapq\nn = int(input())\nlis = list(map(int, input().split()))\nl = list()\nsum = 0\nfor i in lis:\n    sum += i\n    heapq.heappush(l, i)\n    while sum < 0:\n        sum -= heapq.heappop(l)\nprint(len(l))", "from heapq import heappush, heapify, heappop\n\ndef numberOfPotions(potion):\n    heap = []\n    heapify(heap)\n    health = 0\n    for i in potion:\n        heappush(heap, i)\n        health += i\n        if health < 0:\n            health -= heappop(heap)\n    return len(heap)\nn = int(input())\npotion = list(map(int, input().split()))\nprint(numberOfPotions(potion))", "import heapq\nn = int(input())\npotion = list(map(int, input().split()))\n(nowhp, ans) = (0, 0)\nminheap = []\nfor i in range(n):\n    if potion[i] >= 0:\n        nowhp = nowhp + potion[i]\n        ans = ans + 1\n        continue\n    elif nowhp + potion[i] >= 0:\n        nowhp = nowhp + potion[i]\n        ans = ans + 1\n        heapq.heappush(minheap, potion[i])\n        continue\n    elif len(minheap) == 0 or potion[i] < minheap[0]:\n        continue\n    else:\n        nowhp = nowhp - minheap[0] + potion[i]\n        heapq.heappop(minheap)\n        heapq.heappush(minheap, potion[i])\nprint(ans)", "import sys\nfrom heapq import heappop, heappush\nn = int(sys.stdin.readline())\ndata = list(map(int, sys.stdin.readline().split()))\nans = []\ncnt = 0\nfor item in data:\n    cnt += item\n    heappush(ans, item)\n    if cnt < 0:\n        temp = heappop(ans)\n        cnt -= temp\nprint(len(ans))", "n = int(input())\nelems = [int(x) for x in input().split()]\npotions = []\nimport heapq as heap\nheap.heapify(potions)\nlife = 0\nfor i in elems:\n    life += i\n    heap.heappush(potions, i)\n    if life < 0:\n        life -= potions[0]\n        heap.heappop(potions)\nprint(len(potions))", "import heapq\nn = int(input())\nd = [int(p) for p in input().split()]\nheap = []\nhealth = 0\nfor item in d:\n    health += item\n    heapq.heappush(heap, item)\n    if health < 0:\n        health -= heapq.heappop(heap)\nprint(len(heap))", "import heapq\ni = int(input())\n(h, t) = ([], 0)\nfor x in list(map(int, input().split())):\n    heapq.heappush(h, x)\n    t += x\n    while t < 0:\n        t -= heapq.heappop(h)\nprint(len(h))", "import heapq\nq = []\nn = int(input())\nar = list(map(int, input().split()))\nhealth = 0\ncnt = 0\nfor v in ar:\n    if v >= 0:\n        cnt += 1\n        health += v\n    elif health + v >= 0:\n        cnt += 1\n        heapq.heappush(q, v)\n        health += v\n    elif q:\n        t = heapq.heappop(q)\n        if t < v:\n            health -= t\n            health += v\n            heapq.heappush(q, v)\n        else:\n            heapq.heappush(q, t)\nprint(cnt)", "import heapq\na = []\nn = int(input())\nar = list(map(int, input().split()))\nhealth = 0\ncnt = 0\nfor v in ar:\n    if v >= 0:\n        cnt += 1\n        health += v\n    elif health + v >= 0:\n        cnt += 1\n        heapq.heappush(a, v)\n        health += v\n    elif a:\n        t = heapq.heappop(a)\n        if t < v:\n            health -= t\n            health += v\n            heapq.heappush(a, v)\n        else:\n            heapq.heappush(a, t)\nprint(cnt)", "from heapq import heappop, heappush\nn = int(input())\na = [int(x) for x in input().split()]\ncnt = 0\nh = []\nhealth = 0\nfor i in a:\n    health += i\n    cnt += 1\n    if i < 0:\n        heappush(h, i)\n    while health < 0 and h:\n        health -= heappop(h)\n        cnt -= 1\nprint(cnt)", "import heapq\nn = int(input())\na = [*map(int, input().split())]\n(h, t) = ([], 0)\nfor i in a:\n    t += i\n    heapq.heappush(h, i)\n    while t < 0:\n        t -= heapq.heappop(h)\nprint(len(h))", "from heapq import *\nn = int(input())\na = [int(x) for x in input().split()]\nh = []\nS = 0\nfor x in a:\n    S += x\n    heappush(h, x)\n    while S < 0:\n        S -= heappop(h)\nprint(len(h))", "import sys\nimport heapq\n\ndef solve(nums):\n    sum = 0\n    q = []\n    removed = 0\n    for num in nums:\n        sum += num\n        heapq.heappush(q, num)\n        if sum < 0:\n            sum -= heapq.heappop(q)\n            removed += 1\n    return len(nums) - removed\n\ndef main():\n    stdin = sys.stdin\n    stdin.readline()\n    print(solve(list(map(int, stdin.readline().strip().split(' ')))))\nmain()", "import heapq\nH = []\nn = int(input())\nfor i in list(map(int, input().split())):\n    tot = tot + i if 'tot' in locals() or 'tot' in globals() else i\n    tot -= (heapq.heappush(H, i) if tot >= 0 else heapq.heappushpop(H, i)) or 0\nprint(len(H))", "import heapq\nn = int(input())\na = [*map(int, input().split())]\n(h, t) = ([], 0)\nfor i in a:\n    t += i\n    heapq.heappush(h, i)\n    while t < 0:\n        t -= heapq.heappop(h)\nprint(len(h))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nH = []\ntot = 0\nfor i in arr:\n    tot += i\n    heapq.heappush(H, i)\n    while tot < 0:\n        tot -= H[0]\n        heapq.heappop(H)\nprint(len(H))", "import heapq\nimport sys\n\ndef solve(l):\n    (c, s) = (0, 0)\n    k = []\n    heapq.heapify(k)\n    for i in range(len(l)):\n        if l[i] >= 0:\n            s = s + l[i]\n            c = c + 1\n        else:\n            heapq.heappush(k, l[i])\n            s = s + l[i]\n            c = c + 1\n            while s < 0:\n                s = s - heapq.heappop(k)\n                c = c - 1\n    return c\nn = int(sys.stdin.readline())\nl = list(map(int, sys.stdin.readline().split()))\nprint(solve(l))", "from heapq import *\nn = int(input())\narr = list(map(int, input().split()))\nh = []\nheapify(h)\ns = 0\nfor i in arr:\n    s += i\n    heappush(h, i)\n    while s < 0:\n        s -= h[0]\n        heappop(h)\nprint(len(h))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nH = []\ntot = 0\nfor i in arr:\n    tot += i\n    heapq.heappush(H, i)\n    while tot < 0:\n        tot -= H[0]\n        heapq.heappop(H)\nprint(len(H))", "import heapq\nn = int(input())\nlis = list(map(int, input().split()))\nl = list()\nsum = 0\nfor i in lis:\n    sum += i\n    heapq.heappush(l, i)\n    while sum < 0:\n        sum -= heapq.heappop(l)\nprint(len(l))", "import sys\nimport heapq\nn = int(sys.stdin.readline())\nnums = list(map(int, sys.stdin.readline().split()))\nsu = 0\nh = []\nans = 0\nfor i in nums:\n    su += i\n    heapq.heappush(h, i)\n    if su < 0:\n        su -= heapq.heappop(h)\n    else:\n        ans += 1\nprint(ans)", "import math\nimport heapq\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().strip().split()))\n    for i in range(n):\n        if arr[i] >= 0:\n            arr = arr[i:n + 1]\n            n = len(arr)\n            break\n    heap = []\n    S = 0\n    ans = 0\n    for i in range(n):\n        if arr[i] < 0:\n            heapq.heappush(heap, arr[i])\n        S += arr[i]\n        ans += 1\n        while S < 0:\n            a = heapq.heappop(heap)\n            ans -= 1\n            S -= a\n    return ans\nprint(solve())", "import heapq as hp\nn = int(input())\narr = list(map(int, input().split()))\ns = 0\nres = []\nhp.heapify(res)\nfor i in arr:\n    if i < 0:\n        hp.heappush(res, i)\n    s += i\n    if s < 0:\n        s -= hp.heappop(res)\n        n -= 1\nprint(n)", "from heapq import heappop, heappush\nn = int(input())\na = [int(x) for x in input().split()]\ncnt = 0\nhealth = 0\nh = []\nfor i in a:\n    health += i\n    cnt += 1\n    if i < 0:\n        heappush(h, i)\n    while health < 0 and h:\n        health -= heappop(h)\n        cnt -= 1\nprint(cnt)", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\ntemp = []\ntotal = 0\npotions = 0\nfor i in arr:\n    if i < 0:\n        heapq.heappush(temp, i)\n    total += i\n    potions += 1\n    while total < 0:\n        total -= heapq.heappop(temp)\n        potions -= 1\nprint(potions)", "import heapq\nn = int(input())\na = list(map(int, input().split()))\nserved = []\nsum_ = 0\nfor i in range(n):\n    heapq.heappush(served, a[i])\n    sum_ += a[i]\n    if sum_ < 0:\n        sum_ -= heapq.heappop(served)\nprint(len(served))", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nH = []\ntot = 0\nfor i in arr:\n    tot += i\n    heapq.heappush(H, i)\n    while tot < 0:\n        tot -= H[0]\n        heapq.heappop(H)\nprint(len(H))", "import math\nimport re\nimport sys\nMOD = 1000000007\ninp = lambda : map(int, input().split(' '))\nninp = lambda : int(input())\nimport heapq\nn = ninp()\na = list(inp())\nans = list()\nres = 0\nfor i in a:\n    res += i\n    heapq.heappush(ans, i)\n    while res < 0:\n        res -= ans[0]\n        heapq.heappop(ans)\nprint(len(ans))", "import heapq\nn = int(input())\nl = [int(x) for x in input().split()]\nans = 0\ncount = 0\nx = []\nheapq.heapify(x)\nfor i in range(n):\n    ans += l[i]\n    heapq.heappush(x, l[i])\n    while ans < 0:\n        ans = ans - heapq.heappop(x)\nprint(len(x))", "from heapq import *\nn = int(input())\na = list(map(int, input().split()))\nb = []\nheapify(b)\nans = 0\ns = 0\nfor i in range(n):\n    if a[i] >= 0:\n        ans += 1\n        s += a[i]\n    elif s + a[i] >= 0:\n        ans += 1\n        s += a[i]\n        heappush(b, a[i])\n    elif b:\n        s -= heappushpop(b, a[i])\n        s += a[i]\nprint(ans)", "import heapq\nn = int(input())\nlis = list(map(int, input().split()))\nans = 0\narr = list()\nfor i in lis:\n    ans += i\n    heapq.heappush(arr, i)\n    while ans < 0:\n        ans -= heapq.heappop(arr)\nprint(len(arr))", "n = int(input())\nlis = list(map(int, input().split()))\nans = 0\narr = list()\nimport heapq\nfor i in lis:\n    ans += i\n    heapq.heappush(arr, i)\n    while ans < 0:\n        ans -= heapq.heappop(arr)\nprint(len(arr))", "import heapq\nn = int(input())\nd = [int(p) for p in input().split()]\nheap = []\nhealth = 0\nfor item in d:\n    health += item\n    heapq.heappush(heap, item)\n    while health < 0:\n        health -= heapq.heappop(heap)\nprint(len(heap))", "import heapq\nn = int(input())\nheap = []\ns = 0\nheapq.heapify(heap)\nfor i in list(map(int, input().split())):\n    heapq.heappush(heap, i)\n    s += i\n    while s < 0:\n        s -= heapq.heappop(heap)\nprint(len(heap))", "import heapq\nheap = []\nn = int(input())\narr = list(map(int, input().split()))\nsum1 = 0\ncount = 0\nfor i in range(n):\n    sum1 += arr[i]\n    heapq.heappush(heap, arr[i])\n    count += 1\n    while sum1 < 0:\n        ele = heapq.heappop(heap)\n        sum1 -= ele\n        count -= 1\nprint(count)", "import heapq\nn = int(input())\na = list(map(int, input().split()))\npq = []\ns = 0\nfor i in range(n):\n    s += a[i]\n    heapq.heappush(pq, a[i])\n    while s < 0:\n        s -= heapq.heappop(pq)\nprint(len(pq))", "import heapq\nn = int(input())\nl = [int(x) for x in input().split()]\nans = 0\ns = 0\nh = []\nheapq.heapify(h)\nfor i in l:\n    s += i\n    ans += 1\n    if i < 0:\n        heapq.heappush(h, i)\n    while s < 0 and len(l):\n        s -= heapq.heappop(h)\n        ans -= 1\nprint(ans)", "import heapq\nn = int(input())\ndrinkings = [int(item) for item in input().split(' ')]\nhealth = 0\ndrinks = []\nfor i in range(n):\n    health += drinkings[i]\n    heapq.heappush(drinks, drinkings[i])\n    if health < 0:\n        Min = heapq.heappop(drinks)\n        health -= Min\nprint(len(drinks))", "import heapq as h\nn = int(input())\nl = list(map(int, input().split()))\nk = 0\na = 0\nz = []\nfor i in l:\n    if i < 0:\n        h.heappush(z, i)\n    if k + i >= 0:\n        k += i\n        a += 1\n    else:\n        k -= h.heappop(z)\n        k += i\nprint(a)", "import heapq\nn = int(input())\npotions = tuple(map(int, input().split()))\nhealth = 0\nres = 0\nheap = []\nfor potion in potions:\n    res += 1\n    if potion < 0:\n        heapq.heappush(heap, potion)\n    health += potion\n    if health < 0:\n        health -= heapq.heappop(heap)\n        res -= 1\nprint(res)", "import heapq as hp\nn = int(input())\narr = list(map(int, input().split()))\ns = 0\nres = []\nhp.heapify(res)\nfor i in arr:\n    if i < 0:\n        hp.heappush(res, i)\n    s += i\n    if s < 0:\n        s -= hp.heappop(res)\n        n -= 1\nprint(n)", "import heapq as h\nn = int(input())\nl = list(map(int, input().split()))\nk = 0\na = 0\nz = []\nfor i in l:\n    if i < 0:\n        h.heappush(z, i)\n    if k + i >= 0:\n        k += i\n        a += 1\n    else:\n        k -= h.heappop(z)\n        k += i\nprint(a)", "import heapq\nn = int(input())\narr = list(map(int, input().split()))\nsumi = 0\nans = []\nfor i in arr:\n    sumi += i\n    heapq.heappush(ans, i)\n    while sumi < 0:\n        sumi -= ans[0]\n        heapq.heappop(ans)\nprint(len(ans))", "n = int(input())\narr = list(map(int, input().split()))\nheap = []\nfrom heapq import heappop, heappush\ncur = 0\nfor x in range(n):\n    cur += arr[x]\n    heappush(heap, arr[x])\n    while cur < 0:\n        k = heappop(heap)\n        cur += -k\nprint(len(heap))", "import heapq as h\nn = int(input())\na = list(map(int, input().split()))\nl = []\nx = 0\nfor i in range(n):\n    x = x + a[i]\n    h.heappush(l, a[i])\n    if x < 0:\n        x = x - h.heappop(l)\nprint(len(l))", "from heapq import heappushpop, heappush\nn = int(input())\ntotal = 0\nans = 0\npotions = []\nfor i in map(int, input().split()):\n    if total + i < 0:\n        if len(potions):\n            old_potion = heappushpop(potions, i)\n            total -= old_potion\n            total += i\n    else:\n        if i < 0:\n            heappush(potions, i)\n        total += i\n        ans += 1\nprint(ans)", "import heapq\n\ndef func(i, num):\n    count = 0\n    total = 0\n    heap = list()\n    for i in range(n):\n        count += a[i]\n        total += 1\n        heapq.heappush(heap, a[i])\n        while count < 0:\n            poison = heapq.heappop(heap)\n            count -= poison\n            total -= 1\n    print(total)\nn = int(input())\na = list(map(int, input().split()))\nfunc(n - 1, 0)", "from heapq import heappush, heappop\nn = int(input())\nl = [int(x) for x in input().split()]\ncnt = 0\nhealth = 0\nh = []\nfor i in l:\n    if i < 0:\n        heappush(h, i)\n    cnt += 1\n    health += i\n    while health < 0 and h:\n        t = -heappop(h)\n        health += t\n        cnt -= 1\nprint(cnt)", "from heapq import heappush, heappop\nn = int(input())\nl = [int(x) for x in input().split()]\narr = l\nheap = []\ns = 0\ncount = 0\nfor i in range(len(arr)):\n    s += arr[i]\n    count += 1\n    heappush(heap, arr[i])\n    while s < 0:\n        m = heappop(heap)\n        s -= m\n        count -= 1\nprint(count)", "import heapq\nn = int(input())\nl = list(map(int, input().split()))\narr = l\nheap = []\ns = 0\ncount = 0\nfor i in range(len(arr)):\n    s += arr[i]\n    count += 1\n    heapq.heappush(heap, arr[i])\n    while s < 0:\n        m = heapq.heappop(heap)\n        s -= m\n        count -= 1\nprint(count)", "import heapq\nn = int(input())\nl = list(map(int, input().split()))\nhp = []\nheapq.heapify(hp)\ncnt = 0\ncur = 0\nfor i in range(n):\n    if l[i] >= 0:\n        cur += l[i]\n        cnt += 1\n    elif cur + l[i] >= 0:\n        cur += l[i]\n        heapq.heappush(hp, l[i])\n    elif len(hp) > 0:\n        x = heapq.heappop(hp)\n        if x < l[i]:\n            cur += -x\n            cur += l[i]\n            heapq.heappush(hp, l[i])\n        else:\n            heapq.heappush(hp, x)\nprint(cnt + len(hp))", "import heapq\nn = int(input())\nl = list(map(int, input().split()))\nd = []\nsum = 0\nfor i in l:\n    sum += i\n    heapq.heappush(d, i)\n    if sum < 0:\n        c = heapq.heappop(d)\n        sum -= c\nprint(len(d))", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\ninf = int(10 ** 20)\nmax_val = inf\nmin_val = -inf\nRW = lambda : sys.stdin.readline().strip()\nRI = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\nimport heapq\nlens = RI()\narrs = RMI()\nsum_now = 0\ndrop = []\nheapq.heapify(drop)\nfor i in arrs:\n    if i < 0:\n        heapq.heappush(drop, i)\n    sum_now += i\n    if sum_now < 0:\n        sum_now -= heapq.heappop(drop)\n        lens -= 1\nprint(lens)", "import heapq\nn = int(input())\na = list(map(int, input().split()))\nans = 0\nsum_ = 0\nlst = []\nheapq.heapify(lst)\nfor i in range(n):\n    if a[i] >= 0:\n        sum_ += a[i]\n        ans += 1\n    elif sum_ + a[i] >= 0:\n        sum_ += a[i]\n        heapq.heappush(lst, a[i])\n        ans += 1\n    elif len(lst) != 0:\n        min_ = heapq.heappop(lst)\n        if min_ > a[i]:\n            heapq.heappush(lst, min_)\n        else:\n            heapq.heappush(lst, a[i])\n            sum_ += a[i] - min_\nprint(ans)", "from heapq import heapify, heappush, heappop\nn = int(input())\narr = list(map(int, input().split()))\nheap = []\nheapify(heap)\n_sum = 0\nans = 0\nfor i in range(n):\n    _sum += arr[i]\n    heappush(heap, arr[i])\n    ans += 1\n    while _sum < 0:\n        pop = heappop(heap)\n        _sum -= pop\n        ans -= 1\nprint(ans)", "import heapq\ninput()\nb = list(map(int, input().split()))\n(s, a) = (0, [])\nfor x in b:\n    heapq.heappush(a, x)\n    s += x\n    while s < 0:\n        s -= a[0]\n        heapq.heappop(a)\nprint(len(a))", "import heapq\nn = int(input())\nl = [int(x) for x in input().split()]\narr = l\nheap = []\ns = 0\ncount = 0\nfor i in range(len(arr)):\n    s += arr[i]\n    count += 1\n    heapq.heappush(heap, arr[i])\n    while s < 0:\n        m = heapq.heappop(heap)\n        s -= m\n        count -= 1\nprint(count)", "import heapq\nn = int(input())\na = [int(d) for d in input().split()]\nd = []\nx = 0\nfor i in a:\n    heapq.heappush(d, i)\n    x = x + i\n    if x < 0:\n        c = heapq.heappop(d)\n        x = x - c\nprint(len(d))", "n = int(input())\narr = []\ninp = input().split()\nfor i in inp:\n    arr.append(int(i))\nsum1 = 0\nresult = []\ncount = 0\nimport heapq\narr1 = []\nfor i in arr:\n    sum1 += i\n    count += 1\n    if i < 0:\n        heapq.heappush(arr1, i)\n    if sum1 < 0:\n        while sum1 < 0:\n            s = heapq.heappop(arr1)\n            sum1 -= s\n            count -= 1\nprint(count)", "from heapq import heappop, heappush, heapify\nn = int(input())\na = list(map(int, input().split()))\nheap = []\ncnt = 0\nans = 0\nfor i in range(n):\n    ans += a[i]\n    cnt += 1\n    if a[i] < 0:\n        heappush(heap, a[i])\n    if ans < 0:\n        temp = -1 * heappop(heap)\n        cnt -= 1\n        ans += temp\nprint(cnt)", "import sys\nimport heapq\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().rstrip().split(' ')))\nB = [0]\nheapq.heapify(B)\nhealth = 0\nfor a in A:\n    if health + a < 0:\n        b = heapq.heappop(B)\n        health -= b\n        a = max(a, b)\n    heapq.heappush(B, a)\n    health += a\nprint(len(B) - 1)", "from heapq import heapify, heappush, heappop\nn = int(input())\nl = list(map(int, input().split()))\nheap = []\nheapify(heap)\nans = 0\na = 0\nfor i in range(n):\n    a += l[i]\n    ans += 1\n    heappush(heap, l[i])\n    while a < 0:\n        a -= heappop(heap)\n        ans -= 1\nprint(ans)", "from heapq import heappop, heappush\nn = int(input())\nnums = list(map(int, input().split()))\nl = []\ncount = 0\nx = 0\nfor (i, val) in enumerate(nums):\n    x += val\n    count += 1\n    if val < 0:\n        heappush(l, val)\n    while x < 0:\n        p = heappop(l)\n        x -= p\n        count -= 1\nprint(count)", "import calendar\nfrom heapq import *\nn = int(input())\ninp = list(map(int, input().split()))\nh = []\n(ans, tot) = (0, 0)\nfor x in inp:\n    tot += x\n    heappush(h, x)\n    while tot < 0:\n        tot -= heappop(h)\nprint(len(h))", "n = int(input())\na = list(map(int, input().split()))\nimport heapq\nl = []\nheapq.heapify(l)\nans = 0\ns = 0\nfor i in range(0, len(a)):\n    if a[i] < 0:\n        heapq.heappush(l, a[i])\n    s += a[i]\n    if s < 0:\n        ans += 1\n        k = heapq.heappop(l)\n        s -= k\nprint(len(a) - ans)"]