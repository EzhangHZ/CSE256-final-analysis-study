["import math, sys\nq = 1\nn = int(sys.stdin.readline())\nlines = sys.stdin.readlines()\nfor _ in range(q):\n    count = [0] * 100005\n    arr = []\n    for line in lines:\n        (a, b) = map(int, line.split())\n        count[a] += 1\n        count[b] += 1\n        arr.append([a, b])\n    ans = []\n    u = 0\n    v = n - 2\n    for i in range(len(arr)):\n        if count[arr[i][0]] == 1 or count[arr[i][1]] == 1:\n            ans.append(u)\n            u += 1\n        else:\n            ans.append(v)\n            v -= 1\n    print('\\n'.join(list(map(str, ans))))", "n = int(input())\nnodes = [[] for _ in range(n + 2)]\nfor i in range(n - 1):\n    (a, b) = [int(x) for x in input().split()]\n    nodes[a].append(i)\n    nodes[b].append(i)\nmax_node = max(range(1, n + 1), key=lambda x: len(nodes[x]))\nans = [None] * (n - 1)\ncur = 0\nfor i in nodes[max_node]:\n    ans[i] = cur\n    cur += 1\nfor i in range(n - 1):\n    if ans[i] is None:\n        ans[i] = cur\n        cur += 1\nprint('\\n'.join([str(x) for x in ans]))", "n = int(input())\nnodes = [[] for _ in range(n + 2)]\nfor i in range(n - 1):\n    (a, b) = [int(x) for x in input().split()]\n    nodes[a].append(i)\n    nodes[b].append(i)\nmax_node = max(range(1, n + 1), key=lambda x: len(nodes[x]))\nans = [None] * (n - 1)\ncur = 0\nfor i in nodes[max_node]:\n    ans[i] = cur\n    cur += 1\nfor i in range(n - 1):\n    if ans[i] is None:\n        ans[i] = cur\n        cur += 1\nprint('\\n'.join([str(x) for x in ans]))", "def main():\n    n = int(input())\n    turns = []\n    dct = dict()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        turns.append([a, b])\n        if a in dct:\n            dct[a] += 1\n        else:\n            dct[a] = 1\n        if b in dct:\n            dct[b] += 1\n        else:\n            dct[b] = 1\n    to_spec = 0\n    for i in dct:\n        if dct[i] == 1:\n            to_spec += 1\n    to_add1 = 0\n    line = ''\n    for i in turns:\n        if dct[i[0]] == 1 or dct[i[1]] == 1:\n            line += str(to_add1) + '\\n'\n            to_add1 += 1\n        else:\n            line += str(to_spec) + '\\n'\n            to_spec += 1\n    print(line)\nt = 1\nfor i in range(t):\n    main()", "def main():\n    data = input().rstrip().split()\n    n = int(data[0])\n    edges = []\n    g = list(([] for _ in range(n)))\n    leafes = list((False for _ in range(n)))\n    counter = 0\n    for _ in range(n - 1):\n        (a, b) = sorted(map(int, input().split()))\n        (a, b) = (a - 1, b - 1)\n        edges.append((a, b))\n        g[a].append(b)\n        g[b].append(a)\n    for (k, v) in enumerate(g):\n        if counter == 3:\n            break\n        if len(v) == 1:\n            leafes[k] = True\n            counter += 1\n    l_counter = 0\n    to_print = []\n    for edge in edges:\n        (a, b) = edge\n        if leafes[a] or leafes[b]:\n            to_print.append(l_counter)\n            l_counter += 1\n        else:\n            to_print.append(counter)\n            counter += 1\n    print('\\n'.join((str(foo) for foo in to_print)))\nmain()", "import os\nimport sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log\nfrom collections import defaultdict, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom itertools import combinations\nsys.setrecursionlimit(100000000)\nint_inp = lambda : int(input())\nstrng = lambda : input().strip()\njn = lambda x, l: x.join(map(str, l))\nstrl = lambda : list(input().strip())\nmul = lambda : map(int, input().strip().split())\nmulf = lambda : map(float, input().strip().split())\nseq = lambda : list(map(int, input().strip().split()))\nceil = lambda x: int(x) if x == int(x) else int(x) + 1\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nflush = lambda : stdout.flush()\nstdstr = lambda : stdin.readline()\nstdint = lambda : int(stdin.readline())\nstdpr = lambda x: stdout.write(str(x))\nmod = 1000000007\n\ndef solve():\n    n = int_inp()\n    g = [0] * (n + 1)\n    l = []\n    for i in range(n - 1):\n        (a, b) = mul()\n        a -= 1\n        b -= 1\n        g[a] += 1\n        g[b] += 1\n        l.append([a, b])\n    start = 0\n    end = n - 2\n    for (a, b) in l:\n        if g[a] == 1 or g[b] == 1:\n            print(start)\n            start += 1\n        else:\n            print(end)\n            end -= 1\nsolve()", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "import math\nq = 1\nfor _ in range(q):\n    n = int(input())\n    count = [0] * 100005\n    arr = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        count[a] += 1\n        count[b] += 1\n        arr.append([a, b])\n    ans = []\n    u = 0\n    v = n - 2\n    for i in range(len(arr)):\n        if count[arr[i][0]] == 1 or count[arr[i][1]] == 1:\n            ans.append(u)\n            u += 1\n        else:\n            ans.append(v)\n            v -= 1\n    print('\\n'.join(list(map(str, ans))))", "n = int(input())\ndegree = [0] * n\nedges = []\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    u -= 1\n    v -= 1\n    degree[u] += 1\n    degree[v] += 1\n    edges.append((u, v))\nlabel = [None] * (n - 1)\nroot = max(range(n), key=degree.__getitem__)\ncount = 0\nfor i in range(n - 1):\n    if root in edges[i]:\n        label[i] = count\n        count += 1\nfor i in range(n - 1):\n    if label[i] is None:\n        label[i] = count\n        count += 1\nfor x in label:\n    print(x)", "import math\nq = 1\nfor _ in range(q):\n    n = int(input())\n    count = [0] * 100005\n    arr = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        count[a] += 1\n        count[b] += 1\n        arr.append([a, b])\n    ans = []\n    u = 0\n    v = n - 2\n    for i in range(len(arr)):\n        if count[arr[i][0]] == 1 or count[arr[i][1]] == 1:\n            ans.append(str(u))\n            u += 1\n        else:\n            ans.append(str(v))\n            v -= 1\n    print('\\n'.join(ans))", "from sys import stdin\ntry:\n    n = int(stdin.readline().rstrip())\n    l = [0] * (n + 1)\n    arr = []\n    for _ in range(n - 1):\n        (u, v) = map(int, stdin.readline().rstrip().split())\n        arr.append((u, v))\n        l[u] += 1\n        l[v] += 1\n    (x, y) = (0, n - 2)\n    for (u, v) in arr:\n        if l[u] == 1 or l[v] == 1:\n            print(x)\n            x += 1\n        else:\n            print(y)\n            y -= 1\nexcept:\n    pass", "from collections import defaultdict, Counter\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial\nfrom heapq import heapify, heappush, heappop\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef solve():\n    ans_ = ''\n    n = nin()\n    deg = defaultdict(int)\n    arr = []\n    for i in range(n - 1):\n        (u, v) = read()\n        deg[u] += 1\n        deg[v] += 1\n        arr.append((u, v))\n    x = 0\n    m = n - 2\n    s = defaultdict(int)\n    for i in arr:\n        (u, v) = i\n        if deg[u] == 1 or deg[v] == 1:\n            ans_ += str(x) + '\\n'\n            x += 1\n        else:\n            ans_ += str(m) + '\\n'\n            m -= 1\n    print(ans_)\nsolve()", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    g[a - 1] += 1\n    g[b - 1] += 1\n    l.append([a - 1, b - 1])\n(cnt, mex) = (0, n - 2)\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "n = int(input())\nx = [0] * n\na = []\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    x[u - 1] += 1\n    x[v - 1] += 1\n    a.append([u - 1, v - 1])\nstart = 0\nend = n - 2\nfor (u, v) in a:\n    if x[u] == 1 or x[v] == 1:\n        print(start)\n        start += 1\n    else:\n        print(end)\n        end -= 1", "def main():\n    n = int(input())\n    lst = [0] * (n + 1)\n    s = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        s.append((a, b))\n        lst[a] += 1\n        lst[b] += 1\n    sol = []\n    left = 0\n    right = n - 2\n    for (a, b) in s:\n        if lst[a] == 1 or lst[b] == 1:\n            print(left)\n            left += 1\n        else:\n            print(right)\n            right -= 1\nmain()", "n = int(input())\ngraph = {}\nmaxi = 1\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    if u not in graph:\n        graph[u] = {i}\n    else:\n        graph[u].add(i)\n    if v not in graph:\n        graph[v] = {i}\n    else:\n        graph[v].add(i)\n    if len(graph[u]) >= 3:\n        maxi = u\n        break\n    if len(graph[v]) >= 3:\n        maxi = v\n        break\nw = 0\nt = n - 2\ntemp = ''\nfor j in range(n - 1):\n    if j in graph[maxi]:\n        temp += str(w) + '\\n'\n        w += 1\n    else:\n        temp += str(t) + '\\n'\n        t -= 1\nprint(temp)", "from sys import *\nfrom bisect import *\nimport math\nfrom collections import *\nfrom heapq import *\nfrom itertools import *\ninf = 10 ** 18\nmod = 10 ** 9 + 7\nn = int(input())\ndic = defaultdict(int)\narr = []\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    dic[u] += 1\n    dic[v] += 1\n    arr.append((u, v))\ndeg = 0\nsearch = [0, 0]\nfor i in dic:\n    if dic[i] >= 3:\n        search = [i, dic[i]]\n        break\ndeg2 = search[1]\nfor i in arr:\n    if i[0] == search[0] or i[1] == search[0]:\n        print(deg)\n        deg += 1\n    else:\n        print(deg2)\n        deg2 += 1", "def main():\n    n = int(input())\n    turns = []\n    dct = dict()\n    to_spec = n\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        turns.append((a, b))\n        if a in dct:\n            if dct[a] == 1:\n                dct[a] += 1\n                to_spec -= 1\n        else:\n            dct[a] = 1\n        if b in dct:\n            if dct[b] == 1:\n                dct[b] += 1\n                to_spec -= 1\n        else:\n            dct[b] = 1\n    to_add1 = 0\n    line = ''\n    for i in turns:\n        if dct[i[0]] == 1 or dct[i[1]] == 1:\n            line += str(to_add1) + '\\n'\n            to_add1 += 1\n        else:\n            line += str(to_spec) + '\\n'\n            to_spec += 1\n    print(line)\nt = 1\nfor i in range(t):\n    main()", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    n = II()\n    to = [[] for _ in range(n)]\n    deg = [0] * n\n    for i in range(n - 1):\n        (u, v) = MI1()\n        to[u].append((v, i))\n        to[v].append((u, i))\n        deg[u] += 1\n        deg[v] += 1\n    mx = max(deg)\n    if mx < 3:\n        ans = list(range(n - 1))\n    else:\n        ans = [-1] * (n - 1)\n        u = deg.index(mx)\n        c = 0\n        for (v, i) in to[u]:\n            if c == 3:\n                break\n            ans[i] = c\n            c += 1\n        for i in range(n - 1):\n            if ans[i] != -1:\n                continue\n            ans[i] = c\n            c += 1\n    print(*ans, sep='\\n')\nmain()", "n = int(input())\ndeg = [0] * (n + 2)\nes = []\nfor i in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    deg[a] += 1\n    deg[b] += 1\n    es.append((a, b))\nif max(deg) == 2:\n    for i in range(n - 1):\n        print(i)\nelse:\n    k = deg.index(max(deg))\n    e_012 = 0\n    cnt = 3\n    for e in es:\n        if k in e and e_012 < 3:\n            print(e_012)\n            e_012 += 1\n        else:\n            print(cnt)\n            cnt += 1", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    l.append([int(x) for x in input().split()])\n    g[l[-1][0] - 1] += 1\n    g[l[-1][1] - 1] += 1\n(cnt, mex) = (0, n - 2)\nfor (a, b) in l:\n    k = g[a - 1] == 1 or g[b - 1] == 1\n    print(cnt if k else mex)\n    cnt += int(k)\n    mex -= int(not k)", "def f():\n    n = int(input())\n    neibors = [[] for i in range(n + 1)]\n    orders = dict()\n    for i in range(n - 1):\n        (u, v) = [int(s) for s in input().split()]\n        neibors[u].append(v)\n        neibors[v].append(u)\n        orders[u, v] = i\n    leaves = []\n    for i in range(1, n + 1):\n        if len(neibors[i]) == 1:\n            leaves.append(i)\n    if len(leaves) <= 2:\n        for i in range(n - 1):\n            print(i)\n        return\n    ans = [-1] * (n - 1)\n    for i in range(3):\n        u = leaves[i]\n        v = neibors[u][0]\n        if (u, v) in orders:\n            ans[orders[u, v]] = i\n        else:\n            ans[orders[v, u]] = i\n    i = 3\n    for j in range(n - 1):\n        if ans[j] >= 0:\n            continue\n        ans[j] = i\n        i += 1\n    for a in ans:\n        print(a)\nf()", "n = int(input())\ncheck = [0 for i in range(n + 1)]\nnodes = []\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    nodes.append((u, v))\n    check[u] += 1\n    check[v] += 1\nleft = 0\nright = n - 2\nfor (u, v) in nodes:\n    if check[u] == 1 or check[v] == 1:\n        print(left)\n        left += 1\n    else:\n        print(right)\n        right -= 1", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "def f():\n    n = int(input())\n    neibor = [0] * (n + 1)\n    orders = dict()\n    for i in range(n - 1):\n        (u, v) = [int(s) for s in input().split()]\n        if neibor[u] > 0:\n            neibor[u] = n + 1\n        else:\n            neibor[u] = v\n        if neibor[v] > 0:\n            neibor[v] = n + 1\n        else:\n            neibor[v] = u\n        orders[u, v] = i\n    leaves = []\n    for i in range(1, n + 1):\n        if neibor[i] <= n:\n            leaves.append(i)\n    if len(leaves) <= 2:\n        for i in range(n - 1):\n            print(i)\n        return\n    ans = [-1] * (n - 1)\n    for i in range(3):\n        u = leaves[i]\n        v = neibor[u]\n        if (u, v) in orders:\n            ans[orders[u, v]] = i\n        else:\n            ans[orders[v, u]] = i\n    i = 3\n    for j in range(n - 1):\n        if ans[j] >= 0:\n            continue\n        ans[j] = i\n        i += 1\n    for a in ans:\n        print(a)\nf()", "n = int(input())\nlst = [0] * (n + 1)\ns = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    s.append((a, b))\n    lst[a] += 1\n    lst[b] += 1\nsol = []\nleft = 0\nright = n - 2\nfor (a, b) in s:\n    if lst[a] == 1 or lst[b] == 1:\n        print(left)\n        left += 1\n    else:\n        print(right)\n        right -= 1", "n = int(input())\ngraph = [[] for _ in range(n)]\nedges = []\nd = dict()\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    u -= 1\n    v -= 1\n    graph[u].append(v)\n    graph[v].append(u)\n    edges.append((u, v))\n    d[u, v] = i\n    d[v, u] = i\nans = [None] * (n - 1)\nfor u in range(n):\n    if len(graph[u]) >= 3:\n        v1 = graph[u][0]\n        v2 = graph[u][1]\n        v3 = graph[u][2]\n        ans[d[u, v1]] = 0\n        ans[d[u, v2]] = 1\n        ans[d[u, v3]] = 2\n        break\nc = 3\nfor i in range(n - 1):\n    if ans[i] is None:\n        ans[i] = c % (n - 1)\n        c += 1\nprint('\\n'.join(map(str, ans)))", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\nme = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(me)\n        me += 1\n    else:\n        print(mex)\n        mex -= 1", "n = int(input())\ndeg = [0 for _ in range(n)]\nedges = []\nfor e in range(n - 1):\n    (a, b) = map(int, input().split(' '))\n    deg[a - 1] += 1\n    deg[b - 1] += 1\n    edges.append([a - 1, b - 1])\nd3 = -1\nfor (n, i) in enumerate(deg):\n    if i >= 3:\n        d3 = n\n        break\nif d3 == -1:\n    for i in range(n):\n        print(i)\nelse:\n    curr = deg[d3]\n    c2 = 0\n    for (n, i) in enumerate(edges):\n        if d3 in i:\n            print(c2)\n            c2 += 1\n        else:\n            print(curr)\n            curr += 1", "n = int(input())\ntree = [0] * (n + 1)\nedges = []\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    edges.append((u, v))\n    tree[u] += 1\n    tree[v] += 1\nleft = 0\nright = n - 2\nfor (u, v) in edges:\n    if tree[u] == 1 or tree[v] == 1:\n        print(left)\n        left += 1\n    else:\n        print(right)\n        right -= 1", "n = int(input())\nif n == 2:\n    print(0)\n    exit(0)\nlis = [0] * (n + 1)\nlink = [0] * (n + 1)\nprt = [3] * (n - 1)\nfor i in range(n - 1):\n    (x, y) = (int(m) for m in input().split())\n    link[x] = link[y] = i\n    lis[x] += 1\n    lis[y] += 1\npt = lis.index(1)\nprt[link[pt]] = 1\npt = lis.index(1, pt + 1)\nprt[link[pt]] = 0\nif lis.count(1) > 2:\n    prt[link[lis.index(1, pt + 1)]] = 2\nk = n - 2\nfor i in prt:\n    if i > 2:\n        print(k)\n        k = k - 1\n    else:\n        print(i)", "def read_int():\n    return int(input().strip())\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\ndef solve():\n    N = read_int()\n    counts = [0] * N\n    edges = []\n    for _ in range(N - 1):\n        edge = read_ints()\n        edge[0] -= 1\n        edge[1] -= 1\n        edges.append(edge)\n        counts[edge[0]] += 1\n        counts[edge[1]] += 1\n    C = 0\n    labels = [-1] * (N - 1)\n    for (i, (u, v)) in enumerate(edges):\n        if counts[u] == 1 or counts[v] == 1:\n            labels[i] = C\n            C += 1\n    for i in range(N - 1):\n        if labels[i] == -1:\n            labels[i] = C\n            C += 1\n    for label in labels:\n        print(label)\nsolve()", "n = int(input())\ndegree = [0] * (n + 1)\norder = []\nfor _ in range(n - 1):\n    (x, y) = map(int, input().split())\n    degree[x] += 1\n    degree[y] += 1\n    order.append((x, y))\nres1 = 0\nres2 = n - 2\nk = 0\nfor d in range(n + 1):\n    if degree[d] >= 3:\n        k = d\n        break\nfor (x, y) in order:\n    if x == k or y == k:\n        print(res1)\n        res1 += 1\n    else:\n        print(res2)\n        res2 -= 1", "n = int(input())\n(cc, ls) = ([0] * (n + 1), [])\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    ls.append((a, b))\n    cc[a] += 1\n    cc[b] += 1\nif n == 2:\n    print(0)\n    exit()\nr = 0\nfor (k, v) in enumerate(cc):\n    if v >= 3:\n        r = k\n        break\nidx = 3 if r > 0 else 0\nrcc = 0\nfor (a, b) in ls:\n    if rcc < 3 and (a == r or b == r):\n        print(rcc)\n        rcc += 1\n    else:\n        print(idx)\n        idx += 1", "n = int(input())\ndp = [0] * (n + 1)\ndata = []\nfor _ in range(n - 1):\n    (x, y) = map(int, input().split())\n    dp[x - 1] += 1\n    dp[y - 1] += 1\n    data.append([x - 1, y - 1])\n(count, rev) = (0, n - 2)\nfor (x, y) in data:\n    if dp[x] == 1 or dp[y] == 1:\n        print(count)\n        count += 1\n    else:\n        print(rev)\n        rev -= 1", "n = int(input())\ngraph = [0] * (n + 1)\nli = []\nval = [-1] * (n - 1)\nfor _ in range(n - 1):\n    (x, y) = map(int, input().strip().split(' '))\n    li.append([x, y])\n    graph[x] += 1\n    graph[y] += 1\ncount = 0\nfor i in range(n - 1):\n    if graph[li[i][0]] == 1 or graph[li[i][1]] == 1:\n        val[i] = count\n        count += 1\nfor i in val:\n    if i == -1:\n        print(count)\n        count += 1\n    else:\n        print(i)", "import sys\nreadline = sys.stdin.readline\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\n\ndef solve():\n    n = ni()\n    if n == 2:\n        print(0)\n        return\n    edges = [tuple(nm()) for _ in range(n - 1)]\n    ans = [-1] * (n - 1)\n    G = [list() for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        u -= 1\n        v -= 1\n        G[u].append((i, v))\n        G[v].append((i, u))\n    c = 0\n    for i in range(n):\n        if len(G[i]) == 1:\n            ans[G[i][0][0]] = c\n            c += 1\n    for i in range(n - 1):\n        if ans[i] < 0:\n            ans[i] = c\n            c += 1\n    print(*ans, sep='\\n')\n    return\nsolve()", "class Solution:\n\n    def __init__(self):\n        pass\n\n    def s(self):\n        n = int(input())\n        c = {}\n        edges = []\n        (f, l) = (0, n - 2)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            edges.append((u, v))\n            c.setdefault(u, 0)\n            c.setdefault(v, 0)\n            c[u] += 1\n            c[v] += 1\n        for i in edges:\n            if c[i[0]] == 1 or c[i[1]] == 1:\n                print(f)\n                f += 1\n            else:\n                print(l)\n                l -= 1\nc = Solution()\nc.s()", "vertices = int(input())\ncontador_adjacentes = [0] * (vertices + 1)\ngrafo = []\nfor i in range(vertices - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    contador_adjacentes[a] += 1\n    contador_adjacentes[b] += 1\n    grafo.append([a, b])\ncontador = 0\nmex = vertices - 2\nfor (a, b) in grafo:\n    if contador_adjacentes[a] == 1 or contador_adjacentes[b] == 1:\n        print(contador)\n        contador += 1\n    else:\n        print(mex)\n        mex -= 1", "n = int(input())\nc = [0] * 100005\nq = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    c[a] += 1\n    c[b] += 1\n    q.append([a, b])\nx = 0\ny = n - 2\nres = []\nfor i in range(len(q)):\n    if c[q[i][0]] == 1 or c[q[i][1]] == 1:\n        res.append(x)\n        x += 1\n    else:\n        res.append(y)\n        y -= 1\nfor i in res:\n    print(i)", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "class Solution:\n\n    def __init__(self):\n        pass\n\n    def s(self):\n        n = int(input())\n        c = {}\n        edges = []\n        (f, l) = (0, n - 2)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            edges.append((u, v))\n            c.setdefault(u, 0)\n            c.setdefault(v, 0)\n            c[u] += 1\n            c[v] += 1\n        for i in edges:\n            if c[i[0]] == 1 or c[i[1]] == 1:\n                print(f)\n                f += 1\n            else:\n                print(l)\n                l -= 1\nc = Solution()\nc.s()", "n = int(input())\nd = [0] * (n + 1)\narr = []\nfor i1 in range(n - 1):\n    (c1, c2) = list(map(int, input().split()))\n    d[c1] += 1\n    d[c2] += 1\n    arr.append([c1, c2])\nstart = 0\nend = n - 2\nfor i1 in range(n - 1):\n    if d[arr[i1][0]] == 1 or d[arr[i1][1]] == 1:\n        print(start)\n        start += 1\n    else:\n        print(end)\n        end -= 1", "n = int(input())\nadj = []\ndeg = [0 for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    adj += [[a - 1, b - 1]]\n    deg[a - 1] += 1\n    deg[b - 1] += 1\nop = []\ncnt = 0\ncnt1 = n - 2\nfor i in adj:\n    if deg[i[0]] == 1 or deg[i[1]] == 1:\n        op += [cnt]\n        cnt += 1\n    else:\n        op += [cnt1]\n        cnt1 -= 1\nfor i in op:\n    print(i)", "t = int(input())\ncount = [0] * 100005\na = []\nfor j in range(t - 1):\n    (x1, x2) = map(int, input().split())\n    count[x1] += 1\n    count[x2] += 1\n    a.append([x1, x2])\nk = 0\nl = t - 2\nans = []\nfor i in range(len(a)):\n    if count[a[i][0]] == 1 or count[a[i][1]] == 1:\n        ans.append(k)\n        k += 1\n    else:\n        ans.append(l)\n        l -= 1\nfor i in range(len(ans)):\n    print(ans[i])", "n = int(input())\nc = [0] * 100005\narr = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    c[a] += 1\n    c[b] += 1\n    arr.append([a, b])\nans = []\nx = 0\ny = n - 2\nfor i in range(len(arr)):\n    if c[arr[i][0]] == 1 or c[arr[i][1]] == 1:\n        ans.append(x)\n        x += 1\n    else:\n        ans.append(y)\n        y -= 1\nfor i in range(len(ans)):\n    print(ans[i])", "n = int(input())\nedges = []\ndegree = [0] * n\nfor __ in range(n - 1):\n    a = [int(x) for x in input().split()]\n    edges.append(a)\n    degree[a[1] - 1] += 1\n    degree[a[0] - 1] += 1\ncount = n - 2\nvalue = 0\nif max(degree) == 1:\n    for i in range(n - 1):\n        print(i)\nelse:\n    for i in range(n - 1):\n        a = edges[i]\n        if degree[a[0] - 1] == 1 or degree[a[1] - 1] == 1:\n            print(value)\n            value += 1\n        else:\n            print(count)\n            count -= 1", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "lis = []\nn = int(input())\ndic = {}\napprove = -1\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    lis.append([a, b])\n    dic[a] = dic.get(a, 0) + 1\n    dic[b] = dic.get(b, 0) + 1\n    if dic[a] == 3 and approve == -1:\n        approve = a\n    if dic[b] == 3 and approve == -1:\n        approve = b\nstart = 0\nif approve != -1:\n    start2 = dic[approve]\nif approve == -1:\n    for i in lis:\n        print(start)\n        start += 1\nelse:\n    for i in lis:\n        if i[0] == approve or i[1] == approve:\n            print(start)\n            start += 1\n        else:\n            print(start2)\n            start2 += 1", "n = int(input())\npresent = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    present[a] += 1\n    present[b] += 1\n    l.append([a, b])\ns = 0\nm = n - 2\nfor (a, b) in l:\n    if present[a] == 1 or present[b] == 1:\n        print(s)\n        s += 1\n    else:\n        print(m)\n        m -= 1", "n = int(input())\nfreq = [0] * (n + 1)\nadj = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    freq[a] += 1\n    freq[b] += 1\n    adj.append([a, b])\ncnt = 0\nmx = n - 2\nfor (a, b) in adj:\n    if freq[a] == 1 or freq[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mx)\n        mx -= 1", "dic = {}\ncheck = []\nsize = int(input())\nfor _ in range(size - 1):\n    (a, b) = map(int, input().split())\n    check.append((a, b))\n    if a not in dic.keys():\n        dic.update({a: 1})\n    else:\n        dic[a] += 1\n    if b not in dic.keys():\n        dic.update({b: 1})\n    else:\n        dic[b] += 1\n(crat, trap) = (0, size - 2)\nfor (j, k) in check:\n    if dic[j] == 1 or dic[k] == 1:\n        print(crat)\n        crat += 1\n    else:\n        print(trap)\n        trap -= 1", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "def Solution():\n    n = int(input())\n    c = {}\n    edges = []\n    (f, l) = (0, n - 2)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        edges.append((u, v))\n        c.setdefault(u, 0)\n        c.setdefault(v, 0)\n        c[u] += 1\n        c[v] += 1\n    for i in edges:\n        if c[i[0]] == 1 or c[i[1]] == 1:\n            print(f)\n            f += 1\n        else:\n            print(l)\n            l -= 1\nSolution()", "n = int(input())\ng = [0] * (n + 1)\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a] += 1\n    g[b] += 1\n    l.append([a, b])\ncnt = 0\nmex = n - 2\nfor (a, b) in l:\n    if g[a] == 1 or g[b] == 1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(mex)\n        mex -= 1", "n = int(input())\nl = []\nfor i in range(n - 1):\n    s = input().split()\n    l.append((i, int(s[0]) - 1, int(s[1]) - 1))\ng = []\nfor i in range(n):\n    g.append(0)\nfor x in l:\n    g[x[1]] = g[x[1]] + 1\n    g[x[2]] = g[x[2]] + 1\ni = 0\nr = -1\nwhile i < n:\n    if g[i] > 2:\n        r = i\n    i = i + 1\n\ndef h(j, r):\n    return (l[j][1] == r) | (l[j][2] == r)\nif r == -1:\n    for j in range(n - 1):\n        print(j)\nelse:\n    j = 0\n    t1 = 0\n    t2 = 3\n    while j < n - 1:\n        if h(j, r) & (t1 < 3):\n            print(t1)\n            t1 = t1 + 1\n        else:\n            print(t2)\n            t2 = t2 + 1\n        j = j + 1", "import math\nq = 1\nfor _ in range(q):\n    n = int(input())\n    count = [0] * 100005\n    arr = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        count[a] += 1\n        count[b] += 1\n        arr.append([a, b])\n    ans = []\n    u = 0\n    v = n - 2\n    for i in range(len(arr)):\n        if count[arr[i][0]] == 1 or count[arr[i][1]] == 1:\n            ans.append(u)\n            u += 1\n        else:\n            ans.append(v)\n            v -= 1\n    for i in range(len(ans)):\n        print(ans[i])", "import math\nq = 1\nfor _ in range(q):\n    n = int(input())\n    count = [0] * 100005\n    arr = []\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        count[a] += 1\n        count[b] += 1\n        arr.append([a, b])\n    ans = []\n    u = 0\n    v = n - 2\n    for i in range(len(arr)):\n        if count[arr[i][0]] == 1 or count[arr[i][1]] == 1:\n            ans.append(u)\n            u += 1\n        else:\n            ans.append(v)\n            v -= 1\n    for i in range(len(ans)):\n        print(ans[i])", "n = int(input())\ndic = {}\nar = []\nfor i in range(1, n + 1):\n    dic[i] = 0\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    dic[a] += 1\n    dic[b] += 1\n    ar.append([a, b])\nsta = 0\nend = n - 2\nfor (y, z) in ar:\n    if dic[y] == 1 or dic[z] == 1:\n        print(sta)\n        sta += 1\n    else:\n        print(end)\n        end -= 1", "n = int(input())\ndegree = [0] * (n + 1)\norder = []\nfor _ in range(n - 1):\n    (x, y) = map(int, input().split())\n    degree[x] += 1\n    degree[y] += 1\n    order.append((x, y))\nres1 = 0\nres2 = n - 2\nk = 0\nfor d in range(n + 1):\n    if degree[d] >= 3:\n        k = d\nfor (x, y) in order:\n    if x == k or y == k:\n        print(res1)\n        res1 += 1\n    else:\n        print(res2)\n        res2 -= 1", "n = int(input())\ntree = [[] for _ in range(n + 1)]\nenum = dict()\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\n    enum[u, v] = enum[v, u] = i\nfound = False\nans = list(range(n - 1))\nfree = set(range(n - 1))\nfor start in range(1, n + 1):\n    if len(tree[start]) > 2:\n        fork = tree[start][:3]\n        found = True\n        ans[enum[start, fork[2]]] = 0\n        ans[enum[start, fork[0]]] = 1\n        ans[enum[start, fork[1]]] = 2\n        free.remove(enum[start, fork[2]])\n        free.remove(enum[start, fork[0]])\n        free.remove(enum[start, fork[1]])\n        break\nif found:\n    for (i, w) in zip(free, range(3, n - 1)):\n        ans[i] = w\nprint(*ans, sep='\\n')", "node_dict = {}\nflag = True\nmat = []\ntarget = -1\nn = int(input())\nfor t in range(n - 1):\n    (u, v) = map(int, input().split())\n    mat.append((u, v))\n    if flag:\n        try:\n            node_dict[u] += 1\n            if node_dict[u] == 3:\n                target = u\n                flag = False\n        except KeyError:\n            node_dict[u] = 1\n        try:\n            node_dict[v] += 1\n            if node_dict[v] == 3:\n                target = v\n                flag = False\n        except KeyError:\n            node_dict[v] = 1\nedges = n - 2\ncount = 0\nfor (u, v) in mat:\n    if u == target or v == target:\n        print(count)\n        count += 1\n    else:\n        print(edges)\n        edges -= 1", "import sys\nN = int(input())\nif N == 2:\n    print(0)\n    sys.exit(0)\ndegree = [0 for _ in range(N + 1)]\nadj_list = [[] for _ in range(N + 1)]\nedges = []\nleaves = []\nfor _ in range(N - 1):\n    [u, v] = list(map(int, input().split()))\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n    edges.append((u, v))\nfor n in range(1, N + 1):\n    if len(adj_list[n]) == 1:\n        leaves.append(n)\nlabels = {}\nl0 = leaves[0]\n(u0, v0) = (l0, adj_list[l0][0])\nlabels[u0, v0] = 0\nlabels[v0, u0] = 0\nl1 = leaves[1]\n(u1, v1) = (l1, adj_list[l1][0])\nlabels[u1, v1] = 1\nlabels[v1, u1] = 1\nctr = 2\nif len(leaves) > 2:\n    l2 = leaves[-1]\n    (u, v) = (l2, adj_list[l2][0])\n    labels[u, v] = 2\n    labels[v, u] = 2\n    ctr += 1\nfor (u, v) in edges:\n    if (u, v) in labels:\n        print(labels[u, v])\n    else:\n        print(ctr)\n        ctr += 1", "n = int(input())\nans = [-1] * (n - 1)\nd = dict()\nfor i in range(1, n + 1):\n    d[i] = dict()\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    d[u][v] = i\n    d[v][u] = i\ncnt = 0\nfor i in range(1, n + 1):\n    if len(d[i]) >= 3:\n        for j in d[i].values():\n            ans[j] = cnt\n            cnt += 1\n        break\nfor i in range(len(ans)):\n    if ans[i] == -1:\n        ans[i] = cnt\n        cnt += 1\n    print(ans[i])", "def main():\n    data = input().rstrip().split()\n    n = int(data[0])\n    edges = []\n    g = {i + 1: [] for i in range(n)}\n    leafes = set()\n    for _ in range(n - 1):\n        data = input().rstrip().split()\n        (a, b) = (int(data[0]), int(data[1]))\n        (a, b) = sorted([a, b])\n        edges.append((a, b))\n        g[a].append(b)\n        g[b].append(a)\n    for (k, v) in g.items():\n        if len(leafes) == 3:\n            break\n        if len(v) == 1:\n            e = sorted([k, v[0]])\n            leafes.add(tuple(e))\n    counter = len(leafes)\n    l_counter = 0\n    to_print = []\n    for edge in edges:\n        (a, b) = edge\n        if edge in leafes:\n            to_print.append(l_counter)\n            l_counter += 1\n        else:\n            to_print.append(counter)\n            counter += 1\n    for p in to_print:\n        print(p)\nmain()", "n = int(input())\na = [0 for _ in range(n)]\ne = []\nbl = [0] * n\ncnt = 1\nif n == 2:\n    print(0)\n    exit()\nfor i in range(n - 1):\n    (boof1, boof2) = map(int, input().split())\n    boof1 -= 1\n    boof2 -= 1\n    a[boof1] += 1\n    a[boof2] += 1\n    e.append((boof1, boof2))\nfor i in range(n):\n    if a[i] == 1:\n        bl[i] = cnt\n        cnt += 1\ncnt2 = cnt\nfor i in range(n - 1):\n    if bl[e[i][0]] != 0 or bl[e[i][1]] != 0:\n        print(bl[e[i][0]] + bl[e[i][1]] - 1)\n    else:\n        print(cnt2 - 1)\n        cnt2 += 1", "def R():\n    return map(int, input().split())\n\ndef I():\n    return int(input())\n\ndef S():\n    return str(input())\n\ndef L():\n    return list(R())\nfrom collections import Counter\nimport math\nimport sys\nfrom itertools import permutations\nimport bisect\nn = I()\ne = []\ndeg = [0] * n\nfor i in range(n - 1):\n    (a, b) = R()\n    e.append([a - 1, b - 1])\n    deg[a - 1] += 1\n    deg[b - 1] += 1\nx = max(deg)\nif x == 2:\n    for i in range(n - 1):\n        print(i)\n    exit()\nind = deg.index(x)\ncnt = -1\nans = [0] * (n - 1)\ncnt2 = 0\nfor ed in e:\n    (a, b) = ed\n    cnt += 1\n    if a == ind or b == ind:\n        ans[cnt] = cnt2\n        cnt2 += 1\ncnt = -1\nfor ed in e:\n    (a, b) = ed\n    cnt += 1\n    if a != ind and b != ind:\n        ans[cnt] = cnt2\n        cnt2 += 1\nprint(*ans, sep='\\n')", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef in_int():\n    return int(input())\n\ndef in_list():\n    return list(map(int, input().split()))\n\ndef in_str():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef in_ints():\n    return map(int, input().split())\nn = in_int()\ng = [[] for i in range(n + 1)]\ne = [-1] * (n - 1)\nvv = 0\nmx = 0\nfor xx in range(n - 1):\n    (u, v) = in_ints()\n    g[u].append((v, xx))\n    if len(g[u]) > mx:\n        mx = len(g[u])\n        vv = u\n    g[v].append((u, xx))\n    if len(g[v]) > mx:\n        mx = len(g[v])\n        vv = v\ncount = 0\nfor (v, i) in g[vv]:\n    if e[i] == -1:\n        e[i] = count\n        count += 1\nfor i in range(len(e)):\n    if e[i] == -1:\n        e[i] = count\n        count += 1\n    print(e[i])", "n = int(input())\nadj = [[] for _ in range(n + 1)]\nvisited = [False] * (n + 1)\nedge_to_ind = dict()\nans = [-1] * (n + 1)\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    if u > v:\n        (u, v) = (v, u)\n    edge_to_ind[u, v] = i\n    adj[u].append(v)\n    adj[v].append(u)\nfor i in range(1, n + 1):\n    if len(adj[i]) > len(adj[u]):\n        u = i\nnum = 0\nfor v in adj[u]:\n    if (u, v) in edge_to_ind:\n        ans[edge_to_ind[u, v]] = num\n        num += 1\n    elif (v, u) in edge_to_ind:\n        ans[edge_to_ind[v, u]] = num\n        num += 1\nfor i in range(n - 1):\n    if ans[i] == -1:\n        ans[i] = num\n        num += 1\nfor i in range(n - 1):\n    print(ans[i])", "n = int(input())\na = [[] for i in range(n + 1)]\nb = []\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    a[u].append(v)\n    a[v].append(u)\n    b.append((u, v))\nc = 0\nfor _ in range(1, n + 1):\n    if len(a[_]) == 1:\n        c += 1\np = 0\nq = c\nfor i in b:\n    if len(a[i[0]]) == 1 or len(a[i[1]]) == 1:\n        print(p)\n        p += 1\n    else:\n        print(q)\n        q += 1", "import math\nfrom collections import defaultdict\nn = int(input())\nadj_lis = defaultdict(int)\nedges = []\nfor i in range(n - 1):\n    (x, y) = [int(i) for i in input().split()]\n    adj_lis[x] += 1\n    adj_lis[y] += 1\n    edges.append([x, y])\nleaves = {}\nfor i in range(1, n + 1):\n    if adj_lis[i] == 1:\n        leaves[i] = 1\ntot_leaves = len(list(leaves.keys()))\nhigh = tot_leaves\nlow = 0\nfor i in range(len(edges)):\n    (x, y) = edges[i]\n    if x in leaves or y in leaves:\n        print(low)\n        low += 1\n    else:\n        print(high)\n        high += 1", "import sys\nfrom math import *\nfrom collections import defaultdict\nfrom queue import deque\nfrom heapq import heappush, heappop\nlines = [line.strip() for line in sys.stdin.readlines()]\nn = int(lines[0])\nret = [-1 for i in range(n - 1)]\nedges = []\ndeg = [0 for i in range(n)]\nfor i in range(1, n):\n    (v, u) = list(map(int, lines[i].split()))\n    v -= 1\n    u -= 1\n    edges += [(v, u)]\n    deg[v] += 1\n    deg[u] += 1\ncnt = 0\nfor i in range(n - 1):\n    if deg[edges[i][0]] == 1 or deg[edges[i][1]] == 1:\n        ret[i] = cnt\n        cnt += 1\nfor i in range(n - 1):\n    if ret[i] == -1:\n        ret[i] = cnt\n        cnt += 1\nfor x in ret:\n    print(x)", "n = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nans = {e: -1 for e in edges}\ngs = [[] for _ in range(n + 1)]\nfor (u, v) in edges:\n    gs[u].append(v)\n    gs[v].append(u)\ng = max(range(1, n + 1), key=lambda x: len(gs[x]))\ncnt = 0\nfor v in gs[g]:\n    uv = (g, v)\n    if uv not in ans:\n        uv = (v, g)\n    ans[uv] = cnt\n    cnt += 1\nfor a in ans.values():\n    if a == -1:\n        print(cnt)\n        cnt += 1\n    else:\n        print(a)", "n = int(input())\nedges = []\ndegree = [0] * n\nfor __ in range(n - 1):\n    a = [int(x) for x in input().split()]\n    edges.append(a)\n    degree[a[1] - 1] += 1\n    degree[a[0] - 1] += 1\ncount = n - 2\nvalue = 0\nif max(degree) == 1:\n    for i in range(n - 1):\n        print(i)\nelse:\n    for i in range(n - 1):\n        a = edges[i]\n        if degree[a[0] - 1] == 1 or degree[a[1] - 1] == 1:\n            print(value)\n            value += 1\n        else:\n            print(count)\n            count -= 1", "from collections import Counter, OrderedDict\nfrom sys import stdin\nn = int(stdin.readline())\ndct = Counter()\ndct1 = OrderedDict()\nfor _ in range(n - 1):\n    x = tuple(map(int, stdin.readline().split()))\n    dct1[x] = -1\n    dct[x[0]] += 1\n    dct[x[1]] += 1\nco = 0\nfor r in dct:\n    if dct[r] >= 3:\n        for x in dct1:\n            if x[0] == r or x[1] == r:\n                dct1[x] = co\n                co += 1\n        break\nfor r in dct1.keys():\n    if dct1[r] == -1:\n        dct1[r] = co\n        co += 1\nfor k in dct1.values():\n    print(k)", "import sys\nimport collections\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    AB = [[int(x) for x in input().split()] for _ in range(N - 1)]\n    V = [[] for j in range(N)]\n    for (i, (a, b)) in enumerate(AB):\n        V[a - 1].append([b - 1, i])\n        V[b - 1].append([a - 1, i])\n    f = False\n    ans = [-1] * (N - 1)\n    for v in V:\n        if len(v) >= 3:\n            f = True\n            for i in range(3):\n                ans[v[i][1]] = i\n            break\n    cnt = 0\n    if f:\n        cnt = 3\n    for a in ans:\n        if a == -1:\n            print(cnt)\n            cnt += 1\n        else:\n            print(a)\nmain()", "n = int(input())\nd = {}\nl = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    l.append([a, b])\n    if a in d:\n        d[a] += 1\n    else:\n        d[a] = 1\n    if b in d:\n        d[b] += 1\n    else:\n        d[b] = 1\nans = [-1] * (n - 1)\npew = 0\nfor i in range(1, n + 1):\n    if d[i] >= 3:\n        for j in range(n - 1):\n            if l[j][0] == i or l[j][1] == i:\n                ans[j] = pew\n                pew += 1\n                if pew == 3:\n                    break\n        for j in range(n - 1):\n            if ans[j] == -1:\n                ans[j] = pew\n                pew += 1\n        break\nfor j in range(n - 1):\n    if ans[j] == -1:\n        ans[j] = pew\n        pew += 1\nfor i in ans:\n    print(i)", "def solve(graph):\n    ans = [-1 for i in range(len(graph) - 1)]\n    for v in graph:\n        if len(graph[v]) > 2:\n            for (i, (u, k)) in enumerate(graph[v][:3]):\n                ans[k] = i\n            k = 0\n            for i in range(3, len(ans)):\n                while ans[k] != -1:\n                    k += 1\n                ans[k] = i\n            return ans\n    return list(range(len(graph) - 1))\n\ndef test():\n    g1 = {1: [(2, 0), (3, 1)], 2: [(1, 0)], 3: [(1, 1)]}\n    s1 = solve(g1)\n    print(s1)\n    assert s1 == [0, 1]\n    g2 = {1: [(2, 0), (3, 1)], 2: [(1, 0), (4, 2), (5, 3)], 3: [(1, 1)], 4: [(2, 2)], 5: [(2, 3), (6, 5)], 6: [(5, 5)]}\n    s2 = solve(g2)\n    print(s2)\n    assert s2 == [0, 3, 1, 2, 4]\nn = int(input())\ngraph = {i: [] for i in range(1, n + 1)}\nedges = []\nfor i in range(n - 1):\n    (u, v) = [int(c) for c in input().split()]\n    graph[u].append((v, i))\n    graph[v].append((u, i))\nans = solve(graph)\nprint(*ans, sep='\\n')", "n = int(input())\nocc = [0 for i in range(n)]\ngraph = [[0, 0] for i in range(n - 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    occ[x - 1] += 1\n    occ[y - 1] += 1\n    graph[i][0] = x - 1\n    graph[i][1] = y - 1\nfin = [-1 for i in range(n - 1)]\nfor i in range(n):\n    if occ[i] >= 3:\n        var = 0\n        for j in range(n - 1):\n            if graph[j][0] == i or graph[j][1] == i:\n                fin[j] = var\n                var += 1\n        break\nelse:\n    var = 0\n    for i in range(n):\n        if var > 1:\n            break\n        if occ[i] == 1:\n            for j in range(n - 1):\n                if graph[j][0] == i or graph[j][1] == i:\n                    fin[j] = var\n                    var += 1\n                    break\nfor i in fin:\n    if n == 2:\n        print(0)\n        break\n    if i == -1:\n        print(var)\n        var += 1\n    else:\n        print(i)", "from collections import defaultdict\n\ndef f(arr):\n    g = defaultdict(list)\n    for i in range(len(arr)):\n        g[arr[i][0]].append(i)\n        g[arr[i][1]].append(i)\n    ans = [-1] * len(arr)\n    mx = max(g.items(), key=lambda s: len(s[1]))\n    c = 0\n    for i in mx[1]:\n        ans[i] = c\n        c += 1\n    for i in range(len(ans)):\n        if ans[i] == -1:\n            ans[i] = c\n            c += 1\n    return ans\nblanck = []\nfor i in range(int(input()) - 1):\n    (p, c) = map(int, input().strip().split())\n    blanck.append([p, c])\nprint(*f(blanck), sep='\\n')", "n = int(input())\nl = []\nm = [0] * (n + 1)\nchk = [0] * (n + 1)\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    if a > b:\n        (a, b) = (b, a)\n    m[a] += 1\n    m[b] += 1\n    l.append([a, b, -1])\nif n == 2:\n    print(0)\nelse:\n    for x in range(1, n + 1):\n        if m[x] == 1:\n            chk[x] = 1\n    cnt = 0\n    cnt2 = n - 2\n    for x in range(n - 1):\n        if chk[l[x][0]] == 1 or chk[l[x][1]] == 1:\n            l[x][2] = cnt\n            cnt += 1\n        else:\n            l[x][2] = cnt2\n            cnt2 -= 1\n    for x in l:\n        print(x[2])", "n = int(input())\ninputEdges = []\nadjList = [[] for i in range(0, n + 1)]\nfor i in range(0, n - 1):\n    edge = list(map(lambda x: int(x), input().split()))\n    inputEdges.append(edge)\n    adjList[edge[0]].append(edge[1])\n    adjList[edge[1]].append(edge[0])\nisLinear = True\njunction = 0\nfor i in range(1, n + 1):\n    if len(adjList[i]) >= 3:\n        junction = i\n        isLinear = False\n        break\nhigh = n - 2\nlow = 0\nif isLinear:\n    for i in range(0, n - 1):\n        print(i)\nelse:\n    for e in inputEdges:\n        if e[0] == junction or e[1] == junction:\n            print(low)\n            low += 1\n        else:\n            print(high)\n            high -= 1", "n = int(input())\nedges = [[] for i in range(0, n)]\nfor i in range(0, n - 1):\n    (u, v) = map(int, input().split())\n    edges[u - 1].append((v - 1, i))\n    edges[v - 1].append((u - 1, i))\nans = [-1] * (n - 1)\ncc = 0\nfor i in range(0, n):\n    if len(edges[i]) == 1 and ans[edges[i][0][1]] == -1:\n        ans[edges[i][0][1]] = cc\n        cc += 1\nfor i in range(0, n - 1):\n    if ans[i] == -1:\n        ans[i] = cc\n        cc += 1\nfor i in ans:\n    print(i)", "import math\nimport sys\nn = int(input())\ng = [[] for i in range(n)]\ninp = []\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    v -= 1\n    u -= 1\n    inp.append([u, v])\n    g[u].append(v)\n    g[v].append(u)\nright = n - 2\nleft = 0\nfor i in range(n - 1):\n    if len(g[inp[i][0]]) == 1 or len(g[inp[i][1]]) == 1:\n        print(left)\n        left += 1\n    else:\n        print(right)\n        right -= 1", "n = int(input())\nw = []\nfor j in range(n - 1):\n    w.append([int(k) for k in input().split()])\nq = {}\nfor j in w:\n    if j[0] in q:\n        q[j[0]].append(j[1])\n    else:\n        q[j[0]] = [j[1]]\n    if j[1] in q:\n        q[j[1]].append(j[0])\n    else:\n        q[j[1]] = [j[0]]\nif n == 2:\n    print(0)\nelse:\n    eta = {}\n    zeta = 0\n    for j in q.keys():\n        if len(q[j]) == 1:\n            eta[j, q[j][0]] = zeta\n            zeta += 1\n    for j in w:\n        if (j[0], j[1]) in eta:\n            print(eta[j[0], j[1]])\n        elif (j[1], j[0]) in eta:\n            print(eta[j[1], j[0]])\n        else:\n            print(zeta)\n            zeta += 1", "from collections import Counter\nvertexes_number = int(input())\nedges = Counter()\nledger = []\nfor _ in range(vertexes_number - 1):\n    (_from, to) = map(int, input().split())\n    ledger.append((_from, to))\n    edges[_from] += 1\n    edges[to] += 1\n((vertex, power),) = edges.most_common(1)\nif power >= 3:\n    asc_index = 0\n    desc_index = vertexes_number - 2\n    for (index, (_from, to)) in enumerate(ledger):\n        if _from == vertex or to == vertex:\n            print(asc_index)\n            asc_index += 1\n        else:\n            print(desc_index)\n            desc_index -= 1\nelse:\n    for index in range(len(ledger)):\n        print(index)", "n = int(input())\ngraph = [[] for _ in range(n)]\nedges = []\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    a = a - 1\n    b = b - 1\n    edges.append((a, b))\n    graph[a].append(b)\n    graph[b].append(a)\ncount = 0\nc = 0\nans = {}\nfor edge in edges:\n    if len(graph[edge[0]]) == 1 or len(graph[edge[1]]) == 1:\n        ans[edge] = c\n        c += 1\nfor edge in edges:\n    if edge not in ans:\n        ans[edge] = c\n        c += 1\n    print(ans[edge])", "n = int(input())\nedges = []\ndegrees = [0]\nfor i in range(n):\n    degrees.append(0)\noutput = []\nfor i in range(n - 1):\n    output.append(-1)\n\ndef d3():\n    d3_vertex = 0\n    for i in range(n + 1):\n        if degrees[i] > 2:\n            d3_vertex = i\n    return d3_vertex\nfor i in range(n - 1):\n    inp = input().split()\n    inp = [int(i) for i in inp]\n    inp.sort()\n    edges.append(inp)\n    degrees[inp[0]] = degrees[inp[0]] + 1\n    degrees[inp[1]] = degrees[inp[1]] + 1\nf = d3()\nif f > 0:\n    u = 0\n    for i in range(n - 1):\n        if edges[i][0] == f or edges[i][1] == f:\n            output[i] = u\n            u = u + 1\n    for i in range(n - 1):\n        if output[i] == -1:\n            output[i] = u\n            u = u + 1\n    for i in range(n - 1):\n        print(output[i])\nelse:\n    for i in range(n - 1):\n        print(i)", "from sys import stdin\n\ndef func(arr, l, r, x):\n    while l < r:\n        mid = (l + r) // 2\n        if arr[mid] + x > 0:\n            r = mid\n        else:\n            l = mid + 1\n    return l\nd = {}\ni = 0\nn = int(stdin.readline())\nfor _ in range(n - 1):\n    (u, v) = map(int, stdin.readline().split())\n    if u in d:\n        d[u][0] += 1\n        d[u][1].append(i)\n    else:\n        d[u] = [1, [i]]\n    if v in d:\n        d[v][0] += 1\n        d[v][1].append(i)\n    else:\n        d[v] = [1, [i]]\n    i += 1\nans = [-1] * (n - 1)\nval = 0\nfor ele in d:\n    if d[ele][0] >= 3:\n        for item in d[ele][1]:\n            if ans[item] == -1:\n                ans[item] = val\n                val += 1\nfor i in range(n - 1):\n    if ans[i] == -1:\n        print(val)\n        val += 1\n    else:\n        print(ans[i])", "data = input().rstrip().split()\nn = int(data[0])\nedges = []\ng = {i + 1: [] for i in range(n)}\nleafes = set()\nfor _ in range(n - 1):\n    data = input().rstrip().split()\n    (a, b) = (int(data[0]), int(data[1]))\n    (a, b) = sorted([a, b])\n    edges.append((a, b))\n    g[a].append(b)\n    g[b].append(a)\nfor (k, v) in g.items():\n    if len(leafes) == 3:\n        break\n    if len(v) == 1:\n        e = sorted([k, v[0]])\n        leafes.add(tuple(e))\ncounter = len(leafes)\nl_counter = 0\nto_print = []\nfor edge in edges:\n    (a, b) = edge\n    if edge in leafes:\n        to_print.append(l_counter)\n        l_counter += 1\n    else:\n        to_print.append(counter)\n        counter += 1\nfor p in to_print:\n    print(p)", "n = int(input())\ngraph = {}\nfor i in range(n):\n    graph[i + 1] = []\nedges = []\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n    edges.append([a, b])\nbig = 0\nnode = 0\nfor i in range(n):\n    if len(graph[i + 1]) > 2:\n        node = i + 1\n        big = 1\nif big == 0:\n    counter = 0\n    for i in range(n - 1):\n        print(counter)\n        counter += 1\nelse:\n    counter = 3\n    counter2 = 0\n    for i in edges:\n        if i[0] == node or i[1] == node:\n            if counter2 < 3:\n                print(counter2)\n                counter2 += 1\n            else:\n                print(counter)\n                counter += 1\n        else:\n            print(counter)\n            counter += 1", "n = int(input())\nlinks = [set([]) for i in range(n)]\npaths = []\nfor i in range(n - 1):\n    (In, Out) = input().split(' ')\n    links[int(In) - 1].add(i)\n    links[int(Out) - 1].add(i)\nout = [0] * (n - 1)\nk = 0\nlinks.sort(key=len)\ndone = set([])\nfor i in range(n - 1):\n    for j in links[i]:\n        if j not in done:\n            done.add(j)\n            out[j] = str(k)\n            k += 1\nfor i in out:\n    print(i)", "n = int(input())\na = []\ng = []\ndic = {}\nfor i in range(n):\n    g.append([])\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    a.append((u - 1, v - 1))\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\ns = 0\nfor i in range(len(g)):\n    if len(g[i]) >= 3:\n        u = i\n        s = 0\n        for v in g[i]:\n            dic[u, v] = s\n            dic[v, u] = s\n            s += 1\n        break\nif s == 0:\n    for i in range(n - 1):\n        print(i)\nelse:\n    for i in a:\n        if i in dic:\n            print(dic[i])\n        else:\n            print(s)\n            s += 1", "from sys import stdin, exit\nfrom itertools import combinations\nfrom collections import deque\ninput = stdin.readline\nlmi = lambda : list(map(int, input().split()))\nmi = lambda : map(int, input().split())\nsi = lambda : input().strip('\\n')\nssi = lambda : input().strip('\\n').split()\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nedges = []\nedges2 = {}\nfor i in range(n - 1):\n    (a, b) = mi()\n    graph[a].append(b)\n    graph[b].append(a)\n    edges.append((a, b))\n    edges2[a, b] = -1\nif all((len(i) <= 2 for i in graph)):\n    for i in range(n - 2, -1, -1):\n        print(i)\nelse:\n    for (idx, i) in enumerate(graph):\n        if len(i) >= 3:\n            for j in range(3):\n                (a, b) = (idx, graph[idx][j])\n                if (a, b) not in edges2:\n                    (a, b) = (b, a)\n                edges2[a, b] = j\n            break\n    cnt = 3\n    for (a, b) in edges2:\n        if edges2[a, b] == -1:\n            edges2[a, b] = cnt\n            cnt += 1\n    for (a, b) in edges:\n        print(edges2[a, b])"]