["import sys\ninput = sys.stdin.readline\np = 998244353\n\ndef get_facts(n):\n    facts = [1] * (n + 1)\n    for i in range(1, n + 1):\n        facts[i] = facts[i - 1] * i % p\n    return facts\nfor _ in range(int(input())):\n    n = int(input())\n    facts = get_facts(n)\n    group = False\n    zero_count = 0\n    odd_count = 0\n    cur_count = 0\n    for c in input():\n        if c == '0':\n            zero_count += 1\n            if group:\n                odd_count += cur_count % 2\n                group = False\n                cur_count = 0\n        elif c == '1':\n            if group:\n                cur_count += 1\n            else:\n                group = True\n                cur_count = 1\n    even_count = (n - odd_count - zero_count) // 2\n    print(facts[even_count + zero_count] * pow(facts[zero_count], -1, p) * pow(facts[even_count], -1, p) % p)", "num_inp = lambda : int(input())\narr_inp = lambda : list(map(int, input().split()))\nsp_inp = lambda : map(int, input().split())\nstr_inp = lambda : input()\nMOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\nT = int(input())\nk = [1]\nfor i in range(T):\n    n = int(input())\n    arr = input()\n    h = dict()\n    p = [0]\n    r = 0\n    s = 0\n    r = arr.count('11')\n    s = arr.count('0')\n    k = [1]\n    (pf, zf) = (factorial(r), factorial(s))\n    print(factorial(r + s) * pow(pf, -1, MOD) % MOD * pow(zf, -1, MOD) % MOD)", "from math import comb\nfrom sys import stdout\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (r - i) % p\n    return num * pow(den, p - 2, p) % p\nfor t in range(int(input())):\n    n = int(input())\n    a = input()\n    i = 0\n    oc = a.count('11')\n    zc = a.count('0')\n    print(ncr(oc + zc, min(oc, zc), 998244353))\n    stdout.flush()", "from functools import lru_cache\nMOD = 998244353\nf = [1, 1]\n\n@lru_cache()\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\n\ndef solve():\n    n = int(input())\n    s = input()\n    p = 0\n    block = 0\n    for ch in s + '0':\n        if ch == '1':\n            block += 1\n        else:\n            p += block // 2\n            block = 0\n    z = s.count('0')\n    (pf, zf) = (factorial(p), factorial(z))\n    print(factorial(p + z) * pow(pf, -1, MOD) % MOD * pow(zf, -1, MOD) % MOD)\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve()\nmain()", "MOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\nT = int(input())\nk = [1]\nfor i in range(T):\n    n = int(input())\n    arr = input()\n    h = dict()\n    p = [0]\n    r = 0\n    s = 0\n    r = arr.count('11')\n    s = arr.count('0')\n    k = [1]\n    (pf, zf) = (factorial(r), factorial(s))\n    print(factorial(r + s) * pow(pf, -1, MOD) % MOD * pow(zf, -1, MOD) % MOD)", "MOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\nt = int(input())\nfor __ in range(t):\n    n = int(input())\n    s = input()\n    p = sum((len(block) // 2 for block in s.split('0')))\n    z = s.count('0')\n    print(factorial(p + z) * pow(factorial(p), -1, MOD) % MOD * pow(factorial(z), -1, MOD) % MOD)", "from math import comb\nfrom sys import stdout\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (r - i) % p\n    return num * pow(den, p - 2, p) % p\nfor t in range(int(input())):\n    n = int(input())\n    a = input()\n    i = 0\n    oc = a.count('11')\n    zc = a.count('0')\n    print(ncr(oc + zc, min(oc, zc), 998244353))\n    stdout.flush()", "MOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\nt = int(input())\nfor __ in range(t):\n    n = int(input())\n    s = input()\n    p = sum((len(block) // 2 for block in s.split('0')))\n    z = s.count('0')\n    print(factorial(p + z) * pow(factorial(p), -1, MOD) % MOD * pow(factorial(z), -1, MOD) % MOD)", "MOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n    l = len(f)\n    while l <= x:\n        f.append(f[l - 1] * l % MOD)\n        l += 1\n    return f[x]\nt = int(input())\nfor __ in range(t):\n    n = int(input())\n    s = input()\n    p = sum((len(block) // 2 for block in s.split('0')))\n    z = s.count('0')\n    print(factorial(p + z) * pow(factorial(p), -1, MOD) % MOD * pow(factorial(z), -1, MOD) % MOD)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    str = input()\n    d = str.count('11')\n    x = str.count('0')\n    ans = ncr(d + x, d, 998244353)\n    print(ans)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    n = int(input())\n    str = input()\n    d = str.count('11')\n    x = str.count('0')\n    print(ncr(d + x, d, 998244353))", "import sys\nimport math\ninput = sys.stdin.readline\nh = {}\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    s = input().rstrip()\n    prev = 'x'\n    cnt_zero = 0\n    cnt_group = 0\n    for t in s:\n        if t == '0':\n            cnt_zero += 1\n            prev = t\n        elif prev == '1':\n            cnt_group += 1\n            prev = 'x'\n        else:\n            prev = t\n    answer = ncr(cnt_zero + cnt_group, cnt_zero, 998244353)\n    print(answer)", "from functools import reduce\nMOD = 998244353\n\ndef perm(n, k):\n    return reduce(lambda x, y: x * y % MOD, range(n - k + 1, n + 1), 1)\nt = int(input())\nfor __ in range(t):\n    n = int(input())\n    s = input()\n    p = sum((len(block) // 2 for block in s.split('0')))\n    z = s.count('0')\n    print(perm(z + p, p) * pow(perm(p, p), -1, MOD) % MOD)", "M = 998244353\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    i = 0\n    (a, b) = (0, 0)\n    while i < n:\n        l = 1\n        while i + 1 < n and s[i + 1] == s[i]:\n            i += 1\n            l += 1\n        if s[i] == '1':\n            a += l // 2\n        else:\n            b += l\n        i += 1\n    p = 1\n    for i in range(a + 1, a + b + 1):\n        p = p * i % M\n    for i in range(1, b + 1):\n        p = p * pow(i, -1, M) % M\n    print(p)", "def ncr(m, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (m - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    n = int(input())\n    strin = str(input())\n    arr = []\n    for i in strin:\n        arr.append(int(i))\n    m = 0\n    x = 0\n    r = 0\n    while x < n:\n        if arr[x] == 0:\n            x += 1\n            m += 1\n        elif x < n - 1 and arr[x] == arr[x + 1] == 1:\n            m += 1\n            x += 2\n            r += 1\n        else:\n            x += 1\n    print(ncr(m, r, 998244353))", "def ncr(m, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (m - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    n = int(input())\n    strin = str(input())\n    arr = []\n    for i in strin:\n        arr.append(int(i))\n    m = 0\n    x = 0\n    r = 0\n    while x < n:\n        if arr[x] == 0:\n            x += 1\n            m += 1\n        elif x < n - 1 and arr[x] == arr[x + 1] == 1:\n            m += 1\n            x += 2\n            r += 1\n        else:\n            x += 1\n    print(ncr(m, r, 998244353))", "N = 100005\nfac = [1] * N\ninv = [1] * N\nMOD = 998244353\nfor i in range(1, N):\n    fac[i] = fac[i - 1] * i % MOD\ninv[-1] = pow(fac[-1], -1, mod=MOD)\nfor i in range(N - 2, 0, -1):\n    inv[i] = inv[i + 1] * (i + 1) % MOD\n\ndef solve(n, s):\n    i = 1\n    pairs = 0\n    zeros = int(s[0] == '0')\n    while i < n:\n        if s[i] == '1':\n            if s[i - 1] == '1':\n                pairs += 1\n                if i + 1 < n and s[i + 1] == '0':\n                    zeros += 1\n                i += 2\n            else:\n                i += 1\n        else:\n            zeros += 1\n            i += 1\n    ans = fac[zeros + pairs] * inv[zeros] * inv[pairs] % MOD\n    print(ans)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    solve(n, s)", "def ncr(n, r, p):\n    (num, den) = (1, 1)\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\np = 998244353\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    zoz = input()\n    z = zoz.count('0')\n    k = 0\n    j = 1\n    while j < n:\n        if zoz[j] == '1' and zoz[j - 1] == '1':\n            k += 1\n            j += 2\n        else:\n            j += 1\n    print(ncr(z + k, z, p))", "mod = 998244353\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    n = int(input())\n    chess_board = input()\n    count_0 = 0\n    count_11 = 0\n    cnt = 0\n    for square in chess_board:\n        if square == '0':\n            count_11 += cnt // 2\n            count_0 += 1\n            cnt = 0\n        else:\n            cnt += 1\n    count_11 += cnt // 2\n    number_of_gaps = count_0 + 1\n    ans = ncr(count_11 + number_of_gaps - 1, number_of_gaps - 1, mod)\n    print(ans)", "MOD = 998244353\nN = 100000\nfact = [0] * (N + 1)\nfact[0] = 1\nfact[1] = 1\nfor i in range(2, N + 1):\n    fact[i] = i * fact[i - 1] % MOD\nT = int(input())\n\ndef ncr(n, r):\n    num = fact[n]\n    den = fact[r] * fact[n - r] % MOD\n    den = pow(den, MOD - 2, MOD)\n    res = num * den % MOD\n    return res\n\ndef solve():\n    n = int(input())\n    s = input()\n    a = 0\n    zeros = 0\n    i = 0\n    while i < n:\n        if s[i] == '1' and i + 1 < n and (s[i + 1] == '1'):\n            a += 1\n            i += 1\n        elif s[i] == '0':\n            zeros += 1\n        i += 1\n    res = ncr(a + zeros, zeros)\n    print(res)\nwhile T:\n    solve()\n    T -= 1", "from sys import stdout\nfrom math import comb as c\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input()))\n    pair = 0\n    zeros = 0\n    cur = 0\n    for i in range(n):\n        if a[i] == 1:\n            cur += 1\n        else:\n            pair += cur // 2\n            zeros += 1\n            cur = 0\n    pair += cur // 2\n    print(c(pair + zeros, zeros) % 998244353)\n    stdout.flush()\n\ndef main():\n    for _ in range(int(input())):\n        solve()\nmain()", "import itertools, math\nmod = 998244353\n\ndef chess(l):\n    grouped = [len(list(v)) // 2 for (i, v) in itertools.groupby(l) if i == '1']\n    x = l.count('0')\n    y = sum(grouped)\n    return math.comb(x + y, y) % mod\nans = []\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(input())\n    ans.append(chess(l))\nfor i in ans:\n    print(i)"]