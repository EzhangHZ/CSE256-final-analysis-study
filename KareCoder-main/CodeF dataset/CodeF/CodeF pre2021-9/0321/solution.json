["import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nMOD = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    AB = []\n    CD = []\n    for _ in range(n * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            AB.append(y * y)\n        else:\n            CD.append(x * x)\n    AB.sort()\n    CD.sort()\n    res = sum((pow(ab + cd, 0.5) for (ab, cd) in zip(AB, CD)))\n    print(res)\nt = int(input())\nfor _ in range(t):\n    solve()", "from math import sqrt\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (miners, mines) = ([], [])\n    for _ in range(int(input()) * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(y * y)\n        else:\n            mines.append(x * x)\n    ans = sum((sqrt(x + y) for (x, y) in zip(sorted(miners), sorted(mines))))\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    miner = []\n    mine = []\n    for _ in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            miner.append(b)\n        else:\n            mine.append(a)\n    miner.sort(key=lambda x: abs(x))\n    mine.sort(key=lambda x: abs(x))\n    ans = 0\n    for i in range(n):\n        ans += (miner[i] ** 2 + mine[i] ** 2) ** 0.5\n    return ans\nfor _ in range(int(input())):\n    print(solve())", "import sys\ninput = sys.stdin.readline\nfrom math import sqrt\nfor _ in range(int(input())):\n    (a, b) = ([], [])\n    n = int(input())\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x != 0:\n            a.append(abs(x))\n        if y != 0:\n            b.append(abs(y))\n    a.sort()\n    b.sort()\n    energy = 0\n    for i in range(n):\n        r = a[i] * a[i] + b[i] * b[i]\n        p = sqrt(r)\n        energy += p\n    print(energy)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10000000)\n\ndef read_values():\n    return map(int, input().split())\n\ndef read_index():\n    return map(lambda x: int(x) - 1, input().split())\n\ndef read_list():\n    return list(read_values())\n\ndef read_lists(N):\n    return [read_list() for n in range(N)]\n\ndef solve():\n    N = int(input())\n    M = []\n    D = []\n    for _ in range(2 * N):\n        (m, d) = read_values()\n        if m != 0:\n            M.append(abs(m))\n        if d != 0:\n            D.append(abs(d))\n    M.sort(reverse=True)\n    D.sort(reverse=True)\n    res = 0\n    for (m, d) in zip(M, D):\n        res += (m ** 2 + d ** 2) ** 0.5\n    return res\n\ndef main():\n    T = int(input())\n    res = []\n    for _ in range(T):\n        res.append(str(solve()))\n    for r in res:\n        print(r)\nmain()", "from sys import stdin, stderr\n\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\nfrom math import hypot\n(t,) = rl()\nfor _ in range(t):\n    (n,) = rl()\n    miners = []\n    diamonds = []\n    for _ in range(2 * n):\n        (x, y) = rl()\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            diamonds.append(abs(x))\n    miners.sort()\n    diamonds.sort()\n    print(sum((hypot(x, y) for (x, y) in zip(diamonds, miners))))", "import math\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        miners = []\n        diamonds = []\n        for i in range(n * 2):\n            (x, y) = map(int, input().split())\n            if x == 0:\n                miners.append(abs(y))\n            if y == 0:\n                diamonds.append(abs(x))\n        miners.sort()\n        diamonds.sort()\n        ans = 0\n        for i in range(n):\n            (x, y) = (diamonds[i], miners[i])\n            ans += math.sqrt(x ** 2 + y ** 2)\n        print(ans)\nmain()", "import sys\nimport math\nfrom sys import stdin, stdout\n\ndef get_ints_in_variables():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return int(input())\n\ndef get_ints_in_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_list_of_list(n):\n    return [list(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef main():\n    for t in range(get_int()):\n        miners = []\n        mines = []\n        n = int(input())\n        for i in range(0, 2 * n):\n            (x, y) = get_ints_in_variables()\n            if x == 0:\n                miners.append(abs(y))\n            if y == 0:\n                mines.append(abs(x))\n        miners.sort()\n        mines.sort()\n        res = 0\n        for i in range(0, n):\n            op = miners[i] * miners[i] * 1.0 + mines[i] * mines[i] * 1.0\n            srt = math.sqrt(op)\n            res += srt\n        print(res)\nmain()", "from math import sqrt\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (miners, mines) = ([], [])\n    for _ in range(int(input()) * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            mines.append(abs(x))\n    ans = sum((sqrt(x * x + y * y) for (x, y) in zip(sorted(miners), sorted(mines))))\n    print(ans)", "import os, sys, time, collections, math, pprint, itertools as it, operator as op, bisect as bs, functools as fn\n(maxx, localsys, mod) = (float('inf'), 0, int(1000000000.0 + 7))\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\nceil = lambda n, x: (n + x - 1) // x\n(osi, oso) = ('/home/priyanshu/Documents/cp/input.txt', '/home/priyanshu/Documents/cp/output.txt')\nif os.path.exists(osi):\n    sys.stdin = open(osi, 'r')\n    sys.stdout = open(oso, 'w')\ninput = sys.stdin.readline\n\ndef maps():\n    return map(int, input().split())\n\ndef rel(a, b):\n    return abs(a - b) / max(1, abs(b))\nfor _ in range(int(input())):\n    (x, y, ans) = ([], [], 0)\n    for i in range(2 * int(input())):\n        (u, v) = maps()\n        y.append(v) if not u else x.append(u)\n    print(sum(((i * i + j * j) ** 0.5 for (i, j) in zip(sorted(x, key=abs), sorted(y, key=abs)))))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    m = []\n    d = []\n    for _ in range(2 * n):\n        (x, y) = input().split()\n        if x == '0':\n            d.append(abs(int(y)))\n        else:\n            m.append(abs(int(x)))\n    s = 0\n    d.sort()\n    m.sort()\n    for i in range(n):\n        s += pow(m[i] * m[i] + d[i] * d[i], 0.5)\n    print(s)", "import sys\nfor _ in range(int(input())):\n    n = int(input())\n    (miner, dia) = ([], [])\n    f = lambda i: (i[0] * i[0] + i[1] * i[1]) ** 0.5\n    for _ in range(2 * n):\n        (x, y) = map(int, sys.stdin.readline().split())\n        if x:\n            dia.append(abs(x))\n        else:\n            miner.append(abs(y))\n    print(sum(map(f, zip(sorted(miner), sorted(dia)))))", "import os, sys, time, collections, math, pprint, itertools as it, operator as op, bisect as bs, functools as fn\n(maxx, localsys, mod) = (float('inf'), 0, int(1000000000.0 + 7))\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\nceil = lambda n, x: (n + x - 1) // x\n(osi, oso) = ('/home/priyanshu/Documents/cp/input.txt', '/home/priyanshu/Documents/cp/output.txt')\nif os.path.exists(osi):\n    sys.stdin = open(osi, 'r')\n    sys.stdout = open(oso, 'w')\ninput = sys.stdin.readline\n\ndef maps():\n    return map(int, input().split())\n\ndef rel(a, b):\n    return abs(a - b) / max(1, abs(b))\nfor _ in range(int(input())):\n    (x, y) = ([], [])\n    n = int(input())\n    for i in range(2 * n):\n        (u, v) = maps()\n        if u == 0:\n            y.append(v)\n        else:\n            x.append(u)\n    x.sort(key=abs)\n    y.sort(key=abs)\n    (ans1, ans2, ans3) = (0, 0, 0)\n    for i in range(n):\n        ans3 += math.sqrt(y[i] * y[i] + x[i] * x[i])\n    print(ans3)", "import math\nimport sys\nfrom functools import reduce\nimport decimal\nsys.setrecursionlimit(10 ** 9)\ndecimal.getcontext().rounding = decimal.ROUND_HALF_UP\n\ndef rounding(n):\n    return int(decimal.Decimal(f'{n}').to_integral_value())\n\ndef factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef inp():\n    return sys.stdin.readline().strip()\n\ndef map_inp(v_type):\n    return map(v_type, inp().split())\n\ndef list_inp(v_type):\n    return list(map_inp(v_type))\nfor _ in range(int(inp())):\n    n = int(inp())\n    minors = []\n    mines = []\n    for i in range(2 * n):\n        (x, y) = map_inp(int)\n        if y == 0:\n            mines.append(abs(x))\n        else:\n            minors.append(abs(y))\n    minors.sort()\n    mines.sort()\n    ans = 0\n    for (i, j) in zip(mines, minors):\n        ans += math.sqrt(i * i + j * j)\n    print(ans)", "import math\n\ndef main():\n    t = int(input())\n    while t:\n        t -= 1\n        n = int(input())\n        soma = 0\n        mina = []\n        mineiro = []\n        for i in range(2 * n):\n            entrada = input().split(' ')\n            x = int(entrada[0])\n            y = int(entrada[1])\n            if x == 0:\n                mineiro.append(abs(y))\n            else:\n                mina.append(abs(x))\n        mineiro.sort()\n        mina.sort()\n        for i in range(n):\n            soma += math.sqrt(mina[i] * mina[i] + mineiro[i] * mineiro[i])\n        print(soma)\nmain()", "import sys\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    a = []\n    b = []\n    for _ in range(n * 2):\n        (x, y) = list(map(int, sys.stdin.readline().split()))\n        if x == 0:\n            b.append(y * y)\n        else:\n            a.append(x * x)\n    a.sort()\n    b.sort()\n    d = 0\n    for i in range(n):\n        d = d + (a[i] + b[i]) ** 0.5\n    print(d)", "from collections import Counter, deque\nimport math\nfrom random import randint\nfrom bisect import bisect\nimport sys\nimport re\nimport copy\nMOD = 1000000007\nMAX = sys.maxsize\nMIN = -sys.maxsize\n\nclass get:\n\n    def int():\n        return list(map(int, input().split()))\n\n    def str():\n        return input().split()\n\n    def float():\n        return list(map(float, input().split()))\n\n    def map():\n        return map(int, input().split())\n\ndef sqrt(x):\n    return int(math.sqrt(x)) + 1\n\ndef gcd(*args):\n    result = args[0]\n    for item in args:\n        result = math.gcd(result, item)\n    return result\n\ndef LCM(a, b):\n    return a * b // math.gcd(a, b)\n\ndef value(n):\n    if n % 2 == 1:\n        return 2\n    else:\n        for i in range(3, n, 2):\n            if n % i != 0:\n                return i\n\ndef solve():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (a, b) = get.map()\n        if a == 0:\n            y.append(b * b)\n        else:\n            x.append(a * a)\n    x.sort()\n    y.sort()\n    res = 0\n    for i in range(n):\n        res += math.sqrt(x[i] + y[i])\n    print(res)\nfor _ in range(int(input())):\n    solve()", "import math\n\ndef main():\n    t = int(input())\n    diamond = []\n    miner = []\n    sum = 0\n    sum_list = []\n    for i in range(t):\n        n = int(input())\n        for j in range(2 * n):\n            (x, y) = input().split()\n            if int(x) == 0:\n                miner.append(abs(int(y)))\n            else:\n                diamond.append(abs(int(x)))\n        diamond = sorted(diamond)\n        miner = sorted(miner)\n        for j in range(n):\n            sum += math.sqrt(diamond[j] * diamond[j] + miner[j] * miner[j])\n        sum_list.append(sum)\n        sum = 0\n        diamond = []\n        miner = []\n    for i in range(t):\n        print(sum_list[i])\nmain()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    m = []\n    d = []\n    for _ in range(2 * n):\n        (x, y) = input().split()\n        if x == '0':\n            d.append(abs(int(y)))\n        else:\n            m.append(abs(int(x)))\n    s = 0\n    d.sort()\n    m.sort()\n    for i in range(n):\n        s += pow(m[i] * m[i] + d[i] * d[i], 0.5)\n    print(s)", "for t in range(int(input())):\n    miners = []\n    mines = []\n    for n in range(int(input()) * 2):\n        sub = input().split()\n        if sub[0] == '0':\n            miners.append(abs(int(sub[1])))\n        else:\n            mines.append(abs(int(sub[0])))\n    miners.sort()\n    mines.sort()\n    energy = 0\n    for i in range(len(miners)):\n        energy += (mines[i] ** 2 + miners[i] ** 2) ** 0.5\n    print(energy)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    m = []\n    d = []\n    for _ in range(2 * n):\n        (x, y) = input().split()\n        if x == '0':\n            d.append(abs(int(y)))\n        else:\n            m.append(abs(int(x)))\n    s = 0\n    d.sort()\n    m.sort()\n    for i in range(n):\n        s += pow(m[i] * m[i] + d[i] * d[i], 0.5)\n    print(s)", "inn = lambda : int(input())\ninm = lambda : map(int, input().split())\nins = lambda : str(input())\nina = lambda : list(map(int, input().split()))\nfrom math import sqrt\n\ndef solve():\n    n = inn()\n    a = []\n    b = []\n    for i in range(2 * n):\n        (x, y) = inm()\n        if x == 0:\n            a.append(abs(y))\n        else:\n            b.append(abs(x))\n    a.sort()\n    b.sort()\n    ans = 0\n    for (i, v) in enumerate(a):\n        w = b[i]\n        ans += sqrt(v * v + w * w)\n    print(ans)\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "def solve():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (x_temp, y_temp) = input().split()\n        x_temp = abs(int(x_temp))\n        y_temp = abs(int(y_temp))\n        if y_temp == 0:\n            x.append(x_temp)\n        else:\n            y.append(y_temp)\n    x = sorted(x)\n    y = sorted(y)\n    ans = 0\n    for i in range(len(x)):\n        ans += (x[i] * x[i] + y[i] * y[i]) ** 0.5\n    print('%.9f' % ans)\n    return 0\nt = int(input())\nwhile t:\n    solve()\n    t -= 1", "for t in range(int(input())):\n    miners = []\n    diamon = []\n    for n in range(2 * int(input())):\n        coord = input().split(' ')\n        if coord[0] == '0':\n            miners.append(abs(int(coord[1])))\n        elif coord[1] == '0':\n            diamon.append(abs(int(coord[0])))\n    miners.sort()\n    diamon.sort()\n    print(sum([(miners[n] ** 2 + diamon[n] ** 2) ** 0.5 for n in range(len(miners))]))", "import math\nsq = lambda x: x * x\n\ndef solv(xl, yl):\n    n = len(xl)\n    xl = list(map(sq, xl))\n    yl = list(map(sq, yl))\n    xl.sort()\n    yl.sort()\n    zl = [xl[i] + yl[i] for i in range(n)]\n    zl = list(map(math.sqrt, zl))\n    return sum(zl)\nfor _ in range(int(input())):\n    n = int(input())\n    xl = []\n    yl = []\n    for i in range(n << 1):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            yl.append(y)\n        else:\n            xl.append(x)\n    print(solv(xl, yl))", "import math\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nfor _ in range(int(input())):\n    n = int(input())\n    (a, b) = ([], [])\n    for (x, y) in (map(int, input().split()) for _ in range(n * 2)):\n        if x:\n            a.append(abs(x))\n        else:\n            b.append(abs(y))\n    s = sum((math.sqrt(x * x + y * y) for (x, y) in zip(sorted(a), sorted(b))))\n    print(s)", "from math import pi\n\ndef main():\n    n = int(input())\n    sh = []\n    al = []\n    for i in range(2 * n):\n        (x, y) = [int(i) for i in input().split()]\n        if x == 0:\n            if y < 0:\n                sh.append(-y)\n            else:\n                sh.append(y)\n        elif x < 0:\n            al.append(-x)\n        else:\n            al.append(x)\n    sh.sort()\n    al.sort()\n    s = 0\n    for i in range(n):\n        s += (sh[i] ** 2 + al[i] ** 2) ** 0.5\n    print(s)\nfor t in range(int(input())):\n    main()", "from math import sqrt\n\ndef solve(_mines, _miners):\n    _mines = sorted(_mines)\n    _miners = sorted(_miners)\n    ans = 0.0\n    for (mine, miner) in zip(_mines, _miners):\n        ans += sqrt(mine ** 2 + miner ** 2)\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    mines = []\n    miners = []\n    for _ in range(2 * n):\n        (x, y) = map(int, input().split(' '))\n        if x == 0:\n            mines.append(abs(y))\n        else:\n            miners.append(abs(x))\n    print(solve(mines, miners))", "t = int(input())\nwhile t:\n    n = int(input())\n    miners = []\n    diamond = []\n    for i in range(2 * n):\n        (x, y) = input().split()\n        if int(x) == 0:\n            miners.append(int(y) ** 2)\n        else:\n            diamond.append(int(x) ** 2)\n    miners.sort()\n    diamond.sort()\n    ans = [(miners[i] + diamond[i]) ** 0.5 for i in range(n)]\n    print(sum(ans))\n    t -= 1", "testcases = int(input())\nimport sys\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\nimport math\nfor testcase in range(testcases):\n    n = int(input())\n    miner = []\n    diamond = []\n    output = []\n    ranges = []\n    ans = 0\n    for i in range(2 * n):\n        temparr = get_ints()\n        x = temparr[0]\n        y = temparr[1]\n        if x == 0:\n            miner.append(abs(y))\n        else:\n            diamond.append(abs(x))\n    miner = sorted(miner)\n    diamond = sorted(diamond)\n    ans = 0\n    for i in range(n):\n        ans += math.sqrt(miner[i] * miner[i] + diamond[i] * diamond[i])\n    print(ans)", "from math import sqrt\n\ndef solve():\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (x_temp, y_temp) = input().split()\n        x_temp = abs(int(x_temp))\n        y_temp = abs(int(y_temp))\n        if y_temp == 0:\n            x.append(x_temp)\n        else:\n            y.append(y_temp)\n    x = sorted(x)\n    y = sorted(y)\n    ans = 0\n    for i in range(len(x)):\n        ans += sqrt(x[i] ** 2 + y[i] ** 2)\n    print(ans)\n    return 0\nt = int(input())\nwhile t:\n    solve()\n    t -= 1", "from math import dist\nfor _ in range(int(input())):\n    n = int(input())\n    miner = []\n    diamond = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miner.append(abs(y))\n        else:\n            diamond.append(abs(x))\n    miner.sort()\n    diamond.sort()\n    ans = 0\n    for i in range(n):\n        ans += dist((0, miner[i]), (diamond[i], 0))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [[], []]\n    for i in range(2 * n):\n        (l, r) = map(int, input().split())\n        if l:\n            a[0].append(abs(l))\n        else:\n            a[1].append(abs(r))\n    print(sum(((a * a + b * b) ** 0.5 for (a, b) in zip(*map(sorted, a)))))", "for t in range(int(input())):\n    n = int(input())\n    a = [[], []]\n    for i in range(2 * n):\n        (l, r) = map(int, input().split())\n        if l:\n            a[0].append(abs(l))\n        else:\n            a[1].append(abs(r))\n    print(sum(((a * a + b * b) ** 0.5 for (a, b) in zip(*map(sorted, a)))))", "from math import sqrt\n\ndef main():\n    for _ in range(int(input())):\n        m = []\n        n = []\n        for i in range(2 * int(input())):\n            (x, y) = list(map(int, input().split()))\n            if x == 0:\n                m.append(abs(y))\n            else:\n                n.append(abs(x))\n        soma = 0\n        n.sort()\n        m.sort()\n        for i in range(len(m) - 1, -1, -1):\n            soma += sqrt(m[i] ** 2 + n[i] ** 2)\n        print(soma)\nmain()", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if not a:\n            y.append(abs(b))\n        else:\n            x.append(abs(a))\n    x.sort()\n    y.sort()\n    ans = 0\n    for i in range(n):\n        ans += (y[i] ** 2 + x[i] ** 2) ** 0.5\n    print(ans)", "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    (x, y) = ([], [])\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            y.append(b ** 2)\n        else:\n            x.append(a ** 2)\n    x.sort()\n    y.sort()\n    ans1 = 0\n    for i in range(n):\n        ans1 += (x[i] + y[i]) ** 0.5\n    y = y[::-1]\n    ans = 0\n    for i in range(n):\n        ans = ans + (x[i] + y[i]) ** 0.5\n    print(min(ans, ans1))", "for _ in range(int(input())):\n    (miners, mines) = ([], [])\n    for _ in range(int(input()) * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            mines.append(abs(x))\n    ans = sum(((x * x + y * y) ** 0.5 for (x, y) in zip(sorted(miners), sorted(mines))))\n    print(ans)", "from math import sqrt\nfor _ in range(int(input())):\n    (miners, mines) = ([], [])\n    for _ in range(int(input()) * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            mines.append(abs(x))\n    ans = sum((sqrt(x * x + y * y) for (x, y) in zip(sorted(miners), sorted(mines))))\n    print(ans)", "import math\nN = int(input())\nfor _ in range(N):\n    n = int(input())\n    miners = []\n    mines = []\n    for i in range(2 * n):\n        (k1, k2) = input().split()\n        if k1 == '0':\n            miners.append(abs(int(k2)))\n        else:\n            mines.append(abs(int(k1)))\n    miners = sorted(miners, reverse=False)\n    mines = sorted(mines, reverse=False)\n    d = 0\n    for (m1, m2) in zip(miners, mines):\n        d += math.sqrt(m1 ** 2 + m2 ** 2)\n    print(d)", "import math\nimport string\n\ndef main_function():\n    test_cases = range(int(input()))\n    for test_case in test_cases:\n        n = int(input())\n        miners = []\n        diamonds = []\n        for i in range(2 * n):\n            (a, b) = [int(i) for i in input().split(' ')]\n            if a == 0:\n                miners.append(b)\n            else:\n                diamonds.append(a)\n        miners.sort(key=lambda x: abs(x))\n        diamonds.sort(key=lambda x: abs(x))\n        adder = 0\n        for i in range(len(miners)):\n            adder += math.sqrt(miners[i] ** 2 + diamonds[i] ** 2)\n        print(adder)\nmain_function()", "import math\nfrom collections import Counter\nfrom collections import defaultdict\nimport copy\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    mine = []\n    di = []\n    for i in range(2 * n):\n        (x, y) = [int(i) for i in input().split()]\n        if x == 0:\n            mine.append(abs(y))\n        else:\n            di.append(abs(x))\n    mine.sort()\n    di.sort()\n    ans = 0\n    for i in range(n):\n        ans += math.sqrt(mine[i] * mine[i] + di[i] * di[i])\n    print(ans)", "import math\n\ndef dis(x, y):\n    return math.sqrt(x ** 2 + y ** 2)\n\ndef main():\n    T = int(input())\n    while T:\n        T -= 1\n        lx = []\n        ly = []\n        n = int(input())\n        for i in range(n * 2):\n            s = input().split()\n            a = int(s[0])\n            b = int(s[1])\n            if a:\n                lx.append(abs(a))\n            else:\n                ly.append(abs(b))\n        lx.sort()\n        ly.sort()\n        lx = lx[::-1]\n        ly = ly[::-1]\n        ans = 0\n        for i in range(len(lx)):\n            ans += dis(lx[i], ly[i])\n        print(ans)\nmain()", "def fun():\n    from math import sqrt\n    for _ in range(int(input())):\n        n = int(input())\n        (miner, diamond) = ([], [])\n        for i in range(2 * n):\n            (x, y) = map(int, input().split())\n            if x == 0:\n                miner.append(abs(y))\n            if y == 0:\n                diamond.append(abs(x))\n        miner.sort()\n        diamond.sort()\n        sum1 = 0\n        for i in range(n):\n            sum1 += sqrt(diamond[i] * diamond[i] + miner[i] * miner[i])\n        print(sum1)\nfun()", "for _ in range(int(input())):\n    (miners, mines) = ([], [])\n    for _ in range(int(input()) * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            mines.append(abs(x))\n    ans = sum(((x * x + y * y) ** 0.5 for (x, y) in zip(sorted(miners), sorted(mines))))\n    print(ans)", "import sys\ninput = sys.stdin.readline\nimport math\n\ndef solution(n, points):\n    xs = [p[0] for p in points if p[1] == 0]\n    ys = [p[1] for p in points if p[0] == 0]\n    xs.sort(key=lambda x: abs(x))\n    ys.sort(key=lambda y: abs(y))\n    print(sum([math.sqrt(x ** 2 + y ** 2) for (x, y) in zip(xs, ys)]))\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(2 * n)]\n    solution(n, points)", "for _ in range(int(input())):\n    m = []\n    n = []\n    for __ in range(int(input()) * 2):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            n.append(abs(y))\n        else:\n            m.append(abs(x))\n    print(sum(((i * i + j * j) ** 0.5 for (i, j) in zip(sorted(m), sorted(n)))))", "import math\nt = int(input())\n\ndef findmin(arr1):\n    aa = set(arr1)\n    arr = [i for i in aa]\n    arr.sort()\n    i = 0\n    while i < len(arr):\n        if i != arr[i]:\n            return i\n        i += 1\n    return i\nwhile t:\n    t -= 1\n    n = int(input())\n    mm = []\n    m = []\n    n = 2 * n\n    while n:\n        n -= 1\n        (a, b) = input().split()\n        (a, b) = (int(a), int(b))\n        if a == 0:\n            mm.append(abs(b))\n        else:\n            m.append(abs(a))\n    mm.sort()\n    m.sort()\n    mm = [i * i for i in mm]\n    m = [i * i for i in m]\n    ans = 0\n    for i in range(len(mm)):\n        ans += math.sqrt(mm[i] + m[i])\n    print(ans)", "import math\n\ndef diamondMiner(N, d, m):\n    d = sorted(d)\n    m = sorted(m)\n    e = 0\n    for i in range(N):\n        e += math.sqrt(d[i] * d[i] + m[i] * m[i])\n    return e\nfor _ in range(int(input())):\n    N = int(input())\n    d = []\n    m = []\n    for _ in range(2 * N):\n        (x, y) = map(int, input().split())\n        if y == 0:\n            d.append(abs(x))\n        else:\n            m.append(abs(y))\n    print(diamondMiner(N, d, m))", "t = int(input())\nwhile t:\n    n = int(input())\n    m = []\n    d = []\n    ans = 0\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            m.append(abs(y))\n        else:\n            d.append(abs(x))\n    m.sort()\n    d.sort()\n    for i in range(n):\n        ans += (m[i] * m[i] + d[i] * d[i]) ** 0.5\n    print(ans)\n    t -= 1", "import sys\ninput = sys.stdin.readline\n\ndef I():\n    return input().strip()\n\ndef II():\n    return int(input().strip())\n\ndef LI():\n    return [*map(int, input().strip().split())]\nimport string, math, time, functools, random, fractions\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom itertools import permutations, combinations, groupby\nfor _ in range(II()):\n    n = II()\n    x = []\n    y = []\n    for i in range(2 * n):\n        (x1, y1) = LI()\n        if x1 == 0:\n            y.append(abs(y1))\n        else:\n            x.append(abs(x1))\n    x.sort()\n    y.sort()\n    ans = 0\n    for i in range(n):\n        ans += math.sqrt(x[i] ** 2 + y[i] ** 2)\n    print(ans)", "import math as m\n\ndef dis(x, y):\n    return m.sqrt(x ** 2 + y ** 2)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    (y, x) = ([], [])\n    for j in range(2 * n):\n        _ = tuple(input().split())\n        if _[0] == '0':\n            y.append(abs(int(_[1])))\n        else:\n            x.append(abs(int(_[0])))\n    x.sort()\n    y.sort()\n    print(sum([dis(x[i], y[i]) for i in range(n)]))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [[], []]\n    for i in range(2 * n):\n        (l, r) = map(int, input().split())\n        if l:\n            a[0].append(abs(l))\n        else:\n            a[1].append(abs(r))\n    print(sum(((a * a + b * b) ** 0.5 for (a, b) in zip(*map(sorted, a)))))", "from math import sqrt\n\ndef dist(a, b):\n    return sqrt(a ** 2 + b ** 2)\n\ndef solve():\n    n = int(input())\n    d = []\n    m = []\n    for p in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            m.append(abs(b))\n        else:\n            d.append(abs(a))\n    d.sort()\n    m.sort()\n    ans = 0\n    for x in range(n):\n        ans += dist(d[x], m[x])\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            y.append(abs(b))\n        else:\n            x.append(abs(a))\n    x.sort()\n    y.sort()\n    ans = 0\n    for i in range(n):\n        ans += (x[i] * x[i] + y[i] * y[i]) ** 0.5\n    print(ans)", "import math\n\ndef solv(xl, yl):\n    n = len(xl)\n    xl = [x * x for x in xl]\n    yl = [y * y for y in yl]\n    xl.sort()\n    yl.sort()\n    ans = 0\n    for i in range(n):\n        ans += math.sqrt(xl[i] + yl[i])\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    xl = []\n    yl = []\n    for i in range(n << 1):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            yl.append(y)\n        else:\n            xl.append(x)\n    print(solv(xl, yl))", "i = 0\nt = int(input())\nwhile i < t:\n    hipotenusa = 0.0\n    (minerador, mina) = ([], [])\n    n = int(input())\n    for j in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            minerador.append(abs(b))\n        if b == 0:\n            mina.append(abs(a))\n    minerador.sort()\n    mina.sort()\n    for s in range(n):\n        hipotenusa += (minerador[s] ** 2 + mina[s] ** 2) ** 0.5\n    print(hipotenusa)\n    i += 1", "from math import sqrt\ncasos = int(input())\nfor i in range(casos):\n    soma = 0\n    n = int(input())\n    mineradores = []\n    minas = []\n    for j in range(2 * n):\n        (a, b) = [int(x) for x in input().split(' ')]\n        if a == 0:\n            mineradores.append(abs(b))\n        else:\n            minas.append(abs(a))\n    mineradores.sort()\n    minas.sort()\n    for j in range(n):\n        soma += sqrt(mineradores[j] ** 2 + minas[j] ** 2)\n    print('%.15f' % soma)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    distancias = []\n    pos_x = []\n    pos_y = []\n    for j in range(n):\n        pos_xy = input()\n        pos_xy = pos_xy.split()\n        if int(pos_xy[0]) != 0:\n            pos_x.append(abs(int(pos_xy[0])))\n        else:\n            pos_y.append(abs(int(pos_xy[1])))\n        mina_xy = input()\n        mina_xy = mina_xy.split()\n        if int(mina_xy[0]) != 0:\n            pos_x.append(abs(int(mina_xy[0])))\n        else:\n            pos_y.append(abs(int(mina_xy[1])))\n    pos_x.sort()\n    pos_y.sort()\n    for j in range(n):\n        distancia = math.sqrt(pos_x[j] ** 2 + pos_y[j] ** 2)\n        distancias.append(distancia)\n    soma = 0\n    for j in range(n):\n        soma += distancias[j]\n    print(soma)", "import math\nI = lambda : map(int, input().split())\nfor _ in [0] * int(input()):\n    n = int(input())\n    m = [0] * n\n    i = 0\n    d = [0] * n\n    j = 0\n    for _ in [0] * (2 * n):\n        (x, y) = I()\n        if x == 0:\n            m[i] = y ** 2\n            i = i + 1\n        else:\n            d[j] = x ** 2\n            j = j + 1\n    m.sort()\n    d.sort()\n    s = 0\n    for (b, v) in zip(m, d):\n        s = s + math.sqrt(b + v)\n    print(s)", "for _ in range(int(input())):\n    n = int(input())\n    miners = []\n    diamond = []\n    for _ in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            diamond.append(abs(x))\n    miners.sort()\n    diamond.sort()\n    ans = 0\n    for i in range(len(miners)):\n        (x, y) = (miners[i], diamond[i])\n        ans += (x ** 2 + y ** 2) ** 0.5\n    print(ans)", "from math import sqrt\nfor _ in range(int(input())):\n    (a, b) = ([], [])\n    n = int(input())\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x != 0:\n            a.append(abs(x))\n        if y != 0:\n            b.append(abs(y))\n    a.sort()\n    b.sort()\n    energy = 0\n    for i in range(n):\n        r = a[i] * a[i] + b[i] * b[i]\n        p = sqrt(r)\n        energy += p\n    print(energy)", "import sys, math\nt = int(sys.stdin.readline().rstrip())\nfor _ in range(t):\n    n = int(sys.stdin.readline().rstrip())\n    miners = []\n    mines = []\n    for _ in range(2 * n):\n        loc = tuple(map(int, sys.stdin.readline().rstrip().split()))\n        if loc[0] == 0:\n            miners.append(abs(loc[1]))\n        else:\n            mines.append(abs(loc[0]))\n    miners.sort()\n    mines.sort()\n    energy = 0\n    for _ in range(n):\n        miner = miners.pop()\n        mine = mines.pop()\n        energy += math.sqrt(miner ** 2 + mine ** 2)\n    print(energy)", "from math import sqrt\nfor _ in range(int(input())):\n    n = int(input())\n    (miners, mines) = ([], [])\n    for _ in range(2 * n):\n        (x, y) = map(int, input().split())\n        if not x:\n            miners.append(y)\n        else:\n            mines.append(x)\n    miners.sort(key=lambda n: abs(n))\n    mines.sort(key=lambda n: abs(n))\n    print(sum((sqrt(miners[i] * miners[i] + mines[i] * mines[i]) for i in range(n))))", "import math\ntest_case = int(input())\nfor i in range(test_case):\n    n = int(input())\n    miner_pos = []\n    dimond_pos = []\n    for i in range(2 * n):\n        (r, c) = map(int, input().split())\n        if r == 0:\n            miner_pos.append(c * c)\n        else:\n            dimond_pos.append(r * r)\n    min_sum = 0\n    miner_pos.sort()\n    dimond_pos.sort()\n    for i in range(n):\n        min_sum = min_sum + math.sqrt(miner_pos[i] + dimond_pos[i])\n    print(min_sum)", "for _ in range(int(input())):\n    n = int(input())\n    X = []\n    Y = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if y == 0:\n            X.append(abs(x))\n        elif x == 0:\n            Y.append(abs(y))\n    X.sort()\n    Y.sort()\n    ans = 0\n    for i in range(n):\n        ans += (X[i] * X[i] + Y[i] * Y[i]) ** 0.5\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    mine = []\n    miner = []\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            miner.append(abs(b))\n        elif b == 0:\n            mine.append(abs(a))\n    mine.sort()\n    miner.sort()\n    c = 0\n    for i in range(n):\n        c += (mine[i] ** 2 + miner[i] ** 2) ** 0.5\n    print(c)", "import math\n\ndef solve(X, Y, n):\n    X = sorted(X)\n    Y = sorted(Y)\n    minEnergySum = 0\n    for i in range(n):\n        minEnergySum += math.sqrt(X[i] * X[i] + Y[i] * Y[i])\n    return minEnergySum\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    Miners = []\n    Mines = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            Miners.append(abs(y))\n        else:\n            Mines.append(abs(x))\n    result = solve(Miners, Mines, n)\n    print(result)", "for _ in range(int(input())):\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            y.append(b * b)\n        else:\n            x.append(a * a)\n    x.sort()\n    y.sort()\n    ans = 0\n    for j in range(len(x)):\n        ans += (x[j] + y[j]) ** (1 / 2)\n    print(ans)", "import math\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    n <<= 1\n    a = []\n    b = []\n    while n:\n        n -= 1\n        (i, j) = map(int, input().split())\n        if i:\n            a.append(abs(i))\n        else:\n            b.append(abs(j))\n    a.sort()\n    b.sort()\n    ans = 0\n    for i in range(0, len(a)):\n        ans += math.sqrt(a[i] * a[i] + b[i] * b[i])\n    print(ans)", "import math\n\ndef solve(m, d, bound):\n    m.sort()\n    d.sort()\n    ans = 0\n    res = 0\n    for i in range(0, bound):\n        res = math.sqrt(m[i] * m[i] + d[i] * d[i])\n        ans = ans + res\n    return ans\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    points = 2 * n\n    m = []\n    d = []\n    while points > 0:\n        (x, y) = map(int, input().split())\n        if x == 0:\n            m.append(abs(y))\n        if y == 0:\n            d.append(abs(x))\n        points = points - 1\n    print(solve(m, d, len(m)))\n    t = t - 1", "import math\n\ndef solve(x, y):\n    x.sort()\n    y.sort()\n    ans = 0\n    for i in range(len(x)):\n        ans += math.sqrt(1.0 * x[i] * x[i] + 1.0 * y[i] * y[i])\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input()) * 2\n    (xp, yp) = ([], [])\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            yp.append(abs(y))\n        else:\n            xp.append(abs(x))\n    print(solve(xp, yp))", "for _ in range(int(input())):\n    n = int(input())\n    miners = []\n    diamonds = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miners.append(abs(y))\n        else:\n            diamonds.append(abs(x))\n    miners.sort()\n    diamonds.sort()\n    answer = sum([(x ** 2 + y ** 2) ** 0.5 for (x, y) in zip(miners, diamonds)])\n    print(answer)", "import sys\nimport math\nt = int(input())\nfor tt in range(t):\n    n = int(input())\n    miner = []\n    diamond = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miner.append(abs(y))\n        else:\n            diamond.append(abs(x))\n    miner.sort()\n    diamond.sort()\n    dist = 0\n    for i in range(n):\n        dist += math.sqrt(math.pow(diamond[i], 2) + math.pow(miner[i], 2))\n    print(dist)", "for _ in range(int(input())):\n    x = []\n    y = []\n    n = int(input())\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            y.append(abs(b))\n        else:\n            x.append(abs(a))\n    ans = 0\n    x = sorted(x)\n    y = sorted(y)\n    for i in range(n):\n        ans += (x[i] * x[i] + y[i] * y[i]) ** 0.5\n    print('%.10f' % ans)", "for _ in range(int(input())):\n    (n, m, d) = (int(input()), [], [])\n    for _ in range(n + n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            m.append(abs(y))\n        else:\n            d.append(abs(x))\n    m.sort()\n    d.sort()\n    ans = 0\n    for i in range(n):\n        ans += (m[i] * m[i] + d[i] * d[i]) ** 0.5\n    print(ans)", "import sys\nimport math\nMOD = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    (a, b) = (list(), list())\n    for _ in range(2 * n):\n        (x, y) = map(int, input().split(' '))\n        if x == 0:\n            b.append(abs(y))\n        else:\n            a.append(abs(x))\n    a.sort()\n    b.sort()\n    ans = 0\n    for i in range(n):\n        x = a[i] * a[i] + b[i] * b[i]\n        ans += math.sqrt(x)\n    print(ans)", "from math import sqrt\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    (miners, mines) = ([], [])\n    for _ in range(2 * n):\n        (x, y) = (int(x) for x in input().split())\n        if x:\n            mines.append(abs(x))\n        else:\n            miners.append(abs(y))\n    (mines.sort(), miners.sort())\n    print(sum((sqrt(mines[i] ** 2 + miners[i] ** 2) for i in range(n))))", "for _ in range(int(input())):\n    n = int(input())\n    miners = []\n    mines = []\n    for i in range(2 * n):\n        (x, y) = input().split()\n        x = int(x)\n        y = int(y)\n        if x == 0:\n            miners.append(abs(y))\n        if y == 0:\n            mines.append(abs(x))\n    mines.sort()\n    miners.sort()\n    sum = 0\n    for i in range(n):\n        sum += (mines[i] ** 2 + miners[i] ** 2) ** 0.5\n    print(sum)", "t = int(input())\nfor j in range(t):\n    n = int(input())\n    (a, b) = ([], [])\n    for i in range(n * 2):\n        nums = list(map(int, input().split()))\n        if nums[0] == 0:\n            a.append(abs(nums[1]))\n        else:\n            b.append(abs(nums[0]))\n    a.sort()\n    b.sort()\n    g = 0\n    for i in range(n):\n        g = g + (a[i] ** 2 + b[i] ** 2) ** 0.5\n    print(g)", "from math import sqrt\nfor _ in range(int(input())):\n    n = int(input())\n    a = []\n    b = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            a += [abs(y)]\n        else:\n            b += [abs(x)]\n    a.sort()\n    b.sort()\n    dist = 0\n    for i in range(n):\n        dist += sqrt(a[i] ** 2 + b[i] ** 2)\n    print(dist)", "import math\nt = int(input())\nfor _ in range(t):\n    x = []\n    y = []\n    n = int(input())\n    for __ in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            if b < 0:\n                y.append(-1 * b)\n            else:\n                y.append(b)\n        elif a < 0:\n            x.append(-1 * a)\n        else:\n            x.append(a)\n    x.sort()\n    y.sort()\n    sum = 0\n    for i in range(n):\n        sum += math.pow(x[i] * x[i] + y[i] * y[i], 0.5)\n    print(sum)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    xar = []\n    yar = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            if y > 0:\n                yar.append(y)\n            else:\n                yar.append(-1 * y)\n        if y == 0:\n            if x > 0:\n                xar.append(x)\n            else:\n                xar.append(-1 * x)\n    xar.sort()\n    yar.sort()\n    sum = 0\n    for i in range(n):\n        sum += math.sqrt(xar[i] * xar[i] + yar[i] * yar[i])\n    print(sum)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    x = []\n    y = []\n    for i in range(2 * n):\n        (a, b) = map(int, input().split())\n        if a == 0:\n            y.append(abs(b))\n        else:\n            x.append(abs(a))\n    x = sorted(x)\n    y = sorted(y)\n    ans = 0\n    for i in range(len(x)):\n        ans += math.sqrt(x[i] * x[i] + y[i] * y[i])\n    print(round(ans, 15))", "import math\nimport sys\nimport collections\nimport bisect\nimport string\nimport time\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nfor t in range(int(input())):\n    n = int(input())\n    m1 = []\n    m2 = []\n    for j in range(2 * n):\n        (x, y) = get_ints()\n        if x == 0:\n            m2.append(abs(y))\n        if y == 0:\n            m1.append(abs(x))\n    m1.sort()\n    m2.sort()\n    gb_ans = 0\n    for j in range(n):\n        v1 = m1[j] ** 2\n        v2 = m2[j] ** 2\n        sol = v1 + v2\n        sol = math.sqrt(sol)\n        gb_ans += sol\n    print(gb_ans)", "from math import hypot\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    miner = []\n    dia = []\n    for _ in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miner.append(abs(y))\n        else:\n            dia.append(abs(x))\n    res1 = 0\n    miner.sort()\n    dia.sort()\n    for (a, b) in zip(miner, dia):\n        res1 += hypot(a, b)\n    res2 = 0\n    dia.reverse()\n    for (a, b) in zip(miner, dia):\n        res2 += hypot(a, b)\n    print(f'{min(res1, res2)}')", "import math\nt = int(input())\nfor hh in range(0, t):\n    n = int(input())\n    a = []\n    b = []\n    for i in range(0, 2 * n):\n        (x, y) = [int(x) for x in input().split()]\n        if x == 0:\n            a.append(y * y)\n        else:\n            b.append(x * x)\n    a.sort()\n    b.sort()\n    ans = 0\n    for i in range(0, n):\n        ans += math.sqrt(a[i] + b[i])\n    print('{0:.10f}'.format(ans))", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l1 = []\n    l2 = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            l1.append(abs(y))\n        if y == 0:\n            l2.append(abs(x))\n    l1.sort()\n    l2.sort()\n    ans = 0\n    for i in range(n):\n        ans += math.sqrt(l1[i] * l1[i] + l2[i] * l2[i])\n    print(ans)", "import math\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    miner = []\n    mine = []\n    for i in range(2 * n):\n        (x, y) = map(int, input().split(' '))\n        if x == 0:\n            miner.append(abs(y))\n        else:\n            mine.append(abs(x))\n    miner.sort()\n    mine.sort()\n    sm = 0\n    for i in range(n):\n        sm += math.sqrt(miner[i] * miner[i] + mine[i] * mine[i])\n    print(sm)", "import math\nt = int(input())\n\ndef findmin(arr1):\n    aa = set(arr1)\n    arr = [i for i in aa]\n    arr.sort()\n    i = 0\n    while i < len(arr):\n        if i != arr[i]:\n            return i\n        i += 1\n    return i\nwhile t:\n    t -= 1\n    n = int(input())\n    mm = []\n    m = []\n    n = 2 * n\n    while n:\n        n -= 1\n        (a, b) = input().split()\n        (a, b) = (int(a), int(b))\n        if a == 0:\n            mm.append(abs(b))\n        else:\n            m.append(abs(a))\n    mm.sort()\n    m.sort()\n    mm = [i * i for i in mm]\n    m = [i * i for i in m]\n    ans = 0\n    for i in range(len(mm)):\n        ans += math.sqrt(mm[i] + m[i])\n    print(round(ans, 15))", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    (n,) = I()\n    m = []\n    d = []\n    for i in range(2 * n):\n        (a, b) = I()\n        if a == 0:\n            m += [abs(b)]\n        else:\n            d += [abs(a)]\n    m.sort()\n    d.sort()\n    s = 0\n    print(sum(((x * x + y * y) ** 0.5 for (x, y) in zip(m, d))))", "import math\nT = int(input())\nfor cas in range(T):\n    ans = 0\n    x = []\n    y = []\n    n = int(input())\n    for i in range(2 * n):\n        (tx, ty) = map(int, input().split())\n        if tx == 0:\n            if ty > 0:\n                y.append(ty)\n            else:\n                y.append(-ty)\n        elif tx > 0:\n            x.append(tx)\n        else:\n            x.append(-tx)\n    x.sort()\n    y.sort()\n    for i in range(n):\n        ans += math.sqrt(x[i] * x[i] + y[i] * y[i])\n    print(ans)", "for test in range(int(input())):\n    n = int(input())\n    (diamond, miner) = ([], [])\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            miner.append(abs(y))\n        else:\n            diamond.append(abs(x))\n    miner.sort()\n    diamond.sort()\n    dis = 0\n    for (i, j) in zip(miner, diamond):\n        dis += (i ** 2 + j ** 2) ** 0.5\n    print(dis)", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    (a, b) = ([], [])\n    for i in range(2 * n):\n        (x, y) = map(int, input().split())\n        if x == 0:\n            a.append(abs(y))\n        else:\n            b.append(abs(x))\n    a.sort()\n    b.sort()\n    res = 0\n    for i in range(n):\n        res += math.sqrt(a[i] ** 2 + b[i] ** 2)\n    print(res)"]