["def solve():\n    (n, d, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    f = list()\n    g = list()\n    for x in a:\n        if x > m:\n            f.append(x)\n        else:\n            g.append(x)\n    f.sort(reverse=True)\n    g.sort(reverse=True)\n    ng = len(g)\n    a = [0] * (ng + 1)\n    for i in range(ng):\n        a[i + 1] = a[i] + g[i]\n    ans = a[ng]\n    cur = 0\n    for i in range(len(f)):\n        if i + 1 + i * d > n:\n            break\n        cur += f[i]\n        v = n - i * d - i - 1\n        if v > ng:\n            v = ng\n        if v < 0:\n            v = 0\n        if ans < cur + a[v]:\n            ans = cur + a[v]\n    print(ans)\n    return\nsolve()", "from itertools import groupby, accumulate, product, permutations, combinations\n\ndef solve():\n    (n, d, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    over = []\n    safe = []\n    for i in range(n):\n        if A[i] > m:\n            over.append(A[i])\n        else:\n            safe.append(A[i])\n    X = len(over)\n    Y = len(safe)\n    over.sort(reverse=True)\n    over = [0] + list(accumulate(over))\n    safe.sort(reverse=True)\n    safe = [0] + list(accumulate(safe))\n    if X == 0:\n        return sum(A)\n    ans = 0\n    for x in range(1, X + 1):\n        p = (x - 1) * (d + 1) + 1\n        if p > n:\n            break\n        if p >= X:\n            y = n - p\n            ans = max(ans, over[x] + safe[y])\n        elif x * (d + 1) >= X:\n            ans = max(ans, over[x] + safe[Y])\n    return ans\nprint(solve())", "from itertools import groupby, accumulate, product, permutations, combinations\n\ndef solve():\n    (n, d, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    over = []\n    safe = []\n    for i in range(n):\n        if A[i] > m:\n            over.append(A[i])\n        else:\n            safe.append(A[i])\n    X = len(over)\n    Y = len(safe)\n    over.sort(reverse=True)\n    over = [0] + list(accumulate(over))\n    safe.sort(reverse=True)\n    safe = [0] + list(accumulate(safe))\n    safe = safe + [safe[-1]] * (n - Y)\n    if X == 0:\n        return sum(A)\n    ans = 0\n    for x in range(1, X + 1):\n        p = (x - 1) * (d + 1) + 1\n        if p > n:\n            break\n        y = n - p\n        ans = max(ans, over[x] + safe[y])\n    return ans\nprint(solve())", "t = 1\nfor test in range(t):\n    (n, d, m) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    big = [each for each in arr if each > m]\n    small = [each for each in arr if each <= m]\n    big = [0] + sorted(big, reverse=True)\n    small = [0] + sorted(small, reverse=True)\n    for i in range(1, len(big)):\n        big[i] += big[i - 1]\n    for i in range(1, len(small)):\n        small[i] += small[i - 1]\n    ans = small[-1]\n    for i in range(1, len(big)):\n        days = (i - 1) * (d + 1) + 1\n        if days <= n:\n            ans = max(ans, big[i] + small[min(len(small) - 1, n - days)])\n    print(ans)", "(n, d, m) = map(int, input().split())\nl = list(map(int, input().split()))\nsmall = []\nbig = []\nfor i in l:\n    if i <= m:\n        small.append(i)\n    else:\n        big.append(i)\nsmall.sort(reverse=True)\nbig.sort(reverse=True)\ncurr = 0\npre = [0]\nfor i in range(len(small)):\n    pre.append(pre[-1] + small[i])\nans = pre[-1]\nfor i in range(len(big)):\n    if i + 1 + i * d > n:\n        break\n    curr += big[i]\n    ind = n - i * d - i - 1\n    if ind > len(small):\n        ind = len(small)\n    if ind < 0:\n        ind = 0\n    temp = curr + pre[ind]\n    ans = max(ans, temp)\nprint(ans)", "def solve(n, d, m, a):\n    a.sort()\n    small = sorted((x for x in a if x <= m))\n    scs = [0]\n    for x in small:\n        scs.append(scs[-1] + x)\n    sol = scs[-1]\n    bn = n - len(small)\n    (take, r, sbig, possible) = (1, n - 1, 0, True)\n    while possible:\n        skip = d * (take - 1)\n        if a[r] > m and skip + take <= n:\n            sbig += a[r]\n            skip = max(skip - (bn - take), 0)\n            ssmall = scs[-1] - scs[skip] if skip < len(scs) else 0\n            sol = max(sol, sbig + ssmall)\n            r -= 1\n            take += 1\n        else:\n            possible = False\n    return sol\n(n, d, m) = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, d, m, a))", "(n, d, m) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\ncnt = 0\nlt = [x for x in arr if x <= m][::-1]\ngt = [x for x in arr if x > m][::-1]\nif not gt:\n    print(sum(arr))\n    exit(0)\nfor i in range(1, len(gt)):\n    gt[i] += gt[i - 1]\nfor i in range(1, len(lt)):\n    lt[i] += lt[i - 1]\nk = (n + d) // (d + 1)\nans = sum(arr[-k:])\nfor i in range(len(lt)):\n    k = (n + d - i - 1) // (d + 1)\n    if k <= len(gt):\n        ans = max(ans, gt[k - 1] + lt[i])\n    else:\n        ans = max(ans, gt[-1] + lt[k - len(gt) + i])\nprint(ans)", "(n, d, m) = [int(inp) for inp in input().split()]\naArr = sorted([int(inp) for inp in input().split()], reverse=True)\ni = sum([j > m for j in aArr])\naU = aArr[:i]\naL = aArr[i:]\naUS = aU\nfor i in range(1, len(aU)):\n    aUS[i] += aUS[i - 1]\naUS = [0] + aUS\naLS = aL\nfor i in range(1, len(aL)):\n    aLS[i] += aLS[i - 1]\naLS = [0] + aLS\nfromU = min(1 + (n - 1) // (d + 1), len(aU))\nmaxFun = aUS[0] + aLS[-1]\nfor j in range(1, fromU + 1):\n    newFun = aUS[j] + aLS[min(max(0, n - 1 - (j - 1) * (d + 1)), len(aL))]\n    if newFun > maxFun:\n        maxFun = newFun\nprint(maxFun)", "from math import ceil\nimport sys\nread = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef maxFun():\n    (n, d, m) = map(int, read().split())\n    nums = list(map(int, read().split()))\n    nums.sort(reverse=True)\n    smaller = list()\n    larger = list()\n    for i in nums:\n        if i <= m:\n            smaller.append(i)\n        else:\n            larger.append(i)\n    large_len = len(larger)\n    smaller = smaller + [0] * (n - len(smaller))\n    larger = larger + [0] * (n - len(larger))\n    large_suff = [0] * (n + 1)\n    small_pre = [0] * (n + 1)\n    for i in range(1, n + 1):\n        small_pre[i] = small_pre[i - 1] + smaller[i - 1]\n        large_suff[i] = large_suff[i - 1] + larger[i - 1]\n    ans = small_pre[-1]\n    for j in range(1, large_len + 1):\n        pos = (j - 1) * (d + 1) + 1\n        if pos > n:\n            break\n        ans = max(ans, large_suff[j] + small_pre[n - pos])\n    print(ans)\nmaxFun()", "arr = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nn = arr[0]\nd = arr[1]\nm = arr[2]\nbig = []\nsmall = []\nfor i in a:\n    if i > m:\n        big.append(i)\n    else:\n        small.append(i)\nbig = sorted(big)[::-1]\nn1 = len(big)\nans = 0\nn2 = len(small)\nsmall = sorted(small)[::-1]\nfor i in range(1, n1):\n    big[i] += big[i - 1]\nfor i in range(1, n2):\n    small[i] += small[i - 1]\nif n2 > n:\n    ans = small[n - 1]\nelif n2 >= 1:\n    ans = small[n2 - 1]\nfor i in range(n1):\n    no_of_big_considered = i + 1\n    no = (no_of_big_considered - 1) * (d + 1) + 1\n    if no > n:\n        break\n    temp = big[i]\n    ele = n - no\n    if ele > 0 and n2 >= 1:\n        temp += small[min(ele - 1, n2 - 1)]\n    else:\n        pass\n    ans = max(ans, temp)\nprint(ans)", "from itertools import accumulate\n\ndef main():\n    (n, d, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    A_low = []\n    A_high = []\n    for a in A:\n        if a <= m:\n            A_low.append(a)\n        else:\n            A_high.append(a)\n    Ll = len(A_low)\n    Lh = len(A_high)\n    A_low.sort(reverse=True)\n    A_high.sort(reverse=True)\n    accA_high = [0] + list(accumulate(A_high))\n    t = (n + d) // (d + 1)\n    if t <= Lh:\n        ans = accA_high[(n + d) // (d + 1)]\n    else:\n        ans = accA_high[-1]\n    low = 0\n    for i in range(Ll):\n        low += A_low[i]\n        t = (n - i - 1 + d) // (d + 1)\n        if t <= Lh:\n            high = accA_high[(n - i - 1 + d) // (d + 1)]\n        else:\n            high = accA_high[-1]\n        if low + high > ans:\n            ans = low + high\n    print(ans)\nmain()", "def main():\n    (n, d, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(filter(lambda i: i > m, a))\n    c = list(filter(lambda i: i <= m, a))\n    del a\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n    for (idx, i) in enumerate(b):\n        if idx:\n            b[idx] += b[idx - 1]\n    for (idx, i) in enumerate(c):\n        if idx:\n            c[idx] += c[idx - 1]\n    mx = 0\n    k = (n + d) // (d + 1)\n    if len(b) >= k:\n        mx = b[k - 1]\n    for (idx, i) in enumerate(c):\n        bcnt = (n - idx - 1 + d) // (d + 1)\n        if len(b) >= bcnt:\n            if bcnt:\n                mx = max(mx, b[bcnt - 1] + c[idx])\n            elif len(c) == n:\n                mx = max(mx, c[idx])\n    print(mx)\n    return\nmain()", "import sys\ninput = sys.stdin.readline\nfor _ in range(1):\n    (n, d, m) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    (a, b) = ([], [])\n    for i in arr:\n        if i > m:\n            a.append(i)\n        else:\n            b.append(i)\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    for i in range(1, len(a)):\n        a[i] += a[i - 1]\n    for i in range(1, len(b)):\n        b[i] += b[i - 1]\n    if a and b:\n        ans = max(a[0], b[-1])\n    elif a:\n        ans = a[0]\n    else:\n        ans = b[-1]\n    for i in range(len(a)):\n        rem = n - ((d + 1) * i + 1)\n        if rem >= 0:\n            ans = max(ans, a[i])\n        rem -= 1\n        if rem >= 0 and b:\n            rem = min(rem, len(b) - 1)\n            ans = max(ans, a[i] + b[rem])\n    print(ans)", "def mi():\n    return map(int, input().split())\n\ndef ii():\n    return int(input())\n\ndef li():\n    return list(map(int, input().split()))\n\ndef si():\n    return input().split()\n(n, d, m) = mi()\na = li()\na_s = []\na_b = []\nfor i in range(n):\n    if a[i] > m:\n        a_b.append(a[i])\n    else:\n        a_s.append(a[i])\na_b.sort(reverse=True)\na_s.sort(reverse=True)\ns = 0\ndb = []\nds = []\nfor i in a_b:\n    db.append(s)\n    s += i\ndb.append(s)\ns = 0\nfor i in a_s:\n    ds.append(s)\n    s += i\nds.append(s)\nans = ds[-1]\nfor i in range(1, len(db)):\n    tmp = db[i]\n    days = (i - 1) * (d + 1) + 1\n    rem = n - days\n    if rem >= len(ds):\n        ans = max(ans, tmp + ds[-1])\n    elif rem < 1:\n        if days <= n:\n            ans = max(ans, tmp)\n    else:\n        ans = max(ans, tmp + ds[rem])\nprint(ans)", "(n, d, m) = map(int, input().split())\n(n1, n2) = ([0 for i in range(d)], [])\nfor i in map(int, input().split()):\n    if i > m:\n        n2.append(i)\n    else:\n        n1.append(i)\nout = su = sum(n1)\nn1.sort(reverse=True)\nn2.sort(reverse=True)\ncount = 0\nfor i in range(len(n2)):\n    while n1 and count + len(n2) - i - 1 < (i + 1) * d:\n        su -= n1.pop()\n        count += 1\n    su += n2[i]\n    if count + len(n2) - i - 1 >= d * (i + 1):\n        out = max(out, su)\nprint(out)", "import bisect\n(n, d, m) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nnaga = 0\nf = {0: 0}\nfor i in range(n):\n    naga = naga + 1\n    f[i + 1] = f[i] + arr[i]\nk = bisect.bisect_right(arr, m)\nans = 0\nfor nlo in range(k + 1):\n    nhg = (n - nlo + d) // (d + 1)\n    if nhg <= n - k:\n        ans = max(ans, f[n] - f[n - nhg] + f[k] - f[k - nlo])\nprint(ans)", "(n, d, m) = map(int, input().split())\n(n1, n2) = ([0 for i in range(d)], [])\nfor i in map(int, input().split()):\n    if i > m:\n        n2.append(i)\n    else:\n        n1.append(i)\nout = su = sum(n1)\nn1.sort()\nn2.sort()\nj = 0\nfor i in range(len(n2) - 1, -1, -1):\n    while j < len(n1) and i + j < d * (len(n2) - i):\n        su -= n1[j]\n        j += 1\n    su += n2[i]\n    if i + j >= d * (len(n2) - i):\n        out = max(out, su)\nprint(out)", "data = [*open(0)]\ndi = lambda x: map(int, data[x].split())\n(n, d, m) = (*di(0),)\na = (*di(1),)\nl1 = []\nl2 = []\nfor ai in a:\n    if ai > m:\n        l1.append(-ai)\n    else:\n        l2.append(-ai)\nl1.sort()\nl2.sort()\nans = 0\nl1.insert(0, 0)\nl2.insert(0, 0)\nm1 = len(l1)\nm2 = len(l2)\nfor i in range(1, m1):\n    l1[i] = l1[i] + l1[i - 1]\nfor i in range(1, m2):\n    l2[i] = l2[i] + l2[i - 1]\nfor i in range(m2):\n    k = (m2 + m1 - i + d - 2) // (d + 1)\n    if k < m1:\n        ans = max(ans, -l1[k] - l2[i])\nprint(ans)", "import bisect\n(n, d, m) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nf = {0: 0}\nfor i in range(n):\n    f[i + 1] = f[i] + arr[i]\nk = bisect.bisect_right(arr, m)\nans = 0\nfor nlo in range(k + 1):\n    nhg = (n - nlo + d) // (d + 1)\n    if nhg <= n - k:\n        ans = max(ans, f[n] - f[n - nhg] + f[k] - f[k - nlo])\nprint(ans)", "import bisect\n(n, d, m) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nf = {0: 0}\nfor i in range(n):\n    f[i + 1] = f[i] + arr[i]\nk = bisect.bisect_right(arr, m)\nans = 0\nfor nlo in range(k + 1):\n    nhg = (n - nlo + d) // (d + 1)\n    if nhg <= n - k:\n        ans = max(ans, f[n] - f[n - nhg] + f[k] - f[k - nlo])\nprint(ans)", "import bisect\n(n, d, m) = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\nf = {0: 0}\nfor i in range(n):\n    f[i + 1] = f[i] + arr[i]\nk = bisect.bisect_right(arr, m)\nans = 0\nfor nlo in range(k + 1):\n    nhg = (n - nlo + d) // (d + 1)\n    if nhg <= n - k:\n        ans = max(ans, f[n] - f[n - nhg] + f[k] - f[k - nlo])\nprint(ans)"]