["import sys\nt = int(input())\nc = [0] * t\n\ndef error():\n    print('NO')\n    raise SystemExit\n\ndef max2(a, b):\n    if a > b:\n        return a\n    return b\nv = [[10000000000.0, -1]]\nindex = 0\nfor _ in range(t + t):\n    q = sys.stdin.readline()\n    if q[0] == '+':\n        v.append([0, index])\n        index += 1\n        continue\n    n = int(q.split()[1])\n    if v[-1][0] > n:\n        error()\n    c[v.pop()[1]] = n\n    v[-1][0] = max2(n, v[-1][0])\nprint('YES')\nprint(' '.join(list(map(lambda x: str(x), c))))", "import sys\nt = int(input())\nc = [0] * t\n\ndef error():\n    print('NO')\n    raise SystemExit\n\ndef max2(a, b):\n    if a > b:\n        return a\n    return b\nv = [[10000000000.0, -1]]\nindex = 0\nfor _ in range(t + t):\n    q = sys.stdin.readline()\n    if q[0] == '+':\n        v.append([0, index])\n        index += 1\n        continue\n    n = int(q.split()[1])\n    if v[-1][0] > n:\n        error()\n    c[v.pop()[1]] = n\n    v[-1][0] = max2(n, v[-1][0])\nprint('YES')\nprint(' '.join(list(map(lambda x: str(x), c))))", "l = []\nn = int(input())\nfor _ in range(2 * n):\n    l.append(input())\nstk = []\nvisited = [False] * n\nf = True\nans = []\nfor i in reversed(l):\n    if i[0] == '+':\n        if len(stk) == 0:\n            f = False\n            break\n        t = stk.pop()\n        ans.append(t)\n        if visited[t - 1]:\n            f = False\n            break\n        visited[t - 1] = True\n    else:\n        t = int(i[2:])\n        if visited[t - 1]:\n            f = False\n            break\n        if len(stk) > 0 and stk[-1] < t:\n            f = False\n            break\n        stk.append(t)\nif len(stk) != 0:\n    f = False\nif f:\n    print('YES')\n    print(*reversed(ans))\nelse:\n    print('NO')", "t = int(input())\nc = [0] * t\n\ndef error():\n    print('NO')\n    raise SystemExit\nv = [[10000000000.0, -1]]\nindex = 0\nfor _ in range(t + t):\n    q = input()\n    if q[0] == '+':\n        v.append([0, index])\n        index += 1\n        continue\n    n = int(q.split()[1])\n    if v[-1][0] > n:\n        error()\n    c[v.pop()[1]] = n\n    v[-1][0] = max(n, v[-1][0])\nprint('YES')\nprint(' '.join(list(map(lambda x: str(x), c))))", "def read_seq(v):\n    seq = []\n    for i in range(2 * v):\n        s = input().split()\n        if len(s) == 2:\n            s[1] = int(s[1])\n        seq.append(s)\n    return seq\n\ndef solve():\n    n = int(input())\n    pos = [-1] * (2 * n)\n    stack = []\n    seq = read_seq(n)\n    for (i, act) in enumerate(seq):\n        if act[0] == '+':\n            stack.append(i)\n        elif not stack:\n            return None\n        else:\n            v = stack.pop()\n            pos[v] = act[1]\n    if stack:\n        return None\n    stack = []\n    for (i, act) in enumerate(seq):\n        if act[0] == '+':\n            if stack and stack[-1] < pos[i]:\n                return None\n            else:\n                stack.append(pos[i])\n        else:\n            stack.pop()\n    return [x for x in pos if x != -1]\n\ndef main():\n    res = solve()\n    if res:\n        print('YES')\n        print(' '.join(map(str, res)))\n    else:\n        print('NO')\nmain()", "def read_seq(v):\n    seq = []\n    for _ in range(2 * v):\n        s = input().split()\n        if len(s) == 2:\n            s[1] = int(s[1])\n        seq.append(s)\n    return seq\n\ndef solve():\n    n = int(input())\n    pos = [-1] * (2 * n)\n    stack = []\n    seq = read_seq(n)\n    for (i, act) in enumerate(seq):\n        if act[0] == '+':\n            stack.append(i)\n        elif not stack:\n            return None\n        else:\n            v = stack.pop()\n            pos[v] = act[1]\n    if stack:\n        return None\n    stack = []\n    for (i, act) in enumerate(seq):\n        if act[0] == '+':\n            if stack and stack[-1] < pos[i]:\n                return None\n            else:\n                stack.append(pos[i])\n        else:\n            stack.pop()\n    return [x for x in pos if x != -1]\n\ndef main():\n    res = solve()\n    if res:\n        print('YES')\n        print(' '.join(map(str, res)))\n    else:\n        print('NO')\nmain()", "t = int(input())\nc = [0] * t\n\ndef error():\n    print('NO')\n    raise SystemExit\nv = []\nindex = 0\nfor _ in range(t + t):\n    q = input()\n    if q[0] == '+':\n        v.append([0, index])\n        index += 1\n        continue\n    n = int(q.split()[1])\n    if len(v) == 0:\n        error()\n    if v[-1][0] > n:\n        error()\n    c[v.pop()[1]] = n\n    if len(v) != 0:\n        v[-1][0] = max(n, v[-1][0])\nprint('YES')\nprint(' '.join(list(map(lambda x: str(x), c))))", "n = int(input())\na = [input() for _ in range(2 * n)]\nq = []\nans = []\nfor line in a[::-1]:\n    if line == '+':\n        if q == []:\n            print('NO')\n            exit(0)\n        else:\n            ans.append(q[-1])\n            q.pop()\n    else:\n        r = line.split()\n        r[1] = int(r[1])\n        if q != [] and r[1] > q[-1]:\n            print('NO')\n            exit(0)\n        else:\n            q.append(r[1])\nprint('YES')\nprint(*ans[::-1])", "import sys\nimport heapq\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    S = [[x for x in input().split()] for _ in range(2 * N)]\n    q = []\n    ans = []\n    for s in S[::-1]:\n        if s[0] == '-':\n            heapq.heappush(q, int(s[1]))\n        elif q:\n            c = heapq.heappop(q)\n            ans.append(c)\n        else:\n            print('NO')\n            return\n    ans2 = ans[::-1]\n    q = []\n    current = 0\n    for s in S:\n        if s[0] == '-':\n            c = heapq.heappop(q)\n            if c != int(s[1]):\n                print('NO')\n                return\n        else:\n            heapq.heappush(q, ans2[current])\n            current += 1\n    print('YES')\n    print(*ans2)\nmain()", "n = int(input())\nquery = []\nfor i in range(2 * n):\n    a = input().split()\n    if a[0] == '+':\n        query.append(0)\n    else:\n        query.append(int(a[1]))\nstack = []\nout = []\nans = 'YES'\nif query[-1] == 0:\n    ans = 'NO'\nelse:\n    stack.append(query.pop())\n    while query:\n        if not stack and query[-1] == 0 or (stack and stack[-1] < query[-1]):\n            ans = 'NO'\n            break\n        elif query[-1] > 0:\n            stack.append(query.pop())\n        else:\n            _ = query.pop()\n            out.append(stack.pop())\nprint(ans)\nif ans == 'YES':\n    print(*out[::-1])", "n = int(input())\nquery = []\nfor i in range(2 * n):\n    a = input().split()\n    if a[0] == '+':\n        query.append(0)\n    else:\n        query.append(int(a[1]))\nstack = []\nout = []\nans = 'YES'\nif query[-1] == 0:\n    ans = 'NO'\nelse:\n    stack.append(query.pop())\n    while query:\n        if not stack and query[-1] == 0 or (stack and stack[-1] < query[-1]):\n            ans = 'NO'\n            break\n        elif query[-1] > 0:\n            stack.append(query.pop())\n        else:\n            _ = query.pop()\n            out.append(stack.pop())\nprint(ans)\nif ans == 'YES':\n    print(*out[::-1])", "import sys\nimport heapq\ninput = sys.stdin.readline\ndata = []\nfor i in range(2 * int(input())):\n    data.append(input().split())\navalible = []\nresult = []\ntry:\n    for i in data[::-1]:\n        if i[0] == '-':\n            heapq.heappush(avalible, int(i[1]))\n        else:\n            m = heapq.heappop(avalible)\n            result.append(m)\n    result = result[::-1]\n    avalible = []\n    p = 0\n    for i in data:\n        if i[0] == '-':\n            m = heapq.heappop(avalible)\n            if m != int(i[1]):\n                print('NO')\n                sys.exit()\n        else:\n            heapq.heappush(avalible, result[p])\n            p += 1\nexcept Exception:\n    print('NO')\n    sys.exit()\nprint('YES')\nprint(*result)", "import sys\nimport heapq\ninput = sys.stdin.readline\ndata = []\nfor i in range(2 * int(input())):\n    data.append(input().split())\nq = []\nresult = []\nfor i in data[::-1]:\n    if i[0] == '-':\n        heapq.heappush(q, int(i[1]))\n    elif q:\n        m = heapq.heappop(q)\n        result.append(m)\n    else:\n        print('NO')\n        sys.exit()\nresult = result[::-1]\nq = []\ncurrent = 0\nfor i in data:\n    if i[0] == '-':\n        m = heapq.heappop(q)\n        if m != int(i[1]):\n            print('NO')\n            sys.exit()\n    else:\n        heapq.heappush(q, result[current])\n        current += 1\nprint('YES')\nprint(*result)", "import sys\nimport heapq\ninput = sys.stdin.readline\nn = int(input())\na = [-1] * n\nst = []\nt = 0\nflag = True\ncomands = []\nfor i in range(2 * n):\n    comand = input().split()\n    comands.append(comand)\n    if comand[0] == '+':\n        st.append(t)\n        t += 1\n    elif len(st) == 0:\n        flag = False\n    else:\n        i = int(comand[1])\n        j = st.pop()\n        a[j] = i\nif len(st) != 0:\n    flag = False\nh = []\nheapq.heapify(h)\npos = 0\nfor i in range(2 * n):\n    comand = comands[i]\n    if comand[0] == '+':\n        heapq.heappush(h, a[pos])\n        pos += 1\n    elif len(h) > 0:\n        x = heapq.heappop(h)\n        if x != int(comand[1]):\n            flag = False\n    else:\n        flag = False\nif not flag:\n    print('NO')\nelse:\n    print('YES')\n    print(*a)", "import sys\nimport heapq\ninput = sys.stdin.readline\nn = int(input())\ndata = [[x for x in input().split()] for _ in range(2 * n)]\nq = []\nresult = []\nfor i in data[::-1]:\n    if i[0] == '-':\n        heapq.heappush(q, int(i[1]))\n    elif q:\n        m = heapq.heappop(q)\n        result.append(m)\n    else:\n        print('NO')\n        sys.exit()\nresult = result[::-1]\nq = []\ncurrent = 0\nfor i in data:\n    if i[0] == '-':\n        m = heapq.heappop(q)\n        if m != int(i[1]):\n            print('NO')\n            sys.exit()\n    else:\n        heapq.heappush(q, result[current])\n        current += 1\nprint('YES')\nprint(*result)", "import math\nPLUS = '+'\nMINUS = '-'\n\ndef solve():\n    n = int(input())\n    sales = []\n    for _ in range(2 * n):\n        sales.append(input().split(' '))\n    min_queue = []\n    res = []\n    for i in range(2 * n - 1, -1, -1):\n        if sales[i][0] == MINUS:\n            current_sale = int(sales[i][1])\n            if len(min_queue) == 0 or current_sale < min_queue[-1]:\n                min_queue.append(int(sales[i][1]))\n            else:\n                return ('NO', None)\n        elif len(min_queue) == 0:\n            return ('NO', None)\n        else:\n            res.append(min_queue.pop())\n    return ('YES', res[::-1])\n(a, b) = solve()\nprint(a)\nif b != None:\n    print(' '.join(map(str, b)))", "import heapq\nn = int(input())\na = []\nans = []\npq = []\nstring = ''\nfor i in range(2 * n):\n    s = input().split()\n    string += s[0]\n    if s[0] == '-':\n        a.append(int(s[-1]))\nfor j in range(2 * n - 1, -1, -1):\n    if string[j] == '+':\n        if not pq:\n            print('NO')\n            exit()\n        else:\n            ans.append(heapq.heappop(pq))\n    elif not pq:\n        heapq.heappush(pq, a.pop(-1))\n    else:\n        zx = heapq.heappop(pq)\n        heapq.heappush(pq, zx)\n        if zx < a[-1]:\n            print('NO')\n            exit()\n        else:\n            heapq.heappush(pq, a.pop(-1))\nprint('YES')\nprint(*reversed(ans))", "import math\nn = int(input())\ns = []\nfor i in range(2 * n):\n    a = input()\n    if a[0] == '+':\n        s.append(0)\n    else:\n        s.append(int(a[2:]))\nst = []\nf = 0\nans = []\nmi = []\nfor i in range(len(s) - 1, -1, -1):\n    if s[i] > 0:\n        st.append(s[i])\n        if mi == []:\n            mi.append(s[i])\n        elif s[i] < mi[-1]:\n            mi.append(s[i])\n        else:\n            w = mi[-1]\n            mi.append(w)\n    elif st == []:\n        f = 1\n        break\n    elif st[-1] == mi[-1]:\n        p = st[-1]\n        ans.append(p)\n        st.pop()\n        mi.pop()\n    else:\n        f = 1\n        break\nans.reverse()\nif f == 1:\n    print('NO')\nelse:\n    print('YES')\n    print(*ans)", "def solve():\n    n = int(input())\n    a = []\n    for i in range(2 * n):\n        s = input()\n        if s[0] == '-':\n            s = s.split()\n            a.append([s[0], int(s[1])])\n        else:\n            a.append(s)\n    st = []\n    ans = []\n    for i in a[::-1]:\n        if i[0] == '+':\n            if st:\n                ans.append(st.pop())\n            else:\n                print('NO')\n                return\n        elif not st or st[-1] > i[1]:\n            st.append(i[1])\n        else:\n            print('NO')\n            return\n    print('YES')\n    print(*ans[::-1])\n\ndef main():\n    t = 1\n    for _ in range(t):\n        solve()\nmain()", "import heapq\nn = int(input())\ns = ''\na = []\nfor _ in range(2 * n):\n    l = [x for x in input().split()]\n    if l[0] == '+':\n        s += '+'\n    else:\n        s += '-'\n        a.append(int(l[1]))\n\ndef helper():\n    ind = n - 1\n    pq = []\n    ans = []\n    for i in range(2 * n - 1, -1, -1):\n        if s[i] == '+':\n            if len(pq) == 0:\n                print('NO')\n                return\n            else:\n                ans.append(pq[0])\n                heapq.heappop(pq)\n        elif len(pq) == 0:\n            heapq.heappush(pq, a[ind])\n            ind -= 1\n        elif pq[0] < a[ind]:\n            print('NO')\n            return\n        else:\n            heapq.heappush(pq, a[ind])\n            ind -= 1\n    print('YES')\n    for i in ans[::-1]:\n        print(i, end=' ')\n    return\nhelper()", "import sys, heapq\ninput = sys.stdin.readline\nn = int(input())\nstack = []\n(f, c) = (0, 0)\nres = [0 for _ in range(n)]\ninp = []\nfor i in range(2 * n):\n    s = input().strip()\n    inp.append(s)\n    if s[0] == '+':\n        stack.append(c)\n        c += 1\n    elif not stack:\n        f = 1\n        break\n    else:\n        cur = stack.pop()\n        res[cur] = int(s[2:])\nif f == 0:\n    temp = []\n    (c, f) = (0, 0)\n    for i in range(2 * n):\n        if inp[i][0] == '+':\n            heapq.heappush(temp, res[c])\n            c += 1\n        elif int(inp[i][2:]) != heapq.heappop(temp):\n            f = 1\n            break\n    if f == 0:\n        sys.stdout.write('YES' + '\\n')\n        for i in res:\n            sys.stdout.write(str(i) + ' ')\n    else:\n        sys.stdout.write('NO' + '\\n')\nelse:\n    sys.stdout.write('NO' + '\\n')", "N = int(input())\nQ = []\nfor i in range(N * 2):\n    Q.append(input())\nQ = Q[::-1]\nstack = []\nans = []\nfor q in Q:\n    if len(q) == 1:\n        if not stack:\n            print('NO')\n            exit()\n        a = stack.pop()\n        ans.append(a)\n    else:\n        (m, a) = q.split()\n        a = int(a)\n        if stack and stack[-1] < a:\n            print('NO')\n            exit()\n        stack.append(a)\nprint('YES')\nprint(*ans[::-1])", "from heapq import *\nn = int(input())\nok = True\nlisted = 0\nqueries = []\nprev = -1\nfor i in range(2 * n):\n    q = input().strip().split()\n    if len(q) == 2:\n        listed -= 1\n        if int(q[1]) >= prev:\n            prev = int(q[1])\n        else:\n            ok = False\n            break\n    else:\n        listed += 1\n        prev = -1\n    ok &= listed >= 0\n    queries.append(q)\n    if not ok:\n        break\nif not ok:\n    print('NO')\nelse:\n    ans = []\n    queue = []\n    heapify(queue)\n    for i in range(2 * n - 1, -1, -1):\n        if len(queries[i]) == 2:\n            heappush(queue, int(queries[i][1]))\n        else:\n            ans.append(heappop(queue))\n    ptr = len(ans) - 1\n    validate = []\n    heapify(validate)\n    for i in queries:\n        if len(i) == 2:\n            e = heappop(validate)\n            if e != int(i[1]):\n                ok = False\n                break\n        else:\n            heappush(validate, ans[ptr])\n            ptr -= 1\n    if ok:\n        print('YES')\n        print(*ans[::-1])\n    else:\n        print('NO')", "n = int(input())\nimport heapq\ntot = []\nfor i in range(2 * n):\n    l = input()\n    tot.append(l)\ncur = []\nheapq.heapify(cur)\ncan = True\nfor i in range(2 * n - 1, -1, -1):\n    if tot[i][0] == '-':\n        heapq.heappush(cur, int(tot[i][2:]))\n    else:\n        if len(cur) == 0:\n            can = False\n            break\n        tot[i] = heapq.heappop(cur)\ncur = []\nif can:\n    for i in tot:\n        if isinstance(i, int) == False:\n            if len(cur) == 0:\n                can = False\n                break\n            k = int(i[2:])\n            j = heapq.heappop(cur)\n            if j != k:\n                can = False\n                break\n        else:\n            heapq.heappush(cur, i)\nif can:\n    print('YES')\n    for t in tot:\n        if isinstance(t, int):\n            print(t, end=' ')\nelse:\n    print('NO')", "n = int(input())\nans = [0] * n\nval = []\nst = []\ntemp = 'YES'\nc = -1\nfor _ in range(0, 2 * n):\n    s = input().split()\n    if s[0] == '+':\n        c += 1\n        st.append(0)\n        val.append(c)\n    else:\n        tt = int(s[1])\n        if len(st) == 0:\n            temp = 'NO'\n        else:\n            if st[-1] > tt:\n                temp = 'NO'\n            ptr = val.pop()\n            ans[ptr] = tt\n            tt2 = st.pop()\n            if len(st) > 0:\n                st[-1] = max(st[-1], tt, tt2)\nprint(temp)\nif temp == 'YES':\n    print(*ans)", "n = int(input())\nans = [0] * n\nval = []\nst = []\ntemp = 'YES'\nc = -1\nfor _ in range(0, 2 * n):\n    s = input().split()\n    if s[0] == '+':\n        c += 1\n        st.append(0)\n        val.append(c)\n    else:\n        tt = int(s[1])\n        if len(st) == 0:\n            temp = 'NO'\n        else:\n            if st[-1] > tt:\n                temp = 'NO'\n            ptr = val.pop()\n            ans[ptr] = tt\n            tt2 = st.pop()\n            if len(st) > 0:\n                st[-1] = max(st[-1], tt, tt2)\nprint(temp)\nif temp == 'YES':\n    print(*ans)", "import sys, heapq\nn = int(input())\nstack = []\n(f, c) = (0, 0)\nres = [0 for _ in range(n)]\ninp = []\nfor i in range(2 * n):\n    s = input()\n    inp.append(s)\n    if s[0] == '+':\n        stack.append(c)\n        c += 1\n    elif not stack:\n        f = 1\n        break\n    else:\n        cur = stack.pop()\n        res[cur] = int(s[2:])\nif f == 0:\n    temp = []\n    (c, f) = (0, 0)\n    for i in range(2 * n):\n        if inp[i][0] == '+':\n            heapq.heappush(temp, res[c])\n            c += 1\n        elif int(inp[i][2:]) != heapq.heappop(temp):\n            f = 1\n            break\n    if f == 0:\n        print('YES')\n        print(*res)\n    else:\n        print('NO')\nelse:\n    print('NO')"]