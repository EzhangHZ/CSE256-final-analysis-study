["n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\nsz = [1] * n\nfor i in range(1, n):\n    sz[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    citizen[parent[i]] += citizen[i]\n    sz[parent[i]] += sz[i]\nans = 0\nfor i in range(n):\n    ans = max(ans, (citizen[i] + sz[i] - 1) // sz[i])\nprint(ans)", "n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\nsz = [1] * n\nfor i in range(1, n):\n    sz[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    citizen[parent[i]] += citizen[i]\n    sz[parent[i]] += sz[i]\nans = 0\nfor i in range(n):\n    ans = max(ans, (citizen[i] + sz[i] - 1) // sz[i])\nprint(ans)", "n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\ns = [1 for i in range(n)]\nfor i in range(1, n):\n    s[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    k = parent[i]\n    citizen[k] += citizen[i]\n    s[k] += s[i]\nans = 0\nfor i in range(0, n):\n    ans = max(ans, (citizen[i] + s[i] - 1) // s[i])\nprint(ans)", "n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\nsz = [1] * n\nfor i in range(1, n):\n    sz[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    citizen[parent[i]] += citizen[i]\n    sz[parent[i]] += sz[i]\nans = 0\nfor i in range(n):\n    if citizen[i] % sz[i] == 0:\n        ans = max(ans, citizen[i] // sz[i])\n    else:\n        ans = max(ans, citizen[i] // sz[i] + 1)\nprint(ans)", "n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\ns = [1 for i in range(n)]\nfor i in range(1, n):\n    s[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    k = parent[i]\n    citizen[k] += citizen[i]\n    s[k] += s[i]\nans = 0\nfor i in range(0, n):\n    ans = max(ans, (citizen[i] + s[i] - 1) // s[i])\nprint(ans)", "n = int(input())\nparent = [-1] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\nsz = [1] * n\nfor i in range(1, n):\n    sz[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    citizen[parent[i]] += citizen[i]\n    sz[parent[i]] += sz[i]\nans = 0\nfor i in range(n):\n    if citizen[i] % sz[i] == 0:\n        ans = max(ans, citizen[i] // sz[i])\n    else:\n        ans = max(ans, citizen[i] // sz[i] + 1)\nprint(ans)", "n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\nsz = [1] * n\nfor i in range(1, n):\n    sz[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    citizen[parent[i]] += citizen[i]\n    sz[parent[i]] += sz[i]\nans = 0\nfor i in range(n):\n    if citizen[i] % sz[i] == 0:\n        ans = max(ans, citizen[i] // sz[i])\n    else:\n        ans = max(ans, citizen[i] // sz[i] + 1)\nprint(ans)", "n = int(input())\nparent = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizen = list(map(int, input().split()))\ns = [1 for i in range(n)]\nfor i in range(1, n):\n    s[parent[i]] = 0\nfor i in range(n - 1, 0, -1):\n    k = parent[i]\n    citizen[k] += citizen[i]\n    s[k] += s[i]\nans = 0\nfor i in range(0, n):\n    ans = max(ans, (citizen[i] + s[i] - 1) // s[i])\nprint(ans)", "n = int(input())\nparents = [0] + [x - 1 for x in list(map(int, input().split()))]\ncitizens = list(map(int, input().split()))\nsz = [1] * n\nfor i in parents:\n    sz[i] = 0\nfor i in range(n - 1, 0, -1):\n    citizens[parents[i]] += citizens[i]\n    sz[parents[i]] += sz[i]\nans = 0\nfor i in range(n):\n    if citizens[i] % sz[i] == 0:\n        ans = max(ans, citizens[i] // sz[i])\n    else:\n        ans = max(ans, citizens[i] // sz[i] + 1)\nprint(ans)", "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(500000)\nthreading.stack_size(134217728)\n\ndef solve():\n\n    def dfs(node, visited):\n        visited[node - 1] = 1\n        s = a[node - 1]\n        c = 0\n        m = -1\n        for no in g[node]:\n            if visited[no - 1] == 0:\n                p = dfs(no, visited)\n                s = s + p[0]\n                c = c + p[1]\n                m = max(m, p[2])\n        if g[node] == []:\n            c = c + 1\n        q = (s + c - 1) // c\n        if q > m:\n            m = q\n        return (s, c, m)\n    n = int(input())\n    p = list(map(int, sys.stdin.readline().split()))\n    a = list(map(int, sys.stdin.readline().split()))\n    g = defaultdict(list)\n    for j in range(n - 1):\n        g[p[j]].append(j + 2)\n    visited = [0] * n\n    an = dfs(1, visited)\n    print(an[2])\nthreading.Thread(target=solve).start()", "import threading\nimport sys\ninput = sys.stdin.readline\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 7)\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    g = defaultdict(list)\n    p = [0] * 2 + list(map(int, input().split()))\n    for _ in range(2, 2 + n - 1):\n        g[p[_]].append(_)\n    a = [0] + list(map(int, input().split()))\n    global res\n    res = -1\n\n    def dfs(cn, p):\n        global res\n        num_leaves = 0\n        cost = a[cn]\n        if not g[cn]:\n            num_leaves += 1\n        for nn in g[cn]:\n            if nn != p:\n                (t_num_leaves, t_cost) = dfs(nn, cn)\n                num_leaves += t_num_leaves\n                cost += t_cost\n        res = max(res, (cost - 1) // num_leaves + 1)\n        return (num_leaves, cost)\n    dfs(1, -1)\n    print(res)\nthreading.Thread(target=main).start()", "from collections import defaultdict\nfrom math import ceil\nfrom sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\nimport threading\nblanck = []\n\ndef dfs(node, g, parent, person, sub, leaf):\n    sub[node] = person[node]\n    leaf[node] = len(g[node]) == 0\n    for i in g[node]:\n        if i == parent:\n            continue\n        dfs(i, g, node, person, sub, leaf)\n        sub[node] += sub[i]\n        leaf[node] += leaf[i]\n\ndef main():\n    n = int(input())\n    p = [*map(int, input().strip().split())]\n    person = [*map(int, input().strip().split())]\n    g = defaultdict(list)\n    person = [0] + person\n    for i in range(len(p)):\n        t = i + 2\n        g[p[i]].append(t)\n    leaf = [0] * (n + 1)\n    sub = [0] * (n + 1)\n    ans = 0\n    dfs(1, g, -1, person, sub, leaf)\n    for i in range(1, n + 1):\n        if leaf[i]:\n            ans = max(ans, ceil(sub[i] / leaf[i]))\n    print(ans)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nfrom math import ceil\n\ndef solve():\n    n = int(input())\n    graph = defaultdict(list)\n    largest_leaf = defaultdict(int)\n    leaf_count = defaultdict(int)\n    subtree_sum = defaultdict(int)\n    ans = 0\n    for (i, p) in enumerate(input().split(), 2):\n        graph[int(p)] += [i]\n    a = {i: int(x) for (i, x) in enumerate(input().split(), 1)}\n    for v in reversed(range(1, n + 1)):\n        subtree_sum[v] = a[v]\n        if len(graph[v]) == 0:\n            largest_leaf[v] = subtree_sum[v]\n            leaf_count[v] = 1\n        else:\n            largest_child_leaf = 0\n            for child in graph[v]:\n                largest_child_leaf = max(largest_child_leaf, largest_leaf[child])\n                subtree_sum[v] += subtree_sum[child]\n                leaf_count[v] += leaf_count[child]\n            result_sum = max(largest_child_leaf * leaf_count[v], subtree_sum[v])\n            largest_leaf[v] = ceil(result_sum / leaf_count[v])\n        ans = max(ans, largest_leaf[v])\n    print(ans)\nsolve()", "n = int(input())\np = list(map(int, input().split()))\na = list(map(int, input().split()))\ntree = {}\nfor (i, pp) in enumerate(p, start=2):\n    tree.setdefault(pp, []).append(i)\ncache = {}\nfor s in range(n, 0, -1):\n    children = tree.get(s, [])\n    if len(children) == 0:\n        cache[s] = (a[s - 1], a[s - 1], 1)\n        continue\n    ch_p = [cache[c] for c in children]\n    ch_max = max((pp[0] for pp in ch_p))\n    ch_sum = sum((pp[1] for pp in ch_p))\n    ch_l = sum((pp[2] for pp in ch_p))\n    sm = ch_sum + a[s - 1]\n    m = sm // ch_l\n    if sm % ch_l != 0:\n        m += 1\n    cache[s] = (max(ch_max, m), sm, ch_l)\nprint(cache[1][0])"]