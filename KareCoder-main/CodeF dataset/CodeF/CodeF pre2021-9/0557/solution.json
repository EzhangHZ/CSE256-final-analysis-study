["for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    count = [0 for _ in range(27)]\n    for i in l:\n        count[i] += 1\n    ans = 1\n    for x in set(l):\n        r = count[:]\n        i = 0\n        j = n - 1\n        a = 2\n        while i < j:\n            while i < n and l[i] != x:\n                r[l[i]] -= 1\n                i += 1\n            while j >= 0 and l[j] != x:\n                r[l[j]] -= 1\n                j -= 1\n            if i >= j:\n                break\n            else:\n                r[l[i]] -= 1\n                r[l[j]] -= 1\n                ans = max(ans, max(r) + a)\n                a += 2\n                i += 1\n                j -= 1\n    print(ans)", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {i: [] for i in range(1, 26 + 1)}\n    ac = [0 for i in range(26 + 1)]\n    ach = []\n    for (i, ai) in enumerate(a):\n        d[ai].append(i)\n        ac[ai] += 1\n        ach.append(ac.copy())\n    maxs = max(ac)\n    for i in range(1, 26 + 1):\n        j = 0\n        pos = d[i]\n        k = len(pos) - 1\n        while j < k:\n            x = ach[pos[j]]\n            y = ach[pos[k]]\n            for l in range(len(x)):\n                y[l] -= x[l]\n            y[i] -= 1\n            maxs = max(maxs, max(y) + (j + 1) * 2)\n            j += 1\n            k -= 1\n    print(maxs)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\ndef in_int():\n    return int(input())\n\ndef in_list():\n    return list(map(int, input().split()))\n\ndef in_str():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef in_ints():\n    return map(int, input().split())\nt = in_int()\nfor tt in range(t):\n    n = in_int()\n    nums = in_list()\n    count = []\n    tmp = [0] * 27\n    a = [[] for i in range(27)]\n    i = 0\n    for xx in nums:\n        tmp[xx] += 1\n        count.append(list(tmp))\n        a[xx].append(i)\n        i += 1\n\n    def rc(i, j, c):\n        if i > j:\n            return 0\n        if i == 0:\n            return count[j][c]\n        else:\n            return count[j][c] - count[i - 1][c]\n\n    def mc(i, j):\n        if i == 0:\n            mx = 0\n            for xx in range(1, 27):\n                mx = max(mx, count[j][xx])\n            return mx\n        else:\n            mx = 0\n            for c in range(1, 27):\n                mx = max(mx, count[j][c] - count[i - 1][c])\n            return mx\n    ans = mc(0, n - 1)\n    for aa in a:\n        i = 0\n        j = len(aa) - 1\n        while i < j:\n            ans = max(ans, 2 * (i + 1) + mc(aa[i] + 1, aa[j] - 1))\n            i += 1\n            j -= 1\n    print(ans)", "import sys\nlines = sys.stdin.readlines()\nT = int(lines[0].strip())\nfor t in range(T):\n    n = int(lines[2 * t + 1].strip())\n    nums = list(map(int, lines[2 * t + 2].strip().split(' ')))\n    preSum = {}\n    kinds = set(nums)\n    for k in kinds:\n        preSum[k] = [0]\n    for num in nums:\n        for k in kinds:\n            if k == num:\n                preSum[k].append(preSum[k][-1] + 1)\n            else:\n                preSum[k].append(preSum[k][-1])\n    maxLen = 0\n    for k in kinds:\n        maxLen = max(maxLen, preSum[k][-1])\n    for k in kinds:\n        l = 0\n        r = n - 1\n        cnt = 0\n        while l < r:\n            while nums[l] != k:\n                l += 1\n            while nums[r] != k:\n                r -= 1\n            if l >= r:\n                break\n            cnt += 1\n            tmpMax = 0\n            for p in kinds:\n                tmpMax = max(tmpMax, preSum[p][r] - preSum[p][l + 1])\n            maxLen = max(maxLen, tmpMax + cnt * 2)\n            l += 1\n            r -= 1\n    print(maxLen)", "from collections import deque\n\ndef solve():\n    n = int(input())\n    li = [int(x) for x in input().split()]\n    counts = [[0] * 27]\n    pos = [[] for i in range(27)]\n    for (i, a) in enumerate(li):\n        counts.append(list(counts[-1]))\n        counts[-1][a] += 1\n        pos[a].append(i)\n    mx = 0\n    for (i, a) in enumerate(li):\n        pre_occur_a = counts[i + 1][a]\n        pos_suff_occur_a = pos[a][-pre_occur_a]\n        if pos_suff_occur_a > i:\n            for b in range(27):\n                mx = max(mx, counts[pos_suff_occur_a][b] - counts[i + 1][b] + 2 * pre_occur_a)\n        elif pos_suff_occur_a == i:\n            mx = max(mx, 2 * pre_occur_a - 1)\n    print(mx)\nt = int(input())\nfor i in range(t):\n    solve()", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(lambda x: int(x) - 1, input().split()))\n    pref = {i: [] for i in range(26)}\n    cnt = [0 for i in range(26)]\n    counter = []\n    for i in range(n):\n        pref[l[i]].append(i)\n        cnt[l[i]] += 1\n        counter.append(cnt.copy())\n    ans = 1\n    for i in range(26):\n        for j in range(1, cnt[i] // 2 + 1):\n            (r, l) = (pref[i][-j], pref[i][j - 1])\n            curr = 0\n            for x in range(26):\n                curr = max(curr, counter[r - 1][x] - counter[l][x])\n            ans = max(ans, j * 2 + curr)\n    print(ans)", "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(99999)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = [[] for _ in range(27)]\n    for (i, c) in enumerate(arr):\n        d[c].append(i)\n    ans = 1\n    for l in d:\n        ans = max(ans, len(l))\n        if len(l) > 1:\n            i = 0\n            j = len(l) - 1\n            b = 0\n            while i < j:\n                b += 2\n                for k in d:\n                    if k != l:\n                        ans = max(ans, b + bisect.bisect_left(k, l[j]) - bisect.bisect_left(k, l[i] + 1))\n                i += 1\n                j -= 1\n    print(ans)", "from collections import defaultdict\nimport bisect\nfrom sys import stdin\ninput = stdin.readline\n\ndef check(i, j, d):\n    maxi = 0\n    for k in d:\n        k = d[k]\n        a = bisect.bisect_right(k, i)\n        b = bisect.bisect_left(k, j)\n        maxi = max(maxi, b - a)\n    return maxi\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = [int(j) for j in input().split()]\n    maxi = 0\n    d = defaultdict(list)\n    for i in range(n):\n        d[A[i]].append(i)\n    for k in d:\n        k = d[k]\n        i = 0\n        j = len(k) - 1\n        travel = 0\n        while i <= j:\n            if i == j:\n                travel += 1\n                maxi = max(maxi, travel)\n                break\n            a = k[i]\n            b = k[j]\n            travel += 2\n            temp = check(a, b, d)\n            maxi = max(maxi, temp + travel)\n            i += 1\n            j -= 1\n    print(maxi)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    D = {}\n    DC = {}\n    DS = {}\n    A = list(map(int, input().split()))\n    for i in range(n):\n        if A[i] in D:\n            D[A[i]].append(i)\n            DS[A[i]][i] = 1\n            DC[A[i]] += 1\n        else:\n            D[A[i]] = [i]\n            DS[A[i]] = [0 for __ in range(n)]\n            DS[A[i]][i] = 1\n            DC[A[i]] = 1\n    for i in DS:\n        for k in range(n - 1):\n            DS[i][k + 1] += DS[i][k]\n    M = max((DC[i] for i in DC))\n    for i in D:\n        m = DC[i]\n        for j in D:\n            if i != j:\n                for k in range(1, m // 2 + 1):\n                    (l, r) = (D[i][k - 1], D[i][-k])\n                    if l != 0:\n                        cnt = DS[j][r - 1] - DS[j][l - 1]\n                    else:\n                        cnt = DS[j][r - 1]\n                    if M < cnt + k * 2:\n                        M = cnt + k * 2\n    print(M)", "from bisect import bisect_left\nfor x in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        if a[i] in d:\n            d[a[i]].append(i)\n        else:\n            d[a[i]] = [i]\n    ma = 0\n    for i in d.keys():\n        for j in d.keys():\n            if i != j:\n                for k in range(1, len(d[i]) // 2 + 1):\n                    ma = max(ma, 2 * k - bisect_left(d[j], d[i][k - 1]) + bisect_left(d[j], d[i][-k]))\n    for i in d.keys():\n        ma = max(ma, len(d[i]))\n    print(ma)\na = []\nfor i in range(10000):\n    a.append(i)", "T = int(input())\nfor t in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    repeats = [[0] * N for _ in range(26)]\n    indices = [[] for _ in range(26)]\n    for i in range(0, N):\n        if i > 0:\n            for j in range(26):\n                repeats[j][i] = repeats[j][i - 1]\n        repeats[A[i] - 1][i] += 1\n        indices[A[i] - 1].append(i)\n    result = 1\n    for i1 in range(len(A)):\n        c = repeats[A[i1] - 1][i1]\n        i2 = indices[A[i1] - 1][-c]\n        if i2 > i1:\n            mr = max((repeats[j0][i2 - 1] - repeats[j0][i1] for j0 in range(26)))\n            result = max(result, 2 * c + mr)\n    print(result)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = max(a)\n    mem = [[0] * n for i in range(m + 1)]\n    position = {}\n    for i in range(n):\n        if a[i] not in position:\n            position[a[i]] = []\n        position[a[i]].append(i)\n        for j in range(m + 1):\n            mem[j][i] = mem[j][i - 1]\n        mem[a[i]][i] += 1\n    ans = 0\n    for i in range(m + 1):\n        if i in position:\n            ans = max(ans, len(position[i]))\n            for p in range(len(position[i])):\n                left = position[i][p]\n                right = position[i][len(position[i]) - p - 1]\n                if left > right:\n                    break\n                max_middle = 0\n                for middle in range(m + 1):\n                    if i == middle:\n                        continue\n                    freq = mem[middle][right] - mem[middle][left]\n                    max_middle = max(max_middle, freq)\n                if max_middle != 0:\n                    ans = max(ans, 2 * (p + 1) + max_middle)\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(lambda x: int(x) - 1, input().split()))\n    nxt = [[-1] * 26 for _ in range(n)]\n    prv = [[-1] * 26 for _ in range(n)]\n    fst = [-1] * 26\n    lst = [-1] * 26\n    initc = [0] * 26\n    for i in range(n):\n        initc[arr[i]] += 1\n        if fst[arr[i]] == -1:\n            fst[arr[i]] = i\n        else:\n            for j in range(i - 1, -1, -1):\n                if arr[j] == arr[i]:\n                    prv[i][arr[i]] = j\n                    nxt[j][arr[i]] = i\n                    break\n    for i in range(n - 1, -1, -1):\n        if lst[arr[i]] == -1:\n            lst[arr[i]] = i\n    ans = 0\n    for i in range(26):\n        cnt = initc[:]\n        ans = max(cnt[i], ans)\n        cnt[i] = 0\n        if fst[i] == -1:\n            continue\n        l = fst[i]\n        r = lst[i]\n        if l == r:\n            ans = max(1, ans)\n            continue\n        real_l = 0\n        real_r = n - 1\n        prsf = 2\n        ans = max(ans, max(cnt))\n        while l < r:\n            while l > real_l:\n                cnt[arr[real_l]] -= 1\n                real_l += 1\n            while r < real_r:\n                cnt[arr[real_r]] -= 1\n                real_r -= 1\n            ans = max(ans, max(cnt) + prsf)\n            l = nxt[l][i]\n            r = prv[r][i]\n            prsf += 2\n    print(ans)", "import sys\nimport math\nT = int(sys.stdin.readline())\nfor _ in range(T):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    pos = [[] for _ in range(27)]\n    for (i, x) in enumerate(a):\n        pos[x].append(i + 1)\n    pre_sum = [[0] * (n + 1) if pos[i] else [] for i in range(27)]\n    for (i, x) in enumerate(a):\n        pre_sum[x][i + 1] = 1\n    for x in range(1, 27):\n        if pre_sum[x]:\n            for i in range(1, n + 1):\n                pre_sum[x][i] += pre_sum[x][i - 1]\n    ans = 0\n    for x in range(1, 27):\n        if pos[x]:\n            x_num = len(pos[x])\n            ans = max(ans, x_num)\n            mid = x_num // 2\n            for j in range(mid):\n                left = j\n                right = x_num - 1 - j\n                left_pos = pos[x][left]\n                right_pos = pos[x][right]\n                for y in range(1, 27):\n                    if pos[y] and y != x:\n                        ans = max(ans, pre_sum[y][right_pos] - pre_sum[y][left_pos] + (j + 1) * 2)\n    print(ans)", "def match(a, x, s, e):\n    matches = []\n    while s <= e:\n        while s <= e and a[s] != x:\n            s += 1\n        while s <= e and a[e] != x:\n            e -= 1\n        if s <= e:\n            matches.append((s, e))\n            s += 1\n            e -= 1\n    return matches\n\ndef solve(a):\n    ps = [[0] * 27]\n    for x in a:\n        p = ps[-1][:]\n        p[x] += 1\n        ps.append(p)\n    sol = 1\n    for first in range(1, 27):\n        matches = match(a, first, 0, len(a) - 1)\n        for (i, (s, e)) in enumerate(matches):\n            if s != e:\n                sol = max(sol, 2)\n            for second in range(1, 27):\n                total2 = ps[e][second] - ps[s + 1][second]\n                if total2 > 0:\n                    sol = max(sol, (i + 1) * 2 + total2)\n    return sol\nt = int(input())\nfor _ in range(t):\n    input()\n    a = list(map(int, input().split()))\n    print(solve(a))", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [[0 for i in range(n + 1)] for j in range(27)]\n    for i in range(n):\n        dp[a[i]][i + 1] += 1\n        for j in range(1, 27):\n            dp[j][i + 1] += dp[j][i]\n    ans = 1\n    for i in range(1, 27):\n        l = 0\n        r = n - 1\n        c = 0\n        while l < r:\n            while l < r and a[l] != i:\n                l += 1\n            while l < r and a[r] != i:\n                r -= 1\n            if l < r and a[l] == i and (a[r] == i):\n                m = 0\n                for j in range(1, 27):\n                    m = max(m, dp[j][r] - dp[j][l + 1])\n                ans = max(c + m + 2, ans)\n                c += 2\n                l += 1\n                r -= 1\n    print(ans)", "import sys\nimport collections\nimport threading\nimport string\n\ndef sparsetable(a):\n    tmp = [0] * 201\n    st = []\n    for i in range(len(a)):\n        tmp[a[i]] += 1\n        st.append(tmp[:])\n    return st\n\ndef func(x, y, st):\n    if x >= y:\n        return 0\n    ans = 0\n    for i in range(201):\n        ans = max(ans, st[y][i] - st[x][i])\n    return ans\n\ndef main():\n    testn = int(input())\n    for _ in range(testn):\n        n = int(input())\n        a = list(map(int, input().split()))\n        d = collections.defaultdict(list)\n        st = sparsetable(a)\n        for i in range(n):\n            d[a[i]].append(i)\n        ans = 1\n        for key in d:\n            z = len(d[key])\n            l = d[key]\n            for i in range(z // 2):\n                ans = max(ans, (i + 1) * 2 + func(l[i], l[z - 1 - i] - 1, st))\n        print(ans)\ninput = sys.stdin.readline\nmain()", "def threeblock(arr):\n    d = {i: [] for i in range(1, 27)}\n    for i in range(len(arr)):\n        d[arr[i]].append(i)\n    ans = 1\n    for val in range(1, 27):\n        c = 1\n        while c * 2 <= len(d[val]):\n            l = d[val][c - 1] + 1\n            r = d[val][-c]\n            middle = [0] * 27\n            for pt in range(l, r):\n                middle[arr[pt]] += 1\n            ans = max(ans, max(middle) + 2 * c)\n            c += 1\n    return ans\nfor i in range(int(input())):\n    a = input()\n    lst = list(map(int, input().strip().split()))\n    print(threeblock(lst))", "def f(l):\n    d = {}\n    for i in l:\n        try:\n            d[i] += 1\n        except:\n            d[i] = 1\n    maxm = 0\n    for i in d:\n        if d[i] > maxm:\n            maxm = d[i]\n    return maxm\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    m = list(set(l))\n    ans = {}\n    for i in m:\n        ans[i] = 0\n    for k in ans:\n        i = 0\n        j = n - 1\n        count = 0\n        while i <= j:\n            b = 0\n            while l[i] != k and i < n:\n                i += 1\n            while l[j] != k and j >= 0:\n                j -= 1\n            if i < j and i < n and (j >= 0):\n                count += 1\n            elif i == j:\n                b = 1\n            else:\n                break\n            ans[k] = max(ans[k], b + 2 * count + f(l[i + 1:j]))\n            i += 1\n            j -= 1\n    maxm = 0\n    for i in ans:\n        if ans[i] > maxm:\n            maxm = ans[i]\n    print(maxm)", "l = ' abcdefghijklmnopqrstuvwxyz'\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = ''.join((l[i] for i in a))\n    q = set(s)\n    m = 0\n    for i in q:\n        for j in q:\n            if i == j:\n                m = max(m, s.count(i))\n                continue\n            t = ''.join((k for k in s if k == i or k == j))\n            for k in range(t.count(i) // 2):\n                t = t[t.index(i) + 1:t.rindex(i)]\n                m = max(m, t.count(j) + 2 * (k + 1))\n    print(m)", "def max_len_cal(data, start, end):\n    data = list(data)\n    counter = 0\n    for i in range(len(data)):\n        if data[i] >= end:\n            break\n        elif data[i] > start:\n            counter += 1\n    return counter\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    index_recorder = dict()\n    for j in range(n):\n        try:\n            index_recorder[a[j]].append(j)\n        except:\n            index_recorder[a[j]] = [j]\n    max_len = 0\n    for j in index_recorder.keys():\n        counter = 0\n        while counter < len(index_recorder[j]) // 2:\n            for k in index_recorder.keys():\n                max_len = max(max_len, (counter + 1) * 2 + max_len_cal(index_recorder[k], index_recorder[j][counter], index_recorder[j][-counter - 1]))\n            counter += 1\n    print(max(1, max_len))", "for _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    P = [[] for _ in range(27)]\n    S = set(A)\n    for (i, a) in enumerate(A):\n        P[a].append(i)\n    ans = 0\n    for a in S:\n        for i in range(0, len(P[a]) // 2):\n            minp = P[a][i]\n            maxp = P[a][-(1 + i)]\n            s = 0\n            for b in S:\n                if a == b:\n                    continue\n                s = max(s, sum([p > minp and p < maxp for p in P[b]]))\n            ans = max(ans, (i + 1) * 2 + s)\n    ans = max(ans, max([len(p) for p in P]))\n    print(ans)", "t = int(input())\nfor q in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    sl = [[] for i in range(201)]\n    ss = [[0] for i in range(201)]\n    for i in range(n):\n        sl[l[i]].append(i)\n        for j in range(201):\n            ss[j].append(ss[j][-1])\n        ss[l[i]][-1] += 1\n    ans = 0\n    for i in range(200):\n        if not sl[i]:\n            continue\n        if len(sl[i]) == 1:\n            ans = max(ans, 1)\n            continue\n        for j in range(len(sl[i]) // 2):\n            le = sl[i][j]\n            ri = sl[i][-1 - j]\n            for k in range(200):\n                if i == k:\n                    ans = max(ans, len(sl[i]))\n                    continue\n                if sl[k]:\n                    ans = max(ans, 2 * (j + 1) + ss[k][ri] - ss[k][le])\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {i: [] for i in range(1, 27)}\n    i = 0\n    for x in a:\n        d[x].append(i)\n        i += 1\n    ans = 1\n    for x in d:\n        b = d[x]\n        l = len(b)\n        for i in range(0, l // 2):\n            (x, y) = (b[i] + 1, b[-i - 1])\n            f = [0] * 27\n            for j in range(x, y):\n                f[a[j]] += 1\n            ans = max(ans, max(f) + 2 * (i + 1))\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = dict()\n    mx = 0\n    for i in range(n):\n        if a[i] not in p.keys():\n            p[a[i]] = list()\n        p[a[i]].append(i)\n        mx = max(mx, len(p[a[i]]))\n    for x in range(1, n // 2 + 1):\n        for e in p.keys():\n            if len(p[e]) < 2 * x:\n                continue\n            l = p[e][x - 1]\n            r = p[e][len(p[e]) - x]\n            for e2 in p.keys():\n                if e2 == e:\n                    continue\n                count = 0\n                for i in p[e2]:\n                    if i >= r:\n                        break\n                    if i > l:\n                        count += 1\n                mx = max(mx, count + 2 * x)\n    print(mx)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n):\n        graph[arr[i]].append(i)\n    uni = list(set(arr))\n    final = set()\n    final.add(1)\n    for i in uni:\n        cur = i\n        (l, r) = (0, len(graph[cur]) - 1)\n        if len(graph[cur]) >= 2:\n            final.add(2)\n        cnt = 2\n        while l < r:\n            (low, high) = (graph[cur][l], graph[cur][r])\n            d = defaultdict(int)\n            for j in range(low + 1, high):\n                if j < n:\n                    d[arr[j]] += 1\n            ans = -1\n            for j in d:\n                ans = max(ans, d[j])\n            final.add(cnt + ans)\n            l += 1\n            r -= 1\n            cnt += 2\n    final = list(final)\n    print(max(final))", "def three_blocks_length(sequence, outer, inner):\n    filtered = list(filter(lambda x: x == outer or x == inner, sequence))\n    max_length = 0\n    outer_indices = []\n    inner_indices = []\n    for (i, item) in enumerate(filtered):\n        if item == outer:\n            outer_indices.append(i)\n        if item == inner:\n            inner_indices.append(i)\n    for i in range(len(outer_indices) // 2):\n        inner_count = filtered[outer_indices[i]:outer_indices[len(outer_indices) - i - 1]].count(inner)\n        max_length = max(max_length, 2 * (i + 1) + inner_count)\n    return max_length\n\ndef solve(sequence):\n    distinct = set(sequence)\n    max_length = 0\n    for outer in distinct:\n        for inner in distinct:\n            if outer != inner:\n                max_length = max(max_length, three_blocks_length(sequence, outer, inner))\n            else:\n                max_length = max(max_length, sequence.count(outer))\n    return max_length\nfor i in range(int(input())):\n    n = int(input())\n    sequence = [int(x) for x in input().split()]\n    print(solve(sequence))", "import sys\nsys.setrecursionlimit(50000)\ninput = sys.stdin.readline\n\ndef input_list():\n    return map(int, input().split())\n\ndef r(n_i, n_j, i, j, m=[]):\n    n = n_i + n_j\n    if n_i == 0:\n        return n_j\n    elif n_j == 0:\n        return n_i\n    elif m[0] == m[n - 1] and m[0] == i:\n        return 2 + r(n_i - 2, n_j, i, j, m[1:n - 1])\n    elif m[0] == j:\n        return max(n_j, r(n_i, n_j - 1, i, j, m[1:n]))\n    else:\n        return max(n_j, r(n_i, n_j - 1, i, j, m[0:n - 1]))\n\ndef f():\n    n = int(input())\n    l = list(input_list())\n    f_result = 0\n    s = set(l)\n    for i in s:\n        for j in s:\n            m = []\n            n_i = 0\n            n_j = 0\n            for k in l:\n                if k == i:\n                    m.append(k)\n                    n_i += 1\n                elif k == j:\n                    m.append(k)\n                    n_j += 1\n            f_result = max(f_result, r(n_i, n_j, i, j, m))\n    print(f_result)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        f()\nmain()", "import sys\ninput = sys.stdin.readline\nMOD = 1000000007\nMOD2 = 998244353\nii = lambda : int(input())\nsi = lambda : input()\ndgl = lambda : list(map(int, input()))\nf = lambda : map(int, input().split())\nil = lambda : list(map(int, input().split()))\nls = lambda : list(input())\nlet = 'abcdefghijklmnopqrstuvwxyz'\nfor _ in range(ii()):\n    n = ii()\n    l = il()\n    cntr = dict()\n    mxcnt = 0\n    dp = [[0 for i in range(201)] for j in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(1, 201):\n            dp[i][j] = dp[i + 1][j] + (l[i] == j)\n        mxcnt = max(dp[i][l[i]], mxcnt)\n        x = str(dp[i][l[i]]) + ',' + str(l[i])\n        cntr[x] = i\n    cntr2 = dict()\n    for i in range(n):\n        cntr2[l[i]] = cntr2.get(l[i], 0) + 1\n        x = str(cntr2[l[i]]) + ',' + str(l[i])\n        if x in cntr and cntr[x] > i:\n            for j in range(1, 201):\n                mxcnt = max(cntr2[l[i]] * 2 + (dp[i + 1][j] - dp[cntr[x]][j]), mxcnt)\n    print(mxcnt)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(i) - 1 for i in input().split(' ')]\n    dp = [[0 for i in range(200)] for i in range(n)]\n    for i in range(n):\n        for j in range(200):\n            dp[i][j] = dp[i - 1][j]\n        dp[i][a[i]] += 1\n    m = 1\n    for i in range(200):\n        (s, e, c) = (0, n - 1, 0)\n        while s < e:\n            while s < e and a[s] != i:\n                s += 1\n            while s < e and a[e] != i:\n                e -= 1\n            if s < e:\n                c += 2\n                for j in range(200):\n                    m = max(m, c + dp[e - 1][j] - dp[s][j])\n                s += 1\n                e -= 1\n    print(m)", "import bisect\nt = int(input())\nnum = 200\nanswers = []\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    prefix = {}\n    for i in range(1, num + 1):\n        prefix[i] = list()\n        prefix[i].append(0)\n    for i in range(n):\n        for j in range(1, num + 1):\n            if arr[i] == j:\n                prefix[j].append(prefix[j][-1] + 1)\n            else:\n                prefix[j].append(prefix[j][-1])\n    ans = 0\n    for i in range(1, n + 1):\n        j = arr[i - 1]\n        right = prefix[j][i]\n        right_ind = i\n        left_ind = bisect.bisect_right(prefix[j], prefix[j][-1] - right) - 1\n        if left_ind >= len(prefix[j]):\n            left_ind = len(prefix[j]) - 1\n        left = prefix[j][-1] - prefix[j][left_ind]\n        mid = 0\n        for g in range(1, num + 1):\n            if prefix[g][left_ind] - prefix[g][right_ind] > mid:\n                mid = prefix[g][left_ind] - prefix[g][right_ind]\n        if left_ind >= right_ind and 2 * min(right, left) + mid > ans:\n            ans = 2 * min(right, left) + mid\n        if prefix[j][-1] > ans:\n            ans = prefix[j][-1]\n    answers.append(str(ans))\nprint('\\n'.join(answers))", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    d = defaultdict(lambda : [], d)\n    k = 0\n    for i in a:\n        d[i].append(k)\n        k += 1\n    arr = []\n    for i in d.keys():\n        if len(d[i]) > 1:\n            arr.append(i)\n    ans1 = 0\n    for i in d.keys():\n        if ans1 < len(d[i]):\n            ans1 = len(d[i])\n    ans = 0\n    if len(arr) == 0:\n        print(1)\n    else:\n        for i in arr:\n            w = 0\n            e = len(d[i]) - 1\n            while w < e:\n                m1 = d[i][w]\n                m2 = d[i][e]\n                c = sorted(a[m1 + 1:m2])\n                d1 = {}\n                d1 = defaultdict(lambda : 0, d1)\n                maax = 0\n                for q in a[m1 + 1:m2]:\n                    d1[q] += 1\n                    if maax < d1[q]:\n                        maax = d1[q]\n                if ans < maax + 2 * (w + 1):\n                    ans = maax + 2 * (w + 1)\n                w += 1\n                e -= 1\n        print(max(ans, ans1))", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = 0\n    arr = list(map(int, input().strip().split()))\n    cnt = [[0 for i in range(201)] for j in range(n)]\n    freq = defaultdict(int)\n    ind = defaultdict(list)\n    for j in range(n):\n        freq[arr[j]] += 1\n        for i in range(201):\n            cnt[j][i] = (cnt[j - 1][i] if j > 0 else 0) + (i == arr[j])\n        ans = max(ans, freq[arr[j]])\n        ind[arr[j]].append(j)\n    for a in range(201):\n        for sz in range(1, n + 1):\n            if 2 * sz <= len(ind[a]):\n                r = ind[a][sz - 1]\n                l = ind[a][len(ind[a]) - sz]\n                bb = 0\n                for b in range(201):\n                    if b != a:\n                        bb = max(bb, cnt[l][b] - cnt[r][b])\n                ans = max(ans, bb + 2 * sz)\n            else:\n                break\n    print(ans)", "import math\nimport sys\nreadln = sys.stdin.readline\n\ndef solveAll():\n    nbCases = int(input())\n    for _ in range(nbCases):\n        case = readCase()\n        print(solve(case))\n\ndef readCase():\n    input()\n    return [int(x) for x in readln().split()]\n\ndef solve(nums):\n    indices = [[] for _ in range(201)]\n    for (i, num) in enumerate(nums):\n        indices[num] += [i]\n    bucket = [0] * 201\n    for num in nums:\n        bucket[num] += 1\n    ans = -math.inf\n    for num in range(1, 201):\n        ans = max(ans, computeThreeBlock(nums, indices[num], bucket.copy()))\n    return ans\n\ndef computeThreeBlock(nums, indices, bucket):\n    le = 0\n    ri = len(nums) - 1\n    indicesFrom = 0\n    indicesTo = len(indices) - 1\n    ans = -math.inf\n    while indicesFrom <= indicesTo:\n        while le <= indices[indicesFrom]:\n            bucket[nums[le]] -= 1\n            le += 1\n        while ri >= indices[indicesTo]:\n            bucket[nums[ri]] -= 1\n            ri -= 1\n        if indicesFrom < indicesTo:\n            ans = max(ans, max(bucket) + 2 * (indicesFrom + 1))\n        else:\n            ans = max(ans, max(bucket) - 1 + 2 * (indicesFrom + 1))\n        indicesFrom += 1\n        indicesTo -= 1\n    return ans\nsolveAll()", "import math\n\ndef solveAll():\n    nbCases = int(input())\n    for _ in range(nbCases):\n        case = readCase()\n        print(solve(case))\n\ndef readCase():\n    input()\n    return [int(x) for x in input().split()]\n\ndef solve(nums):\n    indices = [[] for _ in range(201)]\n    for (i, num) in enumerate(nums):\n        indices[num] += [i]\n    bucket = [0] * 201\n    for num in nums:\n        bucket[num] += 1\n    ans = -math.inf\n    for num in range(1, 201):\n        ans = max(ans, computeThreeBlock(nums, indices[num], bucket.copy()))\n    return ans\n\ndef computeThreeBlock(nums, indices, bucket):\n    le = 0\n    ri = len(nums) - 1\n    indicesFrom = 0\n    indicesTo = len(indices) - 1\n    ans = -math.inf\n    while indicesFrom <= indicesTo:\n        while le <= indices[indicesFrom]:\n            bucket[nums[le]] -= 1\n            le += 1\n        while ri >= indices[indicesTo]:\n            bucket[nums[ri]] -= 1\n            ri -= 1\n        if indicesFrom < indicesTo:\n            ans = max(ans, max(bucket) + 2 * (indicesFrom + 1))\n        else:\n            ans = max(ans, max(bucket) - 1 + 2 * (indicesFrom + 1))\n        indicesFrom += 1\n        indicesTo -= 1\n    return ans\nsolveAll()", "t = int(input())\nfor you in range(t):\n    n = int(input())\n    lpos = [[] for i in range(200)]\n    lfi = [[0 for i in range(200)] for j in range(n)]\n    l = input().split()\n    li = [int(i) for i in l]\n    for j in range(200):\n        count = 0\n        for i in range(n):\n            if li[i] == j + 1:\n                count += 1\n            lfi[i][j] = count\n    for i in range(n):\n        lpos[li[i] - 1].append(i)\n    maxa = 0\n    for i in range(200):\n        for numofel in range(1, len(lpos[i]) + 1):\n            start = lpos[i][numofel - 1] + 1\n            end = lpos[i][len(lpos[i]) - numofel] - 1\n            if start <= end:\n                for k in range(200):\n                    if k == i:\n                        continue\n                    if start == 0:\n                        if lfi[end][k] + 2 * numofel > maxa:\n                            maxa = 2 * numofel + lfi[end][k]\n                    elif lfi[end][k] + 2 * numofel - lfi[start - 1][k] > maxa:\n                        maxa = 2 * numofel + lfi[end][k] - lfi[start - 1][k]\n            else:\n                break\n        if maxa < len(lpos[i]):\n            maxa = len(lpos[i])\n    print(maxa)", "import math\n\ndef solveAll():\n    nbCases = int(input())\n    for _ in range(nbCases):\n        case = readCase()\n        print(solve(case))\n\ndef readCase():\n    input()\n    return [int(x) for x in input().split()]\n\ndef solve(nums):\n    indices = [[] for _ in range(201)]\n    for (i, num) in enumerate(nums):\n        indices[num] += [i]\n    ans = -math.inf\n    for num in range(1, 201):\n        ans = max(ans, computeThreeBlock(nums, indices[num]))\n    return ans\n\ndef computeThreeBlock(nums, indices):\n    bucket = [0] * 201\n    for num in nums:\n        bucket[num] += 1\n    le = 0\n    ri = len(nums) - 1\n    indicesFrom = 0\n    indicesTo = len(indices) - 1\n    ans = -math.inf\n    while indicesFrom <= indicesTo:\n        while le <= indices[indicesFrom]:\n            bucket[nums[le]] -= 1\n            le += 1\n        while ri >= indices[indicesTo]:\n            bucket[nums[ri]] -= 1\n            ri -= 1\n        if indicesFrom < indicesTo:\n            ans = max(ans, max(bucket) + 2 * (indicesFrom + 1))\n        else:\n            ans = max(ans, max(bucket) - 1 + 2 * (indicesFrom + 1))\n        indicesFrom += 1\n        indicesTo -= 1\n    return ans\nsolveAll()", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    st = set(l)\n    dc = Counter(l)\n    ma = 0\n    for t in dc:\n        ma = max(ma, dc[t])\n    dp = [[0 for tg in range(n + 1)] for ty in range(201)]\n    pos = [[] for pl in range(201)]\n    for i in range(1, 201):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i][j - 1]\n            if l[j - 1] == i:\n                pos[i].append(j)\n                dp[i][j] += 1\n\n    def getto(x, s1, e1):\n        return dp[x][e1] - dp[x][s1 - 1]\n\n    def max_X(ss, ee):\n        aq = 0\n        for ft in st:\n            aq = max(aq, getto(ft, ss, ee))\n        return aq\n    ans = 0\n    for i in st:\n        for t in range(len(pos[i]) // 2):\n            u = pos[i][t] + 1\n            v = pos[i][-(t + 1)] - 1\n            z = max_X(u, v)\n            ans = max(ans, z + 2 * (t + 1))\n    print(max(ans, ma))", "import operator\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    c = dict()\n    ans = 1\n    for a in range(0, n, 1):\n        if arr[a] not in c:\n            c[arr[a]] = 0\n        c[arr[a]] += 1\n        ind = -1\n        co = c[arr[a]]\n        for b in range(n - 1, a + 1, -1):\n            if arr[b] == arr[a]:\n                co -= 1\n            if co == 0:\n                ind = b\n                break\n        ans = max(ans, c[arr[a]])\n        if ind != -1:\n            d = dict()\n            for e in range(a + 1, b, 1):\n                if arr[e] not in d:\n                    d[arr[e]] = 0\n                d[arr[e]] += 1\n            temp = 0\n            if max(d, key=d.get) in d:\n                temp = d[max(d, key=d.get)] + 2 * c[arr[a]]\n            ans = max(ans, temp)\n    print(ans)", "for turn in range(int(input())):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    li = [[] for i in range(26)]\n    for i in range(n):\n        li[lis[i] - 1].append(i)\n    ans = 0\n    for i in range(26):\n        for j in range(26):\n            if i == j:\n                ans = max(ans, len(li[i]))\n            else:\n                for k in range(len(li[i]) // 2):\n                    left = li[i][k]\n                    right = li[i][-(k + 1)]\n                    anss = 2 * (k + 1)\n                    for num in li[j]:\n                        if left < num < right:\n                            anss += 1\n                    ans = max(ans, anss)\n    print(ans)", "import bisect\nt = int(input())\nnum = 26\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    prefix = {}\n    for i in range(1, num + 1):\n        prefix[i] = list()\n        prefix[i].append(0)\n    for i in range(n):\n        for j in range(1, num + 1):\n            if arr[i] == j:\n                prefix[j].append(prefix[j][-1] + 1)\n            else:\n                prefix[j].append(prefix[j][-1])\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, num + 1):\n            right = prefix[j][i]\n            right_ind = i\n            left_ind = bisect.bisect_right(prefix[j], prefix[j][-1] - right) - 1\n            if left_ind >= len(prefix[j]):\n                left_ind = len(prefix[j]) - 1\n            left = prefix[j][-1] - prefix[j][left_ind]\n            mid = 0\n            for g in range(1, num + 1):\n                if prefix[g][left_ind] - prefix[g][right_ind] > mid:\n                    mid = prefix[g][left_ind] - prefix[g][right_ind]\n            if left_ind >= right_ind and 2 * min(right, left) + mid > ans:\n                ans = 2 * min(right, left) + mid\n            if prefix[j][-1] > ans:\n                ans = prefix[j][-1]\n    print(ans)", "t = int(input())\nfor turn in range(t):\n    n = int(input())\n    lis = list(map(int, input().split()))\n    li = [[] for i in range(26)]\n    for i in range(n):\n        li[lis[i] - 1].append(i)\n    ans = 0\n    for i in range(26):\n        for j in range(26):\n            if i == j:\n                ans = max(ans, len(li[i]))\n            else:\n                for k in range(len(li[i]) // 2):\n                    left = li[i][k]\n                    right = li[i][-(k + 1)]\n                    anss = 2 * (k + 1)\n                    for num in li[j]:\n                        if left < num < right:\n                            anss += 1\n                    ans = max(ans, anss)\n    print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    m = 0\n    l1 = [0] * 26\n    for j in range(len(l1)):\n        l1[j] = [0] * n\n    for j in range(n):\n        l1[l[j] - 1][j] += 1\n    for j in range(26):\n        for k in range(1, n):\n            l1[j][k] += l1[j][k - 1]\n    for j in range(1, 27):\n        for k in range(1, 27):\n            if l1[k - 1][n - 1] == 0 and l1[j - 1][n - 1] == 0:\n                continue\n            if j == k:\n                m = max(m, l1[k - 1][n - 1])\n                continue\n            m = max(m, l1[k - 1][n - 1])\n            a = 0\n            b = n - 1\n            v = 0\n            while a < b:\n                if v != 0:\n                    a += 1\n                    b -= 1\n                while a < n and l[a] != j:\n                    a += 1\n                while b >= 0 and l[b] != j:\n                    b -= 1\n                v += 1\n                if a == n or b == -1:\n                    break\n                if a >= b:\n                    break\n                m = max(m, 2 * v + l1[k - 1][b] - l1[k - 1][a])\n    print(m)", "from collections import Counter\nTC = int(input())\nwhile TC > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = Counter(a).most_common()[0][1]\n    for x in range(1, 201):\n        S = Counter(a)\n        i = 0\n        j = n - 1\n        cnt = 0\n        while i < j:\n            while i < j:\n                S[a[i]] -= 1\n                if a[i] == x:\n                    break\n                i += 1\n            while i < j:\n                S[a[j]] -= 1\n                if a[j] == x:\n                    break\n                j -= 1\n            if i >= j:\n                break\n            cnt += 1\n            ans = max(ans, S.most_common(1)[0][1] + cnt * 2)\n            i += 1\n            j -= 1\n    print(ans)\n    TC -= 1", "def max_pos(ar, a, b, counts):\n    ans = 0\n    i = 0\n    j = len(ar) - 1\n    alen = 0\n    while i < j:\n        if ar[i] == a:\n            while i < j and ar[j] != a:\n                j -= 1\n            j -= 1\n            if j >= i:\n                alen += 2\n            curr_ans = alen + counts[b][j] - counts[b][i]\n            ans = max(ans, curr_ans)\n        i += 1\n    return ans\n\ndef solve(ar):\n    counts = [[0] * len(ar) for i in range(202)]\n    counts[ar[0]][0] = 1\n    for (i, val) in enumerate(ar[1:], 1):\n        for j in range(202):\n            if j != val:\n                counts[j][i] = counts[j][i - 1]\n            else:\n                counts[j][i] = counts[j][i - 1] + 1\n    ans = 0\n    for i in range(1, 201):\n        for j in range(1, 201):\n            if counts[i][-1] and counts[j][-1] and (counts[i][-1] + counts[j][-1] > ans):\n                ans = max(ans, max_pos(ar, i, j, counts))\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ar = list(map(int, input().strip().split()))\n    if len(ar) == 1:\n        print(1)\n    else:\n        print(solve(ar))", "import math\nN = int(input())\nfor i in range(0, N):\n    n = int(input())\n    S = input().split()\n    P = []\n    for i in range(0, n):\n        P.append(int(S[i]))\n    ans = 0\n    for i in range(1, 27):\n        for j in range(1, 27):\n            templist = []\n            if i == j:\n                continue\n            inumber = 0\n            numj = 0\n            for k in range(0, n):\n                if P[k] == i:\n                    templist.append([i, numj])\n                    inumber = inumber + 1\n                if P[k] == j:\n                    numj = numj + 1\n            best = numj\n            for k in range(0, math.floor(inumber / 2)):\n                if 2 * (k + 1) + templist[inumber - 1 - k][1] - templist[k][1] > best:\n                    best = 2 * (k + 1) + templist[inumber - 1 - k][1] - templist[k][1]\n            if ans < best:\n                ans = best\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    c = [0] * 27\n    id = [[] for i in range(27)]\n    for i in range(n):\n        id[a[i]].append(i)\n    for x in a:\n        c[x] += 1\n    res = max(c)\n    for l in range(n - 1):\n        r = id[a[l]][-1]\n        c = [0] * 27\n        for x in a[l:r + 1]:\n            c[x] += 1\n        if c[a[l]] == 1:\n            continue\n        c[a[l]] = 0\n        (k, t) = (a[l], 0)\n        while l < r:\n            t += 2\n            res = max(res, max(c) + t)\n            (l, r) = (l + 1, r - 1)\n            while a[l] != k:\n                c[a[l]] -= 1\n                l += 1\n            while a[r] != k:\n                c[a[r]] -= 1\n                r -= 1\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    c = [0] * 27\n    for x in a:\n        c[x] += 1\n    res = max(c)\n    for l in range(n - 1):\n        c = [0] * 27\n        for x in a[l:]:\n            c[x] += 1\n        if c[a[l]] == 1:\n            continue\n        c[a[l]] = 0\n        for r in range(n - 1, l, -1):\n            if a[r] == a[l]:\n                break\n            c[a[r]] -= 1\n        (k, t) = (a[l], 0)\n        while l < r:\n            t += 2\n            res = max(res, max(c) + t)\n            (l, r) = (l + 1, r - 1)\n            while a[l] != k:\n                c[a[l]] -= 1\n                l += 1\n            while a[r] != k:\n                c[a[r]] -= 1\n                r -= 1\n    print(res)", "def max_pos(ar, a, b, counts):\n    ans = 0\n    i = 0\n    j = len(ar) - 1\n    alen = 0\n    while i < j:\n        if ar[i] == a:\n            while i < j and ar[j] != a:\n                j -= 1\n            j -= 1\n            if j >= i:\n                alen += 2\n            curr_ans = alen + counts[b][j] - counts[b][i]\n            ans = max(ans, curr_ans)\n        i += 1\n    return ans\n\ndef solve(ar):\n    counts = [[0] * len(ar) for i in range(202)]\n    counts[ar[0]][0] = 1\n    for (i, val) in enumerate(ar[1:], 1):\n        for j in range(202):\n            if j != val:\n                counts[j][i] = counts[j][i - 1]\n            else:\n                counts[j][i] = counts[j][i - 1] + 1\n    ans = 0\n    for i in range(1, 201):\n        for j in range(1, 201):\n            if counts[i][-1] and counts[j][-1]:\n                ans = max(ans, max_pos(ar, i, j, counts))\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ar = list(map(int, input().strip().split()))\n    if len(ar) == 1:\n        print(1)\n    else:\n        print(solve(ar))", "b = [[0 for i in range(201)] for j in range(200005)]\nfor _ in range(int(input())):\n    (n, a, maximum) = (int(input()), list(map(int, input().split())), 1)\n    a = [0] + a\n    for x in range(1, n + 1):\n        for y in range(1, 201):\n            b[x][y] = b[x - 1][y]\n        b[x][a[x]] += 1\n    s = set(a)\n    for i in s:\n        (start, end, count) = (1, n, 0)\n        while start < end:\n            while start < end and a[start] != i:\n                start += 1\n            while start < end and a[end] != i:\n                end -= 1\n            if start < end:\n                count += 2\n                for j in range(1, 201):\n                    maximum = max(maximum, count + b[end - 1][j] - b[start][j])\n                start += 1\n                end -= 1\n    print(maximum)"]