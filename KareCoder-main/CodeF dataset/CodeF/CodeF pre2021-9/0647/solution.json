["from itertools import groupby\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    q = []\n    for i in range(n - 1):\n        if p[i + 1] > p[i]:\n            q.append(1)\n        else:\n            q.append(-1)\n    group = groupby(q)\n    grad = []\n    keys = []\n    for (k, g) in group:\n        g = list(g)\n        grad.append(len(g))\n        keys.append(k)\n    grad_max = max(grad)\n    c = grad.count(grad_max)\n    ans = -1\n    if c > 2:\n        ans = 0\n    elif c == 2:\n        for i in range(len(grad)):\n            if grad[i] == grad_max:\n                if grad[i + 1] == grad_max and keys[i] == 1:\n                    if grad_max % 2 == 0:\n                        ans = 1\n                    else:\n                        ans = 0\n                else:\n                    ans = 0\n                break\n    else:\n        ans = 0\n    print(ans)\nmain()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    peak = []\n    for i in range(1, n - 1):\n        if arr[i - 1] < arr[i] and arr[i] > arr[i + 1]:\n            peak.append(i)\n    if not peak:\n        return 0\n    bound = {}\n    for idx in peak:\n        l = idx - 1\n        r = idx + 1\n        prev = arr[idx]\n        cnt = cnt2 = 0\n        while l >= 0 and arr[l] < prev:\n            cnt += 1\n            prev = arr[l]\n            l -= 1\n        prev = arr[idx]\n        while r < n and arr[r] < prev:\n            cnt2 += 1\n            prev = arr[r]\n            r += 1\n        bound[idx] = (cnt, cnt2)\n        if idx == peak[-1] and r < n:\n            bound[n - 1] = (n - r, 0)\n        elif idx == peak[0] and l >= 0:\n            bound[0] = (0, l + 1)\n    val = -float('inf')\n    cnt = 0\n    key = -1\n    for idx in bound:\n        if max(bound[idx]) > val:\n            val = max(bound[idx])\n            cnt = 1\n            key = idx\n        elif max(bound[idx]) == val:\n            cnt += 1\n    if cnt > 1:\n        return 0\n    elif bound[key][0] != bound[key][1]:\n        return 0\n    else:\n        return 0 if max(bound[key]) % 2 else 1\nprint(solve())", "import collections\nn = int(input())\nnums = [int(s) for s in input().split()]\nqueue = []\nup = down = 0\nfor i in range(1, len(nums)):\n    if nums[i] > nums[i - 1]:\n        if down > 0:\n            queue.append(-down)\n            down = 0\n            up = 1\n        else:\n            up += 1\n    elif up > 0:\n        queue.append(up)\n        up = 0\n        down = 1\n    else:\n        down += 1\nif up > 0:\n    queue.append(up)\nif down > 0:\n    queue.append(-down)\nc = collections.Counter(queue)\nm = max(c)\nif m == -min(c) and c[m] == 1 and (c[-m] == 1) and (queue.index(m) + 1 == queue.index(-m)) and (m % 2 == 0):\n    print(1)\nelse:\n    print(0)", "n = int(input())\nls = [int(x) for x in input().split()]\nlss = []\nif ls[1] > ls[0]:\n    up = 1\nelse:\n    up = 0\ntmp = up\ncnt = 1\nfor i in range(1, len(ls)):\n    if tmp:\n        if ls[i] > ls[i - 1]:\n            cnt += 1\n        else:\n            lss.append(cnt)\n            cnt = 2\n            tmp = 0\n    elif ls[i] < ls[i - 1]:\n        cnt += 1\n    else:\n        lss.append(cnt)\n        cnt = 2\n        tmp = 1\nlss.append(cnt)\nm = max(lss)\ncnt = lss.count(m)\nans = 0\nif cnt == 2:\n    for i in range(len(lss) - 1):\n        if lss[i] == m and lss[i + 1] == m and (i % 2 != up):\n            ans = 1\nif m % 2:\n    print(ans)\nelse:\n    print(0)", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\nn = int(input())\np = list(map(int, input().split()))\na = [0] * n\nb = [0] * n\nfor i in range(n - 1):\n    if p[i] < p[i + 1]:\n        a[i + 1] = a[i] + 1\nfor i in range(n - 1, 0, -1):\n    if p[i - 1] > p[i]:\n        b[i - 1] = b[i] + 1\nx = max(max(a), max(b))\nk = sum((x == i or x == j for (i, j) in zip(a, b)))\ns = sum((x == i and x == j for (i, j) in zip(a, b)))\nif k > 1 or s == 0 or x % 2:\n    print(0)\nelse:\n    print(1)", "def resi(a, n):\n    boj = 0\n    b = [1] * n\n    c = [1] * n\n    i = 0\n    maxr = 1\n    maxo = 1\n    while i + 1 < n:\n        if a[i] < a[i + 1]:\n            b[i + 1] = b[i] + 1\n            if b[i + 1] > maxr:\n                maxr = b[i + 1]\n        i += 1\n    t = n - 1\n    while t > 0:\n        if a[t - 1] > a[t]:\n            c[t - 1] = c[t] + 1\n            if c[t - 1] > maxo:\n                maxo = c[t - 1]\n        t -= 1\n    if maxr > maxo:\n        ind = b.index(maxr)\n        njp = c[ind]\n        del b[ind]\n        del c[ind]\n        if maxr not in b and maxr not in c and (maxr == njp) and (maxr % 2 == 1):\n            boj = 1\n    else:\n        ind = c.index(maxo)\n        del c[ind]\n        njp = b[ind]\n        del b[ind]\n        if maxo not in b and maxo not in c and (maxo == njp) and (maxo % 2 == 1):\n            boj = 1\n    print(boj)\nn = int(input())\na = [int(i) for i in input().split(' ')]\nresi(a, n)", "inn = lambda : int(input())\ninm = lambda : map(int, input().split())\nins = lambda : str(input())\nina = lambda : list(map(int, input().split()))\n\ndef solve():\n    n = inn()\n    a = ina()\n    inc = [1] * n\n    rinc = inc[:]\n    for (i, v) in enumerate(a):\n        if i:\n            if a[i - 1] < a[i]:\n                inc[i] = 1 + inc[i - 1]\n            else:\n                inc[i] = 1\n    b = a[::-1]\n    for (i, v) in enumerate(b):\n        if i:\n            if b[i - 1] < b[i]:\n                rinc[i] = 1 + rinc[i - 1]\n            else:\n                rinc[i] = 1\n    rinc = rinc[::-1]\n    m = max(inc)\n    m = max(m, max(rinc))\n    c = 0\n    for i in inc:\n        c += i == m\n    for i in rinc:\n        c += i == m\n    if c > 2:\n        print(0)\n    elif c == 1:\n        print(0)\n    else:\n        for i in range(n):\n            if m % 2 == 1 and inc[i] == rinc[i] and (inc[i] == m):\n                print(1)\n                return\n        print(0)\n\ndef main():\n    t = 1\n    for _ in range(t):\n        solve()\nmain()", "n = int(input())\np = list(map(int, input().split()))\nslope = 1\nmaxi = 0\ncount = 0\nend = {}\nfor i in range(1, n):\n    if p[i] > p[i - 1]:\n        slope += 1\n    else:\n        if slope > maxi:\n            maxi = slope\n            count = 1\n            end = {i - 1: 1}\n        elif slope == maxi:\n            count += 1\n        slope = 1\nif slope > maxi:\n    maxi = slope\n    count = 1\n    end = {i - 1: 1}\nelif slope == maxi:\n    count += 1\nslope = 1\nf = 0\nfor i in range(n - 2, -1, -1):\n    if p[i] > p[i + 1]:\n        slope += 1\n    else:\n        if slope > maxi:\n            maxi = slope\n            count = 1\n        elif slope == maxi:\n            count += 1\n            if i + 1 in end:\n                f = 1\n        slope = 1\nif slope > maxi:\n    maxi = slope\n    count = 1\nelif slope == maxi:\n    count += 1\n    if i + 1 in end:\n        f = 1\nif count == 2:\n    if f == 1:\n        if maxi % 2 == 1:\n            print(1)\n        else:\n            print(0)\n    else:\n        print(0)\nelse:\n    print(0)", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\nn = int(input())\np = list(map(int, input().split()))\na = [0] * n\nb = [0] * n\nfor i in range(n - 1):\n    if p[i] < p[i + 1]:\n        a[i + 1] = a[i] + 1\nfor i in range(n - 1, 0, -1):\n    if p[i - 1] > p[i]:\n        b[i - 1] = b[i] + 1\nx = max(max(a), max(b))\nk = sum((x == i or x == j for (i, j) in zip(a, b)))\ns = sum((x == i and x == j for (i, j) in zip(a, b)))\nif k > 1 or s == 0 or x % 2:\n    print(0)\nelse:\n    print(1)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    peak = []\n    if arr[0] > arr[1]:\n        peak.append([0, 0, 0])\n    for i in range(1, n - 1):\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            peak.append([i, 0, 0])\n    if arr[-1] > arr[-2]:\n        peak.append([n - 1, 0, 0])\n    m = len(peak)\n    if m == 1 and peak[0][0] == 0 or peak[0][0] == n - 1:\n        return 0\n    for i in range(m):\n        idx = peak[i][0]\n        (left, right) = (idx - 1, idx + 1)\n        p1 = p2 = arr[idx]\n        while left >= 0 and arr[left] < p1 or (right < n and arr[right] < p2):\n            if left >= 0 and arr[left] < p1:\n                p1 = arr[left]\n                peak[i][1] += 1\n                left -= 1\n            if right < n and arr[right] < p2:\n                p2 = arr[right]\n                peak[i][2] += 1\n                right += 1\n    v = -float('inf')\n    cnt = 0\n    same = False\n    for (i, left, right) in peak:\n        if max(left, right) > v:\n            cnt = 1\n            v = max(left, right)\n            same = left == right\n        elif max(left, right) == v:\n            cnt += 1\n    if cnt > 1:\n        return 0\n    else:\n        return 1 if same and v % 2 == 0 else 0\nprint(solve())", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    peak = []\n    if arr[0] > arr[1]:\n        peak.append([0, 0, 0])\n    for i in range(1, n - 1):\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            peak.append([i, 0, 0])\n    if arr[-1] > arr[-2]:\n        peak.append([n - 1, 0, 0])\n    m = len(peak)\n    if m == 1 and peak[0][0] == 0 or peak[0][0] == n - 1:\n        return 0\n    cnt = 0\n    v = -float('inf')\n    same = False\n    for i in range(m):\n        idx = peak[i][0]\n        (left, right) = (idx - 1, idx + 1)\n        p1 = p2 = arr[idx]\n        while left >= 0 and arr[left] < p1 or (right < n and arr[right] < p2):\n            if left >= 0 and arr[left] < p1:\n                p1 = arr[left]\n                peak[i][1] += 1\n                left -= 1\n            if right < n and arr[right] < p2:\n                p2 = arr[right]\n                peak[i][2] += 1\n                right += 1\n        if max(peak[i][1], peak[i][2]) > v:\n            cnt = 1\n            v = max(peak[i][1], peak[i][2])\n            same = peak[i][1] == peak[i][2]\n        elif max(peak[i][1], peak[i][2]) == v:\n            cnt += 1\n    if cnt > 1:\n        return 0\n    else:\n        return 1 if same and v % 2 == 0 else 0\nprint(solve())", "n = int(input())\np = list(map(int, input().split()))\na = [0] * n\nb = [0] * n\nfor i in range(n - 1):\n    if p[i] < p[i + 1]:\n        a[i + 1] = a[i] + 1\nfor i in range(n - 1, 0, -1):\n    if p[i - 1] > p[i]:\n        b[i - 1] = b[i] + 1\nx = max(max(a), max(b))\nk = sum((x == i or x == j for (i, j) in zip(a, b)))\ns = sum((x == i and x == j for (i, j) in zip(a, b)))\nif k > 1 or s == 0 or x % 2:\n    print(0)\nelse:\n    print(1)", "n = int(input())\narray = list(map(int, input().split()))\nleftToRight = [0 for i in range(n)]\nrightToLeft = [0 for i in range(n)]\nfor i in range(1, n):\n    if array[i - 1] < array[i]:\n        leftToRight[i] = leftToRight[i - 1] + 1\nfor i in range(n - 2, -1, -1):\n    if array[i + 1] < array[i]:\n        rightToLeft[i] = rightToLeft[i + 1] + 1\nmaxVal = max(max(leftToRight), max(rightToLeft))\nmaxCount = 0\nmaxOnSameIdx = 0\nfor i in range(n):\n    if leftToRight[i] == maxVal:\n        maxCount += 1\n    if rightToLeft[i] == maxVal:\n        maxCount += 1\n    if leftToRight[i] == maxVal and rightToLeft[i] == maxVal:\n        maxOnSameIdx += 1\nif maxCount == 2 and maxOnSameIdx == 1 and (maxVal % 2 == 0):\n    print(1)\nelse:\n    print(0)", "import sys\nimport math\nfrom math import factorial, inf, gcd\nfrom heapq import *\nfrom functools import *\nfrom itertools import *\nfrom collections import *\nfrom typing import *\nsys.setrecursionlimit(10 ** 5)\nt = 1\nfor ii in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    v = []\n    v2 = []\n    i = 0\n    while i + 1 < n:\n        j = i\n        while i + 1 < n and a[i + 1] > a[i]:\n            i += 1\n        t1 = i - j + 1\n        j = i\n        while i + 1 < n and a[i + 1] < a[i]:\n            i += 1\n        t2 = i - j + 1\n        v.append(t1)\n        v.append(t2)\n        if t1 % 2 == 1 and t1 == t2:\n            v2.append(t1)\n    p = max(v)\n    print(1 if v2.count(p) == 1 and v.count(p) == 2 else 0)", "import sys\n\ndef input():\n    return sys.stdin.readline().rstrip()\nn = int(input())\np = list(map(int, input().split()))\na = [0] * n\nb = [0] * n\nfor i in range(n - 1):\n    if p[i] < p[i + 1]:\n        a[i + 1] = a[i] + 1\nfor i in range(n - 1, 0, -1):\n    if p[i - 1] > p[i]:\n        b[i - 1] = b[i] + 1\nx = max(max(a), max(b))\nk = sum((x == i or x == j for (i, j) in zip(a, b)))\ns = sum((x == i and x == j for (i, j) in zip(a, b)))\nif k > 1 or s == 0 or x % 2:\n    print(0)\nelse:\n    print(1)", "n = int(input())\ndata = list(map(int, input().split()))\nprocess = []\nflag = False\nfor i in range(1, len(data) - 1):\n    if data[i] > data[i - 1] and data[i] > data[i + 1]:\n        flag = True\n        process.append([])\n        index1 = i - 1\n        index2 = i + 1\n        while index1 >= 0 and data[index1] < data[index1 + 1]:\n            index1 -= 1\n        process[-1].append(index1 + 1)\n        process[-1].append(i)\n        while index2 < n and data[index2] < data[index2 - 1]:\n            index2 += 1\n        process[-1].append(index2 - 1)\nif not flag:\n    print(0)\n    exit(0)\nmax_len = 0\nmax_len_b = max(process[0][0] + 1, n - process[-1][-1])\ncounter = 0\nfor i in range(len(process)):\n    len1 = process[i][1] - process[i][0] + 1\n    len2 = process[i][2] - process[i][1] + 1\n    if len1 != len2 or len1 % 2 != 1:\n        process[i] = []\n        max_len_b = max(max_len_b, len1, len2)\n    else:\n        max_len = max(max_len, len1)\nif max_len <= max_len_b:\n    print(0)\nelse:\n    for i in range(len(process)):\n        if process[i]:\n            if process[i][1] - process[i][0] + 1 == max_len:\n                counter += 1\n    if counter > 1:\n        print(0)\n    else:\n        print(1)", "def process(n, a):\n    l = [0] * n\n    r = [0] * n\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            l[i] = l[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if a[i + 1] < a[i]:\n            r[i] = r[i + 1] + 1\n    max_path = 0\n    for i in range(n):\n        max_path = max(max_path, l[i])\n        max_path = max(max_path, r[i])\n    n_count = 0\n    for i in range(n):\n        if l[i] == max_path:\n            n_count += 1\n        if r[i] == max_path:\n            n_count += 1\n    if n_count > 2:\n        return 0\n    result = 0\n    for i in range(n):\n        if not (l[i] > 0 and r[i] > 0):\n            continue\n        if l[i] != r[i] and (l[i] == max_path or r[i] == max_path) and (n_count == 2):\n            return 0\n        if max(l[i], r[i]) < max_path:\n            continue\n        max_odd_l = l[i]\n        if l[i] % 2 == 0:\n            max_odd_l = l[i] - 1\n        max_odd_r = r[i]\n        if r[i] % 2 == 0:\n            max_odd_r = r[i] - 1\n        if max_odd_l < r[i] and max_odd_r < l[i]:\n            return 1\n    return 0\nn = int(input())\na = [int(x) for x in input().split()]\nprint(process(n, a))", "n = int(input())\narray = list(map(int, input().split()))\nleftToRight = [0 for i in range(n)]\nrightToLeft = [0 for i in range(n)]\nfor i in range(1, n):\n    if array[i - 1] < array[i]:\n        leftToRight[i] = leftToRight[i - 1] + 1\nfor i in range(n - 2, -1, -1):\n    if array[i + 1] < array[i]:\n        rightToLeft[i] = rightToLeft[i + 1] + 1\nmaxVal = max(max(leftToRight), max(rightToLeft))\nmaxCount = 0\nmaxOnSameIdx = 0\nfor i in range(n):\n    if leftToRight[i] == maxVal:\n        maxCount += 1\n    if rightToLeft[i] == maxVal:\n        maxCount += 1\n    if leftToRight[i] == maxVal and rightToLeft[i] == maxVal:\n        maxOnSameIdx += 1\nif maxCount == 2 and maxOnSameIdx == 1 and (maxVal % 2 == 0):\n    print(1)\nelse:\n    print(0)", "def solve(P, n):\n    trailLengths = [(-1, -1)] * n\n    lastIndex = 0\n    for i in range(1, n):\n        if i == n - 1 or (P[i] > P[i - 1] and P[i] > P[i + 1]) or (P[i] < P[i - 1] and P[i] < P[i + 1]):\n            trailLengths[lastIndex] = (trailLengths[lastIndex][0], i - lastIndex)\n            trailLengths[i] = (i - lastIndex, trailLengths[i][1])\n            lastIndex = i\n    maxTrailLength = 0\n    freq = {}\n    for i in range(n):\n        freq[trailLengths[i][0]] = freq.get(trailLengths[i][0], 0) + 1\n        maxTrailLength = max(trailLengths[i][0], maxTrailLength)\n    maxTrailLengthFreq = freq[maxTrailLength]\n    if maxTrailLengthFreq > 2:\n        return 0\n    totalWinPositions = 0\n    for i in range(1, n - 1):\n        if not (P[i - 1] < P[i] and P[i + 1] < P[i]):\n            continue\n        if trailLengths[i][0] != trailLengths[i][1] or trailLengths[i][0] % 2 == 1:\n            continue\n        if trailLengths[i][0] == maxTrailLength:\n            totalWinPositions += 1\n    return totalWinPositions\nn = int(input())\nP = list(map(int, input().split()))\nresult = solve(P, n)\nprint(result)", "import sys\nn = int(sys.stdin.readline().rstrip())\nperms = list(map(int, sys.stdin.readline().rstrip().split()))\nmax_increase = 0\nmax_decrease = 0\nls = []\nis_lost = False\ni = 0\nwhile i < n - 1:\n    walk = i + 1\n    if perms[walk] > perms[i]:\n        while walk < n:\n            if perms[walk] < perms[walk - 1]:\n                break\n            walk += 1\n        walk -= 1\n        if walk - i > max_increase:\n            max_increase = walk - i\n        ls.append((walk - i, 0))\n    else:\n        while walk < n:\n            if perms[walk] > perms[walk - 1]:\n                break\n            walk += 1\n        walk -= 1\n        if walk - i > max_decrease:\n            max_decrease = walk - i\n        ls.append((walk - i, 1))\n    i = walk\nmax_hike = max(max_increase, max_decrease)\ncount = 0\nfor i in range(len(ls)):\n    if ls[i][0] == max_hike:\n        count += 1\nif count >= 3:\n    is_lost = True\nelif count == 2:\n    for i in range(len(ls) - 1):\n        if ls[i][0] == max_hike:\n            if ls[i + 1][0] == max_hike and ls[i][1] == 0 and (max_hike % 2 == 0):\n                is_lost = False\n                break\n            else:\n                is_lost = True\nelif count == 1:\n    is_lost = True\nif not is_lost:\n    print(1)\nelse:\n    print(0)", "n = int(input())\na = list(map(int, input().split()))\nnew1 = [0]\nmx = 0\nnew2 = [0] * n\nfor i in range(1, n):\n    new1.append(new1[i - 1] + 1 if a[i] > a[i - 1] else 0)\n    mx = max(mx, new1[i])\nfor i in range(n - 2, -1, -1):\n    if a[i + 1] < a[i]:\n        new2[i] = new2[i + 1] + 1\n    mx = max(mx, new2[i])\nans = new1.count(mx) + new2.count(mx)\nif ans == 2:\n    flag = 0\n    for i in range(n):\n        if new1[i] == mx and new2[i] == mx:\n            flag += 1\n    if flag == 1:\n        print('1') if mx % 2 == 0 else print('0')\n    else:\n        print('0')\nelse:\n    print('0')", "n = int(input())\ndata = list(map(int, input().split()))\nprocess = []\nflag = False\nfor i in range(1, len(data) - 1):\n    if data[i] > data[i - 1] and data[i] > data[i + 1]:\n        flag = True\n        process.append([])\n        index1 = i - 1\n        index2 = i + 1\n        while index1 >= 0 and data[index1] < data[index1 + 1]:\n            index1 -= 1\n        process[-1].append(index1 + 1)\n        process[-1].append(i)\n        while index2 < n and data[index2] < data[index2 - 1]:\n            index2 += 1\n        process[-1].append(index2 - 1)\nif not flag:\n    print(0)\n    exit(0)\nmax_len = 0\nmax_len_b = max(process[0][0] + 1, n - process[-1][-1])\ncounter = 0\nfor i in range(len(process)):\n    len1 = process[i][1] - process[i][0] + 1\n    len2 = process[i][2] - process[i][1] + 1\n    if len1 != len2 or len1 % 2 != 1:\n        process[i] = []\n        max_len_b = max(max_len_b, len1, len2)\n    else:\n        max_len = max(max_len, len1)\nif max_len <= max_len_b:\n    print(0)\nelse:\n    for i in range(len(process)):\n        if process[i]:\n            if process[i][1] - process[i][0] + 1 == max_len:\n                counter += 1\n    if counter > 1:\n        print(0)\n    else:\n        print(1)", "n = int(input())\na = list(map(int, input().split()))\nnew1 = []\nnew1.append(0)\nmx = 0\nfor i in range(1, n):\n    if a[i] > a[i - 1]:\n        new1.append(new1[i - 1] + 1)\n    else:\n        new1.append(0)\n    mx = max(mx, new1[i])\nnew2 = [0] * n\nfor i in range(n - 2, -1, -1):\n    if a[i + 1] < a[i]:\n        new2[i] = new2[i + 1] + 1\n    mx = max(mx, new2[i])\nans = 0\nfor i in range(n):\n    if new1[i] == mx:\n        ans += 1\n    if new2[i] == mx:\n        ans += 1\nif ans == 2:\n    flag = 0\n    for i in range(n):\n        if new1[i] == mx and new2[i] == mx:\n            flag += 1\n    if flag == 1:\n        if mx % 2 == 0:\n            print('1')\n        else:\n            print('0')\n    else:\n        print('0')\nelse:\n    print('0')", "n = int(input())\npp = list(map(int, input().split()))\nmx = 0\ncnt = 0\nfor i in range(1, n - 1):\n    if pp[i] > pp[i - 1] and pp[i] > pp[i + 1]:\n        for j in range(i - 1, -1, -1):\n            if pp[j] > pp[j + 1]:\n                break\n        for k in range(i + 1, n):\n            if pp[k] > pp[k - 1]:\n                break\n        if pp[j] > pp[j + 1]:\n            j += 1\n        if pp[k] > pp[k - 1]:\n            k -= 1\n        j = i - j\n        k = k - i\n        if j == k and j & 1 == 0:\n            if j > mx:\n                mx = j\n                cnt = 1\n            elif j == mx:\n                cnt += 1\nok = cnt == 1\nmxinccnt = mxinc = cnt = 0\nfor (x, y) in zip(pp, pp[1:]):\n    if y > x:\n        cnt += 1\n        if cnt > mxinc:\n            mxinc = cnt\n            mxinccnt = 1\n        elif cnt == mxinc:\n            mxinccnt += 1\n    else:\n        cnt = 0\ncnt = 0\nfor (y, x) in zip(reversed(pp[:-1]), reversed(pp)):\n    if y > x:\n        cnt += 1\n        if cnt > mxinc:\n            mxinc = cnt\n            mxinccnt = 1\n        elif cnt == mxinc:\n            mxinccnt += 1\n    else:\n        cnt = 0\nprint(1 if ok and (mxinc < mx or (mxinc == mx and mxinccnt == 2)) else 0)"]