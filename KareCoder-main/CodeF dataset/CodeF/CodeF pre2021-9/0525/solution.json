["def soluciona():\n    n = int(input())\n    visitados = list(map(int, input().split()))\n    anterior = 0\n    largura = 1\n    nova_largura = 0\n    altura = 1\n    for v in visitados[1:]:\n        if anterior > v:\n            largura -= 1\n        if largura == 0:\n            largura = nova_largura\n            nova_largura = 0\n            altura += 1\n        nova_largura += 1\n        anterior = v\n    print(altura)\nfor _ in range(int(input())):\n    soluciona()", "nTests = int(input())\nfor test in range(nTests):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print('0')\n    else:\n        n1 = 1\n        n2 = 0\n        ret = 1\n        last = a[0]\n        for i in range(1, n):\n            if a[i] < last:\n                n1 -= 1\n                if n1 == 0:\n                    ret += 1\n                    n1 = n2\n            else:\n                n2 += 1\n            last = a[i]\n        print(ret)", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (c, p, q) = (1, 0, 0)\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (c, p, q) = (1, 0, 0)\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "from sys import stdin\nrl = stdin.readline\n\ndef main(n, a):\n    (depth, start_i, end_i, members) = (0, 0, 0, 1)\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            members -= 1\n            if members == 0:\n                depth += 1\n                start_i = end_i + 1\n                members = i - start_i\n                end_i = i - 1\n    print(depth + 1)\nt = int(rl())\ncases = [(int(rl()), list(map(int, rl().split()))) for _ in range(t)]\nfor (n, a) in cases:\n    main(n, a)", "nTests = int(input())\nfor test in range(nTests):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print('0')\n    else:\n        n1 = 1\n        n2 = 0\n        ret = 1\n        last = a[0]\n        for i in range(1, n):\n            if a[i] < last:\n                n1 -= 1\n                if n1 == 0:\n                    ret += 1\n                    n1 = n2\n            else:\n                n2 += 1\n            last = a[i]\n        print(ret)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    que = deque(arr[1:])\n    q = deque([0])\n    ans = 0\n    while q:\n        ans = q.popleft()\n        prev = 0\n        while que and que[0] >= prev:\n            prev = que.popleft()\n            q.append(ans + 1)\n    return ans\nfor _ in range(int(input())):\n    print(main())", "from sys import stdin\nrl = stdin.readline\n\ndef main(n, a):\n    (depth, start_i, end_i, members) = (0, 0, 0, 1)\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            members -= 1\n            if members == 0:\n                depth += 1\n                start_i = end_i + 1\n                members = i - start_i\n                end_i = i - 1\n    print(depth + 1)\nt = int(rl())\ncases = [(int(rl()), list(map(int, rl().split()))) for _ in range(t)]\nfor (n, a) in cases:\n    main(n, a)", "from sys import stdin\nrl = stdin.readline\n\ndef main(n, a):\n    (depth, start_i, end_i, members) = (0, 0, 0, 1)\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            members -= 1\n            if members == 0:\n                depth += 1\n                start_i = end_i + 1\n                members = i - start_i\n                end_i = i - 1\n    print(depth + 1)\nt = int(rl())\ncases = [(int(rl()), list(map(int, rl().split()))) for _ in range(t)]\nfor (n, a) in cases:\n    main(n, a)", "def rl():\n    return list(map(int, input().split()))\n\ndef ri():\n    return int(input())\n\ndef rm():\n    return map(int, input().split())\n\ndef solve():\n    n = ri()\n    a = rl()\n    (i, j) = (1, 2)\n    p = 1\n    tmp = 0\n    l = 0\n    while i < n:\n        p -= 1\n        while j < n and a[j] > a[j - 1]:\n            j += 1\n        tmp += j - i\n        i = j\n        j += 1\n        if p == 0:\n            p = tmp\n            l += 1\n            tmp = 0\n        elif i == n:\n            l += 1\n    return l\nt = ri()\nfor i in range(t):\n    print(solve())", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 1\n    k = 0\n    nexk = 0\n    for i in range(2, n):\n        if a[i] < a[i - 1]:\n            if k:\n                k -= 1\n                nexk += 1\n            else:\n                c += 1\n                k = nexk\n                nexk = 0\n        else:\n            nexk += 1\n    print(c)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = [10 ** 9] * n\n    ans[0] = 0\n    last = 0\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            last += 1\n        ans[i] = ans[last] + 1\n    print(ans[-1])", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 1\n    p = 0\n    q = 0\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "for count in range(int(input())):\n    n = int(input())\n    t = list(map(int, input().split()))\n    res = 1\n    pcount = 1\n    ccount = 0\n    for i in range(1, n - 1):\n        ccount += 1\n        if t[i] >= t[i + 1]:\n            pcount -= 1\n            if pcount == 0:\n                pcount = ccount\n                ccount = 0\n                res += 1\n    print(res)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(lambda x: int(x), input().split()))\n    count = 0\n    h = [0]\n    for i in range(1, n):\n        if a[i - 1] > a[i]:\n            count += 1\n        h.append(h[count] + 1)\n    print(h[-1])", "from sys import stdin\nrl = stdin.readline\n\ndef main(n, a):\n    (depth, start_i, end_i, members) = (0, 0, 0, 1)\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            members -= 1\n            if members == 0:\n                depth += 1\n                start_i = end_i + 1\n                members = i - start_i\n                end_i = i - 1\n    print(depth + 1)\nt = int(rl())\ncases = [(int(rl()), list(map(int, rl().split()))) for _ in range(t)]\nfor (n, a) in cases:\n    main(n, a)", "def main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = [int(word) for word in input().rstrip().split()]\n        depth = 0\n        fathers = 1\n        sons = 0\n        fa_iter = 0\n        last = float('inf')\n        for i in range(1, len(a)):\n            if a[i] >= last:\n                last = a[i]\n                sons += 1\n                continue\n            fa_iter += 1\n            if fa_iter >= fathers:\n                depth += 1\n                fathers = sons\n                fa_iter = 0\n                last = a[i]\n                sons = 1\n            else:\n                last = a[i]\n                sons += 1\n        print(depth)\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    p = 0\n    levelCompleted = 0\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            p += 1\n        elif levelCompleted == 0:\n            ans += 1\n            levelCompleted = p - 1\n        else:\n            levelCompleted = levelCompleted - 1\n    print(ans)", "def solve(n, arr):\n    height = 1\n    prev = 1\n    now = 0\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            now += 1\n        else:\n            prev -= 1\n            if prev == 0:\n                prev = now\n                height += 1\n                now = 1\n            else:\n                now += 1\n    return height\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    ans = solve(n, arr)\n    print(ans)", "def solve(n, a):\n    ret = 1\n    prev_cnt = 1\n    tmp = 1\n    cnt = 1\n    for i in range(2, n):\n        if a[i - 1] > a[i]:\n            if tmp < prev_cnt:\n                tmp += 1\n                cnt += 1\n            else:\n                ret += 1\n                prev_cnt = cnt\n                tmp = 1\n                cnt = 1\n        else:\n            cnt += 1\n    return ret\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))", "from sys import stdin\n\ndef main(n, a):\n    (depth, start_i, end_i, members) = (0, 0, 0, 1)\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            members -= 1\n            if members == 0:\n                depth += 1\n                start_i = end_i + 1\n                members = i - start_i\n                end_i = i - 1\n    print(depth + 1)\nt = int(stdin.readline())\ncases = [(int(stdin.readline()), list(map(int, stdin.readline().split()))) for _ in range(t)]\nfor (n, a) in cases:\n    main(n, a)", "from collections import deque\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    a = list(map(int, input().split(' ')))\n    que = deque([0])\n    (d, pos) = (0, n + 1)\n    for x in a[1:]:\n        if pos > x:\n            d = que.popleft() + 1\n        que.append(d)\n        pos = x\n    print(que[-1])", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return list(map(int, sys.stdin.readline().strip().split()))[0]\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nN = 0\na = []\n\ndef solve():\n    global N\n    N = get_int()\n    a = get_list()\n    totalParentsOfLastLevel = 1\n    nodesAtCurrentLevel = 1\n    answer = 1\n    for i in range(2, N):\n        if a[i] < a[i - 1]:\n            totalParentsOfLastLevel = totalParentsOfLastLevel - 1\n            if totalParentsOfLastLevel == 0:\n                answer = answer + 1\n                totalParentsOfLastLevel = nodesAtCurrentLevel\n                nodesAtCurrentLevel = 1\n                i = i + 1\n            else:\n                nodesAtCurrentLevel = nodesAtCurrentLevel + 1\n        else:\n            nodesAtCurrentLevel = nodesAtCurrentLevel + 1\n    print(answer)\ntest_cases = get_int()\nfor _ in range(test_cases):\n    solve()", "for _ in range(int(input())):\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    levels = [0] * n\n    index = 0\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            index += 1\n        levels[i] = levels[index] + 1\n    print(levels[-1])", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (c, p, q) = (1, 0, 0)\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "for _ in range(int(input())):\n    n = input()\n    nodes = list(map(int, input().split()))\n    length = 1\n    new_length = 0\n    depth = 1\n    prev = 0\n    for i in nodes[1:]:\n        if i > prev:\n            q = 0\n        else:\n            length -= 1\n        if length == 0:\n            length = new_length\n            new_length = 0\n            depth += 1\n        new_length += 1\n        prev = i\n    print(depth)", "t = int(input())\n\ndef solve(an):\n    N = len(an)\n    depth = [0] * N\n    current_root = 0\n    for i in range(1, N):\n        if i - 1 > 0 and an[i - 1] > an[i]:\n            current_root += 1\n        depth[i] = depth[current_root] + 1\n    return depth[-1]\nfor _ in range(t):\n    n = int(input())\n    an = list(map(int, input().split()))\n    print(solve(an))", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (c, p, q) = (1, 0, 0)\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "for t in range(int(input())):\n    n = int(input())\n    order = list(map(int, input().split()))\n    par = 0\n    from collections import defaultdict\n    lvl = defaultdict(int)\n    for i in range(1, n):\n        if order[i - 1] > order[i]:\n            par += 1\n        lvl[i] = lvl[par] + 1\n    print(lvl[n - 1])", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    levels = [0] * n\n    index = 0\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            index += 1\n        levels[i] = levels[index] + 1\n    print(levels[-1])", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    height = 1\n    last = 1\n    x = 1\n    tmp = 0\n    while x < n:\n        if arr[x] < arr[x - 1]:\n            last -= 1\n        if last == 0:\n            height += 1\n            last = tmp\n            tmp = 1\n        else:\n            tmp += 1\n        x += 1\n    print(height)", "import math\nfrom collections import deque, defaultdict\nfrom math import sqrt, ceil, factorial, floor, inf, gcd\nimport bisect\nimport sys\nimport random\nimport heapq\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\nfor _ in range(int(input())):\n    n = int(input())\n    arr = deque(get_array())\n    queue = deque([arr.popleft()])\n    ht = [0] * n\n    while queue and arr:\n        k = queue.popleft()\n        cur = arr.popleft()\n        queue.append(cur)\n        ht[cur - 1] = ht[k - 1] + 1\n        while arr and cur < arr[0]:\n            cur = arr.popleft()\n            queue.append(cur)\n            ht[cur - 1] = ht[k - 1] + 1\n    print(max(ht))", "from sys import stdin, stdout\nimport collections, heapq, bisect, math\ninput = stdin.readline\n\ndef rint():\n    return int(input())\n\ndef rstr():\n    return input().strip()\n\ndef rlstr():\n    return list(input().strip().split())\n\ndef rlint():\n    return list(map(int, input().split()))\n\ndef main():\n    n = rint()\n    a = rlint()\n    d = 0\n    i = 1\n    count = 1\n    while i < n:\n        temp = 0\n        for _ in range(count):\n            while i + 1 < n and a[i] <= a[i + 1]:\n                temp += 1\n                i += 1\n            temp += 1\n            i += 1\n        d += 1\n        count = temp\n    print(d)\nfor _ in range(rint()):\n    main()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = 1\n    p = 0\n    q = 0\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    a = [0] + [int(i) for i in input().split()] + [0, 0, 0, 0, 0]\n    res = 1\n    lastcut = 1\n    cnt = 1\n    for i in range(3, n + 1):\n        if a[i] < a[i - 1]:\n            lastcut -= 1\n            if lastcut == 0:\n                res += 1\n                lastcut = cnt\n                cnt = 0\n        cnt += 1\n    print(res)", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    depth = 0\n    prev = 1\n    parents = [a[1]]\n    heights = dict()\n    k = 0\n    heights[a[1]] = 1\n    cur_mx = a[1]\n    for i in range(2, n):\n        if a[i] < cur_mx:\n            heights[a[i]] = heights[parents[k]] + 1\n            k += 1\n            cur_mx = a[i]\n        else:\n            heights[a[i]] = heights[parents[k]]\n            cur_mx = a[i]\n        parents.append(a[i])\n    print(max(heights.values()))\nt = int(input())\nfor i in range(t):\n    main()", "t = int(input())\nfor case in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    last = 1\n    prev_children = 1\n    children = 0\n    h = 1\n    for i in range(1, n):\n        cur = a[i]\n        if cur > last:\n            children += 1\n        else:\n            prev_children -= 1\n            if prev_children == 0:\n                h += 1\n                prev_children = children\n                children = 0\n            children += 1\n        last = cur\n    print(h)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    cur = 1\n    res = 0\n    ans = 0\n    for i in range(1, n):\n        if i != 1 and l[i] > l[i - 1]:\n            cur += 1\n        elif res > 0:\n            res -= 1\n            cur += 1\n        else:\n            ans += 1\n            res = cur\n            cur = 1\n            res -= 1\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (c, p, q) = (1, 0, 0)\n    for j in range(1, n):\n        if a[j] > a[j - 1]:\n            p = p + 1\n        elif q == 0:\n            c = c + 1\n            q = p - 1\n        else:\n            q = q - 1\n    print(c)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    p = 0\n    levelCompleted = 0\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            p += 1\n        elif levelCompleted == 0:\n            ans += 1\n            levelCompleted = p - 1\n        else:\n            levelCompleted = levelCompleted - 1\n    print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    a = [0] + [int(i) for i in input().split()] + [0, 0, 0, 0, 0]\n    res = 1\n    f = 1\n    cnt = 1\n    for i in range(3, n + 1):\n        if a[i] < a[i - 1]:\n            f -= 1\n            if f == 0:\n                res += 1\n                f = cnt\n                cnt = 0\n        cnt += 1\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 1\n    p = 0\n    levelCompleted = 0\n    for i in range(1, n):\n        if a[i - 1] < a[i]:\n            p += 1\n        elif levelCompleted == 0:\n            ans += 1\n            levelCompleted = p - 1\n        else:\n            levelCompleted = levelCompleted - 1\n    print(ans)", "for df in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    s.pop(0)\n    a = 1\n    c = 1\n    x = 1\n    for i in range(n - 2):\n        if s[i] < s[i + 1]:\n            a += 1\n        else:\n            c -= 1\n            if c == 0:\n                x += 1\n                c = a\n                a = 1\n            else:\n                a += 1\n    print(x)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = [int(x) for x in input().split(' ')]\n    (height, max_slots, new_slots, cur_slot) = (1, 1, 0, 0)\n    for i in range(1, n):\n        if arr[i] >= arr[i - 1]:\n            new_slots += 1\n        else:\n            cur_slot += 1\n            if cur_slot < max_slots:\n                new_slots += 1\n            else:\n                height += 1\n                cur_slot = 0\n                max_slots = new_slots\n                new_slots = 1\n    print(height)", "import sys\nfrom bisect import bisect_left\nt = int(sys.stdin.readline().strip())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    dis = [0 for i in range(n)]\n    idx = 0\n    for j in range(1, n):\n        if a[j] < a[j - 1]:\n            idx += 1\n        dis[j] = dis[idx] + 1\n    print(dis[n - 1])", "for cnt in range(int(input())):\n    n = int(input())\n    t = list(map(int, input().split()))\n    res = 1\n    pcnt = 1\n    ccnt = 0\n    for i in range(1, n - 1):\n        ccnt += 1\n        if t[i] >= t[i + 1]:\n            pcnt -= 1\n            if pcnt == 0:\n                pcnt = ccnt\n                ccnt = 0\n                res += 1\n    print(res)", "import sys\nimport math, bisect\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef neo():\n    return map(int, sys.stdin.readline().split())\n\ndef Neo():\n    return list(map(int, sys.stdin.readline().split()))\nfor _ in range(I()):\n    n = I()\n    a = Neo()\n    up = 1\n    ans = 1\n    temp = 1\n    for i in range(2, n):\n        if a[i] > a[i - 1]:\n            temp += 1\n        else:\n            up -= 1\n            if up > 0:\n                temp += 1\n            else:\n                ans += 1\n                up = temp\n                temp = 1\n    print(ans)", "t = int(input())\nwhile t:\n    n = int(input())\n    s = list(map(int, input().split()))\n    height = 1\n    prvl = 1\n    level = 0\n    for i in range(1, len(s) - 1):\n        level += 1\n        if s[i] > s[i + 1]:\n            prvl -= 1\n        if prvl == 0:\n            height += 1\n            prvl = level\n            level = 0\n    print(height)\n    t -= 1", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    (current_parent, last_children, *nodes) = list(map(int, input().split()))\n    max_height = 1\n    current_height = 1\n    parents = [(last_children, 2)]\n    for node in nodes:\n        if node < last_children:\n            (current_parent, current_height) = parents.pop(0)\n            if current_height > max_height:\n                max_height = current_height\n        last_children = node\n        parents.append((node, current_height + 1))\n    print(max_height)", "import sys\ninput = sys.stdin.readline\n\ndef I():\n    return input().strip()\n\ndef II():\n    return int(input().strip())\n\ndef LI():\n    return [*map(int, input().strip().split())]\nimport string, math, time, functools, random, fractions\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict, Counter, OrderedDict\nfrom itertools import permutations, combinations, groupby\nfor _ in range(II()):\n    n = II()\n    l = LI()\n    ans = 1\n    prevcnt = 1\n    cnt = 0\n    for i in range(1, n - 1):\n        cnt += 1\n        if l[i + 1] < l[i]:\n            if prevcnt > 1:\n                prevcnt -= 1\n            else:\n                ans += 1\n                prevcnt = cnt\n                cnt = 0\n    print(ans)", "def solve(n, a):\n    b = [0] * n\n    b[0] = 1\n    m = 1\n    l = 1\n    while l < n:\n        k = b[m - 1]\n        b[m] = 0\n        while k > 0:\n            k -= 1\n            if l == n:\n                continue\n            l += 1\n            b[m] += 1\n            while l < n and a[l] > a[l - 1]:\n                l += 1\n                b[m] += 1\n        m += 1\n    return m - 1\nt = int(input())\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n    t -= 1", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    ordem = [int(a) for a in input().split()]\n    arvore = [1]\n    galho = 1\n    for j in range(2, n):\n        if ordem[j] > ordem[j - 1]:\n            arvore[-1] = arvore[-1] + 1\n        elif len(arvore) > 1 and galho < arvore[-2]:\n            galho = galho + 1\n            arvore[-1] = arvore[-1] + 1\n        else:\n            arvore.append(1)\n            galho = 1\n    print(len(arvore))", "tests = int(input())\nfor test in range(tests):\n    n = int(input())\n    a = list(map(int, input().split()))\n    res = 1\n    tails = 1\n    ntails = 0\n    i = 1\n    while i < n:\n        if tails == 0:\n            res += 1\n            tails = ntails\n            ntails = 0\n        while i + 1 < n and a[i] < a[i + 1]:\n            i += 1\n            ntails += 1\n        i += 1\n        ntails += 1\n        tails -= 1\n    print(res)", "input = __import__('sys').stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        ans = 1\n        level = {}\n        i = 1\n        k = 1\n        while i < n:\n            if a[i] > a[i - 1]:\n                if k + 1 in level:\n                    level[k + 1] += 1\n                elif k in level:\n                    level[k] += 1\n                else:\n                    level[k] = 1\n            elif level[k]:\n                level[k] -= 1\n                if k + 1 in level:\n                    level[k + 1] += 1\n                else:\n                    level[k + 1] = 1\n            else:\n                k += 1\n                level[k + 1] = 1\n                level[k] -= 1\n            i += 1\n        print(max(level))", "from collections import deque\n\ndef solve(n, a):\n    ans = 0\n    cnt = 1\n    queue = deque()\n    queue.append(1)\n    idx = 1\n    x = 0\n    while queue:\n        x = 0\n        for i in range(cnt):\n            temp = queue.popleft()\n            prev = -1\n            while idx < n:\n                if a[idx] < prev:\n                    break\n                prev = a[idx]\n                queue.append(a[idx])\n                x += 1\n                idx += 1\n        cnt = x\n        if queue:\n            ans += 1\n    return ans\nt = int(input())\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n    t -= 1", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    (pre, new) = (1, 0)\n    i = 1\n    ct = 1\n    temp = 0\n    while i < n - 1:\n        if arr[i] > arr[i + 1]:\n            temp += 1\n            pre -= 1\n            if pre > 0:\n                new += temp\n            else:\n                pre = new + temp\n                new = 0\n                ct += 1\n            temp = 0\n        else:\n            temp += 1\n        i += 1\n    print(ct)", "a = int(input())\nfor i in range(a):\n    b = int(input())\n    arr = list(map(int, input().split()))\n    sarr = []\n    tans = 1\n    for i in range(2, len(arr)):\n        if arr[i] >= arr[i - 1]:\n            tans = tans + 1\n        else:\n            sarr.append(tans)\n            tans = 1\n    sarr.append(tans)\n    elem = 0\n    pelem = 1\n    sett = 0\n    ans = 0\n    for i in range(0, len(sarr)):\n        sett = sett + 1\n        elem = elem + sarr[i]\n        if sett == pelem:\n            ans = ans + 1\n            pelem = elem\n            elem = 0\n            sett = 0\n    if not elem == 0:\n        ans = ans + 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if n == 1:\n        print(0)\n    else:\n        ans = 1\n        level = {}\n        f = True\n        i = 1\n        k = 1\n        while i < n:\n            if a[i] > a[i - 1]:\n                if k + 1 in level:\n                    level[k + 1] += 1\n                elif k in level:\n                    level[k] += 1\n                else:\n                    level[k] = 1\n            elif level[k]:\n                level[k] -= 1\n                if k + 1 in level:\n                    level[k + 1] += 1\n                else:\n                    level[k + 1] = 1\n            else:\n                k += 1\n                level[k + 1] = 1\n                level[k] -= 1\n            i += 1\n        print(max(level))", "t = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    a = [int(_) for _ in input().strip().split()]\n    m = 1\n    i = 1\n    h = 0\n    while i < n:\n        j = i + 1\n        cur = 0\n        while j < n:\n            if a[j - 1] > a[j]:\n                cur += 1\n            if cur == m:\n                break\n            j += 1\n        m = j - i\n        i = j\n        h += 1\n    print(h)", "t = int(input())\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    (curr, f, j) = (1, 0, 1)\n    level = 0\n    while j < n:\n        cnt = 1\n        while j < n - 1 and a[j + 1] > a[j]:\n            cnt += 1\n            j += 1\n        f += cnt\n        curr -= 1\n        if curr != 0 and j == n - 1:\n            level += 1\n        if curr == 0:\n            curr = f\n            f = 0\n            level += 1\n        j += 1\n    print(level)\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.append(float('-inf'))\n    l = []\n    x = 1\n    for i in range(1, n):\n        if a[i] < a[i + 1]:\n            x += 1\n            continue\n        l.append(x)\n        x = 1\n    l.reverse()\n    x = l.pop()\n    h = 1\n    while len(l) > 0:\n        ans = 0\n        while x > 0 and len(l) > 0:\n            ans += l.pop()\n            x -= 1\n        h += 1\n        x = ans\n    print(h)", "for i in range(int(input())):\n    n = int(input())\n    d = [0] * n\n    dinh = list(map(int, input().split()))\n    queue = []\n    queue.append(0)\n    l = 1\n    r = 1\n    dinh.append(-1)\n    d[0] = 0\n    d[1] = 1\n    while dinh[r] != -1:\n        pgoc = queue.pop(0)\n        d[r] = d[pgoc] + 1\n        queue.append(r)\n        while dinh[r + 1] > dinh[r]:\n            r += 1\n            d[r] = d[pgoc] + 1\n            queue.append(r)\n        r += 1\n        l = r\n    print(d[n - 1])", "for _ in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    x = 1\n    newx = 1\n    ans = 0\n    i = 1\n    while i < n:\n        ans += 1\n        prev = 0\n        x = newx\n        newx = 0\n        while i < n and x:\n            x -= 1\n            prev = 0\n            while i < n and s[i] > prev:\n                prev = s[i]\n                i += 1\n                newx += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    k = []\n    i = 1\n    j = 2\n    while j < n:\n        if l[j] >= l[j - 1]:\n            j += 1\n        else:\n            k.append(j - i)\n            i = j\n            j += 1\n    k.append(j - i)\n    ans = 0\n    x = 1\n    s = 0\n    i = 0\n    j = 0\n    while j < len(k):\n        if j - i < x:\n            s += k[j]\n            j += 1\n        else:\n            ans += 1\n            x = s\n            s = 0\n            i = j\n    ans += 1\n    print(ans)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    a = list(map(int, input().split()))\n    grafo = [1, 1]\n    i = 2\n    j = 1\n    while i < n:\n        filho = a[i - 1]\n        if a[i] < filho:\n            grafo.append(1)\n            j += 1\n        else:\n            grafo[j] += 1\n        i += 1\n    i = 0\n    s = 0\n    lim = 1\n    prof = 0\n    while i < j:\n        if i + lim <= j:\n            for k in range(i, i + lim):\n                s += grafo[k]\n            prof += 1\n        i += lim\n        lim = s\n        s = 0\n    print(prof)\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    psize = 1\n    csize = 0\n    h = 0\n    i = 1\n    q = []\n    q.append(a[0])\n    while len(q) != 0:\n        s = len(q)\n        for p in range(s):\n            del q[0]\n            if i < n:\n                q.append(a[i])\n                i += 1\n            while i < n and a[i] > a[i - 1]:\n                q.append(a[i])\n                i += 1\n        if i == n:\n            break\n        h += 1\n    print(h + 1)", "for _ in range(int(input())):\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    q = [[0, 0]]\n    curr = 1\n    while len(q) != 0:\n        (a, b) = q.pop(0)\n        if a == n - 1:\n            print(b)\n            break\n        prev = -1\n        while curr < n and arr[curr] > prev:\n            q.append([curr, b + 1])\n            prev = arr[curr]\n            curr += 1\n        if curr == n:\n            print(b + 1)\n            break", "from collections import deque\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {}\n    d[0] = 1\n    i = 1\n    while i < n:\n        tmp = i\n        d[tmp] = 1\n        i += 1\n        while i < n and a[i] > a[i - 1]:\n            i += 1\n            d[tmp] += 1\n    ans = 0\n    i = 0\n    sz = 0\n    lst = [(k, v) for (k, v) in d.items()]\n    lst.sort()\n    ptr = 0\n    tmp_sz = 1\n    sizes = []\n    while ptr < len(lst):\n        sz = tmp_sz\n        tmp_sz = 0\n        for j in range(sz):\n            if ptr >= len(lst):\n                break\n            tmp_sz += lst[ptr][1]\n            ptr += 1\n        sizes.append(tmp_sz)\n    print(len(sizes) - 1)", "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(99999)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = collections.deque(map(int, input().split()))\n    arr.popleft()\n    level = 0\n    cnt = 1\n    while arr:\n        nc = 0\n        for i in range(cnt):\n            p = float('-inf')\n            if arr:\n                while arr and arr[0] > p:\n                    p = arr.popleft()\n                    nc += 1\n            else:\n                break\n        cnt = nc\n        level += 1\n    print(level)", "for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    nodes = dict()\n    currentNode = 0\n    nodes[1] = [0, set()]\n    for i in range(len(arr) - 1):\n        if arr[i + 1] > arr[i]:\n            nodes[arr[i + 1]] = [nodes[arr[currentNode]][0] + 1, set()]\n            nodes[arr[currentNode]][1].add(arr[i])\n        else:\n            currentNode += 1\n            nodes[arr[i + 1]] = [nodes[arr[currentNode]][0] + 1, set()]\n            nodes[arr[currentNode]][1].add(arr[i])\n    ans = 0\n    for node in nodes:\n        if nodes[node][0] > ans:\n            ans = nodes[node][0]\n    print(ans)", "t = int(input())\nfor j in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    nodes = dict()\n    currentNode = 0\n    nodes[1] = [0, set()]\n    for i in range(len(arr) - 1):\n        if arr[i + 1] > arr[i]:\n            nodes[arr[i + 1]] = [nodes[arr[currentNode]][0] + 1, set()]\n            nodes[arr[currentNode]][1].add(arr[i])\n        else:\n            currentNode += 1\n            nodes[arr[i + 1]] = [nodes[arr[currentNode]][0] + 1, set()]\n            nodes[arr[currentNode]][1].add(arr[i])\n    ans = 0\n    for node in nodes:\n        if nodes[node][0] > ans:\n            ans = nodes[node][0]\n    print(ans)", "N = 200005\n\ndef solve(n, a):\n    b = [0] * N\n    b[0] = 1\n    m = 1\n    l = 1\n    while l < n:\n        k = b[m - 1]\n        b[m] = 0\n        while k > 0:\n            k -= 1\n            if l == n:\n                continue\n            l += 1\n            b[m] += 1\n            while l < n and a[l] > a[l - 1]:\n                l += 1\n                b[m] += 1\n        m += 1\n    return m - 1\nt = int(input())\nwhile t:\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n    t -= 1", "t = int(input())\nfor _ in range(0, t):\n    n = int(input())\n    ls = list(map(int, input().split()))\n    count = 1\n    f = 0\n    ch = 0\n    level = [0] * 200000\n    index = 0\n    for i in range(1, n):\n        if ls[i - 1] > ls[i]:\n            if level[index] - 1 < 0:\n                index += 1\n            level[index] -= 1\n        level[index + 1] += 1\n    print(index + 1)", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 9)\nfrom copy import deepcopy\n\ndef maxH(curr, adjacent_arr):\n    global memo\n    if curr in memo:\n        return memo[curr]\n    adjacent_nodes = adjacent_arr[curr]\n    ans = -float('inf')\n    if len(adjacent_nodes) == 0:\n        return 0\n    for node in adjacent_nodes:\n        curr_ans = 1 + maxH(node, adjacent_arr)\n        ans = max(ans, curr_ans)\n    memo[curr] = ans\n    return ans\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    bfs = list(map(int, input().strip().split()))\n    adjacent_arr = [[] for i in range(n + 1)]\n    prev = [bfs[0], 0]\n    root = [bfs[0], 0]\n    n = len(bfs)\n    memo = {}\n    queue = deque()\n    level = 0\n    max_level = 0\n    for i in range(1, n):\n        if bfs[i] > prev[0]:\n            adjacent_arr[root[0]].append(bfs[i])\n            curr_prev = [bfs[i], root[1] + 1]\n            prev = deepcopy(curr_prev)\n            max_level = max(prev[1], max_level)\n            queue.append(curr_prev)\n        else:\n            root = queue.popleft()\n            adjacent_arr[root[0]].append(bfs[i])\n            curr_prev = [bfs[i], root[1] + 1]\n            prev = deepcopy(curr_prev)\n            queue.append(curr_prev)\n            max_level = max(prev[1], max_level)\n    print(max_level)", "from collections import defaultdict\nfrom queue import PriorityQueue, Queue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = Queue()\n    level = [0] * (n + 1)\n    q.put(1)\n    i = 1\n    while i < n:\n        x = q.get()\n        j = i + 1\n        q.put(a[i])\n        level[a[i]] = level[x] + 1\n        while j < n and a[j] > a[j - 1]:\n            level[a[j]] = level[x] + 1\n            q.put(a[j])\n            j += 1\n        i = j\n    print(max(level))", "from queue import Queue\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input().split()\n    depth = [0]\n    for i in range(n):\n        depth.append(0)\n        a[i] = int(a[i])\n    q = Queue()\n    ans = 0\n    bap = 1\n    depth[1] = 0\n    for i in range(1, n):\n        depth[a[i]] = depth[bap] + 1\n        ans = max(ans, depth[a[i]])\n        q.put(a[i])\n        if i + 1 < n and a[i] > a[i + 1]:\n            bap = q.get()\n    print(ans)", "from queue import Queue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    (profundidade, indice, qtd_nos) = (0, 1, 1)\n    q = Queue()\n    q.put(1)\n    while not q.empty():\n        nos_proximo_nivel = 0\n        for i in range(qtd_nos):\n            q.get()\n            atual = -1\n            while indice < n:\n                if a[indice] < atual:\n                    break\n                atual = a[indice]\n                q.put(a[indice])\n                indice += 1\n                nos_proximo_nivel += 1\n        qtd_nos = nos_proximo_nivel\n        if q.qsize():\n            profundidade += 1\n    print(profundidade)", "from queue import Queue\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = input().split()\n    for i in range(n):\n        a[i] = int(a[i])\n    q = Queue()\n    depth = {1: 0}\n    ans = 0\n    bap = 1\n    for i in range(1, n):\n        depth[a[i]] = depth[bap] + 1\n        ans = max(ans, depth[a[i]])\n        q.put(a[i])\n        if i + 1 < n and a[i] > a[i + 1]:\n            bap = q.get()\n    print(ans)"]