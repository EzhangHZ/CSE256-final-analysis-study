["import itertools\n\ndef is_digraph(edges):\n    n = len(edges)\n    color = [None] * n\n    color[0] = 1\n    q = [0]\n    while q:\n        pos = q.pop()\n        c = 1 - color[pos]\n        for nxt in edges[pos]:\n            if color[nxt] is None:\n                color[nxt] = c\n                q.append(nxt)\n            elif color[nxt] != c:\n                return (False, None)\n    return (True, color)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    v = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    edges = [list() for __ in range(n)]\n    parity = 0\n    for __ in range(m):\n        (i, j) = map(int, input().split())\n        i -= 1\n        j -= 1\n        edges[i].append(j)\n        edges[j].append(i)\n    for x in itertools.chain(v, t):\n        parity ^= x & 1\n    if parity:\n        print('NO')\n        return\n    (di, colors) = is_digraph(edges)\n    if not di:\n        print('YES')\n    else:\n        sums = [0, 0]\n        for (i, c) in enumerate(colors):\n            sums[c] += t[i] - v[i]\n        (a, b) = sums\n        print('YES') if a == b else print('NO')\nfor testcases in range(int(input())):\n    solve()", "import itertools\n\ndef is_digraph(edges):\n    n = len(edges)\n    color = [None] * n\n    color[0] = 1\n    q = [0]\n    while q:\n        pos = q.pop()\n        c = 1 - color[pos]\n        for nxt in edges[pos]:\n            if color[nxt] is None:\n                color[nxt] = c\n                q.append(nxt)\n            elif color[nxt] != c:\n                return (False, None)\n    return (True, color)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    v = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    edges = [list() for __ in range(n)]\n    for __ in range(m):\n        (i, j) = map(int, input().split())\n        i -= 1\n        j -= 1\n        edges[i].append(j)\n        edges[j].append(i)\n    parity = 0\n    for x in itertools.chain(v, t):\n        parity ^= x & 1\n    if parity:\n        print('NO')\n        return\n    (di, colors) = is_digraph(edges)\n    if not di:\n        print('YES')\n    else:\n        sums = [0, 0]\n        for (i, c) in enumerate(colors):\n            sums[c] += t[i] - v[i]\n        (a, b) = sums\n        print('YES') if a == b else print('NO')\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve()\nmain()", "import itertools\n\ndef is_digraph(edges):\n    n = len(edges)\n    color = [None] * n\n    color[0] = 1\n    q = [0]\n    while q:\n        pos = q.pop()\n        c = 1 - color[pos]\n        for nxt in edges[pos]:\n            if color[nxt] is None:\n                color[nxt] = c\n                q.append(nxt)\n            elif color[nxt] != c:\n                return (False, None)\n    return (True, color)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    v = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    edges = [list() for __ in range(n)]\n    parity = 0\n    for __ in range(m):\n        (i, j) = map(int, input().split())\n        i -= 1\n        j -= 1\n        edges[i].append(j)\n        edges[j].append(i)\n    for x in itertools.chain(v, t):\n        parity ^= x & 1\n    if parity:\n        print('NO')\n        return\n    (di, colors) = is_digraph(edges)\n    if not di:\n        print('YES')\n    else:\n        sums = [0, 0]\n        for (i, c) in enumerate(colors):\n            sums[c] += t[i] - v[i]\n        (a, b) = sums\n        print('YES') if a == b else print('NO')\nfor testcases in range(int(input())):\n    solve()", "import itertools\n\ndef readline():\n    return map(int, input().split())\n\ndef is_digraph(edges):\n    n = len(edges)\n    color = [None] * n\n    color[0] = 1\n    q = [0]\n    while q:\n        pos = q.pop()\n        c = 1 - color[pos]\n        for nxt in edges[pos]:\n            if color[nxt] is None:\n                color[nxt] = c\n                q.append(nxt)\n            elif color[nxt] != c:\n                return (False, None)\n    return (True, color)\n\ndef solve():\n    (n, m) = readline()\n    v = list(readline())\n    t = list(readline())\n    edges = [list() for __ in range(n)]\n    for __ in range(m):\n        (i, j) = readline()\n        i -= 1\n        j -= 1\n        edges[i].append(j)\n        edges[j].append(i)\n    parity = 0\n    for x in itertools.chain(v, t):\n        parity ^= x & 1\n    if parity:\n        print('NO')\n        return\n    (di, colors) = is_digraph(edges)\n    if not di:\n        print('YES')\n    else:\n        sums = [0, 0]\n        for (i, c) in enumerate(colors):\n            sums[c] += t[i] - v[i]\n        (a, b) = sums\n        if a == b:\n            print('YES')\n        else:\n            print('NO')\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve()\nmain()", "def isTwoColorable(gr, n, cols):\n    cols[1] = 0\n    (qu, ind) = ([1], 0)\n    isBip = True\n    while ind < len(qu):\n        node = qu[ind]\n        ind += 1\n        for cnode in gr[node]:\n            if cols[cnode] == -1:\n                cols[cnode] = cols[node] ^ 1\n                qu.append(cnode)\n            else:\n                isBip &= cols[cnode] != cols[node]\n    return isBip\n\ndef solve(gr, n, v, t):\n    if sum(v) % 2 != sum(t) % 2:\n        return 'NO'\n    cols = [-1] * (n + 1)\n    if isTwoColorable(gr, n, cols):\n        gsm = [0, 0]\n        for i in range(1, n + 1):\n            gsm[cols[i]] += t[i - 1] - v[i - 1]\n        if gsm[0] == gsm[1]:\n            return 'YES'\n        return 'NO'\n    return 'YES'\nfor case in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    gr = [[] for i in range(n + 1)]\n    for ed in range(m):\n        (u, v) = list(map(int, input().split()))\n        gr[u].append(v)\n        gr[v].append(u)\n    ans = solve(gr, n, V, T)\n    print(ans)", "def isTwoColorable(gr, n, cols):\n    cols[1] = 0\n    (qu, ind) = ([1], 0)\n    isBip = True\n    while ind < len(qu):\n        node = qu[ind]\n        ind += 1\n        for cnode in gr[node]:\n            if cols[cnode] == -1:\n                cols[cnode] = cols[node] ^ 1\n                qu.append(cnode)\n            else:\n                isBip &= cols[cnode] != cols[node]\n    return isBip\n\ndef solve(gr, n, v, t):\n    if sum(v) % 2 != sum(t) % 2:\n        return 'NO'\n    cols = [-1] * (n + 1)\n    if isTwoColorable(gr, n, cols):\n        gsm = [0, 0]\n        for i in range(1, n + 1):\n            gsm[cols[i]] += t[i - 1] - v[i - 1]\n        if gsm[0] == gsm[1]:\n            return 'YES'\n        return 'NO'\n    return 'YES'\nfor case in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    gr = [[] for i in range(n + 1)]\n    for ed in range(m):\n        (u, v) = list(map(int, input().split()))\n        gr[u].append(v)\n        gr[v].append(u)\n    ans = solve(gr, n, V, T)\n    print(ans)", "for test in range(int(input())):\n    (n, m) = map(int, input().split())\n    lv = [int(i) for i in input().split()]\n    t = [int(i) for i in input().split()]\n    lv.insert(0, 0)\n    t.insert(0, 0)\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (U, V) = map(int, input().split())\n        g[U].append(V)\n        g[V].append(U)\n    color = [-1] * (n + 1)\n    two_set = 1\n    L = int(0)\n    R = int(0)\n    color[1] = 0\n    q = [0, 1]\n    while q:\n        u = q.pop()\n        if color[u]:\n            L += lv[u] - t[u]\n        else:\n            R += lv[u] - t[u]\n        for v in g[u]:\n            if color[v] == -1:\n                color[v] = color[u] ^ 1\n                q.append(v)\n            elif color[u] == color[v]:\n                two_set = 0\n    res = 1\n    if two_set:\n        res &= L == R\n    else:\n        res &= L + R & 1 == 0\n    if res:\n        print('YES')\n    else:\n        print('NO')", "def chbi(adj, c):\n    c[0] = 1\n    q = [0]\n    while q:\n        i = q.pop()\n        for j in range(len(adj[i])):\n            n = adj[i][j]\n            if c[n] == -1:\n                c[n] = 1 - c[i]\n                q.append(n)\n            elif c[n] == c[i]:\n                return False\n    return True\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    v = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    c = [-1] * n\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    if (sum(v) - sum(t)) % 2 != 0:\n        print('NO')\n    elif chbi(adj, c):\n        s1 = s2 = 0\n        for i in range(n):\n            if c[i] == 0:\n                s1 += t[i] - v[i]\n            else:\n                s2 += t[i] - v[i]\n        if s1 != s2:\n            print('NO')\n        else:\n            print('YES')\n    else:\n        print('YES')", "def chbi(adj, c):\n    c[0] = 1\n    q = [0]\n    while q:\n        i = q.pop()\n        for j in range(len(adj[i])):\n            n = adj[i][j]\n            if c[n] == -1:\n                c[n] = 1 - c[i]\n                q.append(n)\n            elif c[n] == c[i]:\n                return False\n    return True\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    v = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    c = [-1] * n\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    if (sum(v) - sum(t)) % 2 != 0:\n        print('NO')\n    elif chbi(adj, c):\n        s1 = s2 = 0\n        for i in range(n):\n            if c[i] == 0:\n                s1 += t[i] - v[i]\n            else:\n                s2 += t[i] - v[i]\n        if s1 != s2:\n            print('NO')\n        else:\n            print('YES')\n    else:\n        print('YES')", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    v = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    d = [t[i] - v[i] for i in range(n)]\n    edge = []\n    x = [-1] * n\n    for _ in range(n):\n        edge.append([])\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    if sum(d) % 2 != 0:\n        print('NO')\n    else:\n        isbgph = 0\n        x[0] = 0\n        p = [0]\n        while len(p) > 0:\n            i = p.pop()\n            for nxt in edge[i]:\n                if x[nxt] == -1:\n                    x[nxt] = 1 - x[i]\n                    p.append(nxt)\n                elif x[nxt] == x[i]:\n                    isbgph = 1\n        if isbgph == 1:\n            print('YES')\n        else:\n            sum1 = sum([d[i] for i in range(n) if x[i] == 0])\n            sum2 = sum([d[i] for i in range(n) if x[i] == 1])\n            if sum1 == sum2:\n                print('YES')\n            else:\n                print('NO')"]