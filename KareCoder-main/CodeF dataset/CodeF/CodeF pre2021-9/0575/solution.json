["import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    m = 10 ** 9 + 7\n    val = pow(2, n - 1, m)\n    if n % 2:\n        val += 1\n        val %= m\n        return pow(val, k, m)\n    else:\n        R = pow(val + 1, m - 2, m)\n        ans = (pow(2, n * k, m) - pow(val - 1, k, m)) % m * R % m\n        ans += pow(val - 1, k, m)\n        ans %= m\n        return ans\nfor _ in range(int(input())):\n    print(solve())", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    mod = 1000000007\n    K = pow(2, n - 1, mod)\n    if n & 1:\n        ans = pow(K + 1, k, mod)\n    else:\n        R = pow(K + 1, mod - 2, mod)\n        s = (pow(2, n * k, mod) - pow(K - 1, k, mod)) % mod * R % mod\n        s += pow(K - 1, k, mod)\n        ans = s % mod\n    print(ans)", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "P = 10 ** 9 + 7\nQ = P - 1\ni2 = 1 + P >> 1\nT = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    if n % 2:\n        print(pow(pow(2, n - 1, P) + 1, k, P))\n    else:\n        i2n = pow(i2, n, P)\n        p2n1 = pow(2, n - 1, P) - 1\n        print((pow(2, n * (k - 1) % Q, P) * (1 - pow(p2n1 * i2n, k, P)) % P * pow((1 - p2n1 * i2n) % P, P - 2, P) + pow(p2n1, k, P)) % P)", "MOD = 10 ** 9 + 7\n\ndef f(n, k):\n    good = n - 1 & 1\n    maybe = (pow(2, n - 1, MOD) + 1 - 2 * good) % MOD\n    all_ = pow(2, n, MOD)\n    return (good * (pow(all_, k, MOD) - pow(maybe, k, MOD)) * pow(all_ - maybe, MOD - 2, MOD) + pow(maybe, k, MOD)) % MOD\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    print(f(n, k))", "for s in [*open(0)][1:]:\n    M = 10 ** 9 + 7\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, M)\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "MODULO = 1000000007\n\ndef calc(n, k):\n    K = pow(2, n - 1, MODULO)\n    if n & 1:\n        return pow(K + 1, k, MODULO)\n    else:\n        R = pow(K + 1, MODULO - 2, MODULO)\n        s = (pow(2, n * k, MODULO) - pow(K - 1, k, MODULO)) % MODULO * R % MODULO\n        s += pow(K - 1, k, MODULO)\n        return s % MODULO\nfor i in range(int(input())):\n    (n, k) = input().split()\n    print(calc(int(n), int(k)))", "MOD = 10 ** 9 + 7\n\ndef f(n, k):\n    good = n - 1 & 1\n    maybe = (pow(2, n - 1, MOD) + 1 - 2 * good) % MOD\n    all_ = pow(2, n, MOD)\n    return (good * (pow(all_, k, MOD) - pow(maybe, k, MOD)) * pow(all_ - maybe, MOD - 2, MOD) + pow(maybe, k, MOD)) % MOD\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    print(f(n, k))", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    mod = 1000000007\n    K = pow(2, n - 1, mod)\n    if n & 1:\n        ans = pow(K + 1, k, mod)\n    else:\n        R = pow(K + 1, mod - 2, mod)\n        s = (pow(2, n * k, mod) - pow(K - 1, k, mod)) % mod * R % mod\n        s += pow(K - 1, k, mod)\n        ans = s % mod\n    print(ans)", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "t = int(input())\nmod = 1000000007\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    K = pow(2, n - 1, mod)\n    if n & 1:\n        ans = pow(K + 1, k, mod)\n    else:\n        R = pow(K + 1, mod - 2, mod)\n        s = (pow(2, n * k, mod) - pow(K - 1, k, mod)) % mod * R % mod\n        s += pow(K - 1, k, mod)\n        ans = s % mod\n    print(ans)", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "for s in [*open(0)][1:]:\n    P = pow\n    (n, k) = map(int, s.split())\n    p = P(2, n - 1, (M := (10 ** 9 + 7)))\n    print([(P(2 * p, k, M) + p * P(~-p, k, M)) * P(p + 1, -1, M) % M, P(p + 1, k, M)][n & 1])", "import math\nimport heapq\nimport string\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\nS = lambda : input()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nfor _ in range(I()):\n    (n, k) = M()\n    s = 0\n    if n % 2 == 1:\n        s = pow(pow(2, n - 1, H) + 1, k, H)\n    else:\n        d = (pow(2, n - 1, H) - 1) % H\n        p = pow(2, n, H) * pow(d, -1, H) % H\n        z = pow(d, k - 1, H)\n        m = pow(p, k, H) - 1\n        q = p - 1\n        s = m % H * pow(q, -1, H) * z\n        s += pow(d, k, H)\n    print(s % H)", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    mod = 1000000007\n    K = pow(2, n - 1, mod)\n    if n & 1:\n        ans = pow(K + 1, k, mod)\n    else:\n        R = pow(K + 1, mod - 2, mod)\n        s = (pow(2, n * k, mod) - pow(K - 1, k, mod)) % mod * R % mod\n        s += pow(K - 1, k, mod)\n        ans = s % mod\n    print(ans)", "def func():\n    t = int(input().strip())\n    cases = []\n    for _ in range(t):\n        (n, k) = map(int, input().strip().split())\n        cases.append((n, k))\n    for case in cases:\n        (n, k) = case\n        print(and_xor(n, k))\n\ndef and_xor(n, k):\n    mod = 1000000007\n    if n % 2:\n        ans = pow(2, n - 1, mod) + 1\n        return pow(ans, k, mod)\n    if k == 0:\n        return 1\n    tmp = pow(2, n - 1, mod) - 1\n    ans = tmp + 1\n    res = cnt = pow(2, n, mod)\n    for i in range(1, k):\n        ans = (ans * tmp % mod + res) % mod\n        res = res * cnt % mod\n        ans %= mod\n    return ans\nfunc()", "MOD = 1000000007\n\ndef solve(n, k):\n    if n % 2:\n        ks = pow(2, n - 1, MOD) + 1\n        return pow(ks, k, MOD)\n    else:\n        ks = pow(2, n - 1, MOD) - 1\n        if k == 0:\n            return 1\n        else:\n            ans = 1 + ks\n            cg = pow(2, n, MOD)\n            binn = cg\n            for i in range(1, k):\n                ans = (ans * ks % MOD + binn) % MOD\n                binn = binn * cg % MOD\n                ans %= MOD\n            return ans\nt = int(input())\nfor alskfjlakfja in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    print(solve(n, k))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    mod = int(1000000000.0 + 7)\n    p = pow(2, n - 1, mod)\n    b = 1\n    c = 1\n    if n % 2 == 0:\n        b = p\n    else:\n        b = p + 1\n    m = 2 * p % mod\n    for i in range(2, k + 1):\n        c = c * m % mod\n        if n % 2 == 0:\n            b = (c + (p - 1) * b) % mod\n        else:\n            b = (p + 1) * b % mod\n    if k == 0:\n        print(1)\n    else:\n        print(b)", "t = int(input())\nfor i in range(t):\n    [n, k] = [int(x) for x in input().split()]\n    p = 10 ** 9 + 7\n    pow2 = pow(2, n - 1, p)\n    prev = 1\n    if n % 2 == 0:\n        prev = pow2\n    else:\n        prev = pow2 + 1\n    z = 1\n    mu = 2 * pow2 % p\n    for h in range(2, k + 1):\n        z = z * mu % p\n        if n % 2 == 0:\n            prev = (z + (pow2 - 1) * prev % p) % p\n        else:\n            prev = (pow2 + 1) * prev % p\n    if k == 0:\n        print(1)\n    else:\n        print(prev % p)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    tmp1 = 2 ** (n - 1) % 1000000007\n    tmp2 = 1\n    ans = 0\n    if k == 0:\n        ans = 1\n    elif k >= 1:\n        if n % 2 == 0:\n            ans = 2 ** (n - 1) % 1000000007\n        else:\n            ans = (2 ** (n - 1) + 1) % 1000000007\n    for i in range(2, k + 1):\n        tmp2 = tmp2 * tmp1 * 2 % 1000000007\n        if n % 2 == 0:\n            ans = (tmp2 + (tmp1 - 1) * ans) % 1000000007\n        else:\n            ans = (tmp1 + 1) * ans % 1000000007\n    if n == 1:\n        ans = 2 ** k % 1000000007\n    print(ans)", "T = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    p = 10 ** 9 + 7\n    if n & 1 == 1:\n        answer = pow(pow(2, n - 1, p) + 1, k, p)\n    else:\n        answer = 1\n        pow_ = 1\n        _2_n_1 = pow(2, n - 1, p)\n        for i in range(k):\n            answer = answer * (_2_n_1 - 1) % p\n            answer = (answer + pow_) % p\n            pow_ = pow_ * _2_n_1 * 2 % p\n    print(answer)", "mod = 1000000007\nT = int(input())\nfpow = pow\nfor i in range(T):\n    ans = 1\n    (n, k) = map(int, input().split())\n    if n % 2 != 0:\n        ans = fpow(2, n - 1, mod) + 1\n        ans = fpow(ans, k, mod)\n    else:\n        ans = 1\n        pow_ = 1\n        _2_n_1 = pow(2, n - 1, mod)\n        for i in range(k):\n            ans = ans * (_2_n_1 - 1) % mod\n            ans = (ans + pow_) % mod\n            pow_ = pow_ * _2_n_1 * 2 % mod\n    print(ans)", "t = int(input())\nfor i in range(t):\n    [n, k] = [int(x) for x in input().split()]\n    p = 10 ** 9 + 7\n    pow2 = pow(2, n - 1, p)\n    prev = 1\n    if n % 2 == 0:\n        prev = pow2\n    else:\n        prev = pow2 + 1\n    z = 1\n    mu = 2 * pow2 % p\n    for h in range(2, k + 1):\n        z = z * mu % p\n        if n % 2 == 0:\n            prev = (z + (pow2 - 1) * prev % p) % p\n        else:\n            prev = (pow2 + 1) * prev % p\n    if k == 0:\n        print(1)\n    else:\n        print(prev % p)", "def power(a, n):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % 1000000007\n        a = a * a % 1000000007\n        n >>= 1\n    return res\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k == 0:\n        print(1)\n        continue\n    poww = power(2, n - 1)\n    if n % 2:\n        print(power(poww + 1, k) % 1000000007)\n    else:\n        x = poww\n        ans = x\n        y = 2 * x\n        MOD = 1000000007\n        x -= 1\n        for i in range(1, k):\n            ans = (ans * x % MOD + y % MOD) % 1000000007\n            y = y * 2 * (x + 1) % MOD\n        print(ans)", "MOD = 1000000007\n\ndef power(a, n):\n    res = 1\n    while n > 0:\n        if n & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        n >>= 1\n    return res\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    if k == 0:\n        print(1)\n        continue\n    poww = power(2, n - 1)\n    if n % 2:\n        print(power(poww + 1, k) % MOD)\n    else:\n        ans = poww\n        y = poww * 2\n        poww -= 1\n        for i in range(1, k):\n            ans = (ans * poww % MOD + y % MOD) % MOD\n            y = 2 * y * (poww + 1) % MOD\n        print(ans)", "t = int(input())\nmodval = int(1000000000.0 + 7)\nfor _ in range(t):\n    (n, k) = [int(x) for x in input().split(' ')]\n    if not k:\n        print('1')\n        continue\n    dp = [1 for _ in range(k + 1)]\n    ndigsequal = pow(2, n - 1, modval)\n    allopts = pow(2, n, modval)\n    st = 1\n    if n & 1:\n        isodd = True\n        ndigsequal += 1\n    else:\n        isodd = False\n        ndigsequal -= 1\n    for i in range(1, k + 1):\n        ans = ndigsequal * dp[i - 1]\n        ans %= modval\n        if not isodd:\n            ans += st\n            ans %= modval\n            st *= allopts\n            st %= modval\n        dp[i] = ans\n    print(dp[k])"]