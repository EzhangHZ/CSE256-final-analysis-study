["import sys\nimport re\n\ndef minp():\n    return sys.stdin.readline().strip()\n\ndef mint():\n    return int(minp())\n\ndef mints():\n    return map(int, minp().split())\n\ndef solve():\n    (n, h, m, k) = mints()\n    m //= 2\n    a = [0] * n\n    e = [None] * (2 * n + 2)\n    c = 0\n    for i in range(n):\n        (hh, mm) = mints()\n        x = mm % m\n        a[i] = mm\n        e[2 * i] = ((x + k) % m, -1, i)\n        e[2 * i + 1] = ((x + 1) % m, 1, i)\n        if (x + 1) % m > (x + k) % m:\n            c += 1\n    e[2 * n] = (0, 0, 0)\n    e[2 * n + 1] = (m - 1, 0, 0)\n    e.sort()\n    p = -1\n    r = (int(1000000000.0), 0)\n    for (x, t, id) in e:\n        if p != x and p != -1:\n            r = min(r, (c, p))\n        p = x\n        c += t\n    r = min(r, (c, p))\n    print(*r)\n    p = r[1]\n    for i in range(n):\n        mm = a[i]\n        x = (mm - p) % m\n        if (x + 1) % m > (x + k) % m and (x + k) % m != 0 or ((x + 1) % m < (x + k) % m and (x + 1) % m == 0):\n            print(i + 1, end=' ')\nsolve()", "(n, H, M, k) = map(int, input().split())\nhm = []\nfor i in range(n):\n    hm.append(list(map(int, input().split())))\nM2 = M // 2\nll = []\nrr = []\nst = {0, M2}\nfor (h, m) in hm:\n    s = (m + 1) % M2\n    ll.append(s)\n    rr.append(s + k - 1)\n    st.add(s)\n    st.add(s + M2)\n    st.add((s + k - 1) % M2)\n    st.add((s + k - 1) % M2 + M2)\ndec = list(sorted(st))\nenc = {a: i for (i, a) in enumerate(dec)}\nln = len(dec)\ntt = [0] * ln\nfor (l, r) in zip(ll, rr):\n    tt[enc[l]] += 1\n    tt[enc[r]] -= 1\nfor i in range(ln - 1):\n    tt[i + 1] += tt[i]\nfor i in range(ln // 2):\n    tt[i] += tt[i + ln // 2]\nmn = min(tt[:ln // 2])\ni = tt[:ln // 2].index(mn)\nt = dec[i]\nans = []\nfor (i, (l, r)) in enumerate(zip(ll, rr)):\n    if l <= t < r or l <= t + M2 < r:\n        ans.append(i + 1)\nprint(mn, t)\nprint(*ans)", "import sys\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n(n, H, M, k) = MI()\nhm = LLI(n)\nM2 = M // 2\nll = []\nrr = []\nst = set([0, M2])\nfor (h, m) in hm:\n    s = (m + 1) % M2\n    ll.append(s)\n    rr.append(s + k - 1)\n    st.add(s)\n    st.add(s + M2)\n    st.add((s + k - 1) % M2)\n    st.add((s + k - 1) % M2 + M2)\ndec = list(sorted(st))\nenc = {a: i for (i, a) in enumerate(dec)}\nln = len(dec)\ntt = [0] * ln\nfor (l, r) in zip(ll, rr):\n    tt[enc[l]] += 1\n    tt[enc[r]] -= 1\nfor i in range(ln - 1):\n    tt[i + 1] += tt[i]\nfor i in range(ln // 2):\n    tt[i] += tt[i + ln // 2]\nmn = min(tt[:ln // 2])\ni = tt[:ln // 2].index(mn)\nt = dec[i]\nans = []\nfor (i, (l, r)) in enumerate(zip(ll, rr)):\n    if l <= t < r or l <= t + M2 < r:\n        ans.append(i + 1)\nprint(mn, t)\nprint(*ans)"]