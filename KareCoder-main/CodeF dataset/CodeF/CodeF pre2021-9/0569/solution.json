["def ss(n, s):\n    if n == 1:\n        return 1\n    d = {}\n    i = 0\n    j = 0\n    ans = 0\n    while i < n:\n        while j + 1 < n and s[j] != s[j + 1]:\n            j += 1\n        if j >= n - 1:\n            i += 1\n            while i in d:\n                i += 1\n            i += 1\n            while i in d:\n                i += 1\n        else:\n            d[j] = 1\n            x = s[i]\n            i += 1\n            while i in d or (i < n and s[i] == x):\n                i += 1\n        ans += 1\n        j = max(i, j + 1)\n    return ans\nfor _ in range(int(input())):\n    n = int(input())\n    s = str(input())\n    print(ss(n, s))", "import math\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        s = input()\n        count = 1\n        ar = []\n        for i in range(n - 1):\n            if s[i + 1] == s[i]:\n                count += 1\n            else:\n                ar.append(count)\n                count = 1\n        if count > 0:\n            ar.append(count)\n        ct = 0\n        ans = 0\n        for i in ar:\n            if i > 1:\n                ct = max(0, ct - (i - 2))\n                ans += 1\n            else:\n                ans += 1\n                ct += 1\n        ans -= int(math.floor(ct / 2))\n        print(ans)\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    s = list(input())\n    rd = 0\n    id = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            rd = min(rd + 1, id)\n        else:\n            id += 1\n    print(rd + (id - rd + 1) // 2)", "import sys, math, bisect\ninf = float('inf')\nmod = inf + 7\n\ndef lcm(a, b):\n    return int(a / math.gcd(a, b) * b)\n\ndef gcd(a, b):\n    return int(math.gcd(a, b))\n\ndef binarySearch(a, x):\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    else:\n        return -1\n\ndef lowerBound(a, x):\n    i = bisect.bisect_left(a, x)\n    if i:\n        return i - 1\n    else:\n        return -1\n\ndef upperBound(a, x):\n    i = bisect.bisect_right(a, x)\n    if i != len(a) + 1 and a[i - 1] == x:\n        return i - 1\n    else:\n        return -1\n\ndef freq(a, x):\n    z = upperBound(a, x) - lowerBound(a, x)\n    if z <= 0:\n        return 0\n    return z\nfrom collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    ans = 0\n    c = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            ans += 1\n            ans = min(ans, c)\n        else:\n            c += 1\n    print(ans + (c - ans + 1) // 2)", "import sys\ninput = sys.stdin.readline\nfrom itertools import groupby\n\ndef HalfDead():\n    n = int(input())\n    s = input().strip()\n    a = [len(list(g)) for (_, g) in groupby(s)]\n    cnt = 0\n    for (i, v) in enumerate(a):\n        if v == 1:\n            cnt += 1\n        else:\n            r = v - 2\n            cnt = max(0, cnt - r)\n    print(len(a) - cnt // 2)\nfor _ in range(int(input())):\n    HalfDead()", "from collections import deque\nimport itertools as I\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    gps = enumerate(map(lambda x: len(list(x[1])), I.groupby(s)))\n    gps_more_than_one = deque(filter(lambda x: x[1] > 1, gps))\n    n_gps_ones = n - sum(map(lambda x: x[1], gps_more_than_one))\n    ops = 0\n    i = 0\n    while gps_more_than_one or n_gps_ones:\n        if gps_more_than_one:\n            gps_more_than_one[0] = (gps_more_than_one[0][0], gps_more_than_one[0][1] - 1)\n            if gps_more_than_one[0][0] == i or gps_more_than_one[0][1] == 1:\n                gps_more_than_one.popleft()\n                n_gps_ones += 1\n            n_gps_ones -= 1\n            i += 1\n        else:\n            n_gps_ones = max(0, n_gps_ones - 2)\n            i += 2\n        ops += 1\n    print(ops)", "import heapq\nimport collections\nfrom math import log2\nimport itertools\nfrom functools import lru_cache\nfrom sys import setrecursionlimit as srl\nsrl(2 * 10 ** 6)\nN = 200001\n\ndef solve(n, s):\n    segs = []\n    cur = '?'\n    val = 0\n    for x in s:\n        if x != cur:\n            if val:\n                segs.append(val)\n            val = 1\n            cur = x\n        else:\n            val += 1\n    if val:\n        segs.append(val)\n    total = 0\n    debt = 0\n    for x in segs:\n        total += x - 1\n    ans = 0\n    kill_nxt = 0\n    cnt_nxt = 0\n    for x in segs:\n        if kill_nxt:\n            if cnt_nxt:\n                ans += 1\n            cnt_nxt = cnt_nxt ^ 1\n            continue\n        ans += 1\n        x -= 1\n        if debt < total:\n            debt += 1\n        else:\n            kill_nxt = 1\n        debt -= min(debt, x)\n        total -= x\n    return ans\nt = int(input())\nfor tc in range(1, t + 1):\n    n = int(input())\n    s = input()\n    print(solve(n, s))", "import heapq\nimport collections\nfrom math import log2\nimport itertools\nfrom functools import lru_cache\nfrom sys import setrecursionlimit as srl\nsrl(2 * 10 ** 6)\nN = 200001\n\ndef solve(n, s):\n    total = 2\n    debt = 0\n    segs = []\n    val = 0\n    cur = '?'\n    for x in s:\n        if x != cur:\n            if val:\n                segs.append(val)\n            cur = x\n            val = 1\n        else:\n            val += 1\n    if val:\n        segs.append(val)\n    total = 0\n    debt = 0\n    for x in segs:\n        total += x - 1\n    kill = 0\n    cur = 0\n    ans = 0\n    for x in segs:\n        if kill:\n            if cur:\n                ans += 1\n            cur ^= 1\n            continue\n        ans += 1\n        x -= 1\n        if debt < total:\n            debt += 1\n        else:\n            kill = 1\n        debt -= min(x, debt)\n        total -= x\n    return ans\nt = int(input())\nfor _ in range(1, t + 1):\n    n = int(input())\n    s = input()\n    print(solve(n, s))", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    count = []\n    c = 0\n    last = s[0]\n    for i in range(n):\n        if s[i] == last:\n            c += 1\n        else:\n            last = s[i]\n            count.append(c)\n            c = 1\n    if c != 0:\n        count.append(c)\n    tot = []\n    for i in range(len(count)):\n        if count[i] > 1:\n            tot.append(i)\n    j = 0\n    ans = 0\n    i = 0\n    while i < len(count):\n        if j < len(tot):\n            count[tot[j]] -= 1\n            if count[tot[j]] == 1:\n                j += 1\n            elif i == tot[j]:\n                j += 1\n        else:\n            ans += (len(count) - i + 1) // 2\n            break\n        i += 1\n        ans += 1\n    print(ans)", "from collections import deque\nimport itertools as I\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    gps = enumerate(map(lambda x: len(list(x[1])), I.groupby(s)))\n    gps_more_than_one = deque(filter(lambda x: x[1] > 1, gps))\n    n_gps_ones = n - sum(map(lambda x: x[1], gps_more_than_one))\n    ops = 0\n    i = 0\n    while gps_more_than_one or n_gps_ones:\n        if gps_more_than_one:\n            gps_more_than_one[0] = (gps_more_than_one[0][0], gps_more_than_one[0][1] - 1)\n            if gps_more_than_one[0][0] == i:\n                gps_more_than_one.popleft()\n            elif gps_more_than_one[0][1] == 1:\n                gps_more_than_one.popleft()\n            else:\n                n_gps_ones -= 1\n            i += 1\n        else:\n            n_gps_ones = max(0, n_gps_ones - 2)\n            i += 2\n        ops += 1\n    print(ops)", "def main():\n    n = int(input())\n    line = input()\n    turn_take = []\n    prev = line[-1]\n    can_be = 0\n    for i in range(n - 2, -1, -1):\n        if line[i] == prev:\n            can_be += 1\n        else:\n            prev = line[i]\n            turn_take.append(can_be)\n    turn_take.append(can_be)\n    turns = len(turn_take)\n    taken = 0\n    res = 0\n    for i in range(1, turns + 1):\n        if i > 1 and turn_take[-i] < turn_take[-i + 1]:\n            taken = min(0, taken + turn_take[-i + 1] - turn_take[-i])\n        if turn_take[-i] > -taken:\n            taken -= 1\n            res += 1\n        else:\n            res += (turns - i + 1) // 2\n            if (turns - i + 1) % 2 != 0:\n                res += 1\n            break\n    print(res)\nt = int(input())\nfor i in range(t):\n    main()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    conts = []\n    last = None\n    for c in s:\n        if c == last:\n            conts[-1] += 1\n        else:\n            conts.append(1)\n            last = c\n    before = 0\n    ops = 0\n    for (i, cont) in enumerate(conts):\n        before += 1\n        if cont > 1:\n            _ops = min(before, cont - 1)\n            before -= _ops\n            ops += _ops\n    print(ops + (before + 1) // 2)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    print(x + (y - x + 1) // 2)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    print(x + (y - x + 1) // 2)", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    start = 1\n    end = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            end += 1\n            end = min(end, start)\n        else:\n            start += 1\n    print(end + (start - end + 1) // 2)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    print(x + (y - x + 1) // 2)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    print(x + (y - x + 1) // 2)", "for u in range(int(input())):\n    n = int(input())\n    s = input()\n    ans = 0\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i - 1] == s[i]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    ans = x + (y - x + 1) // 2\n    print(ans)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    print(x + (y - x + 1) // 2)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    x = 0\n    y = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            x += 1\n            x = min(x, y)\n        else:\n            y += 1\n    print(x + (y - x + 1) // 2)", "ts = int(input())\nfor t in range(ts):\n    n = int(input())\n    l = input()\n    a = []\n    curr = l[0]\n    count = 1\n    for i in l[1:]:\n        if i == curr:\n            count += 1\n        else:\n            a.append(count)\n            count = 1\n            curr = i\n    a.append(count)\n    p1 = 0\n    p2 = 0\n    op = 0\n    la = len(a)\n    while p1 < la and a[p1] == 1:\n        p1 += 1\n    while p1 < la and p2 < la:\n        a[p1] -= 1\n        p2 += 1\n        op += 1\n        if p1 < p2:\n            p1 += 1\n        while p1 < la and a[p1] == 1:\n            p1 += 1\n    if p1 == la:\n        if (la - p2) % 2:\n            op += (la - p2) // 2 + 1\n        else:\n            op += (la - p2) // 2\n    print(op)", "def ans(s, n):\n    temp = 1\n    curr = s[0]\n    seq = []\n    i = 1\n    while i < n:\n        if s[i] == curr:\n            temp += 1\n        else:\n            seq.append(temp)\n            temp = 1\n            curr = s[i]\n        i += 1\n    seq.append(temp)\n    answer = 0\n    if len(seq) == 1:\n        return 1\n    j = 0\n    while j < len(seq) and seq[j] == 1:\n        j += 1\n    if j == len(seq):\n        if len(seq) % 2:\n            return len(seq) // 2 + 1\n        else:\n            return len(seq) // 2\n    i = 0\n    while i < len(seq) and j < len(seq):\n        if i == j:\n            answer += 1\n            i += 1\n            j += 1\n            while j < len(seq) and seq[j] == 1:\n                j += 1\n            if j == len(seq):\n                break\n        else:\n            answer += 1\n            i += 1\n            seq[j] -= 1\n            while j < len(seq) and seq[j] == 1:\n                j += 1\n            if j == len(seq):\n                break\n    x = len(seq) - i\n    if x % 2:\n        answer += x // 2 + 1\n    else:\n        answer += x // 2\n    return answer\nm = int(input())\nfor j in range(m):\n    n = int(input())\n    s = input()\n    print(ans(s, n))", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    st = 0\n    i = n - 1\n    ans = 0\n    while i >= 0:\n        size = 0\n        de = s[i]\n        while i >= 0 and s[i] == de:\n            size += 1\n            i -= 1\n        st += size - 1\n        ans += 1\n        if st == 0 and i == -1:\n            break\n        if st == 0:\n            i -= 1\n        else:\n            st -= 1\n    print(ans)", "t = int(input())\nfor j in range(t):\n    n = int(input())\n    s = input()\n    (i, op, future) = (0, 0, 0)\n    left = n\n    while left > 0:\n        op += 1\n        if i == n - 1:\n            break\n        symbol = s[i]\n        flag = True\n        left -= 1\n        i += 1\n        while left != 0 and symbol == s[i]:\n            if future > 0:\n                future -= 1\n                left += 1\n            else:\n                flag = False\n            left -= 1\n            i += 1\n        if flag:\n            future += 1\n            left -= 1\n    print(op)", "import math\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    list = []\n    count = 1\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n        else:\n            list.append(count)\n            count = 1\n    list.append(count)\n    count = 0\n    x = 0\n    for i in range(len(list)):\n        if x == i and list[i] > 1:\n            count += 1\n            x += 1\n        elif x != i and list[i] > 1:\n            while list[i] != 1:\n                list[i] -= 1\n                x += 1\n                count += 1\n                if x == i and list[i] > 1:\n                    count += 1\n                    x += 1\n                    break\n    count = count + math.ceil((len(list) - x) / 2)\n    print(count)", "for t in range(int(input())):\n    n = int(input())\n    s = input()\n    if n < 3:\n        print(1)\n    else:\n        a = []\n        b = []\n        c = 1\n        j = 0\n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                c += 1\n            else:\n                a.append(c)\n                if c > 1:\n                    b.append(j)\n                c = 1\n                j += 1\n        a.append(c)\n        if c > 1:\n            b.append(j)\n        la = len(a)\n        lb = len(b)\n        if lb == 0:\n            print((la + 1) // 2)\n        else:\n            ia = ib = r = 0\n            while ia < la:\n                r += 1\n                if a[ia] == 1:\n                    a[b[ib]] -= 1\n                    if a[b[ib]] == 1:\n                        ib += 1\n                        if ib >= lb:\n                            r += (la - ia) // 2\n                            break\n                else:\n                    ib += 1\n                    if ib >= lb:\n                        r += (la - ia) // 2\n                        break\n                ia += 1\n            print(r)", "import sys\nimport math, bisect\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef neo():\n    return map(int, sys.stdin.readline().split())\n\ndef Neo():\n    return list(map(int, sys.stdin.readline().split()))\nfor _ in range(I()):\n    n = I()\n    s = input()\n    l = [len(list(j)) for (_, j) in groupby(list(s))]\n    (curr, Ans) = (0, 0)\n    for i in range(len(l)):\n        curr = min(curr + l[i] - 1, i + 1)\n    Ans = curr + (len(l) - curr + 1) // 2\n    print(Ans)", "from collections import deque\n\ndef p(a):\n    l = []\n    for i in range(len(a)):\n        if i <= len(a) - 2 and a[i] == a[i + 1]:\n            l.append(i)\n    return deque(l)\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(input())\n        (d, de, s, ans) = (p(a), 0, set(), 0)\n        (i, j) = (0, 0)\n        while i < n:\n            while d and d[0] < i:\n                d.popleft()\n            if not d:\n                break\n            while i in s:\n                i += 1\n            ans += 1\n            x = d.popleft()\n            s.add(x)\n            t = i + 1\n            while t < n and a[i] == a[t]:\n                t += 1\n            i = t\n        de = 0\n        for j in range(i, n):\n            if j not in s:\n                de += 1\n        print(ans + de // 2 + de % 2)\nmain()", "import math\nt = int(input())\n\ndef get_non_singleton_block_ind(blocks, start_ind, block_amount):\n    for j in range(start_ind, block_amount):\n        if blocks[j] > 1:\n            return j\n    return block_amount\n\ndef get_repeat_string_blocks(s):\n    blocks = []\n    prev_item = ''\n    for i in range(0, len(s)):\n        if s[i] != prev_item:\n            blocks.append(1)\n            prev_item = s[i]\n        else:\n            blocks[len(blocks) - 1] += 1\n    return blocks\nfor case in range(0, t):\n    n = int(input())\n    s = list(input())\n    blocks = get_repeat_string_blocks(s)\n    max_steps = 0\n    blocks_removed = 0\n    block_amount = len(blocks)\n    non_singleton_block_ind = -1\n    for i in range(0, block_amount):\n        if non_singleton_block_ind < i or blocks[non_singleton_block_ind] == 1:\n            non_singleton_block_ind = get_non_singleton_block_ind(blocks, max(i, non_singleton_block_ind), block_amount)\n        if non_singleton_block_ind == block_amount:\n            break\n        blocks[non_singleton_block_ind] -= 1\n        max_steps += 1\n        blocks_removed += 1\n    blocks_remaining = block_amount - blocks_removed\n    max_steps += int(math.ceil(blocks_remaining / float(2)))\n    print(max_steps)", "for _ in range(int(input())):\n    n = int(input())\n    s = str(input())\n    (one, zero) = (0, 0)\n    l = []\n    for i in range(n):\n        if s[i] == '1':\n            if zero != 0:\n                l.append(zero)\n                zero = 0\n            one += 1\n        elif s[i] == '0':\n            if one != 0:\n                l.append(one)\n                one = 0\n            zero += 1\n    if one != 0:\n        l.append(one)\n    if zero != 0:\n        l.append(zero)\n    ans = 0\n    loan = 0\n    m = len(l)\n    for i in range(m):\n        if l[i] >= 2:\n            if loan:\n                ans += min(l[i] - 2, loan)\n                loan -= min(l[i] - 2, loan)\n            ans += 1\n        elif l[i] == 1:\n            loan += 1\n    print(ans + (loan + 1) // 2)", "for _ in range(int(input())):\n    n = int(input())\n    s = list(input())\n    groups = []\n    last = ''\n    cnt = 0\n    for c in s:\n        if c != last:\n            if cnt:\n                groups.append(cnt)\n            cnt = 1\n        else:\n            cnt += 1\n        last = c\n    if cnt:\n        groups.append(cnt)\n    m = len(groups)\n    i = 0\n    j = 0\n    ops = 0\n    while i < m:\n        ops += 1\n        while j < i or (j < m and groups[j] == 1):\n            j += 1\n        if j < m:\n            groups[j] -= 1\n        else:\n            i += 1\n        i += 1\n    print(ops)", "for _ in range(int(input())):\n    siz = int(input())\n    st = input()\n    diff = 0\n    q = []\n    for x in range(1, siz):\n        if st[x] != st[x - 1]:\n            diff += 1\n        if st[x] == st[x - 1]:\n            q.append(diff)\n    q.reverse()\n    (rem, ans) = (0, 0)\n    for x in range(siz):\n        if not q:\n            break\n        q.pop(-1)\n        rem += 1\n        ans += 1\n        while q and q[-1] == x:\n            q.pop(-1)\n            rem += 1\n        rem += 1\n    print(ans + (siz - rem + 1) // 2)", "for _ in range(int(input())):\n    siz = int(input())\n    st = input()\n    diff = 0\n    q = []\n    for x in range(1, siz):\n        if st[x] != st[x - 1]:\n            diff += 1\n        if st[x] == st[x - 1]:\n            q.append(diff)\n    q.reverse()\n    (rem, ans) = (0, 0)\n    for x in range(siz):\n        if not q:\n            break\n        q.pop(-1)\n        rem += 1\n        ans += 1\n        while q and q[-1] == x:\n            q.pop(-1)\n            rem += 1\n        rem += 1\n    print(ans + (siz - rem + 1) // 2)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    string = []\n    flag = False\n    temp = ''\n    stack = []\n    for i in range(n):\n        if not stack:\n            stack.append(s[i])\n        elif s[i] == stack[-1]:\n            stack.append(s[i])\n        else:\n            string.append(len(stack))\n            stack = [s[i]]\n    if stack:\n        string.append(len(stack))\n    i = 0\n    j = 0\n    c = 0\n    n = len(string)\n    flag = False\n    while i < n:\n        if not flag:\n            if string[j] >= 2:\n                if i == j:\n                    string[j] = 0\n                else:\n                    string[j] -= 1\n                i += 1\n                c += 1\n            else:\n                j += 1\n            if j == n:\n                flag = True\n        else:\n            a = n - 1 - i + 1\n            c += a // 2\n            if a % 2 != 0:\n                c += 1\n            break\n    print(c)", "n = int(input())\nfor _ in range(n):\n    k = int(input())\n    s = input()\n    s = s[0] + s + str(int(s[-1]) ^ 1)\n    m = []\n    prev = 1\n    for i in range(1, k + 2):\n        if s[i] != s[i - 1]:\n            m.append(i - prev)\n            prev = i\n    ans = 0\n    start = 0\n    end = len(m)\n    first = 0\n    while start < end:\n        if m[start] > 1:\n            start += 1\n            first = max(first, start)\n        else:\n            while first < end and m[first] == 1:\n                first += 1\n            if first >= end:\n                end -= 1\n            else:\n                m[first] -= 1\n            start += 1\n        ans += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    l = []\n    counter = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            counter += 1\n        else:\n            l.append(counter)\n            counter = 1\n    if counter != 0:\n        l.append(counter)\n    ans = 0\n    x = []\n    for i in range(len(l) - 1, -1, -1):\n        if l[i] > 1:\n            x.append([i, l[i]])\n    for i in range(len(l)):\n        if l[i] > 1:\n            ans += 1\n            x.pop()\n        elif len(x) > 0:\n            x[-1][1] -= 1\n            l[x[-1][0]] -= 1\n            if x[-1][1] == 1:\n                x.pop()\n            ans += 1\n        else:\n            ans += (len(l) - i + 1) // 2\n            break\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    s = list(input())\n    groups = []\n    last = ''\n    cnt = 0\n    for c in s:\n        if c != last:\n            if cnt:\n                groups.append(cnt)\n            cnt = 1\n        else:\n            cnt += 1\n        last = c\n    if cnt:\n        groups.append(cnt)\n    m = len(groups)\n    i = 0\n    j = 0\n    ops = 0\n    while i < m:\n        ops += 1\n        while j < i or (j < m and groups[j] == 1):\n            j += 1\n        if j < m:\n            groups[j] -= 1\n        else:\n            i += 1\n        i += 1\n    print(ops)", "for i in range(int(input())):\n    n = int(input())\n    s = input()\n    arr = []\n    curr = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            curr += 1\n        else:\n            arr.append(curr)\n            curr = 1\n    arr.append(curr)\n    i = 0\n    j = 0\n    steps = 0\n    while i < len(arr):\n        if arr[i] == 1:\n            while j < len(arr) and arr[j] == 1:\n                j += 1\n            if j < len(arr):\n                arr[j] -= 1\n                i += 1\n            else:\n                steps += (len(arr) - i) // 2 + (len(arr) - i) % 2\n                break\n        else:\n            i += 1\n            if j < i:\n                j = i\n        steps += 1\n    print(steps)", "t = int(input())\nwhile t != 0:\n    n = int(input())\n    s = input()\n    arr = []\n    i = 0\n    while i < n:\n        p = s[i]\n        c = 0\n        while i < n and s[i] == p:\n            c += 1\n            i += 1\n        arr.append(c)\n    ans = 0\n    temp = 0\n    for i in range(len(arr)):\n        if arr[i] != 1:\n            p = arr[i] - 2\n            if temp > 0 and p > 0:\n                temp = max(0, temp - p)\n            ans += 1\n        else:\n            temp += 1\n            ans += 1\n    print(ans - temp // 2)\n    t -= 1", "t = int(input())\nwhile t != 0:\n    n = int(input())\n    s = input()\n    arr = []\n    i = 0\n    while i < n:\n        p = s[i]\n        c = 0\n        while i < n and s[i] == p:\n            c += 1\n            i += 1\n        arr.append(c)\n    ans = 0\n    temp = 0\n    for i in range(len(arr)):\n        if arr[i] != 1:\n            p = arr[i] - 2\n            if temp > 0 and p > 0:\n                temp = max(0, temp - p)\n            ans += 1\n        else:\n            temp += 1\n            ans += 1\n    print(ans - temp // 2)\n    t -= 1", "import math\nt = int(input())\n\ndef get_non_singleton_block_ind(blocks, start_ind, block_amount):\n    for j in range(start_ind, block_amount):\n        if blocks[j] > 1:\n            return j\n    return block_amount\n\ndef get_repeat_string_blocks(s):\n    blocks = []\n    prev_item = ''\n    for i in range(0, len(s)):\n        if s[i] != prev_item:\n            blocks.append(1)\n            prev_item = s[i]\n        else:\n            blocks[len(blocks) - 1] += 1\n    return blocks\nfor case in range(0, t):\n    n = int(input())\n    s = list(input())\n    blocks = get_repeat_string_blocks(s)\n    max_steps = 0\n    blocks_removed = 0\n    block_amount = len(blocks)\n    non_singleton_block_ind = -1\n    for i in range(0, block_amount):\n        if non_singleton_block_ind < i or blocks[non_singleton_block_ind] == 1:\n            non_singleton_block_ind = get_non_singleton_block_ind(blocks, max(i, non_singleton_block_ind), block_amount)\n        if non_singleton_block_ind == block_amount:\n            break\n        blocks[non_singleton_block_ind] -= 1\n        max_steps += 1\n        blocks_removed += 1\n    blocks_remaining = block_amount - blocks_removed\n    max_steps += int(math.ceil(blocks_remaining / float(2)))\n    print(max_steps)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    string = []\n    stack = []\n    for i in range(n):\n        if not stack:\n            stack.append(s[i])\n        elif s[i] == stack[-1]:\n            stack.append(s[i])\n        else:\n            string.append(len(stack))\n            stack = [s[i]]\n    if stack:\n        string.append(len(stack))\n    i = 0\n    j = 0\n    c = 0\n    n = len(string)\n    flag = False\n    while i < n:\n        if not flag:\n            if string[j] >= 2:\n                if i == j:\n                    string[j] = 0\n                else:\n                    string[j] -= 1\n                i += 1\n                c += 1\n            else:\n                j += 1\n            if j == n:\n                flag = True\n        else:\n            a = n - 1 - i + 1\n            c += a // 2\n            if a % 2 != 0:\n                c += 1\n            break\n    print(c)", "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    curr = 1\n    a = []\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            a.append(curr)\n            curr = 1\n        else:\n            curr += 1\n    a.append(curr)\n    l = 0\n    r = l\n    ans = 0\n    while l < len(a):\n        if a[l] == 0:\n            l += 1\n            continue\n        if a[l] > 1:\n            ans += 1\n            a[l] = 0\n        else:\n            while r < len(a) and a[r] <= 1:\n                r += 1\n            if l < r < len(a):\n                a[r] -= 1\n                a[l] = 0\n                ans += 1\n            else:\n                ans += (len(a) - l) // 2 + (len(a) - l) % 2\n                break\n        l += 1\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    paq = []\n    l = 1\n    last_seen = s[0]\n    for i in range(1, len(s)):\n        if s[i] == last_seen:\n            l += 1\n        else:\n            paq.append(l)\n            l = 1\n            last_seen = s[i]\n    paq.append(l)\n    vie = 0\n    num = 0\n    reste = len(paq)\n    next_greater = 0\n    while reste > 0:\n        if next_greater < len(paq) and (next_greater < vie or paq[next_greater] <= 1):\n            j = max(next_greater, vie)\n            while j < len(paq) and paq[j] <= 1:\n                j += 1\n            next_greater = j\n        i = next_greater\n        if i == len(paq):\n            vie += 2\n            reste -= 2\n        else:\n            paq[i] -= 1\n            reste -= 1\n            vie += 1\n        num += 1\n    print(num)", "n_inputs = int(input())\nfor _ in range(n_inputs):\n    str_len = int(input())\n    str_input = input()\n    arr_of_lens = []\n    i = 0\n    while i < str_len:\n        curr_len = 0\n        current_char = str_input[i]\n        while i < str_len and current_char == str_input[i]:\n            curr_len += 1\n            i += 1\n        arr_of_lens += [curr_len]\n    n_lens = len(arr_of_lens)\n    first_step_ind = 0\n    second_step_ind = 0\n    iters = 0\n    while first_step_ind < n_lens:\n        while first_step_ind < n_lens and arr_of_lens[first_step_ind] <= 1:\n            first_step_ind += 1\n        if first_step_ind < n_lens:\n            arr_of_lens[first_step_ind] -= 1\n            arr_of_lens[second_step_ind] = 0\n            second_step_ind += 1\n            iters += 1\n        else:\n            iters += (first_step_ind - second_step_ind + 1) // 2\n    print(iters)", "import math\n\ndef value():\n    return tuple(map(int, input().split()))\n\ndef arr():\n    return [int(i) for i in input().split()]\n\ndef inn():\n    return int(input())\nfor _ in range(inn()):\n    n = inn()\n    a = [int(x) for x in input()]\n    ans = 0\n    i = 0\n    c = 0\n    while i < n:\n        if i < n - 1 and a[i] != a[i + 1]:\n            a[i] = -1\n            i += 1\n            c += 1\n        elif i < n - 1 and a[i] == a[i + 1]:\n            if c > 0:\n                a[i] = -1\n                i += 1\n                c -= 1\n            else:\n                val = a[i]\n                while i < n and a[i] == val:\n                    a[i] = -1\n                    i += 1\n            ans += 1\n        else:\n            c += 1\n            i += 1\n    ans += math.ceil(c / 2)\n    print(ans)", "t = int(input())\nfor case in range(t):\n    n = int(input())\n    s = input()\n    arr = []\n    if n == 1:\n        print(1)\n        continue\n    count = 0\n    for i in range(n):\n        if i == 0:\n            count += 1\n        elif i < n - 1:\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                arr.append(count)\n                count = 1\n        elif s[i] == s[i - 1]:\n            arr.append(count + 1)\n        else:\n            arr.append(count)\n            arr.append(1)\n    ans = 0\n    i = 0\n    j = 0\n    m = len(arr)\n    while i < m:\n        if arr[i] > 1:\n            ans += 1\n            i += 1\n        else:\n            while j < m and arr[j] <= 1:\n                j += 1\n            if j == m:\n                ans += (j - i + 1) // 2\n                break\n            else:\n                arr[j] -= 1\n                i += 1\n                ans += 1\n        if i > j:\n            j = i\n    print(ans)", "import sys\nimport math\nimport random\ninput = sys.stdin.readline\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    S = input()\n    size = 1\n    A = []\n    for i in range(1, N):\n        if S[i] == S[i - 1]:\n            size += 1\n        else:\n            A.append(size)\n            size = 1\n    A.append(size)\n    i = 0\n    j = 0\n    ans = 0\n    while i < len(A):\n        while j < i or (j + 1 < len(A) and A[j] == 1):\n            j += 1\n        A[j] -= 1\n        A[i] = 0\n        if j == len(A) - 1 and A[j] == 0:\n            A.pop()\n            j -= 1\n        i += 1\n        ans += 1\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    s = str(input())\n    j = 0\n    ll = []\n    count = 1\n    tt = 0\n    while j < n - 1:\n        if s[j + 1] == s[j]:\n            count += 1\n            if j == n - 2:\n                ll.append(count)\n                tt += count\n            j += 1\n        else:\n            j += 1\n            ll.append(count)\n            tt += count\n            count = 1\n    if n - tt > 0:\n        ll.append(n - tt)\n    zz = 0\n    ans = 0\n    qq = 0\n    count = 0\n    i = 0\n    j = i + 1\n    ttt = len(ll)\n    while i < ttt:\n        if j == ttt:\n            break\n        if ll[i] != 1:\n            ans += 1\n            i += 1\n            j = max(i + 1, j)\n        elif ll[j] > 1:\n            ll[j] -= 1\n            ans += 1\n            i += 1\n            j = max(i + 1, j)\n        else:\n            j += 1\n    ans += (ttt - i) // 2 + (ttt - i) % 2\n    print(ans)", "def find_cnt_seg(string, start):\n    l = len(string)\n    ind = start\n    while ind < l - 1:\n        if string[ind] == string[ind + 1]:\n            return ind\n        ind += 1\n    if ind >= l - 1:\n        return -1\nt = int(input())\nfor ii in range(t):\n    n = int(input())\n    s = input()\n    m = [False] * len(s)\n    cnt = 0\n    i = 0\n    ind = find_cnt_seg(s, 0)\n    if ind == i:\n        i += 1\n    if ind == -1:\n        print(n // 2 + n % 2)\n        continue\n    while i < n:\n        cnt += 1\n        m[ind] = True\n        start = s[i]\n        while i < n:\n            if s[i] == start:\n                m[i] = True\n                i += 1\n            elif m[i] == True:\n                i += 1\n            else:\n                break\n        j = max(i, ind)\n        while j < n:\n            if m[j] == True:\n                j += 1\n            else:\n                break\n        ind = find_cnt_seg(s, j)\n        if ind == -1:\n            break\n    int_ = 0\n    for i in m:\n        if i == False:\n            int_ += 1\n    print(cnt + int_ // 2 + int_ % 2)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    (i, c) = (0, 0)\n    visit = [-1 for _ in range(n)]\n    (flag, last) = (0, -1)\n    while i < n:\n        if visit[i] == 1:\n            i += 1\n            continue\n        if i + 1 < n and s[i] == s[i + 1]:\n            c += 1\n            while i + 1 < n and s[i] == s[i + 1]:\n                i += 1\n            i += 1\n        elif i == n - 1:\n            i += 1\n            c += 1\n        else:\n            c += 1\n            if flag == 1:\n                c1 = 1\n                j = i + 1\n                while j < n:\n                    if visit[j] == -1:\n                        visit[j] = 1\n                        c1 -= 1\n                        break\n                    j += 1\n                i = j + 1\n                continue\n            if last == -1:\n                j = i + 1\n            else:\n                j = max(i + 1, last + 1)\n            while j < n and visit[j] == 1 or (j + 1 < n and s[j] != s[j + 1]):\n                j += 1\n            if j < n:\n                visit[j] = 1\n                i += 1\n                last = j\n            else:\n                flag = 1\n                c1 = 1\n                j = i + 1\n                while j < n:\n                    if visit[j] == -1:\n                        visit[j] = 1\n                        c1 -= 1\n                        break\n                    j += 1\n                i = j + 1\n    print(c)", "from sys import stdin, stdout\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    s = stdin.readline()\n    s1 = []\n    i = 0\n    ind = []\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == s[i]:\n            j += 1\n        s1.append([int(s[i]), j - i])\n        if j - i >= 3:\n            ind.append(len(s1) - 1)\n        i = j\n    op = 0\n    for i in range(len(s1)):\n        if s1[i][1] == 0:\n            continue\n        if s1[i][1] == 1:\n            op += 1\n            while len(ind) != 0 and ind[0] < i:\n                ind.pop(0)\n            if len(ind) != 0:\n                s1[ind[0]][1] -= 1\n                if s1[ind[0]][1] == 2:\n                    ind.pop(0)\n            elif i + 1 < len(s1):\n                s1[i + 1][1] -= 1\n        else:\n            op += 1\n    print(op)", "import sys\nimport math\nfrom collections import Counter, defaultdict\nLI = lambda : list(map(int, input().split()))\nMAP = lambda : map(int, input().split())\nIN = lambda : int(input())\nS = lambda : input()\n\ndef case():\n    n = IN()\n    s = S()\n    b = []\n    c = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            b += [c]\n            c = 1\n        else:\n            c += 1\n    b += [c]\n    l = sum(b) - len(b)\n    (ans, ye) = (0, 0)\n    while len(b) > 0:\n        if l > ye:\n            ye += 1\n            ye -= b[0] - 1\n            if ye < 0:\n                ye = 0\n            l -= b[0] - 1\n            b.pop(0)\n        else:\n            b.pop(0)\n            if len(b) > 0:\n                b.pop()\n        ans += 1\n    print(ans)\nfor _ in range(IN()):\n    case()", "from sys import stdin, stdout\nimport math, bisect\nfrom collections import Counter, deque, defaultdict\nL = lambda : list(map(int, stdin.readline().strip().split()))\nM = lambda : map(int, stdin.readline().strip().split())\nI = lambda : int(stdin.readline().strip())\nS = lambda : stdin.readline().strip()\nC = lambda : stdin.readline().strip().split()\n\ndef pr(a):\n    return ' '.join(list(map(str, a)))\n\ndef solve():\n    n = I()\n    s = S()\n    a = []\n    b = []\n    c = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            a += [s[i - 1]]\n            b += [c]\n            c = 1\n        else:\n            c += 1\n    a += [s[-1]]\n    b += [c]\n    l = sum(b) - len(b)\n    (ans, x) = (0, 0)\n    while len(b):\n        if l > x:\n            x += 1\n            x -= b[0] - 1\n            if x < 0:\n                x = 0\n            l -= b[0] - 1\n            b.pop(0)\n        else:\n            b.pop(0)\n            if len(b):\n                b.pop()\n        ans += 1\n    print(ans)\nfor _ in range(I()):\n    solve()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    arr = []\n    val = s[0]\n    c = 0\n    for i in s:\n        if i == val:\n            c += 1\n        else:\n            arr.append(c)\n            c = 1\n            val = i\n    if c > 0:\n        arr.append(c)\n    ans = 0\n    q = []\n    for i in range(len(arr)):\n        if arr[i] != 1:\n            q.append(i)\n    k = 0\n    while 1:\n        if arr == []:\n            break\n        if arr[0] > 1:\n            ans += 1\n            q.pop(0)\n            arr.pop(0)\n        else:\n            if len(q) > 0:\n                arr[q[0] - k] -= 1\n                if arr[q[0] - k] == 1:\n                    q.pop(0)\n                ans += 1\n            else:\n                ans += len(arr) // 2 + len(arr) % 2\n                break\n            arr.pop(0)\n        k += 1\n    print(ans)", "from collections import deque, defaultdict\nfrom heapq import heapify, heappop\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    kol = deque([1])\n    for x in range(1, n):\n        if s[x] != s[x - 1]:\n            kol.append(1)\n        else:\n            kol[-1] += 1\n    res = 0\n    j = 0\n    for (i, x) in enumerate(kol):\n        while kol[i] > 1 and j <= i:\n            kol[i] -= 1\n            j += 1\n            res += 1\n    print(res + (len(kol) - j + 1) // 2)", "t = int(input())\nfor case in range(t):\n    n = int(input())\n    s = input()\n    i = 0\n    x = []\n    while i < n:\n        cnt = 1\n        while i + cnt < n and s[i + cnt] == s[i]:\n            cnt += 1\n        x.append(cnt)\n        i += cnt\n    i = 0\n    j = 0\n    ops = 0\n    while x:\n        f = False\n        while i < len(x):\n            if x[i] > 1:\n                x[i] -= 1\n                ops += 1\n                f = True\n                break\n            else:\n                i += 1\n        if not f:\n            del x[-1]\n            ops += 1\n        if len(x) > 0:\n            del x[0]\n        i = max(i - 1, 0)\n    print(ops)", "from math import ceil\n\ndef stringdel(string):\n    q = []\n    curr = 0\n    for i in range(len(string)):\n        if i > 0 and string[i] != string[i - 1]:\n            curr += 1\n        if i > 0 and string[i] == string[i - 1]:\n            q.append(curr)\n    deleted = 0\n    score = 0\n    for i in range(len(string)):\n        if len(q) == 0:\n            break\n        q.pop(0)\n        deleted += 1\n        score += 1\n        while q and q[0] == i:\n            q.pop(0)\n            deleted += 1\n        deleted += 1\n    score += ceil((len(string) - deleted) / 2)\n    return score\nfor i in range(int(input())):\n    a = input()\n    print(stringdel(input()))"]