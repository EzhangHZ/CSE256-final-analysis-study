["from collections import deque\nT = int(input())\nfor case in range(T):\n    a = input()\n    (n, m) = map(int, input().split())\n    G = [[] for ele in range(n + 1)]\n    d = [-1] * (n + 1)\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        G[x].append(y)\n    q = deque()\n    q.append(1)\n    d[1] = 0\n    count = 0\n    while q:\n        count += 1\n        for i in range(len(q)):\n            node = q.popleft()\n            for ele in G[node]:\n                if d[ele] == -1:\n                    d[ele] = count\n                    q.append(ele)\n    ans = [0] * (n + 1)\n    for u in sorted([i + 1 for i in range(n)], key=lambda x: d[x], reverse=True):\n        ans[u] = d[u]\n        for v in G[u]:\n            if d[u] >= d[v]:\n                ans[u] = min(ans[u], d[v])\n            else:\n                ans[u] = min(ans[u], ans[v])\n    print(*ans[1:])", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "from collections import deque\n\ndef solution(n, m, edges):\n    adj = [[] for _ in range(n)]\n    dist = {}\n    q = deque()\n    sol = [10 ** 6 for _ in range(n)]\n    for [u, v] in edges:\n        adj[u - 1].append(v - 1)\n    q.append((0, 0))\n    dist[0] = 0\n    while len(q) > 0:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if v not in dist or d + 1 < dist[v]:\n                q.append((v, d + 1))\n                dist[v] = d + 1\n    verts = list(range(n))\n    verts.sort(key=lambda u: dist[u], reverse=True)\n    for u in verts:\n        cur = dist[u]\n        for v in adj[u]:\n            if dist[u] < dist[v]:\n                cur = min(cur, sol[v])\n            else:\n                cur = min(cur, dist[v])\n        sol[u] = cur\n    print(*sol)\nT = int(input())\nfor t in range(1, T + 1):\n    input()\n    [n, m] = list(map(int, input().split()))\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    solution(n, m, edges)", "from collections import deque\n\ndef solution(n, m, edges):\n    adj = [[] for _ in range(n)]\n    dist = {}\n    q = deque()\n    sol = [10 ** 6 for _ in range(n)]\n    for [u, v] in edges:\n        adj[u - 1].append(v - 1)\n    q.append((0, 0))\n    dist[0] = 0\n    while len(q) > 0:\n        (u, d) = q.popleft()\n        for v in adj[u]:\n            if v not in dist or d + 1 < dist[v]:\n                q.append((v, d + 1))\n                dist[v] = d + 1\n    verts = list(range(n))\n    verts.sort(key=lambda u: dist[u], reverse=True)\n    for u in verts:\n        cur = dist[u]\n        for v in adj[u]:\n            if dist[u] < dist[v]:\n                cur = min(cur, sol[v])\n            else:\n                cur = min(cur, dist[v])\n        sol[u] = cur\n    print(*sol)\nT = int(input())\nfor t in range(1, T + 1):\n    input()\n    [n, m] = list(map(int, input().split()))\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    solution(n, m, edges)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    ans = [0] * n\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            if dis[u] >= dis[v]:\n                ans[u] = min(ans[u], dis[v])\n            else:\n                ans[u] = min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    ans = [0] * n\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            if dis[u] >= dis[v]:\n                ans[u] = min(ans[u], dis[v])\n            else:\n                ans[u] = min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "for _ in range(int(input())):\n    input()\n    (n, m) = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    dis = [-1] * n\n    dis[0] = 0\n    que = [0]\n    ans = [0] * n\n    for _ in range(m):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        adj[u].append(v)\n    for i in range(n):\n        u = que[i]\n        for v in adj[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                que.append(v)\n    for u in sorted([i for i in range(n)], key=lambda x: dis[x], reverse=True):\n        ans[u] = dis[u]\n        for v in adj[u]:\n            ans[u] = min(ans[u], dis[v]) if dis[u] >= dis[v] else min(ans[u], ans[v])\n    print(*ans)", "t = int(input())\nfor _ in range(t):\n    blank = input()\n    (n, m) = map(int, input().split())\n    dct = {i: [] for i in range(1, n + 1)}\n    for times in range(m):\n        (start, end) = map(int, input().split())\n        dct[start].append(end)\n    dis = {1: 0}\n    stack = [1]\n    iterate = [1]\n    so = 1\n    decoy = 0\n    while so < n:\n        decoy = stack.pop(0)\n        for adj in dct[decoy]:\n            if adj in dis:\n                continue\n            else:\n                so += 1\n                dis[adj] = dis[decoy] + 1\n                iterate.append(adj)\n                stack.append(adj)\n    ans = [dis[i] for i in range(1, n + 1)]\n    for node in iterate[::-1]:\n        minn = dis[node]\n        for adj in dct[node]:\n            if dis[adj] <= dis[node]:\n                minn = min(minn, dis[adj])\n            else:\n                minn = min(ans[adj - 1], minn)\n        ans[node - 1] = minn\n    print(*ans)"]