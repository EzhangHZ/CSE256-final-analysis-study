["import math\n\ndef lcm(lista):\n    k = 1\n    for i in lista:\n        if i != 0:\n            k = k * i // math.gcd(k, i)\n    return k\n\ndef lyans():\n    a = input()\n    listn = []\n    for i in a:\n        listn.append(int(i))\n    n = len(listn)\n    for i in range(len(a)):\n        l = lcm(listn[:n - i - 1])\n        nb = int(a[n - i - 1:])\n        if i == len(a) - 1:\n            star = int(a)\n        elif int(a) % l == 0:\n            star = nb\n        else:\n            temp = l - int(a) % l\n            star = temp + nb\n        for m in range(star, 10 ** (i + 1), l):\n            lsm = [int(i) for i in str(m)]\n            lsm.append(l)\n            lm = lcm(lsm)\n            last = int(a[:n - i - 1] + '0' * (i + 1 - len(str(m))) + str(m))\n            if last % lm == 0:\n                return last\nt = int(input())\nfor ti in range(t):\n    print(lyans())", "def gcd(a, b):\n    while a and b:\n        if a > b:\n            a %= b\n        else:\n            b %= a\n    return a + b\n\ndef check(n):\n    s = str(n)\n    nok = 1\n    for elem in s:\n        if elem != '0':\n            nok = nok * int(elem) // gcd(nok, int(elem))\n    return n % nok == 0\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    for i in range(20):\n        nn = n\n        if i == 0:\n            cur_s = str(n)\n        elif i >= len(str(n)):\n            cur_s = '0'\n        else:\n            cur_s = str(n)[:-i]\n        st10 = 10 ** i\n        nok = 1\n        for elem in cur_s:\n            if elem != '0':\n                nok = nok * int(elem) // gcd(nok, int(elem))\n        if i == 0 and n % nok == 0:\n            print(n)\n            break\n        diff = nok - n % nok\n        n += diff\n        while str(n // st10) == cur_s and (not check(n)):\n            n += nok\n        if str(n // st10) == cur_s and check(n):\n            print(n)\n            break\n        n = nn", "def checkFair(num):\n    temp = num\n    while temp != 0:\n        mod = temp % 10\n        if mod != 0:\n            if num % mod != 0:\n                return False\n        temp = temp // 10\n    return True\ndic = {}\nfor _ in range(int(input())):\n    num = int(input())\n    flag = checkFair(num)\n    if flag:\n        print(num)\n    else:\n        temp = num\n        if dic.get(num, -1) != -1:\n            print(dic[temp])\n        else:\n            while not flag:\n                flag = checkFair(num)\n                if flag:\n                    dic[temp] = num\n                    print(num)\n                num += 1", "import sys\nimport math\nimport bisect\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log, ceil\nfrom collections import defaultdict as dd\nfrom collections import Counter as cc\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport functools\nsys.setrecursionlimit(100000000)\nintinp = lambda : int(input().strip())\nstripinp = lambda : input().strip()\nfltarr = lambda : list(map(float, input().strip().split()))\nintarr = lambda : list(map(int, input().strip().split()))\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nMOD = 1000000007\nnum_cases = intinp()\nseen = {}\n\n@functools.lru_cache(None)\ndef check(num):\n    for v in set(str(num)):\n        v = int(v)\n        if v != 0 and num % v:\n            return False\n    return True\nfor _ in range(num_cases):\n    n = intinp()\n    y = n\n    if n in seen:\n        print(seen[n])\n        continue\n    while not check(n):\n        n += 1\n    print(n)\n    seen[y] = n"]