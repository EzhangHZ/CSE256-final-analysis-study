["from heapq import heappop, heappush\nimport sys\ninput = sys.stdin.readline\nperc = 0\nserved = {}\npera = []\ncurs = 1\nans = []\nfor _ in range(int(input())):\n    inp = input().split()\n    if inp[0] == '1':\n        m = int(inp[1])\n        perc += 1\n        heappush(pera, (-m, perc))\n        served[perc] = False\n    else:\n        q = int(inp[0])\n        if q == 2:\n            while served[curs]:\n                curs += 1\n            served[curs] = True\n            ans.append(curs)\n        else:\n            while served[pera[0][1]]:\n                heappop(pera)\n            (_, i) = heappop(pera)\n            ans.append(i)\n            served[i] = True\nprint(*ans)", "from sys import stdin\nfrom heapq import *\nQ = int(stdin.readline())\ncustomer_id = 1\npq = []\nfirst = 1\nans = []\nserved = set()\nfor q in range(Q):\n    args = stdin.readline().split()\n    if args[0] == '1':\n        heappush(pq, [-1 * int(args[1]), customer_id])\n        customer_id += 1\n    elif args[0] == '2':\n        ans.append(first)\n        served.add(first)\n        while first in served:\n            first += 1\n    else:\n        while pq[0][1] in served:\n            heappop(pq)\n        (price, c_id) = heappop(pq)\n        ans.append(c_id)\n        served.add(c_id)\n        while first in served:\n            first += 1\nprint(*ans)", "import heapq\nq = int(input())\nmono_queue = []\npoly_queue = []\nserved = dict()\nans = []\ncount = 0\nfor query in range(1, q + 1):\n    read_line = input().split(' ')\n    if read_line[0] == '1':\n        m = int(read_line[1])\n        count += 1\n        heapq.heappush(mono_queue, (count, -m))\n        heapq.heappush(poly_queue, (-m, count))\n    elif read_line[0] == '2':\n        next_to_serve = heapq.heappop(mono_queue)[0]\n        while next_to_serve in served.keys():\n            next_to_serve = heapq.heappop(mono_queue)[0]\n        ans.append(next_to_serve)\n        served[next_to_serve] = True\n    elif read_line[0] == '3':\n        next_to_serve = heapq.heappop(poly_queue)[1]\n        while next_to_serve in served.keys():\n            next_to_serve = heapq.heappop(poly_queue)[1]\n        ans.append(next_to_serve)\n        served[next_to_serve] = True\nprint(' '.join([str(x) for x in ans]))", "from collections import deque, Counter\nfrom collections import defaultdict as dfd\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial, log2\nfrom heapq import heapify, heappush, heappop\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef readfl():\n    return list(map(float, input().strip().split()))\n\ndef readffl():\n    return list(map(float, file.readline().strip().split()))\n\ndef solve():\n    arr = []\n    heap = []\n    i = 0\n    ans = ''\n    for j in range(nin()):\n        tem = read()\n        if len(tem) > 1:\n            (a, b) = tem\n        else:\n            a = tem[0]\n        if a == 2:\n            while i < len(arr) and arr[i] == -1:\n                i += 1\n            ans += str(i + 1) + ' '\n            arr[i] = -1\n        elif a == 3:\n            while heap and arr[heap[0][1]] == -1:\n                heappop(heap)\n            curr = heappop(heap)[1]\n            arr[curr] = -1\n            ans += str(curr + 1) + ' '\n        else:\n            arr.append(j)\n            heappush(heap, [-b, len(arr) - 1])\n    ans_.append(ans)\nsolve()\nfor i in ans_:\n    print(i)", "from heapq import heappop, heappush\nimport sys\nperc = 0\nserved = {}\npera = []\ncurs = 1\nans = []\nfor _ in range(int(input())):\n    inp = input().split()\n    if inp[0] == '1':\n        m = int(inp[1])\n        perc += 1\n        heappush(pera, (-m, perc))\n        served[perc] = False\n    else:\n        q = int(inp[0])\n        if q == 2:\n            while served[curs]:\n                curs += 1\n            served[curs] = True\n            ans.append(curs)\n        else:\n            while served[pera[0][1]]:\n                heappop(pera)\n            (_, i) = heappop(pera)\n            ans.append(i)\n            served[i] = True\nprint(*ans)", "import math\nimport heapq\n\ndef S():\n    return input()\n\ndef M():\n    return map(int, input().split())\n\ndef I():\n    return int(S())\n\ndef L():\n    return list(M())\nq = I()\na = []\ndi = {}\nm = 10000000\nk = 1\nt = 1\nar = []\nheapq.heapify(a)\nfor i in range(q):\n    l = L()\n    if len(l) == 2:\n        heapq.heappush(a, (m - l[1], l[1], k))\n        di[k] = 0\n        k += 1\n    elif l[0] == 2:\n        while di.get(t, 0) == 1:\n            t += 1\n        ar.append(t)\n        di[t] = 1\n        t += 1\n    else:\n        p = heapq.heappop(a)\n        while di.get(p[2]) == 1:\n            p = heapq.heappop(a)\n        di[p[2]] = 1\n        ar.append(p[2])\nprint(*ar)", "import math\nimport heapq\n\ndef S():\n    return input()\n\ndef M():\n    return map(int, input().split())\n\ndef I():\n    return int(S())\n\ndef L():\n    return list(M())\nq = I()\na = []\ndi = {}\nm = 10000000\nk = 1\nt = 1\nar = []\nheapq.heapify(a)\nfor i in range(q):\n    l = L()\n    if len(l) == 2:\n        heapq.heappush(a, (m - l[1], l[1], k))\n        di[k] = 0\n        k += 1\n    elif l[0] == 2:\n        while di.get(t, 0) == 1:\n            t += 1\n        ar.append(t)\n        di[t] = 1\n        t += 1\n    else:\n        p = heapq.heappop(a)\n        while di.get(p[2]) == 1:\n            p = heapq.heappop(a)\n        di[p[2]] = 1\n        ar.append(p[2])\nprint(*ar)", "from queue import PriorityQueue\n\ndef main():\n    queries = int(input())\n    customer_pqueue = PriorityQueue()\n    marked = [None]\n    out_list = []\n    customer_id = 0\n    count = 1\n    for _ in range(queries):\n        query = input()\n        if not query.isdigit():\n            customer_id += 1\n            money_amount = int(query.split()[1])\n            customer_pqueue.put((-1 * money_amount, customer_id))\n            marked.append(False)\n        elif query == '2':\n            while marked[count] == True:\n                count += 1\n            marked[count] = True\n            out_list.append(str(count))\n        elif query == '3':\n            while customer_pqueue:\n                customer = customer_pqueue.get()\n                id = customer[1]\n                if marked[id] == False:\n                    out_list.append(str(id))\n                    marked[id] = True\n                    break\n    print(' '.join(out_list))\nmain()", "from heapq import heapify, heappop, heappush\nfrom collections import defaultdict\ncoun = 0\nminheap = []\nmaxheap = []\nans = []\ndic = defaultdict(int)\ntry:\n    for _ in range(int(input())):\n        a = list(map(int, input().split()))\n        if a[0] == 1:\n            coun += 1\n            dic[coun] = 0\n            heappush(maxheap, (-a[1], coun))\n            heappush(minheap, (coun, a[1]))\n        elif a[0] == 2:\n            (x, y) = heappop(minheap)\n            while dic[x] == 1:\n                (x, y) = heappop(minheap)\n            dic[x] = 1\n            ans.append(x)\n        else:\n            (x, y) = heappop(maxheap)\n            while dic[y] == 1:\n                (x, y) = heappop(maxheap)\n            dic[y] = 1\n            ans.append(y)\n    print(*ans)\nexcept:\n    print(*ans)", "import math\nimport heapq\nIP = lambda : list(map(int, input().split()))\nlst = []\ni = j = 1\nserved = [0] * (5 * 10 ** 5 + 1)\nres = []\nheapq.heapify(lst)\nfor _ in range(int(input())):\n    tmp = IP()\n    if tmp[0] == 1:\n        heapq.heappush(lst, (-tmp[1], i))\n        i += 1\n    elif tmp[0] == 2:\n        while served[j] == 1:\n            j += 1\n        served[j] = 1\n        res.append(j)\n    elif tmp[0] == 3:\n        per = heapq.heappop(lst)\n        while served[per[1]]:\n            per = heapq.heappop(lst)\n        served[per[1]] = 1\n        res.append(per[1])\nprint(' '.join(map(str, res)))", "import heapq\nmono = []\npoly = []\nd = {}\ncount = 1\nans = []\nq = int(input())\nfor i in range(q):\n    query = list(input().split())\n    if len(query) > 1:\n        heapq.heappush(mono, [count, int(query[1])])\n        heapq.heappush(poly, [-int(query[1]), count])\n        count += 1\n    elif query[0] == '2':\n        while 1:\n            p = heapq.heappop(mono)\n            try:\n                del d[p[0]]\n            except:\n                ans.append(p[0])\n                d[p[0]] = 1\n                break\n    elif query[0] == '3':\n        while 1:\n            p = heapq.heappop(poly)\n            try:\n                del d[p[1]]\n            except:\n                ans.append(p[1])\n                d[p[1]] = 1\n                break\nprint(*ans)", "from heapq import heappush, heappop\nheap = []\nclient_number = 1\nserved = [True]\nlast_served = 1\nfor i in range(int(input())):\n    q = input().split()\n    if q[0] == '3':\n        while served[heap[0][1]]:\n            heappop(heap)\n        (_, i) = heappop(heap)\n        print(i, end=' ')\n        served[i] = True\n    if q[0] == '2':\n        while served[last_served]:\n            last_served = last_served + 1\n        print(last_served, end=' ')\n        served[last_served] = True\n    if q[0] == '1':\n        heappush(heap, (-int(q[1]), client_number))\n        served.append(False)\n        client_number += 1", "import math\nimport heapq\n\ndef S():\n    return input()\n\ndef M():\n    return map(int, input().split())\n\ndef I():\n    return int(S())\n\ndef L():\n    return list(M())\nq = I()\na = []\ndi = {}\nm = 10000000\nk = 1\nt = 1\nar = []\nheapq.heapify(a)\nfor i in range(q):\n    l = L()\n    if len(l) == 2:\n        heapq.heappush(a, (m - l[1], l[1], k))\n        di[k] = 0\n        k += 1\n    elif l[0] == 2:\n        while di.get(t, 0) == 1:\n            t += 1\n        ar.append(t)\n        di[t] = 1\n        t += 1\n    else:\n        p = heapq.heappop(a)\n        while di.get(p[2]) == 1:\n            p = heapq.heappop(a)\n        di[p[2]] = 1\n        ar.append(p[2])\nprint(*ar)", "import sys\nsys.setrecursionlimit(1000000)\nfrom collections import defaultdict, deque, Counter\nfrom itertools import permutations\nfrom math import sqrt, gcd, pi, factorial\nfrom functools import reduce\nfrom sys import stdin\nfrom bisect import bisect_right, bisect_left\nfrom copy import copy\nfrom heapq import heapify, heappop, heappush\n\ndef solve(n, queries):\n    p = []\n    heapify(p)\n    served_indexes = set()\n    unserved_pairs = deque([])\n    ret = []\n    cnt = 0\n    for (i, query) in enumerate(queries):\n        if query[0] == 1:\n            cnt += 1\n            heappush(p, [-query[1], cnt])\n            unserved_pairs.append([cnt, query[1]])\n        elif query[0] == 2:\n            while True:\n                (index, value) = unserved_pairs.popleft()\n                if index in served_indexes:\n                    continue\n                served_indexes.add(index)\n                ret.append(index)\n                break\n        else:\n            while True:\n                (value, index) = heappop(p)\n                if index in served_indexes:\n                    continue\n                served_indexes.add(index)\n                ret.append(index)\n                break\n    return ret\nn = int(input())\nqueries = [list(map(int, input().split())) for _ in range(n)]\nans = solve(n, queries)\nprint(*ans)", "from collections import deque\nfrom heapq import heapify, heappop, heappush\nmono = deque()\npoly = []\na = 1\nseen = set()\nfor _ in range(int(input())):\n    while mono and mono[0] in seen:\n        mono.popleft()\n    while poly and poly[0][1] in seen:\n        heappop(poly)\n    p = list(map(int, input().split()))\n    if p[0] == 1:\n        mono.append(a)\n        heappush(poly, (-p[1], a))\n        a += 1\n    elif p[0] == 2:\n        q = mono.popleft()\n        seen.add(q)\n        print(q, end=' ')\n    else:\n        q = heappop(poly)[1]\n        print(q, end=' ')\n        seen.add(q)", "import heapq\nserved = []\ncur = 0\npq = []\nq = int(input())\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        heapq.heappush(pq, (-query[1], len(served)))\n        served.append(False)\n    elif query[0] == 2:\n        while served[cur]:\n            cur += 1\n        served[cur] = True\n        print(cur + 1, end=' ')\n    else:\n        while True:\n            (_, index) = heapq.heappop(pq)\n            if not served[index]:\n                break\n        served[index] = True\n        print(index + 1, end=' ')\nprint()", "import heapq\nserved = []\ncur = 0\npq = []\nq = int(input())\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        heapq.heappush(pq, (-query[1], len(served)))\n        served.append(False)\n    elif query[0] == 2:\n        while served[cur]:\n            cur += 1\n        served[cur] = True\n        print(cur + 1, end=' ')\n    else:\n        while True:\n            (_, index) = heapq.heappop(pq)\n            if not served[index]:\n                break\n        served[index] = True\n        print(index + 1, end=' ')\nprint()", "from heapq import heappop, heappush, heapify\nT = int(input())\ncust_served = [True]\ncust_money = [-1]\ncurr_m = 1\nN = 1\nheap = []\nfor _ in range(T):\n    l = list(map(int, input().split()))\n    if l[0] == 1:\n        cust_served.append(False)\n        cust_money.append(l[1])\n        heappush(heap, [-1 * l[1], N])\n        N += 1\n    elif l[0] == 2:\n        for i in range(curr_m, N):\n            if not cust_served[i]:\n                curr_m = i\n                cust_served[i] = True\n                print(i, end=' ')\n                break\n    elif l[0] == 3:\n        while 1:\n            el = heappop(heap)\n            if not cust_served[el[1]]:\n                cust_served[el[1]] = True\n                print(el[1], end=' ')\n                break", "from collections import deque\nfrom heapq import *\n\nclass Customer:\n\n    def __init__(self, cid, m):\n        self.cid = cid\n        self.m = m\n        self.served = False\n\n    def __lt__(self, other):\n        if self.m == other.m:\n            return self.cid < other.cid\n        return self.m < other.m\n\n    def __eq__(self, other):\n        return self.m == other.m\n\n    def __gt__(self, other):\n        return not (self < other or self == other)\n\n    def __repr__(self):\n        return 'cid: {}, m: {}'.format(self.cid, self.m)\nq = int(input())\nd = deque()\nh = []\nnext_id = 1\nout = []\nfor case in range(q):\n    query = [int(t) for t in input().split()]\n    if query[0] == 1:\n        m = query[1]\n        customer = Customer(next_id, -m)\n        next_id += 1\n        d.append(customer)\n        heappush(h, customer)\n    else:\n        if query[0] == 2:\n            customer = d.popleft()\n            while customer.served:\n                customer = d.popleft()\n        else:\n            customer = heappop(h)\n            while customer.served:\n                customer = heappop(h)\n        customer.served = True\n        out.append(str(customer.cid))\nprint(' '.join(out))", "import heapq\nmono = []\npoly = []\nd = {}\ncount = 1\nq = int(input())\nfor i in range(q):\n    query = list(input().split())\n    if len(query) > 1:\n        heapq.heappush(mono, [count])\n        heapq.heappush(poly, [-int(query[1]), count])\n        count += 1\n    elif query[0] == '2':\n        while 1:\n            p = heapq.heappop(mono)\n            try:\n                del d[p[0]]\n            except:\n                print(p[0], end=' ')\n                d[p[0]] = 1\n                break\n    elif query[0] == '3':\n        while 1:\n            p = heapq.heappop(poly)\n            try:\n                del d[p[1]]\n            except:\n                print(p[1], end=' ')\n                d[p[1]] = 1\n                break", "import sys\nfrom queue import PriorityQueue\nfrom queue import Queue\nl = sys.stdin.readlines()\ni = 0\nn = int(l[i].replace('\\n', ''))\ni = 1\nfilaClientes = {}\nat = 1\natendidos = ''\natAtual = 0\npQ = PriorityQueue()\nQ = Queue()\njaAtendido = [False] * n\nwhile True:\n    if len(l[i].replace('\\n', '').split()) == 2:\n        a = l[i].replace('\\n', '').split()\n        a = [int(a[0]), int(a[1])]\n    else:\n        a = int(l[i].replace('\\n', ''))\n    i = i + 1\n    if type(a) is list:\n        filaClientes[at] = a[1]\n        pQ.put((-a[1], at))\n        Q.put(at)\n        at += 1\n    elif a == 2:\n        while True:\n            b = Q.get()\n            if jaAtendido[b]:\n                continue\n            atendidos += str(b) + ' '\n            jaAtendido[b] = True\n            break\n    elif a == 3:\n        while True:\n            b = pQ.get()\n            if jaAtendido[b[1]]:\n                continue\n            atendidos += str(b[1]) + ' '\n            jaAtendido[b[1]] = True\n            break\n    if i == len(l) or i == n + 1:\n        break\nprint(atendidos.strip())", "import heapq\n\ndef solution(n: int, arr: [[int]]) -> [int]:\n    queue = []\n    heap = []\n    result = []\n    lastIndex = 0\n    for i in arr:\n        if i[0] == 1:\n            lastIndex += 1\n            element = [-i[1], lastIndex, False]\n            queue.append(element)\n            heapq.heappush(heap, element)\n        if i[0] == 2:\n            customer = queue.pop(0)\n            while customer[2] == True:\n                customer = queue.pop(0)\n            customer[2] = True\n            result.append(customer[1])\n        if i[0] == 3:\n            customer = heapq.heappop(heap)\n            while customer[2] == True:\n                customer = heapq.heappop(heap)\n            customer[2] = True\n            result.append(customer[1])\n    return result\n\ndef main():\n    n = int(input())\n    arr = [[int(j) for j in input().split(' ')] for i in range(n)]\n    print(' '.join([str(i) for i in solution(n, arr)]))\nmain()"]