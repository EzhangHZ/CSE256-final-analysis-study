["def solve(a, b, m):\n    s = 0\n    while m > 0 and a and b:\n        if a[-1] >= m:\n            m -= a.pop()\n            s += 1\n            break\n        elif len(a) == 1 or b[-1] > a[-1] + a[-2]:\n            m -= b.pop()\n            s += 2\n        else:\n            s += 1\n            m -= a.pop()\n    while m > 0 and a:\n        s += 1\n        m -= a.pop()\n    while m > 0 and b:\n        s += 2\n        m -= b.pop()\n    if m <= 0:\n        print(s)\n    else:\n        print(-1)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    u = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    (a, b) = ([], [])\n    for i in range(n):\n        if v[i] == 1:\n            a.append(u[i])\n        else:\n            b.append(u[i])\n    solve(sorted(a), sorted(b), m)", "__version__ = '2.1'\n__date__ = '2021-03-16'\nimport sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\nfrom math import inf\n\ndef solve(n, m, a, b):\n    if sum(a) < m:\n        return -1\n    b1 = list()\n    b2 = list()\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = inf\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] > m:\n            return answer\n    return answer\n\ndef main(argv=None):\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        print(solve(n, m, a, b))\n    return 0\nSTATUS = main()\nsys.exit(STATUS)", "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        v1 = []\n        v2 = []\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        for i in range(n):\n            if b[i] == 1:\n                v1.append(a[i])\n            else:\n                v2.append(a[i])\n        v1.sort(reverse=True)\n        v2.sort(reverse=True)\n        ls1 = []\n        ls2 = []\n        temp = 0\n        for i in v1:\n            temp += i\n            ls1.append(temp)\n        temp = 0\n        for i in v2:\n            temp += i\n            ls2.append(temp)\n        ls1.insert(0, 0)\n        ls2.insert(0, 0)\n        ans = inf\n        for i in range(len(ls1)):\n            cur = bisect_left(ls2, m - ls1[i])\n            if cur >= len(ls2):\n                cur -= 1\n            if ls1[i] + ls2[cur] >= m:\n                ans = min(ans, i + 2 * cur)\n                if cur == 0:\n                    break\n        if ans == inf:\n            print(-1)\n        else:\n            print(ans)\nmain()", "import sys\nN = int(200000.0 + 5)\nsys.setrecursionlimit(N)\n\ndef charming():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(zip(a, b))\n    c.sort(key=lambda x: x[0] / x[1], reverse=True)\n    res = 0\n    last = 0\n    sum = 0\n    for i in range(n):\n        if sum >= m:\n            break\n        sum += c[i][0]\n        res += c[i][1]\n        last = i\n    if sum < m:\n        print(-1)\n        return\n    if c[last][1] == 1:\n        print(res)\n        return\n    for i in range(last + 1, n):\n        if c[i][1] == 1 and sum - c[last][0] + c[i][0] >= m:\n            print(res - 1)\n            return\n    for i in range(last):\n        if c[i][1] == 1 and sum - c[i][0] >= m:\n            print(res - 1)\n            return\n    print(res)\nfor t in range(int(input())):\n    charming()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    (a, b) = (list(map(int, input().split())), list(map(int, input().split())))\n    imp = sorted([a[i] for i in range(n) if b[i] == 2])\n    not_imp = sorted([a[i] for i in range(n) if b[i] == 1])\n    res = 0\n    while (imp and not_imp) and m > 0:\n        if imp[-1] > sum(not_imp[-2:]) and not_imp[-1] < m:\n            m -= imp.pop()\n            res += 2\n        else:\n            m -= not_imp.pop()\n            res += 1\n    if m > 0:\n        while imp and m > 0:\n            m -= imp.pop()\n            res += 2\n        while not_imp and m > 0:\n            m -= not_imp.pop()\n            res += 1\n    if m > 0:\n        print(-1)\n    else:\n        print(res)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    arrA = []\n    arrB = []\n    for i in range(n):\n        if b[i] == 1:\n            arrA.append(a[i])\n        else:\n            arrB.append(a[i])\n    arrA.sort(reverse=True)\n    arrB.sort(reverse=True)\n    if sum(a) < m:\n        print(-1)\n    else:\n        i = 0\n        j = 0\n        space = 0\n        ans = 0\n        while space < m:\n            if i < len(arrA):\n                space += arrA[i]\n                i += 1\n                ans += 1\n            else:\n                space += arrB[j]\n                j += 1\n                ans += 2\n        i -= 1\n        mini = ans\n        flag = True\n        while i > -1:\n            space -= arrA[i]\n            ans -= 1\n            i -= 1\n            while space < m and j < len(arrB):\n                space += arrB[j]\n                j += 1\n                ans += 2\n            if space < m:\n                flag = False\n                break\n            if ans < mini:\n                mini = ans\n        print(mini)", "rn = lambda : int(input())\nrns = lambda : map(int, input().split())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nYN = lambda x: print('YES') if x else print('NO')\nmod = lambda x: x % (10 ** 9 + 7)\n\ndef d(a):\n    d = {}\n    for i in a:\n        if i not in d:\n            d[i] = 0\n        d[i] += 1\n    return d\nfor _ in range(rn()):\n    (n, m) = rns()\n    a = rl()\n    b = rl()\n    if sum(a) < m:\n        print(-1)\n    else:\n        ones = []\n        twos = []\n        for i in range(n):\n            if b[i] == 1:\n                ones.append(a[i])\n            else:\n                twos.append(a[i])\n        ones.sort(reverse=True)\n        twos.sort(reverse=True)\n        i = 0\n        j = 0\n        acc = 0\n        while acc < m and i < len(ones):\n            acc += ones[i]\n            i += 1\n        while acc < m and j < len(twos):\n            acc += twos[j]\n            j += 1\n        ans = i + 2 * j\n        while i > 0:\n            i -= 1\n            acc -= ones[i]\n            while acc < m and j < len(twos):\n                acc += twos[j]\n                j += 1\n            if acc >= m:\n                ans = min(ans, i + 2 * j)\n            else:\n                break\n        print(ans)", "import sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\ndef resolve():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        one = [0] + list(accumulate(sorted([a for (a, b) in zip(A, B) if b == 1], reverse=True)))\n        two = [0] + list(accumulate(sorted([a for (a, b) in zip(A, B) if b == 2], reverse=True)))\n        res = f_inf\n        for i in range(len(two)):\n            diff = m - two[i]\n            idx = bisect_left(one, diff)\n            if idx < len(one):\n                res = min(res, 2 * i + idx)\n        print(res if res != f_inf else -1)\nresolve()", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    memories = list(map(int, input().split()))\n    points = list(map(int, input().split()))\n    if sum(memories) < m:\n        print(-1)\n    else:\n        ones = []\n        twos = []\n        for i in range(n):\n            if points[i] == 1:\n                ones.append(memories[i])\n            else:\n                twos.append(memories[i])\n        ones.sort(reverse=True)\n        twos.sort(reverse=True)\n        a = len(ones)\n        b = len(twos)\n        (i, j) = (0, 0)\n        space = 0\n        ans = 0\n        while space < m:\n            if i < a:\n                space += ones[i]\n                i += 1\n                ans += 1\n            else:\n                space += twos[j]\n                j += 1\n                ans += 2\n        flag = True\n        res = ans\n        i -= 1\n        while i >= 0:\n            ans -= 1\n            space -= ones[i]\n            i -= 1\n            while j < b and space < m:\n                space += twos[j]\n                j += 1\n                ans += 2\n            if space < m:\n                flag = False\n                break\n            if ans < res:\n                res = ans\n        print(res)", "for t in range(int(input())):\n    (n, m) = [int(k) for k in input().split()]\n    a = [int(k) for k in input().split()]\n    b = [int(k) for k in input().split()]\n    if m > sum(a):\n        print(-1)\n        continue\n    imp = []\n    non = []\n    for i in range(n):\n        if b[i] == 2:\n            imp += [a[i]]\n        else:\n            non += [a[i]]\n    ans = 0\n    imp.sort(reverse=True)\n    non.sort(reverse=True)\n    il = len(imp)\n    nl = len(non)\n    ii = 0\n    ni = 0\n    while m > 0:\n        if ni < nl:\n            m -= non[ni]\n            ni += 1\n            ans += 1\n        else:\n            m -= imp[ii]\n            ii += 1\n            ans += 2\n    fin = ans\n    ni -= 1\n    while ni >= 0:\n        m += non[ni]\n        ans -= 1\n        ni -= 1\n        while m > 0 and ii < il:\n            m -= imp[ii]\n            ii += 1\n            ans += 2\n        if m > 0:\n            break\n        if ans < fin:\n            fin = ans\n    print(fin)", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    i = 0\n    q = [None, [], []]\n    for v in map(int, input().split()):\n        q[v].append(a[i])\n        i += 1\n    aa = q[1]\n    bb = q[2]\n    aa.sort(reverse=True)\n    bb.sort(reverse=True)\n    cc = [0] * (len(bb) + 1)\n    for i in range(len(bb)):\n        cc[i + 1] = cc[i] + bb[i]\n    s = m\n    z = len(cc)\n    ans = int(1000000000.0)\n    for i in range(len(aa)):\n        idx = bisect_left(cc, s)\n        if idx < z:\n            ans = min(ans, i + idx * 2)\n        s -= aa[i]\n    i = len(aa)\n    idx = bisect_left(cc, s)\n    if idx < z:\n        ans = min(ans, i + idx * 2)\n    if ans == int(1000000000.0):\n        ans = -1\n    print(ans)\nfor i in range(int(input())):\n    solve()", "import sys\nfrom math import inf\nfrom itertools import accumulate\nfrom bisect import bisect_left\n\ndef main():\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        (N, M) = (int(i) for i in sys.stdin.readline().split())\n        memory = [int(i) for i in sys.stdin.readline().split()]\n        conv = [int(i) for i in sys.stdin.readline().split()]\n        singles = []\n        doubles = []\n        for (m, c) in zip(memory, conv):\n            if c == 1:\n                singles.append(m)\n            else:\n                doubles.append(m)\n        singles.sort(reverse=True)\n        doubles.sort(reverse=True)\n        singles_prefix = list(accumulate(singles))\n        doubles_prefix = list(accumulate(doubles))\n        soln = inf\n        j = bisect_left(doubles_prefix, M)\n        if j < len(doubles_prefix):\n            loss = (j + 1) * 2\n            soln = min(soln, loss)\n        for (i, s) in enumerate(singles_prefix):\n            d = M - s\n            loss = i + 1\n            if d <= 0:\n                soln = min(soln, loss)\n            else:\n                j = bisect_left(doubles_prefix, d)\n                if j < len(doubles_prefix):\n                    loss += (j + 1) * 2\n                    soln = min(soln, loss)\n        print(-1 if soln == inf else soln)\nmain()", "t = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if sum(a) < m:\n        print(-1)\n    else:\n        one_arr = []\n        two_arr = []\n        for (app, score) in zip(a, b):\n            if score == 1:\n                one_arr.append(app)\n            else:\n                two_arr.append(app)\n        one_arr.sort()\n        two_arr.sort()\n        counter = 0\n        while m > 0:\n            if len(one_arr) == 0:\n                m -= two_arr[-1]\n                del two_arr[-1]\n                counter += 2\n            elif len(two_arr) == 0:\n                m -= one_arr[-1]\n                del one_arr[-1]\n                counter += 1\n            elif m <= one_arr[-1]:\n                m -= one_arr[-1]\n                counter += 1\n                del one_arr[-1]\n            elif len(one_arr) > 1:\n                if one_arr[-1] + one_arr[-2] > two_arr[-1]:\n                    m -= one_arr[-1]\n                    counter += 1\n                    del one_arr[-1]\n                else:\n                    m -= two_arr[-1]\n                    counter += 2\n                    del two_arr[-1]\n            else:\n                m -= two_arr[-1]\n                counter += 2\n                del two_arr[-1]\n        print(counter)", "def readInt():\n    return int(input())\n\ndef readInts():\n    return [int(x) for x in input().split()]\n\ndef readBin():\n    return [int(x) for x in readString()]\n\ndef readString():\n    return input().rstrip()\n\ndef readCase():\n    return readString()\n\ndef solve(n, m, usage, convenience):\n    normal = []\n    high = []\n    max_loss = 2 * n + 1\n    for x in range(n):\n        if convenience[x] == 1:\n            normal.append(usage[x])\n        else:\n            high.append(usage[x])\n    normal.sort(reverse=True)\n    high.sort(reverse=True)\n    loss = 0\n    normalPos = 0\n    highPos = 0\n    while m > 0 and normalPos < len(normal):\n        m -= normal[normalPos]\n        normalPos += 1\n        loss += 1\n    best_loss = max_loss\n    if m <= 0:\n        best_loss = loss\n    normalPos -= 1\n    while highPos < len(high):\n        m -= high[highPos]\n        highPos += 1\n        loss += 2\n        while normalPos >= 0:\n            if m + normal[normalPos] <= 0:\n                m += normal[normalPos]\n                normalPos -= 1\n                loss -= 1\n            else:\n                break\n        if m <= 0 and loss < best_loss:\n            best_loss = loss\n    if best_loss == max_loss:\n        return -1\n    else:\n        return best_loss\ncases = readInt()\nfor case in range(cases):\n    (n, m) = readInts()\n    usage = readInts()\n    convenience = readInts()\n    print(solve(n, m, usage, convenience))", "cases = int(input())\nfor i in range(cases):\n    (n, m) = map(int, input().split())\n    twos = []\n    ones = []\n    mem = list(map(int, input().split()))\n    conv = list(map(int, input().split()))\n    for i in range(n):\n        if conv[i] == 2:\n            twos.append(mem[i])\n        else:\n            ones.append(mem[i])\n    twos.sort()\n    ones.sort()\n    convCount = 0\n    while m > 0 and twos and ones:\n        if ones[-1] >= m:\n            convCount += 1\n            m -= ones.pop()\n            break\n        if len(ones) == 1 or twos[-1] > ones[-1] + ones[-2]:\n            convCount += 2\n            m -= twos.pop()\n        else:\n            convCount += 1\n            m -= ones.pop()\n    while m > 0 and twos:\n        convCount += 2\n        m -= twos.pop()\n    while m > 0 and ones:\n        convCount += 1\n        m -= ones.pop()\n    print(convCount if m <= 0 else -1)", "from bisect import bisect_left\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    i = 0\n    q = [None, [], []]\n    for v in map(int, input().split()):\n        q[v].append(a[i])\n        i += 1\n    aa = q[1]\n    bb = q[2]\n    aa.sort(reverse=True)\n    bb.sort(reverse=True)\n    cc = [0] * (len(bb) + 1)\n    for i in range(len(bb)):\n        cc[i + 1] = cc[i] + bb[i]\n    s = m\n    z = len(cc)\n    ans = int(1000000000.0)\n    for i in range(len(aa)):\n        idx = bisect_left(cc, s)\n        if idx < z:\n            ans = min(ans, i + idx * 2)\n        s -= aa[i]\n    i = len(aa)\n    idx = bisect_left(cc, s)\n    if idx < z:\n        ans = min(ans, i + idx * 2)\n    if ans == int(1000000000.0):\n        ans = -1\n    print(ans)\nfor i in range(int(input())):\n    solve()", "from bisect import bisect_left\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    i = 0\n    q = [None, [], []]\n    for v in map(int, input().split()):\n        q[v].append(a[i])\n        i += 1\n    aa = q[1]\n    bb = q[2]\n    aa.sort(reverse=True)\n    bb.sort(reverse=True)\n    cc = [0] * (len(bb) + 1)\n    for i in range(len(bb)):\n        cc[i + 1] = cc[i] + bb[i]\n    s = m\n    z = len(cc)\n    ans = int(1000000000.0)\n    for i in range(len(aa)):\n        idx = bisect_left(cc, s)\n        if idx < z:\n            ans = min(ans, i + idx * 2)\n        s -= aa[i]\n    i = len(aa)\n    idx = bisect_left(cc, s)\n    if idx < z:\n        ans = min(ans, i + idx * 2)\n    if ans == int(1000000000.0):\n        ans = -1\n    print(ans)\nfor i in range(int(input())):\n    solve()", "def main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        d = {'1': [], '2': []}\n        for (a, b) in zip(map(int, input().split()), input().split()):\n            d[b].append(a)\n        if sum(map(sum, d.values())) < m:\n            print(-1)\n            continue\n        (i, j, k, best) = (0, 0, len(d['1']), 1000000)\n        ri = [*sorted(d['1']), *sorted(d['2'], reverse=True)]\n        while i < n:\n            while i < n and m > 0:\n                m -= ri[i]\n                i += 1\n            if m <= 0:\n                while m + ri[j] <= 0:\n                    m += ri[j]\n                    j += 1\n                x = (i if i < k else i * 2 - k) - (j if j < k else j * 2 - k)\n                if best > x:\n                    best = x\n            m += ri[j]\n            j += 1\n        print(best)\nmain()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    x = []\n    y = []\n    for i in range(n):\n        if b[i] == 1:\n            x.append(a[i])\n        else:\n            y.append(a[i])\n    x.sort(reverse=True)\n    y.sort(reverse=True)\n    (t, cost) = (0, 0)\n    p2 = -1\n    ans = 210000000000\n    while p2 + 1 < len(y) and t < m:\n        p2 += 1\n        t += y[p2]\n        cost += 2\n    if t >= m:\n        ans = min(ans, cost)\n    for i in range(len(x)):\n        t += x[i]\n        cost += 1\n        while p2 >= 0 and t - y[p2] >= m:\n            t -= y[p2]\n            p2 -= 1\n            cost -= 2\n        if t >= m:\n            ans = min(ans, cost)\n    if ans >= 210000000000:\n        print(-1)\n    else:\n        print(ans)", "cases = int(input())\nfor i in range(cases):\n    (n, m) = map(int, input().split())\n    twos = []\n    ones = []\n    mem = list(map(int, input().split()))\n    conv = list(map(int, input().split()))\n    for i in range(n):\n        if conv[i] == 2:\n            twos.append(mem[i])\n        else:\n            ones.append(mem[i])\n    twos.sort()\n    ones.sort()\n    convCount = 0\n    while m > 0 and twos and ones:\n        if ones[-1] >= m:\n            convCount += 1\n            m -= ones.pop()\n            break\n        elif twos[-1] >= m:\n            convCount += 2\n            m -= twos.pop()\n            break\n        if len(ones) == 1 or twos[-1] > ones[-1] + ones[-2]:\n            convCount += 2\n            m -= twos.pop()\n        else:\n            convCount += 1\n            m -= ones.pop()\n    while m > 0 and ones:\n        convCount += 1\n        m -= ones.pop()\n    while m > 0 and twos:\n        convCount += 2\n        m -= twos.pop()\n    print(convCount if m <= 0 else -1)", "def solve():\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    regular = []\n    important = []\n    for i in range(n):\n        if b[i] == 1:\n            regular.append(a[i])\n        else:\n            important.append(a[i])\n    regular.sort(reverse=True)\n    important.sort(reverse=True)\n    s_reg = 0\n    s_imp = sum(important)\n    index_important = len(important)\n    res = 1000000000.0 + 1\n    for i in range(len(regular) + 1):\n        while index_important > 0 and s_reg + s_imp - important[index_important - 1] >= m:\n            index_important -= 1\n            s_imp -= important[index_important]\n        if s_reg + s_imp >= m:\n            res = min(res, 2 * index_important + i)\n        if i != len(regular):\n            s_reg += regular[i]\n    if res != 1000000000.0 + 1:\n        print(res)\n        return\n    else:\n        print(-1)\n        return\nfor i in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef solution(n, m, a, b):\n    l_1 = []\n    l_2 = []\n    diff_memory = 0\n    sol = 10 ** 10\n    sum_a = sum(a)\n    if sum_a < m:\n        print(-1)\n        return\n    l_1 = [ai for (ai, bi) in zip(a, b) if bi == 1]\n    l_2_slave = [ai for (ai, bi) in zip(a, b) if bi == 2]\n    l_1.sort(reverse=True)\n    l_2_slave.sort(reverse=True)\n    l_2 = []\n    for i in range(-1, 2 * len(l_2_slave) - 1):\n        if i % 2 == 1:\n            l_2.append(0)\n        else:\n            l_2.append(l_2_slave[i // 2])\n    partial_l1 = [0]\n    for elem in l_1:\n        partial_l1.append(partial_l1[-1] + elem)\n    partial_l2 = [0]\n    for elem in l_2:\n        partial_l2.append(partial_l2[-1] + elem)\n    i1 = len(partial_l1) - 1\n    for i2 in range(len(partial_l2)):\n        while i1 >= 0:\n            if partial_l1[i1] + partial_l2[i2] >= m:\n                sol = min(sol, i1 + i2)\n                i1 -= 1\n            else:\n                break\n    print(sol)\nT = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    solution(n, m, a, b)", "def clean(apps, free, app_mem, points):\n    if sum(app_mem) < free:\n        return -1\n    elif sum(app_mem) == free:\n        return sum(points)\n    else:\n        (s2, s1) = (0, 0)\n        (mem1, mem2) = ([], [])\n        for i in range(apps):\n            if points[i] == 1:\n                mem1.append(app_mem[i])\n            else:\n                mem2.append(app_mem[i])\n                s2 += app_mem[i]\n        (mem1.sort(reverse=True), mem2.sort(reverse=True))\n        ans = float('inf')\n        k = len(mem2) - 1\n        for j in range(len(mem1) + 1):\n            while k >= 0 and s2 - mem2[k] + s1 >= free:\n                s2 -= mem2[k]\n                k -= 1\n            if s1 + s2 >= free:\n                ans = min(ans, 2 * (k + 1) + j)\n            if j < len(mem1):\n                s1 += mem1[j]\n        return ans\nfor test in range(int(input())):\n    (n, m) = map(int, input().split())\n    memory = list(map(int, input().split()))\n    pts = list(map(int, input().split()))\n    print(clean(n, m, memory, pts))", "def find():\n    (n, m) = map(int, input().split())\n    mem = tuple(input().split())\n    val = tuple(input().split())\n    a = []\n    b = []\n    for i in range(n):\n        a.append(int(mem[i])) if int(val[i]) == 1 else b.append(int(mem[i]))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    sumA = 0\n    sumB = sum(b)\n    j = len(b)\n    res = 0\n    for i in range(len(a) + 1):\n        while j > 0 and sumA + sumB - b[j - 1] >= m:\n            j -= 1\n            sumB -= b[j]\n        if sumA + sumB >= m:\n            tmp = i + 2 * j\n            res = res or tmp\n            res = min(res, tmp)\n        if i != len(a):\n            sumA += a[i]\n    print(res if res else -1)\nfor i in range(int(input())):\n    find()", "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        v1 = []\n        v2 = []\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        for i in range(n):\n            if b[i] == 1:\n                v1.append(a[i])\n            else:\n                v2.append(a[i])\n        v1.sort(reverse=True)\n        v2.sort(reverse=True)\n        ls1 = []\n        ls2 = []\n        temp = 0\n        for i in v1:\n            temp += i\n            ls1.append(temp)\n        temp = 0\n        for i in v2:\n            temp += i\n            ls2.append(temp)\n        ls1.insert(0, 0)\n        ls2.insert(0, 0)\n        ans = inf\n        for i in range(len(ls1)):\n            cur = bisect_left(ls2, m - ls1[i])\n            if cur >= len(ls2):\n                cur -= 1\n            if ls1[i] + ls2[cur] >= m:\n                ans = min(ans, i + 2 * cur)\n        if ans == inf:\n            print(-1)\n        else:\n            print(ans)\nmain()", "def dell(mlst, imp, m):\n    n = len(mlst)\n    cc = []\n    for i in range(n):\n        cc.append((mlst[i] / imp[i], i))\n    cc.sort()\n    sm = lose = 0\n    i = place2 = place = place1 = -1\n    for i in range(n - 1, -1, -1):\n        place = cc[i][1]\n        sm += mlst[place]\n        lose += imp[place]\n        if imp[place] == 2:\n            place2 = place\n        else:\n            place1 = place\n        if sm >= m:\n            break\n    if sm < m:\n        return -1\n    if place == place2:\n        if place1 != -1 and sm - mlst[place1] >= m:\n            return lose - 1\n        i -= 1\n        while i >= 0 and imp[cc[i][1]] == 2:\n            i -= 1\n        if i >= 0 and sm - mlst[place2] + mlst[cc[i][1]] >= m:\n            return lose - 1\n    return lose\nt = int(input())\nfor u in range(t):\n    mm = input().split()\n    ml = list(map(int, input().split()))\n    imp = list(map(int, input().split()))\n    print(dell(ml, imp, int(mm[1])))", "import sys\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    cost1 = []\n    cost2 = []\n    for i in range(n):\n        if b[i] == 1:\n            cost1.append(a[i])\n        else:\n            cost2.append(a[i])\n    cost1.sort(reverse=True)\n    cost2.sort(reverse=True)\n    i = -1\n    ans = sys.maxsize\n    cost = 0\n    total_memory = 0\n    while i + 1 < len(cost2) and total_memory < m:\n        i += 1\n        total_memory += cost2[i]\n        cost += 2\n    if total_memory >= m:\n        ans = min(ans, cost)\n    for j in range(len(cost1)):\n        total_memory += cost1[j]\n        cost += 1\n        while i >= 0 and total_memory - cost2[i] >= m:\n            cost -= 2\n            total_memory -= cost2[i]\n            i -= 1\n        if total_memory >= m:\n            ans = min(ans, cost)\n    if ans == sys.maxsize:\n        print(-1)\n    else:\n        print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    x = []\n    y = []\n    for i in range(n):\n        if b[i] == 1:\n            x.append(a[i])\n        else:\n            y.append(a[i])\n    x.sort(reverse=True)\n    y.sort(reverse=True)\n    (t, cost) = (0, 0)\n    p2 = -1\n    ans = 210000000000\n    while p2 + 1 < len(y) and t < m:\n        p2 += 1\n        t += y[p2]\n        cost += 2\n    if t >= m:\n        ans = min(ans, cost)\n    for i in range(len(x)):\n        t += x[i]\n        cost += 1\n        while p2 >= 0 and t - y[p2] >= m:\n            t -= y[p2]\n            p2 -= 1\n            cost -= 2\n        if t >= m:\n            ans = min(ans, cost)\n    if ans >= 210000000000:\n        print(-1)\n    else:\n        print(ans)", "def solve():\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    mem = input().split()\n    unit = input().split()\n    regular = []\n    important = []\n    for i in range(n):\n        mem[i] = int(mem[i])\n        unit[i] = int(unit[i])\n        if unit[i] == 1:\n            regular.append(mem[i])\n        else:\n            important.append(mem[i])\n    regular.sort(reverse=True)\n    important.sort(reverse=True)\n    sum_regular = 0\n    sum_important = sum(important)\n    index_important = len(important)\n    res = 1000000000.0 + 1\n    for i in range(len(regular) + 1):\n        while index_important > 0 and sum_regular + sum_important - important[index_important - 1] >= m:\n            index_important -= 1\n            sum_important -= important[index_important]\n        if sum_regular + sum_important >= m:\n            res = min(res, 2 * index_important + i)\n        if i != len(regular):\n            sum_regular += regular[i]\n    if res != 1000000000.0 + 1:\n        return res\n    else:\n        return -1\nno_tests = int(input())\nresults = []\nfor i in range(no_tests):\n    results.append(solve())\nfor result in results:\n    print(result)", "rn = lambda : int(input())\nrns = lambda : map(int, input().split())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nYN = lambda x: print('YES') if x else print('NO')\nmod = lambda x: x % (10 ** 9 + 7)\n\ndef d(a):\n    d = {}\n    for i in a:\n        if i not in d:\n            d[i] = 0\n        d[i] += 1\n    return d\nfor _ in range(rn()):\n    (n, m) = rns()\n    a = rl()\n    b = rl()\n    if sum(a) < m:\n        print(-1)\n    else:\n        ones = []\n        twos = []\n        for i in range(n):\n            if b[i] == 1:\n                ones.append(a[i])\n            else:\n                twos.append(a[i])\n        ones.sort(reverse=True)\n        twos.sort(reverse=True)\n        i = 0\n        j = 0\n        acc = 0\n        while acc < m and i < len(ones):\n            acc += ones[i]\n            i += 1\n        while acc < m and j < len(twos):\n            acc += twos[j]\n            j += 1\n        ans = i + 2 * j\n        while i > 0:\n            i -= 1\n            acc -= ones[i]\n            while acc < m and j < len(twos):\n                acc += twos[j]\n                j += 1\n            if acc >= m:\n                ans = min(ans, i + 2 * j)\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, g) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if g > sum(a):\n        print(-1)\n        continue\n    (p1, p2) = ([], [])\n    for i in range(n):\n        if b[i] == 1:\n            p1.append(a[i])\n        else:\n            p2.append(a[i])\n    (p1, p2) = (sorted(p1, reverse=True), sorted(p2, reverse=True))\n    (i, j, sp1, sp2, o) = (-1, len(p2) - 1, 0, sum(p2), 2 * n + 1)\n    for i in range(-1, len(p1)):\n        if i >= 0:\n            sp1 += p1[i]\n        while j >= 0 and sp1 + sp2 - p2[j] >= g:\n            sp2 -= p2[j]\n            j -= 1\n        if sp1 + sp2 >= g:\n            o = min(o, i + 1 + 2 * (j + 1))\n    print(o)", "for i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    one = []\n    two = []\n    l1 = l2 = 0\n    for j in range(n):\n        if b[j] == 1:\n            one.append(a[j])\n            l1 += 1\n        else:\n            two.append(a[j])\n            l2 += 1\n    one.sort(reverse=True)\n    two.sort(reverse=True)\n    for j in range(1, l1):\n        one[j] += one[j - 1]\n    for j in range(1, l2):\n        two[j] += two[j - 1]\n    if sum(a) < m:\n        print(-1)\n    else:\n        points = 100000000000\n        for j in range(l2):\n            if two[j] >= m:\n                points = min(points, 2 * (j + 1))\n                break\n        for j in range(l1):\n            if one[j] >= m:\n                points = min(points, j + 1)\n                break\n        j = 0\n        k = l2 - 1\n        while j != l1 and k != -1:\n            if one[j] + two[k] < m:\n                j += 1\n            else:\n                points = min(points, j + 1 + 2 * (k + 1))\n                k -= 1\n        print(points)", "import sys\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (reg, imp) = ([], [])\n    for i in range(n):\n        if b[i] == 1:\n            reg.append(a[i])\n        else:\n            imp.append(a[i])\n    reg.sort(reverse=True)\n    imp.sort(reverse=True)\n    (reg_len, imp_len) = (len(reg), len(imp))\n    r = imp_len\n    ans = sys.maxsize\n    (curSumA, curSumB) = (0, sum(imp))\n    for i in range(reg_len + 1):\n        while r > 0 and curSumA + curSumB - imp[r - 1] >= k:\n            r -= 1\n            curSumB -= imp[r]\n        if curSumA + curSumB >= k:\n            ans = min(ans, 2 * r + i)\n        if i != reg_len:\n            curSumA += reg[i]\n    print(-1 if ans == sys.maxsize else ans)", "__version__ = '2.0'\n__date__ = '2021-03-16'\nimport sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\nfrom math import inf\n\ndef solve(n, m, a, b):\n    if sum(a) < m:\n        return -1\n    b1 = list()\n    b2 = list()\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = inf\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n    return answer\n\ndef main(argv=None):\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        print(solve(n, m, a, b))\n    return 0\nSTATUS = main()\nsys.exit(STATUS)", "t = int(input())\nfor j in range(t):\n    (n, m) = tuple(map(int, input().split(' ')))\n    a = list(map(int, input().split(' ')))\n    b = list(map(int, input().split(' ')))\n    one = []\n    two = []\n    for i in range(n):\n        if b[i] == 1:\n            one.append(a[i])\n        else:\n            two.append(a[i])\n    two.sort(key=lambda x: -x)\n    one.sort(key=lambda x: -x)\n    (sum1, sum2) = (0, sum(two))\n    r = len(two)\n    INF = 9999999999999\n    ans = INF\n    for i in range(len(one) + 1):\n        while r > 0 and sum1 + sum2 - two[r - 1] >= m:\n            sum2 -= two[r - 1]\n            r -= 1\n        if sum1 + sum2 >= m:\n            ans = min(ans, i + 2 * r)\n        if i < len(one):\n            sum1 += one[i]\n    print('-1' if ans == INF else str(ans))", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    release = [int(i) for i in input().split()]\n    cost = [int(i) for i in input().split()]\n    one_cost = [release[i] for i in range(n) if cost[i] == 1]\n    two_cost = [release[i] for i in range(n) if cost[i] == 2]\n    one_cost.sort(reverse=True)\n    two_cost.sort(reverse=True)\n    one_index = 0\n    two_index = 0\n    cur = 0\n    ans = 0\n    while True:\n        if cur >= m:\n            break\n        if two_index >= len(two_cost) and one_index >= len(one_cost):\n            break\n        if two_index >= len(two_cost):\n            cur += one_cost[one_index]\n            ans += 1\n            one_index += 1\n        elif one_index >= len(one_cost):\n            cur += two_cost[two_index]\n            ans += 2\n            two_index += 1\n        elif one_cost[one_index] >= two_cost[two_index] or cur + one_cost[one_index] >= m:\n            cur += one_cost[one_index]\n            ans += 1\n            one_index += 1\n        elif one_index + 1 < len(one_cost) and one_cost[one_index] + one_cost[one_index + 1] >= two_cost[two_index]:\n            cur += one_cost[one_index]\n            ans += 1\n            one_index += 1\n        else:\n            cur += two_cost[two_index]\n            ans += 2\n            two_index += 1\n    print(ans if cur >= m else -1)", "import sys\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    mem = list(map(int, input().split()))\n    cost = list(map(int, input().split()))\n    arr1 = []\n    arr2 = []\n    for i in range(n):\n        if cost[i] == 1:\n            arr1.append(mem[i])\n        else:\n            arr2.append(mem[i])\n    arr1.sort(reverse=True)\n    arr2.sort(reverse=True)\n    sumb = sum(arr2)\n    suma = 0\n    r = len(arr2)\n    ans = int(sys.maxsize)\n    for i in range(len(arr1) + 1):\n        while r > 0 and suma + sumb - arr2[r - 1] >= m:\n            r -= 1\n            sumb -= arr2[r]\n        if suma + sumb >= m:\n            ans = min(ans, i + r * 2)\n        if i < len(arr1):\n            suma += arr1[i]\n    if ans < int(sys.maxsize):\n        print(ans)\n    else:\n        print(-1)", "import bisect\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    l1 = sorted([a[i] for i in range(n) if b[i] == 1], reverse=True)\n    l2 = sorted([a[i] for i in range(n) if b[i] == 2], reverse=True)\n    pre1 = [0]\n    pre2 = []\n    t1 = 0\n    t2 = 0\n    for i in range(0, len(l1)):\n        t1 += l1[i]\n        pre1.append(t1)\n    for i in range(0, len(l2)):\n        t2 += l2[i]\n        pre2.append(t2)\n    ans = 10000000000\n    for i in range(len(pre1)):\n        l = i\n        num = m - pre1[i]\n        if num > 0:\n            ind = bisect.bisect_left(pre2, num)\n            if ind == len(l2):\n                continue\n            l += 2 * (ind + 1)\n        ans = min(l, ans)\n    if ans == 10000000000:\n        print('-1')\n    else:\n        print(ans)", "import sys, io, os, time\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\nimport bisect, math, heapq\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\ninput = sys.stdin.readline\nfor ii in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    one = []\n    two = []\n    for i in range(n):\n        if b[i] == 1:\n            one.append(a[i])\n        else:\n            two.append(a[i])\n    i = 0\n    j = 0\n    one.sort(reverse=True)\n    two.sort(reverse=True)\n    for i in range(1, len(one)):\n        one[i] += one[i - 1]\n    for i in range(1, len(two)):\n        two[i] += two[i - 1]\n    one = [0] + one\n    two = [0] + two\n    ans = float('inf')\n    n1 = len(one)\n    n2 = len(two)\n    for i in range(n1):\n        need = m - one[i]\n        if need <= 0:\n            ans = min(ans, i)\n            continue\n        pos = bisect.bisect_left(two, need)\n        if pos == n2:\n            continue\n        elif two[pos] + one[i] < m:\n            continue\n        else:\n            ans = min(ans, i + pos * 2)\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)", "tests = int(input())\nwhile tests > 0:\n    (apps, clean) = list(map(int, input().split()))\n    storage = list(map(int, input().split()))\n    conv = list(map(int, input().split()))\n    if sum(storage) < clean:\n        print(-1)\n        tests -= 1\n        continue\n    arr1 = list()\n    arr2 = list()\n    for i in range(apps):\n        if conv[i] == 1:\n            arr1.append(storage[i])\n        else:\n            arr2.append(storage[i])\n    arr1.sort(reverse=True)\n    arr2.sort(reverse=True)\n    if clean in arr1:\n        print(1)\n        tests -= 1\n        continue\n    else:\n        index1 = 0\n        index2 = 0\n        convenience = 0\n        while clean > 0:\n            if index1 < len(arr1) and arr1[index1] >= clean:\n                convenience += 1\n                break\n            state1 = 0\n            state2 = 0\n            if index1 < len(arr1):\n                state1 = arr1[index1]\n            if index2 < len(arr2):\n                state2 = arr2[index2]\n            if index1 < len(arr1) - 1:\n                state1 += arr1[index1 + 1]\n            if state2 > state1:\n                clean -= state2\n                index2 += 1\n                convenience += 2\n            else:\n                clean -= arr1[index1]\n                index1 += 1\n                convenience += 1\n        print(convenience)\n    tests -= 1", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    memories = list(map(int, input().split()))\n    convenience = list(map(int, input().split()))\n    (X, Y) = ([], [])\n    for (a, b) in zip(memories, convenience):\n        if b == 1:\n            X.append(a)\n        else:\n            Y.append(a)\n    X.sort(reverse=True)\n    Y.sort()\n    (i, j) = (0, 0)\n    suma = sum(Y)\n    puntos = float('inf')\n    while i <= len(X):\n        while j < len(Y) and suma - Y[j] >= m:\n            suma -= Y[j]\n            j += 1\n        if suma >= m:\n            puntos = min(puntos, i + 2 * (len(Y) - j))\n        if i < len(X):\n            suma += X[i]\n        i += 1\n    if suma < m:\n        print(-1)\n        continue\n    print(puntos)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    memories = list(map(int, input().split()))\n    convenience = list(map(int, input().split()))\n    (X, Y) = ([], [])\n    for (a, b) in zip(memories, convenience):\n        if b == 1:\n            X.append(a)\n        else:\n            Y.append(a)\n    X.sort(reverse=True)\n    Y.sort()\n    (i, j) = (0, 0)\n    suma = sum(Y)\n    puntos = float('inf')\n    while i <= len(X):\n        while j < len(Y) and suma - Y[j] >= m:\n            suma -= Y[j]\n            j += 1\n        if suma >= m:\n            puntos = min(puntos, i + 2 * (len(Y) - j))\n        if i < len(X):\n            suma += X[i]\n        i += 1\n    if suma < m:\n        print(-1)\n        continue\n    print(puntos)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    (X, Y) = ([], [])\n    for (a, b) in zip(A, B):\n        if b == 1:\n            X.append(a)\n        else:\n            Y.append(a)\n    X.sort(reverse=True)\n    Y.sort()\n    (i, j) = (0, 0)\n    cur = sum(Y)\n    ans = float('inf')\n    while i <= len(X):\n        while j < len(Y) and cur - Y[j] >= m:\n            cur -= Y[j]\n            j += 1\n        if cur >= m:\n            ans = min(ans, i + (len(Y) - j) * 2)\n        if i < len(X):\n            cur += X[i]\n        i += 1\n    print(ans if ans < float('inf') else -1)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    memories = list(map(int, input().split()))\n    convenience = list(map(int, input().split()))\n    (X, Y) = ([], [])\n    for (a, b) in zip(memories, convenience):\n        if b == 1:\n            X.append(a)\n        else:\n            Y.append(a)\n    X.sort(reverse=True)\n    Y.sort()\n    (i, j) = (0, 0)\n    suma = sum(Y)\n    puntos = float('inf')\n    while i <= len(X):\n        while j < len(Y) and suma - Y[j] >= m:\n            suma -= Y[j]\n            j += 1\n        if suma >= m:\n            puntos = min(puntos, i + 2 * (len(Y) - j))\n        if i < len(X):\n            suma += X[i]\n        i += 1\n    if suma < m:\n        print(-1)\n        continue\n    print(puntos)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    memories = list(map(int, input().split()))\n    convenience = list(map(int, input().split()))\n    (X, Y) = ([], [])\n    for (a, b) in zip(memories, convenience):\n        if b == 1:\n            X.append(a)\n        else:\n            Y.append(a)\n    X.sort(reverse=True)\n    Y.sort()\n    (i, j) = (0, 0)\n    suma = sum(Y)\n    puntos = float('inf')\n    while i <= len(X):\n        while j < len(Y) and suma - Y[j] >= m:\n            suma -= Y[j]\n            j += 1\n        if suma >= m:\n            puntos = min(puntos, i + 2 * (len(Y) - j))\n        if i < len(X):\n            suma += X[i]\n        i += 1\n    if suma < m:\n        print(-1)\n        continue\n    print(puntos)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    (o, t, s) = ([], [], 0)\n    for i in range(n):\n        s += a[i]\n        if c[i] == 1:\n            o.append(a[i])\n        else:\n            t.append(a[i])\n    if s < m:\n        print(-1)\n    else:\n        o.sort(reverse=True)\n        t.sort(reverse=True)\n        (i1, i2, M, C) = (0, 0, 0, 0)\n        (l1, l2) = (len(o), len(t))\n        while M < m:\n            (s1, s2) = (0, 0)\n            if i1 < l1:\n                s1 = o[i1]\n                if i1 < l1 - 1:\n                    s1 += o[i1 + 1]\n            if i2 < l2:\n                s2 = t[i2]\n            if m - M <= s1 or s1 >= s2:\n                M += o[i1]\n                i1 += 1\n                C += 1\n            else:\n                M += t[i2]\n                C += 2\n                i2 += 1\n        print(C)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom bisect import bisect_left, bisect_right\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    mem = [int(x) for x in input().split()]\n    val = [int(x) for x in input().split()]\n    if sum(mem) < k:\n        print(-1)\n        continue\n    one = []\n    two = []\n    for i in range(n):\n        if val[i] == 1:\n            one.append(mem[i])\n        else:\n            two.append(mem[i])\n    onepre = []\n    temp = 0\n    one.sort(reverse=True)\n    two.sort(reverse=True)\n    for i in one:\n        temp += i\n        onepre.append(temp)\n    temp = 0\n    twopre = []\n    for i in two:\n        temp += i\n        twopre.append(temp)\n    ans = 10 ** 10\n    indd = bisect_left(twopre, k)\n    if indd != len(twopre):\n        ans = min(ans, 2 * (indd + 1))\n    for i in range(len(one)):\n        x = onepre[i]\n        if x >= k:\n            ans = min(ans, i + 1)\n        ind = bisect_left(twopre, k - x)\n        if ind == len(twopre):\n            continue\n        ans = min(ans, i + 1 + 2 * (ind + 1))\n    print(ans)", "import sys\nfrom collections import defaultdict, deque\nfrom bisect import bisect_left\ninput = lambda : sys.stdin.readline().rstrip()\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [*map(int, input().split())]\n    b = [*map(int, input().split())]\n    (c, d) = ([], [])\n    sm = 0\n    for i in range(n):\n        sm += a[i]\n        if b[i] == 1:\n            c.append(a[i])\n        else:\n            d.append(a[i])\n    c.sort(reverse=True)\n    d.sort(reverse=True)\n    for i in range(1, len(c)):\n        c[i] += c[i - 1]\n    for i in range(1, len(d)):\n        d[i] += d[i - 1]\n    if sm >= m:\n        ans = len(c) + 2 * len(d)\n    else:\n        print(-1)\n        continue\n    for i in range(len(c)):\n        if c[i] >= m:\n            ans = min(ans, i + 1)\n            continue\n        idx = bisect_left(d, m - c[i])\n        if idx != len(d):\n            ans = min(ans, i + 2 * idx + 3)\n    for i in range(len(d)):\n        if d[i] >= m:\n            ans = min(ans, 2 * (i + 1))\n            continue\n        idx = bisect_left(c, m - d[i])\n        if idx != len(c):\n            ans = min(ans, 2 * i + idx + 3)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().rsplit())\n    gen_a = map(int, input().rsplit())\n    gen_b = map(int, input().rsplit())\n    (a_1, a_2) = ([0], [0])\n    total_m = 0\n    for (i, j) in zip(gen_a, gen_b):\n        if j == 1:\n            a_1.append(i)\n        else:\n            a_2.append(i)\n        total_m += i\n    if total_m < m:\n        print(-1)\n        continue\n    a_1 = sorted(a_1)\n    a_2 = sorted(a_2)\n    (sum_m, sum_r) = (0, 0)\n    (l, r) = (len(a_1) - 1, len(a_2) - 1)\n    while l + r > 0:\n        if a_1[l] >= m - sum_m:\n            sum_m += a_1[l]\n            sum_r += 1\n            break\n        if a_2[r] >= m - sum_m:\n            sum_m += a_2[r]\n            sum_r += 2\n            break\n        if r <= 0 and l > 0:\n            sum_m += a_1[l]\n            sum_r += 1\n            l -= 1\n        elif l <= 0 and r > 0:\n            sum_m += a_2[r]\n            sum_r += 2\n            r -= 1\n        elif a_1[l] + a_1[l - 1] > a_2[r]:\n            sum_m += a_1[l]\n            sum_r += 1\n            l -= 1\n        else:\n            sum_m += a_2[r]\n            sum_r += 2\n            r -= 1\n        if sum_m >= m:\n            break\n    print(sum_r)", "from bisect import bisect_left, bisect_right\nT = int(input())\nfor i in range(T):\n    v1 = []\n    v2 = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if b[i] == 1:\n            v1.append(a[i])\n        else:\n            v2.append(a[i])\n    v1.sort(reverse=True)\n    v2.sort(reverse=True)\n    ls1 = []\n    ls2 = []\n    temp = 0\n    for i in v1:\n        temp += i\n        ls1.append(temp)\n    temp = 0\n    for i in v2:\n        temp += i\n        ls2.append(temp)\n    ls1.insert(0, 0)\n    ls2.insert(0, 0)\n    ans = float('inf')\n    for i in range(len(ls1)):\n        c = bisect_left(ls2, m - ls1[i])\n        if c >= len(ls2):\n            c = c - 1\n        if ls1[i] + ls2[c] >= m:\n            ans = min(ans, i + 2 * c)\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)", "from bisect import bisect_left, bisect_right\nT = int(input())\nfor i in range(T):\n    v1 = []\n    v2 = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if b[i] == 1:\n            v1.append(a[i])\n        else:\n            v2.append(a[i])\n    v1.sort(reverse=True)\n    v2.sort(reverse=True)\n    ls1 = []\n    ls2 = []\n    temp = 0\n    for i in v1:\n        temp += i\n        ls1.append(temp)\n    temp = 0\n    for i in v2:\n        temp += i\n        ls2.append(temp)\n    ls1.insert(0, 0)\n    ls2.insert(0, 0)\n    ans = float('inf')\n    for i in range(len(ls1)):\n        cur = bisect_left(ls2, m - ls1[i])\n        if cur >= len(ls2):\n            cur -= 1\n        if ls1[i] + ls2[cur] >= m:\n            ans = min(ans, i + 2 * cur)\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)", "import sys\nimport bisect\n\ndef amin(x, y):\n    if x > y:\n        x = y\n    return x\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    zip1 = zip(a, b)\n    zip1 = sorted(zip1, reverse=True)\n    (a, b) = zip(*zip1)\n    zip1 = zip(b, a)\n    zip1 = sorted(zip1, reverse=True)\n    (b, a) = zip(*zip1)\n    a = list(a)\n    b = list(b)\n    try:\n        index_1 = b.index(1)\n    except ValueError:\n        index_1 = len(a)\n    for i in range(1, index_1):\n        a[i] = a[i] + a[i - 1]\n    for i in range(index_1 + 1, n):\n        a[i] = a[i] + a[i - 1]\n    p1 = [a[i] for i in range(index_1, n)]\n    p2 = [a[i] for i in range(0, index_1)]\n    ans = sys.maxsize\n    for i in range(0, len(p2) + 1):\n        sum = 0\n        cost = 2 * i\n        if i > 0:\n            sum = p2[i - 1]\n        if sum >= m:\n            ans = amin(ans, cost)\n        k = bisect.bisect_left(p1, m - sum)\n        if k < len(p1):\n            ans = amin(ans, cost + k + 1)\n    if ans == sys.maxsize:\n        ans = -1\n    print(ans)\nt = int(input())\nfor i in range(t):\n    solve()", "from bisect import bisect_left, bisect_right\nT = int(input())\nfor i in range(T):\n    v1 = []\n    v2 = []\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if b[i] == 1:\n            v1.append(a[i])\n        else:\n            v2.append(a[i])\n    v1.sort(reverse=True)\n    v2.sort(reverse=True)\n    ls1 = []\n    ls2 = []\n    temp = 0\n    for i in v1:\n        temp += i\n        ls1.append(temp)\n    temp = 0\n    for i in v2:\n        temp += i\n        ls2.append(temp)\n    ls1.insert(0, 0)\n    ls2.insert(0, 0)\n    ans = float('inf')\n    for i in range(len(ls1)):\n        c = bisect_left(ls2, m - ls1[i])\n        if c >= len(ls2):\n            c = c - 1\n        if ls1[i] + ls2[c] >= m:\n            ans = min(ans, i + 2 * c)\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    one = []\n    two = []\n    if sum(a) >= m:\n        for i in range(n):\n            if b[i] == 1:\n                one.append(a[i])\n            else:\n                two.append(a[i])\n        one.sort(reverse=True)\n        two.sort(reverse=True)\n        pr1 = [0]\n        pr2 = [0]\n        ans = 3 * n\n        for i in one:\n            pr1.append(pr1[-1] + i)\n        for i in two:\n            pr2.append(pr2[-1] + i)\n        for i in range(len(pr1)):\n            c = bisect.bisect_left(pr2, m - pr1[i])\n            if c >= len(pr2):\n                c = c - 1\n            if pr1[i] + pr2[c] >= m:\n                ans = min(ans, i + 2 * c)\n        print(ans)\n    else:\n        print(-1)", "def bisect(b, m):\n    (l, h, ind) = (0, len(b) - 1, -1)\n    while l <= h:\n        mid = (l + h) // 2\n        if b[mid] >= m:\n            ind = mid\n            h = mid - 1\n        else:\n            l = mid + 1\n    return ind\n\ndef answer(m):\n    (c1, c2) = ([0], [])\n    for i in range(n):\n        if b[i] == 1:\n            c1.append(a[i])\n        else:\n            c2.append(a[i])\n    c1.sort(reverse=True)\n    c2.sort(reverse=True)\n    c1.insert(0, 0)\n    (i, j, ans) = (0, 0, 0)\n    for i in range(1, len(c2)):\n        c2[i] += c2[i - 1]\n    ans = 10 ** 8\n    for i in range(len(c1)):\n        m -= c1[i]\n        if m <= 0:\n            ans = min(ans, i)\n            break\n        val = bisect(c2, m)\n        if val != -1:\n            ans = min(ans, i + (val + 1) * 2)\n    if ans == 10 ** 8:\n        return -1\n    else:\n        return ans\nfor T in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(answer(m))", "R = lambda : list(map(int, input().split()))\n\ndef bs(a, k):\n    l = 0\n    r = len(a) - 1\n    while l < r:\n        m = l + (r - l) // 2\n        if a[m] < k:\n            l = m + 1\n        else:\n            r = m\n    m = (l + r) // 2\n    return m\nfor _ in range(int(input())):\n    (n, m) = R()\n    a = R()\n    b = R()\n    if sum(a) < m:\n        print(-1)\n        continue\n    (reg, imp) = ([], [])\n    for i in range(n):\n        if b[i] == 1:\n            reg.append(a[i])\n        else:\n            imp.append(a[i])\n    reg = sorted(reg)[::-1]\n    imp = sorted(imp)[::-1]\n    pi = [0]\n    for i in range(len(imp)):\n        pi.append(pi[-1] + imp[i])\n    mr = 0\n    mi = bs(pi, m)\n    ans = 10 ** 9\n    if pi[mi] >= m:\n        ans = mi * 2\n    for i in range(len(reg)):\n        mr += reg[i]\n        lef = m - mr\n        mi = bs(pi, lef)\n        if pi[mi] + mr >= m:\n            ans = min(ans, mi * 2 + i + 1)\n    print(ans)"]