["import sys\nimport threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\ninput = sys.stdin.readline\nB = []\nA = defaultdict(list)\n\ndef dfs(now, fa, depth):\n    son = 1\n    for to in A[now]:\n        if to != fa:\n            son += dfs(to, now, depth + 1)\n    B.append(depth - son)\n    return son\n\ndef main():\n    (n, m) = map(int, input().split())\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        A[x].append(y)\n        A[y].append(x)\n    dfs(0, -1, 1)\n    print(sum(sorted(B, reverse=True)[:m]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\ninput = sys.stdin.readline\nB = []\nA = defaultdict(list)\n\ndef dfs(now, fa, depth):\n    son = 1\n    for to in A[now]:\n        if to != fa:\n            son += dfs(to, now, depth + 1)\n    B.append(depth - son)\n    return son\n\ndef main():\n    (n, m) = map(int, input().split())\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        A[x].append(y)\n        A[y].append(x)\n    dfs(0, -1, 1)\n    print(sum(sorted(B, reverse=True)[:m]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\ninput = sys.stdin.readline\n\ndef main():\n    (n, k) = map(int, input().split())\n    tree = defaultdict(list)\n    for edge in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    res = []\n\n    def dfs(cn, p, d):\n        sz = 1\n        for nn in tree[cn]:\n            if nn != p:\n                sz += dfs(nn, cn, d + 1)\n        res.append(d - sz)\n        return sz\n    dfs(1, -1, 1)\n    res.sort(reverse=True)\n    ans = 0\n    for i in range(k):\n        ans += res[i]\n    print(ans)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\ns = []\n\ndef dfs(graph, n, p, level):\n    penalty = 1\n    for c in graph[n]:\n        if c == p:\n            continue\n        penalty += dfs(graph, c, n, level + 1)\n    s.append(level - penalty)\n    return penalty\n\ndef main():\n    (n, k) = map(int, input().split())\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split(' '))\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    try:\n        dfs(g, 0, None, 1)\n    except Exception as e:\n        print(e)\n    m = sorted(s, reverse=True)\n    print(sum(m[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nbuffer = []\n\ndef dfs(graph, n, p, level):\n    penalty = 1\n    for c in graph[n]:\n        if c == p:\n            continue\n        penalty += dfs(graph, c, n, level + 1)\n    buffer.append(level - penalty)\n    return penalty\n\ndef main():\n    (n, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    try:\n        dfs(graph, 1, None, 1)\n    except Exception as e:\n        print(e)\n    print(sum(sorted(buffer, reverse=True)[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nbuffer = []\n\ndef dfs(graph, n, p, level):\n    penalty = 1\n    for c in graph[n]:\n        if c == p:\n            continue\n        penalty += dfs(graph, c, n, level + 1)\n    buffer.append(level - penalty)\n    return penalty\n\ndef main():\n    (n, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    try:\n        dfs(graph, 1, None, 1)\n    except Exception as e:\n        print(e)\n    print(sum(sorted(buffer, reverse=True)[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef dfs(node, parent, g, depth, child):\n    depth[node] = depth[parent] + 1\n    child[node] = 0\n    for e in g[node]:\n        if e == parent:\n            continue\n        child[node] += dfs(e, node, g, depth, child)\n    return child[node] + 1\n\ndef main():\n    (n, k) = map(int, input().strip().split())\n    g = defaultdict(list)\n    for i in range(n - 1):\n        (x, y) = map(int, input().strip().split())\n        g[x].append(y)\n        g[y].append(x)\n    depth = [-1] * (n + 1)\n    child = [0] * (n + 1)\n    dfs(1, 0, g, depth, child)\n    l = list(map(lambda x, y: x - y, depth[1:], child[1:]))\n    l = sorted(l, reverse=True)\n    print(sum(l[:k]))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport collections\nimport threading\nimport heapq\nimport string\n\ndef main():\n    try:\n        (n, k) = map(int, input().split())\n        d = collections.defaultdict(list)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            d[u].append(v)\n            d[v].append(u)\n        if k == n:\n            print(0)\n            return\n        if k == n - 1:\n            print(k)\n            return\n        cost = [-1] * n\n\n        def dfs(par, i, cost, h):\n            if len(d[i]) == 1 and i > 1:\n                cost[i - 1] = -h\n                return 1\n            ans = 0\n            for j in d[i]:\n                if j != par:\n                    ans += dfs(i, j, cost, h + 1)\n            cost[i - 1] = ans - h\n            return ans + 1\n        dfs(0, 1, cost, 0)\n        cost.sort()\n        print(sum(cost[k:]))\n    except RuntimeError as e:\n        print(e)\ninput = sys.stdin.readline\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "from collections import defaultdict\nimport sys\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nbuffer = []\n\ndef dfs(graph, n, p, level):\n    penalty = 1\n    for c in graph[n]:\n        if c == p:\n            continue\n        penalty += dfs(graph, c, n, level + 1)\n    buffer.append(level - penalty)\n    return penalty\n\ndef main():\n    (n, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    dfs(graph, 1, None, 1)\n    print(sum(sorted(buffer, reverse=True)[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef dfs(node, depth, visited, graph, happiness):\n    visited[node] = True\n    impact = 0\n    for child_node in graph[node]:\n        if not visited[child_node]:\n            impact += 1 + dfs(child_node, depth + 1, visited, graph, happiness)\n    happiness.append(depth - impact)\n    return impact\n\ndef solve():\n    (n, k) = map(int, input().split())\n    visited = [False] * n\n    graph = [[] for i in range(n)]\n    happiness = []\n    while n != 1:\n        (node_1, node_2) = map(int, input().split())\n        node_1 -= 1\n        node_2 -= 1\n        graph[node_1].append(node_2)\n        graph[node_2].append(node_1)\n        n -= 1\n    dfs(0, 0, visited, graph, happiness)\n    happiness.sort(reverse=True)\n    ans = 0\n    for i in range(0, k, 1):\n        ans += happiness[i]\n    print(ans)\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=solve)\nthread.start()\nthread.join()", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\ndef bfs(a, b):\n    q = deque([(a, b)])\n    stack = deque([(a, b)])\n    while q:\n        (x, p) = q[0]\n        q.popleft()\n        depth[x] = depth[p] + 1\n        size[x] = 1\n        for i in l[x]:\n            if i == p:\n                continue\n            q.append((i, x))\n            stack.append((i, x))\n    while stack:\n        (x, p) = stack[-1]\n        stack.pop()\n        size[p] += size[x]\n        ans[x] = depth[x] - size[x]\n    size[0] = 0\n(n, k) = map(int, input().split())\nl = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    l[u].append(v)\n    l[v].append(u)\ndepth = [0] * (n + 1)\nsize = [0] * (n + 1)\nans = [0] * (n + 1)\nbfs(1, 0)\nans = ans[1:]\nans.sort(reverse=True)\nprint(sum(ans[:k]))", "from collections import defaultdict\nimport threading\nimport sys\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nbuffer = []\n\ndef dfs(graph, n, p, level):\n    penalty = 1\n    for c in graph[n]:\n        if c == p:\n            continue\n        penalty += dfs(graph, c, n, level + 1)\n    buffer.append(level - penalty)\n    return penalty\n\ndef main():\n    (n, k) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    dfs(graph, 1, None, 1)\n    print(sum(sorted(buffer, reverse=True)[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef dfs(node, parent, g, depth, child):\n    depth[node] = depth[parent] + 1\n    child[node] = 0\n    for e in g[node]:\n        if e == parent:\n            continue\n        child[node] += dfs(e, node, g, depth, child)\n    return child[node] + 1\n\ndef main():\n    (n, k) = map(int, input().strip().split())\n    g = defaultdict(list)\n    for i in range(n - 1):\n        (x, y) = map(int, input().strip().split())\n        g[x].append(y)\n        g[y].append(x)\n    depth = [-1] * (n + 1)\n    child = [0] * (n + 1)\n    dfs(1, 0, g, depth, child)\n    l = list(map(lambda x, y: x - y, depth[1:], child[1:]))\n    l = sorted(l, reverse=True)\n    print(sum(l[:k]))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys, threading\n\ndef main():\n    (n, k) = map(int, input().split())\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    res = []\n\n    def dfs(s, e, depth):\n        count = 1\n        for u in adj[s]:\n            if u != e:\n                count += dfs(u, s, depth + 1)\n        res.append(depth - count)\n        return count\n    dfs(0, -1, 1)\n    print(sum(sorted(res, reverse=True)[:k]))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n\n    def dfs():\n        first = [True] * n\n        stack = [(0, -1)]\n        while stack:\n            (u, pu) = stack.pop()\n            if first[u]:\n                first[u] = False\n                stack.append((u, pu))\n                for v in to[u]:\n                    if v == pu:\n                        continue\n                    dep[v] = dep[u] + 1\n                    stack.append((v, u))\n            else:\n                for v in to[u]:\n                    if v == pu:\n                        continue\n                    chi[u] += chi[v] + 1\n    (n, k) = MI()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = MI1()\n        to[u].append(v)\n        to[v].append(u)\n    dep = [0] * n\n    chi = [0] * n\n    dfs()\n    vv = [dep[u] - chi[u] for u in range(n)]\n    vv.sort(reverse=True)\n    ans = sum(vv[:k])\n    print(ans)\nmain()", "import sys, threading\nfrom collections import defaultdict\n\ndef main():\n    (n, k) = list(map(int, input().split()))\n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        tree[u].append(v)\n        tree[v].append(u)\n    candidates = []\n\n    def dfs(node, depth, p):\n        res = 1\n        for adj in tree[node]:\n            if p == adj:\n                continue\n            res += dfs(adj, depth + 1, node)\n        candidates.append(res - 1 - depth)\n        return res\n    dfs(1, 0, -1)\n    candidates.sort(reverse=True)\n    print(sum(candidates[:n - k]))\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nimport threading\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef dfs(node, depth, visited, graph, happiness):\n    visited[node] = True\n    impact = 0\n    for child_node in graph[node]:\n        if not visited[child_node]:\n            impact += 1 + dfs(child_node, depth + 1, visited, graph, happiness)\n    happiness.append(depth - impact)\n    return impact\n\ndef solve():\n    (n, k) = map(int, input().split())\n    visited = [False] * n\n    happiness = []\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    while n != 1:\n        (node_1, node_2) = map(int, input().split())\n        node_1 -= 1\n        node_2 -= 1\n        graph[node_1].append(node_2)\n        graph[node_2].append(node_1)\n        n -= 1\n    dfs(0, 0, visited, graph, happiness)\n    happiness.sort(reverse=True)\n    ans = 0\n    for i in range(0, k, 1):\n        ans += happiness[i]\n    print(ans)\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=solve)\nthread.start()\nthread.join()", "import sys\nimport threading\nfrom collections import defaultdict\n(n, k) = list(map(int, input().split()))\nadj = defaultdict(list)\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    adj[a].append(b)\n    adj[b].append(a)\nli = []\n\ndef fun(node, par, ht):\n    size = 1\n    for ch in adj[node]:\n        if ch != par:\n            size += fun(ch, node, ht + 1)\n    li.append(ht - size)\n    return size\n\ndef main():\n    fun(1, -1, 1)\n    li.sort(reverse=True)\n    print(sum(li[:k]))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nimport sys, threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\ninput = sys.stdin.readline\n\ndef main():\n    (n, k) = map(int, input().split())\n    gra = defaultdict(list)\n    for _ in range(n - 1):\n        (s, e) = map(int, input().split())\n        gra[s].append(e)\n        gra[e].append(s)\n    hap = []\n\n    def dfs(n, p, offset):\n        sz = 1\n        for i in gra[n]:\n            if i != p:\n                sz += dfs(i, n, offset + 1)\n        hap.append(offset - sz)\n        return sz\n    dfs(1, -1, 1)\n    hap.sort(reverse=True)\n    count = 0\n    for i in range(k):\n        count += hap[i]\n    print(count)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\ninput = sys.stdin.readline\n\ndef main():\n    (n, k) = map(int, input().split())\n    t = [[] for i in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        t[u - 1].append(v - 1)\n        t[v - 1].append(u - 1)\n    d = [0 for i in range(n)]\n    s = [1 for i in range(n)]\n\n    def dfs(mae, ima):\n        for tsugi in t[ima]:\n            if mae != tsugi:\n                d[tsugi] = d[ima] + 1\n                dfs(ima, tsugi)\n        for tsugi in t[ima]:\n            if tsugi != mae:\n                s[ima] += s[tsugi]\n    dfs(-1, 0)\n    p = sorted([d[i] - (s[i] - 1) for i in range(n)])[::-1]\n    print(sum(p[:k]))\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import threading\nfrom sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(10 ** 6)\nfrom collections import defaultdict\n\ndef dfs(node, parent, g, depth, child):\n    depth[node] = depth[parent] + 1\n    child[node] = 0\n    for e in g[node]:\n        if e == parent:\n            continue\n        child[node] += dfs(e, node, g, depth, child)\n    return child[node] + 1\n\ndef main():\n    (n, k) = map(int, input().strip().split())\n    g = defaultdict(list)\n    for i in range(n - 1):\n        (x, y) = map(int, input().strip().split())\n        g[x].append(y)\n        g[y].append(x)\n    depth = [-1] * (n + 1)\n    child = [0] * (n + 1)\n    dfs(1, 0, g, depth, child)\n    l = list(map(lambda x, y: x - y, depth[1:], child[1:]))\n    l = sorted(l, reverse=True)\n    print(sum(l[:k]))\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport math\nfrom bisect import bisect_right as br\nimport threading\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    arr = [-300000 for i in range(200004)]\n\n    def dfs(val, cnt, prev, arr):\n        down = 0\n        for i in dict[val]:\n            if i != prev:\n                down += dfs(i, cnt + 1, val, arr)\n        arr[val] = cnt - down\n        return down + 1\n    (n, k) = int_arr()\n    dict = {}\n    for i in range(1, n):\n        (a, b) = int_arr()\n        if dict.get(a, 0) == 0:\n            dict[a] = [b]\n        else:\n            dict[a].append(b)\n        if dict.get(b, 0) == 0:\n            dict[b] = [a]\n        else:\n            dict[b].append(a)\n    dfs(1, 0, -1, arr)\n    arr.sort(reverse=True)\n    print(sum(arr[:k]))\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nimport math\nfrom bisect import bisect_right as br\nimport threading\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    arr = [-300000 for i in range(200004)]\n\n    def dfs(val, cnt, prev, arr):\n        down = 0\n        for i in dict[val]:\n            if i != prev:\n                down += dfs(i, cnt + 1, val, arr)\n        arr[val] = cnt - down\n        return down + 1\n    (n, k) = int_arr()\n    dict = {}\n    for i in range(1, n):\n        (a, b) = int_arr()\n        if dict.get(a, 0) == 0:\n            dict[a] = [b]\n        else:\n            dict[a].append(b)\n        if dict.get(b, 0) == 0:\n            dict[b] = [a]\n        else:\n            dict[b].append(a)\n    dfs(1, 0, -1, arr)\n    arr.sort(reverse=True)\n    print(sum(arr[:k]))\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import collections\n\ndef calc():\n    (n, k) = map(int, input().split())\n    g = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        g[a].append(b)\n        g[b].append(a)\n    q = collections.deque()\n    q.append((1, 0))\n    checked = [0] * (n + 1)\n    checked[1] = 1\n    ds = [[] for _ in range(n + 1)]\n    pairs = {}\n    while len(q) != 0:\n        (v, d) = q.popleft()\n        ds[d].append(v)\n        for u in g[v]:\n            if checked[u] == 0:\n                checked[u] = 1\n                q.append((u, d + 1))\n                pairs[u] = v\n    cnt = [0] * (n + 1)\n    tmp = []\n    for i in range(n, 0, -1):\n        for v in ds[i]:\n            cnt[pairs[v]] += cnt[v] + 1\n            tmp.append(i - cnt[v])\n    tmp = sorted(tmp, reverse=True)\n    print(sum(tmp[:k]))\ncalc()", "import sys\nimport threading\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef dfs(node, depth, visited, graph, happiness):\n    visited.add(node)\n    impact = 0\n    for child_node in graph[node]:\n        if child_node not in visited:\n            impact += 1 + dfs(child_node, depth + 1, visited, graph, happiness)\n    happiness.append(depth - impact)\n    return impact\n\ndef solve():\n    (n, k) = map(int, input().split())\n    visited = set()\n    happiness = []\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    while n != 1:\n        (node_1, node_2) = map(int, input().split())\n        node_1 -= 1\n        node_2 -= 1\n        graph[node_1].append(node_2)\n        graph[node_2].append(node_1)\n        n -= 1\n    dfs(0, 0, visited, graph, happiness)\n    happiness.sort(reverse=True)\n    ans = 0\n    for i in range(0, k, 1):\n        ans += happiness[i]\n    print(ans)\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=solve)\nthread.start()\nthread.join()", "def main():\n    from sys import stdin\n    from sys import stdout\n    input = stdin.readline\n    print = stdout.write\n\n    def dfs(town_ix, deep=0, parent=0):\n        deeps[town_ix] = deep\n        if len(kingdom_structure[town_ix]) == 1 and kingdom_structure[town_ix][0] == parent:\n            return 1\n        for road_to in kingdom_structure[town_ix]:\n            if road_to != parent:\n                quantity_child[town_ix] += dfs(road_to, deep + 1, town_ix)\n        return quantity_child[town_ix] + 1\n    (n, k) = list(map(int, input().split()))\n    kingdom_structure = [[] for _ in range(n)]\n    memo = [list(map(int, input().split())) for _ in range(n - 1)]\n    deeps = [0] * n\n    quantity_child = [0] * n\n    for i in range(n - 1):\n        v = memo[i][0] - 1\n        u = memo[i][1] - 1\n        kingdom_structure[v].append(u)\n        kingdom_structure[u].append(v)\n    dfs(0)\n    towns_profit = sorted([deeps[i] - quantity_child[i] for i in range(n)], reverse=True)\n    print(f'{sum(towns_profit[:k])}\\n')\nfrom sys import setrecursionlimit\nimport threading\nsetrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n\n    def dfs():\n        first = [True] * n\n        stack = [(0, -1)]\n        while stack:\n            (u, pu) = stack.pop()\n            if first[u]:\n                first[u] = False\n                stack.append((u, pu))\n                for v in to[u]:\n                    if v == pu:\n                        continue\n                    dep[v] = dep[u] + 1\n                    stack.append((v, u))\n            else:\n                for v in to[u]:\n                    if v == pu:\n                        continue\n                    chi[u] += chi[v] + 1\n    (n, k) = MI()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = MI1()\n        to[u].append(v)\n        to[v].append(u)\n    dep = [0] * n\n    chi = [0] * n\n    dfs()\n    vv = [dep[u] - chi[u] for u in range(n)]\n    vv.sort(reverse=True)\n    ans = sum(vv[:k])\n    print(ans)\nmain()", "import sys\nimport collections\nimport threading\nimport heapq\nimport string\n\ndef main():\n    try:\n        (n, k) = map(int, input().split())\n        ht = [-1] * n\n        st = [0] * n\n        g = [[] for i in range(n)]\n\n        def dfs(g, e, h):\n            if ht[e] != -1:\n                return\n            else:\n                ht[e] = h\n                for i in g[e]:\n                    dfs(g, i, h + 1)\n                s = 0\n                for i in g[e]:\n                    s += st[i]\n                st[e] = s + 1\n                ht[e] -= st[e]\n        for j in range(n - 1):\n            (x, y) = map(int, input().split())\n            g[x - 1].append(y - 1)\n            g[y - 1].append(x - 1)\n        dfs(g, 0, 1)\n        ht.sort(reverse=True)\n        print(sum(ht[:k]))\n    except RuntimeError as e:\n        print(e)\ninput = sys.stdin.readline\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\nimport threading\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef dfs(i, deep):\n    sub = 1\n    for key in dic[i]:\n        if vis[key] == 0:\n            vis[key] = 1\n            sub += dfs(key, deep + 1)\n    diff[i] = deep - sub\n    return sub\n(n, k) = [int(x) for x in input().split(' ')]\ndic = {}\nvis = [0] * (n + 1)\nvis[0] = vis[1] = 1\ndiff = [0] * (n + 1)\n\ndef main():\n    for i in range(n - 1):\n        (a, b) = [int(x) for x in input().split(' ')]\n        if not a in dic:\n            dic[a] = []\n        if not b in dic:\n            dic[b] = []\n        dic[a].append(b)\n        dic[b].append(a)\n    dfs(1, 1)\n    print(sum(sorted(diff[1:], reverse=True)[:k]))\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nfrom collections import defaultdict\n(n, k) = list(map(int, input().split()))\nadj = defaultdict(list)\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    adj[a].append(b)\n    adj[b].append(a)\nli = []\n\ndef fun(node, par, ht):\n    size = 1\n    for ch in adj[node]:\n        if ch != par:\n            size += fun(ch, node, ht + 1)\n    li.append(ht - size)\n    return size\n\ndef main():\n    fun(1, -1, 1)\n    li.sort(reverse=True)\n    print(sum(li[:k]))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nfrom collections import defaultdict\n(n, k) = list(map(int, input().split()))\nadj = defaultdict(list)\nfor _ in range(n - 1):\n    (a, b) = list(map(int, input().split()))\n    adj[a].append(b)\n    adj[b].append(a)\nli = []\n\ndef fun(node, par, ht):\n    size = 1\n    for ch in adj[node]:\n        if ch != par:\n            size += fun(ch, node, ht + 1)\n    li.append(ht - size)\n    return size\n\ndef main():\n    fun(1, -1, 1)\n    li.sort(reverse=True)\n    print(sum(li[:k]))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nfrom collections import defaultdict\n(n, k) = map(int, input().split())\nadj = defaultdict(list)\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\nheight = [0] * (n + 1)\nsubtree = [0] * (n + 1)\n\ndef dfs(node, par, ht):\n    height[node] = ht\n    s = 1\n    for i in range(len(adj[node])):\n        if adj[node][i] != par:\n            s += dfs(adj[node][i], node, ht + 1)\n    subtree[node] = s\n    return s\n\ndef main():\n    dfs(1, 0, 1)\n    final = []\n    for i in range(1, n + 1):\n        final.append(height[i] - subtree[i])\n    final.sort(reverse=True)\n    ans = 0\n    for i in range(k):\n        ans += final[i]\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(10 ** 8)\n\ndef solve():\n    (n, k) = map(int, input().split())\n    s = [set() for _ in range(n + 1)]\n    d = []\n    used = [0] * (n + 1)\n\n    def depth(x, val):\n        res = 1\n        used[x] = 1\n        for v in s[x]:\n            if not used[v]:\n                res += depth(v, val + 1)\n        d.append(res - val)\n        return res\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        s[u].add(v)\n        s[v].add(u)\n    depth(1, 1)\n    d.sort(reverse=True)\n    res = 0\n    for i in range(n - k):\n        res += d[i]\n    print(res)\nthreading.Thread(target=solve).start()", "import sys\nimport threading\nfrom collections import defaultdict\n(n, k) = map(int, input().split())\nadj = defaultdict(list)\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\nheight = [0] * (n + 1)\nsubtree = [0] * (n + 1)\n\ndef dfs(node, par, ht):\n    height[node] = ht\n    subtree[node] = 1\n    for i in range(len(adj[node])):\n        if adj[node][i] != par:\n            subtree[node] += dfs(adj[node][i], node, ht + 1)\n    return subtree[node]\n\ndef main():\n    dfs(1, 0, 1)\n    final = []\n    for i in range(1, n + 1):\n        final.append(height[i] - subtree[i])\n    final.sort(reverse=True)\n    ans = 0\n    for i in range(k):\n        ans += final[i]\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\nsys.setrecursionlimit(10 ** 8 + 5)\nthreading.stack_size(10 ** 8 + 5)\n\ndef solve():\n    (n, k) = map(int, input().split())\n    s = [set() for _ in range(n + 1)]\n    d = []\n    used = [0] * (n + 1)\n\n    def depth(x, val):\n        res = 1\n        used[x] = 1\n        for v in s[x]:\n            if not used[v]:\n                res += depth(v, val + 1)\n        d.append(res - val)\n        return res\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        s[u].add(v)\n        s[v].add(u)\n    depth(1, 1)\n    d.sort(reverse=True)\n    res = 0\n    for i in range(n - k):\n        res += d[i]\n    print(res)\nthreading.Thread(target=solve).start()", "(n, k) = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (i, j) = map(lambda i: int(i) - 1, input().split())\n    g[i].append(j)\n    g[j].append(i)\nq = [0]\nc = [0] * n\np = [None] + [0] * (n - 1)\nd = [0] + [None] * (n - 1)\nwhile True:\n    i = q.pop()\n    if i == -1:\n        break\n    j = -(i + 1)\n    if j > 0:\n        c[p[j]] += c[j] + 1\n        continue\n    q.append(j)\n    for j in g[i]:\n        if d[j] is not None:\n            continue\n        d[j] = d[i] + 1\n        p[j] = i\n        q.append(j)\nsr = sorted([d[i] - c[i] for i in range(n)], reverse=True)\nprint(sum(sr[:k]))", "import math\nfrom collections import Counter, deque\nfrom sys import stdout\nimport time\nfrom math import factorial, log, gcd\nimport sys\nfrom decimal import Decimal\nimport threading\nfrom heapq import *\n\ndef S():\n    return sys.stdin.readline().split()\n\ndef I():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef IS():\n    return sys.stdin.readline().replace('\\n', '')\n\ndef main():\n    (n, k) = I()\n    tree = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = I()\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n    deap = [0] * n\n    size = [0] * n\n    visited = [False] * n\n    visited[0] = True\n\n    def dfs(x, d):\n        s = 1\n        deap[x] = d\n        for r in tree[x]:\n            if not visited[r]:\n                visited[r] = True\n                s += dfs(r, d + 1)\n        size[x] = s - 1\n        return s\n    dfs(0, 0)\n    ans = list(sorted([size[i] - deap[i] for i in range(n)]))\n    print(sum(ans[::-1][:n - k]))\nthreading.stack_size(10 ** 8 + 5)\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\nthreading.Thread(target=main).start()", "import sys\nimport threading\n\ndef main():\n\n    def dfs(v):\n        used[v] = True\n        cnt[v] = 1\n        for i in g[v]:\n            if not used[i]:\n                h[i] = h[v] + 1\n                dfs(i)\n                cnt[v] = cnt[v] + cnt[i]\n    (n, k) = map(int, input().split())\n    used = [False] * (n + 1)\n    h = [0] * (n + 1)\n    cnt = [0] * (n + 1)\n    g = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u not in g:\n            g[u] = []\n        if v not in g:\n            g[v] = []\n        g[u].append(v)\n        g[v].append(u)\n    h[1] = 1\n    dfs(1)\n    val = []\n    for i in range(1, n + 1):\n        val.append(h[i] - cnt[i])\n    val.sort(reverse=True)\n    ans = 0\n    for i in range(k):\n        ans = ans + val[i]\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport threading\n\ndef main():\n    (n, k) = [int(v) for v in input().split()]\n    edges = {}\n    for i in range(n - 1):\n        (u, w) = [int(v) for v in input().split()]\n        if u not in edges:\n            edges[u] = set()\n        if w not in edges:\n            edges[w] = set()\n        edges[u].add(w)\n        edges[w].add(u)\n    visited = set()\n    res = []\n\n    def dfs(cur, d):\n        visited.add(cur)\n        s = 1\n        for e in edges.get(cur, []):\n            if e not in visited:\n                s += dfs(e, d + 1)\n        res.append((cur, d - s + 1))\n        return s\n    dfs(1, 0)\n    data = sorted(res, key=lambda b: b[1], reverse=True)\n    print(sum([v[1] for v in data[:k]]))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from sys import stdin, setrecursionlimit\nfrom collections import *\nimport threading\nrints = lambda : [int(x) for x in stdin.readline().split()]\nget_col = lambda arr, i: [row[i] for row in arr]\n\nclass graph:\n\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        (self.gdict, self.edges, self.l) = (gdict, [], defaultdict(int))\n\n    def get_vertices(self):\n        return list(self.gdict.keys())\n\n    def addEdge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n        self.l[node2] += 1\n        self.l[node1] += 1\n\n    def DfsUtil(self, v, lev):\n        (self.visit[v], nodes) = (1, 0)\n        for i in self.gdict[v]:\n            if self.visit[i] == 0:\n                nodes += self.DfsUtil(i, lev + 1)\n        self.cnt.append(nodes - lev)\n        return 1 if self.l[v] == 1 else nodes + 1\n\n    def dfs(self):\n        (self.cnt, self.visit) = ([], [0] * (n + 1))\n        self.DfsUtil(1, 0)\n        return sum(sorted(self.cnt, reverse=True)[:n - k])\n\ndef main():\n    print(g.dfs())\ng = graph()\n(n, k) = rints()\nfor _ in range(n - 1):\n    (u, b) = rints()\n    g.addEdge(u, b)\nsetrecursionlimit(10 ** 9)\nthreading.stack_size(102400000)\nthread = threading.Thread(target=main)\nthread.start()", "def dfs():\n    while stack:\n        (u, p, depth) = stack.pop()\n        if not visited[u]:\n            visited[u] = True\n            stack.append((u, p, depth))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, depth + 1))\n        else:\n            for v in adj[u]:\n                if v != p:\n                    count[u] += count[v] + 1\n            happiness[u] = depth - count[u]\n(node, k) = list(map(int, input().split()))\nadj = [[] for _ in range(node)]\nvisited = [False] * node\nstack = [(0, -1, 0)]\nfor _ in range(node - 1):\n    (u, v) = list(map(lambda x: int(x) - 1, input().split()))\n    adj[u].append(v)\n    adj[v].append(u)\ncount = [0] * node\nhappiness = [0] * node\ndfs()\nhappiness.sort(reverse=True)\nans = sum(happiness[:k])\nprint(ans)", "(n, k) = map(int, input().split())\ngs = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    gs[u].append(v)\n    gs[v].append(u)\nq = [1]\nccnt = [0] * (n + 1)\nds = [None] * (n + 1)\nds[1] = 0\npar = [0] * (n + 1)\npar[1] = 0\nwhile q:\n    u = q.pop()\n    if u < 0:\n        ccnt[par[-u]] += ccnt[-u] + 1\n        continue\n    q.append(-u)\n    for v in gs[u]:\n        if ds[v] is not None:\n            continue\n        ds[v] = ds[u] + 1\n        par[v] = u\n        q.append(v)\nsrr = (ds[x] - ccnt[x] for x in range(1, n + 1))\nsr = sorted(srr, reverse=True)\nans = sum(sr[:k])\nprint(ans)", "import sys, threading\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef dfs(index, d, visited, p, dep, ans):\n    visited[index] = True\n    dep[index] = d\n    for i in range(len(ans[index])):\n        if visited[ans[index][i]] == False:\n            dfs(ans[index][i], d + 1, visited, p, dep, ans)\n            p[index] += p[ans[index][i]]\n\ndef solve():\n    n = list(map(int, input().split()))\n    ans = [[] for i in range(n[0])]\n    for i in range(n[0] - 1):\n        v = list(map(int, input().split()))\n        ans[v[0] - 1].append(v[1] - 1)\n        ans[v[1] - 1].append(v[0] - 1)\n    p = [1 for i in range(n[0])]\n    dep = [0 for i in range(n[0])]\n    visited = [False for i in range(n[0])]\n    dfs(0, 0, visited, p, dep, ans)\n    dp = [0 for i in range(n[0])]\n    for i in range(n[0]):\n        dp[i] = dep[i] - p[i] + 1\n    dp.sort(reverse=True)\n    sum1 = 0\n    for i in range(n[1]):\n        sum1 += dp[i]\n    print(sum1)\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=solve)\nthread.start()\nthread.join()", "def dfs():\n    while stack:\n        (u, p, depth) = stack.pop()\n        if not visited[u]:\n            visited[u] = True\n            stack.append((u, p, depth))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, depth + 1))\n        else:\n            for v in adj[u]:\n                if v != p:\n                    count[u] += count[v] + 1\n            happiness[u] = depth - count[u]\n(n, k) = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nvisited = [False] * n\nstack = [(0, -1, 0)]\nfor _ in range(n - 1):\n    (u, v) = list(map(lambda x: int(x) - 1, input().split()))\n    adj[u].append(v)\n    adj[v].append(u)\ncount = [0] * n\nhappiness = [0] * n\ndfs()\nhappiness.sort(reverse=True)\nans = sum(happiness[:k])\nprint(ans)", "(n, k) = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = (int(x) - 1 for x in input().split())\n    g[u].append(v)\n    g[v].append(u)\ndepth = [None] * n\ndepth[0] = 0\nsize = [None] * n\nstack = [0]\nwhile stack:\n    u = stack[-1]\n    if size[u] is None:\n        size[u] = 0\n        for v in g[u]:\n            if depth[v] is None:\n                depth[v] = depth[u] + 1\n                stack.append(v)\n        continue\n    stack.pop()\n    size[u] += 1 + sum((size[v] for v in g[u]))\nprint(sum(sorted((depth[x] - size[x] + 1 for x in range(n)), reverse=True)[:k]))", "import sys\nimport threading\n\ndef main():\n    (n, k) = [int(v) for v in input().split()]\n    edges = {}\n    for i in range(n - 1):\n        (u, w) = [int(v) for v in input().split()]\n        if u not in edges:\n            edges[u] = set()\n        if w not in edges:\n            edges[w] = set()\n        edges[u].add(w)\n        edges[w].add(u)\n    visited = set()\n    res = []\n\n    def dfs(cur, d):\n        visited.add(cur)\n        s = 1\n        for e in edges.get(cur, []):\n            if e not in visited:\n                s += dfs(e, d + 1)\n        res.append((cur, d - s + 1))\n        return s\n    dfs(1, 0)\n    data = sorted(res, key=lambda b: b[1], reverse=True)\n    print(sum([v[1] for v in data[:k]]))\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "(n, k) = map(int, input().split())\nG = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(lambda x: int(x) - 1, input().split())\n    G[u].append(v)\n    G[v].append(u)\norder = []\npar = [-1] * n\nstack = [0]\nwhile stack:\n    v = stack.pop()\n    order.append(v)\n    for c in G[v]:\n        if c != par[v]:\n            par[c] = v\n            stack.append(c)\npar_count = [0] * n\nchi_count = [0] * n\nfor v in order:\n    p = par[v]\n    if p != -1:\n        par_count[v] = par_count[p] + 1\nfor v in order[::-1]:\n    p = par[v]\n    if p != -1:\n        chi_count[p] += chi_count[v] + 1\nscore = [par_count[i] - chi_count[i] for i in range(n)]\nscore.sort(reverse=True)\nprint(sum(score[:k]))", "import sys, threading\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef dfs(index, d, visited, p, dep, ans):\n    visited[index] = True\n    dep[index] = d\n    for i in range(len(ans[index])):\n        if visited[ans[index][i]] == False:\n            dfs(ans[index][i], d + 1, visited, p, dep, ans)\n            p[index] += p[ans[index][i]]\n\ndef solve():\n    n = list(map(int, input().split()))\n    ans = [[] for i in range(n[0])]\n    for i in range(n[0] - 1):\n        v = list(map(int, input().split()))\n        ans[v[0] - 1].append(v[1] - 1)\n        ans[v[1] - 1].append(v[0] - 1)\n    p = [1 for i in range(n[0])]\n    dep = [0 for i in range(n[0])]\n    visited = [False for i in range(n[0])]\n    dfs(0, 0, visited, p, dep, ans)\n    dp = [0 for i in range(n[0])]\n    for i in range(n[0]):\n        dp[i] = dep[i] - p[i] + 1\n    dp.sort(reverse=True)\n    sum1 = 0\n    for i in range(n[1]):\n        sum1 += dp[i]\n    print(sum1)\n\ndef main():\n    solve()\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "from collections import *\n\ndef addGraph(edges):\n    tree = defaultdict(list)\n    for i in range(edges):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    return tree\n\ndef bfs(node, order, parent):\n    depth = defaultdict(int)\n    queue = deque()\n    queue.append(node)\n    parent[1] = -1\n    while queue:\n        curr = queue.popleft()\n        for i in tree[curr]:\n            if i not in parent:\n                parent[i] = curr\n                depth[i] = depth[curr] + 1\n                order.append(i)\n                queue.append(i)\n    return depth\n(n, k) = map(int, input().split())\ntree = addGraph(n - 1)\nparent = dict()\norder = [0, 1]\nsubTree = defaultdict(int)\ndepth = bfs(1, order, parent)\nfor i in range(n, 1, -1):\n    curr = order[i]\n    subTree[parent[curr]] += subTree[curr] + 1\nhappiness = []\nfor i in range(1, n + 1):\n    happiness.append(depth[i] - subTree[i])\nprint(sum(sorted(happiness, reverse=True)[:k]))", "from collections import deque\n\ndef readTree(V):\n    adj = [set() for i in range(V + 1)]\n    for i in range(V - 1):\n        (v1, v2) = [int(x) for x in input().split()]\n        adj[v1].add(v2)\n        adj[v2].add(v1)\n    return adj\n\ndef happiness(V, k, adj):\n    visited = [True, True] + [False] * (V - 1)\n    bfs_ordered = [0] * (V + 1)\n    depth = [0] * (V + 1)\n    father = [0] * (V + 1)\n    j = 1\n    q = deque()\n    q.append(1)\n    while q:\n        ele = q.popleft()\n        bfs_ordered[j] = ele\n        j += 1\n        for a in adj[ele]:\n            if visited[a] == False:\n                depth[a] = depth[ele] + 1\n                father[a] = ele\n                q.append(a)\n                visited[a] = True\n    return (bfs_ordered, father, depth)\n(V, k) = [int(x) for x in input().split()]\nadj = readTree(V)\n(bfs_ordered, father, depth) = happiness(V, k, adj)\nsub_tree_size = [1] * (V + 1)\nfor ele in bfs_ordered[:1:-1]:\n    sub_tree_size[father[ele]] = sub_tree_size[father[ele]] + sub_tree_size[ele]\nfinal = list(map(lambda a, b: a - b + 1, depth, sub_tree_size))\nfinal[0] = -9999999999999999999999999999999\nfinal.sort(reverse=True)\n(i, hppy) = (0, 0)\nwhile i < k:\n    hppy += final[i]\n    i += 1\nprint(hppy)", "(n, m) = map(int, input().split())\na = [[] for i in range(n)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    a[x - 1].append(y - 1)\n    a[y - 1].append(x - 1)\nht = [-1 for i in range(n)]\npar = [-1 for i in range(n)]\nh = 0\nstack = [0]\norder = []\nwhile stack:\n    node = stack.pop()\n    order.append(node)\n    if ht[node] == -1:\n        ht[node] = h\n    for i in a[node]:\n        if ht[i] == -1:\n            par[i] = node\n            stack.append(i)\n        else:\n            ht[node] = ht[i] + 1\nscore = [0] * n\nfor i in order[::-1]:\n    if par[i] != -1:\n        score[par[i]] += 1 + score[i]\nfor i in range(n):\n    score[i] = ht[i] - score[i]\nscore.sort(reverse=True)\nprint(sum(score[:m]))", "from collections import deque\n[N, K] = list(map(int, input().split()))\nconnections = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    [U, V] = list(map(int, input().split()))\n    connections[U] += (V,)\n    connections[V] += (U,)\nordre = []\nrestants = deque([1])\nprofondeur = [None] * (N + 1)\nprofondeur[1] = 0\nsuivant = [None] * (N + 1)\nwhile restants:\n    actuel = restants.popleft()\n    ordre += (actuel,)\n    for connection in connections[actuel]:\n        if profondeur[connection] == None:\n            profondeur[connection] = profondeur[actuel] + 1\n            restants += (connection,)\n            suivant[connection] = actuel\nsuivants = [0] * (N + 1)\nfor ville in ordre[N:0:-1]:\n    suivants[suivant[ville]] += 1 + suivants[ville]\nscores = [profondeur[ville] - suivants[ville] for ville in ordre[1:]]\nscores.sort(reverse=True)\nprint(sum(scores[:K]))", "import sys\nimport threading\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\n\nclass node:\n\n    def __init__(self):\n        self.dist = 0\n        self.count = 0\nvisited = []\nedges = []\ntree = []\n\ndef dfs(pos):\n    global visited\n    global edges\n    global tree\n    cnt = 0\n    visited[pos] = True\n    if edges[pos]:\n        for child in edges[pos]:\n            if not visited[child]:\n                tree[child][0] = tree[pos][0] + 1\n                cnt += dfs(child)\n    tree[pos][1] = cnt\n    return cnt + 1\n\ndef main():\n    (n, k) = list(map(int, input().split()))\n    global visited\n    global edges\n    global tree\n    visited = [False] * (n + 1)\n    edges = [[] for i in range(n + 1)]\n    tree = [[0, 0] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = list(map(int, input().split()))\n        edges[a].append(b)\n        edges[b].append(a)\n    dfs(1)\n    ans = sum(sorted([tree[i][0] - tree[i][1] for i in range(1, n + 1)], reverse=True)[:k])\n    print(ans)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import deque\n\ndef readTree(n):\n    adj = [set() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].add(v - 1)\n        adj[v - 1].add(u - 1)\n    return adj\n\ndef treeOrderByDepth(n, adj, root=0):\n    parent = [-2] + [-1] * (n - 1)\n    ordered = []\n    q = deque()\n    q.append(root)\n    depth = [0] * n\n    while q:\n        c = q.popleft()\n        ordered.append(c)\n        for a in adj[c]:\n            if parent[a] == -1:\n                parent[a] = c\n                depth[a] = depth[c] + 1\n                q.append(a)\n    return (ordered, parent, depth)\n(n, k) = map(int, input().split())\nadj = readTree(n)\n(ordered, parent, depth) = treeOrderByDepth(n, adj)\nchildren = [0] * n\nfor nd in ordered[::-1]:\n    if parent[nd] != -2:\n        children[parent[nd]] += children[nd] + 1\nvalue = list(map(lambda a, b: a - b, depth, children))\nvalue.sort(reverse=True)\nprint(sum(value[:k]))", "from sys import *\nimport collections\nimport math\n(n, k) = list(map(int, stdin.readline().split(' ')))\ng = []\nfor i in range(n + 1):\n    g.append([])\nfor i in range(n - 1):\n    (x, y) = list(map(int, stdin.readline().split(' ')))\n    g[x].append(y)\n    g[y].append(x)\na = []\na = [1]\nexp = {}\nexp[1] = True\ndst = [0] * (n + 1)\nroot = [0] * (n + 1)\nhei = {}\nwhile a:\n    u = a.pop()\n    h = dst[u] + 1\n    for v in g[u]:\n        if v not in exp:\n            root[v] = u\n            dst[v] = h\n            if h not in hei:\n                hei[h] = []\n            hei[h].append(v)\n            exp[v] = True\n            a.append(v)\nval = [1] * (n + 1)\nfor h in range(n, 0, -1):\n    if h not in hei:\n        continue\n    for x in hei[h]:\n        val[root[x]] = val[root[x]] + val[x]\nfor i in range(1, n + 1, 1):\n    dst[i] = dst[i] - val[i] + 1\ndst = dst[1:]\ndst.sort(reverse=True)\nans = 0\nfor i in range(k):\n    ans += dst[i]\nprint(ans)", "def dfs():\n    while stack:\n        (u, p, depth) = stack.pop()\n        if not visited[u]:\n            visited[u] = True\n            stack.append((u, p, depth))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, depth + 1))\n        else:\n            for v in adj[u]:\n                if v != p:\n                    count[u] += count[v] + 1\n            happiness[u] = depth - count[u]\n(n, k) = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nvisited = [False] * n\nstack = [(0, -1, 0)]\nfor _ in range(n - 1):\n    (u, v) = list(map(lambda x: int(x) - 1, input().split()))\n    adj[u].append(v)\n    adj[v].append(u)\ncount = [0] * n\nhappiness = [0] * n\ndfs()\nhappiness.sort(reverse=True)\nans = sum(happiness[:k])\nprint(ans)", "import sys, threading\nsys.setrecursionlimit(300000)\nthreading.stack_size(10 ** 8)\n\ndef solve():\n    (n, k) = map(int, input().split())\n    n1 = [n, k]\n    adj = {}\n    depths = {}\n    cities = []\n    subtrees = {}\n    nums = {}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        if a not in adj:\n            adj[a] = []\n        if b not in adj:\n            adj[b] = []\n        adj[a].append(b)\n        adj[b].append(a)\n    v = set()\n\n    def dfs(node, depth):\n        v.add(node)\n        depths[node] = depth\n        subtrees[node] = 0\n        for child in adj.get(node, []):\n            if child not in v:\n                r = dfs(child, depth + 1)\n                if type(r) == int:\n                    subtrees[node] += r\n        return subtrees[node] + 1\n    dfs(1, 0)\n    ans = []\n    for i in range(1, n + 1):\n        ans.append(depths.get(i, 0) - subtrees.get(i, 0))\n    ans.sort(reverse=True)\n    print(sum(ans[:k]))\nthreading.Thread(target=solve).start()", "from collections import defaultdict\nimport sys\nimport threading\nthreading.stack_size(2 ** 27)\nsys.setrecursionlimit(10 ** 7)\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef ri():\n    return int(input())\n\ndef rm():\n    return map(int, input().split())\n\ndef main():\n    (n, k) = rm()\n    g = defaultdict(list)\n    ns = [0 for i in range(n + 1)]\n    hs = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = rm()\n        g[u].append(v)\n        g[v].append(u)\n\n    def f1(u, p):\n        a = 1\n        for v in g[u]:\n            if v != p:\n                a += f1(v, u)\n        ns[u] = a\n        return a\n\n    def f2(u, p, h):\n        hs[u] = h\n        for v in g[u]:\n            if v != p:\n                f2(v, u, h + 1)\n    f1(1, -1)\n    f2(1, -1, 0)\n    hn = [hs[i] - ns[i] + 1 for i in range(1, n + 1)]\n    hn.sort(reverse=True)\n    print(sum(hn[:k]))\nthreading.Thread(target=main).start()", "import sys\nimport threading\n\ndef main():\n\n    def dfs(v):\n        used[v] = True\n        cnt[v] = 1\n        for i in g[v]:\n            if not used[i]:\n                h[i] = h[v] + 1\n                dfs(i)\n                cnt[v] = cnt[v] + cnt[i]\n    (n, k) = map(int, input().split())\n    used = [False] * (n + 1)\n    h = [0] * (n + 1)\n    cnt = [0] * (n + 1)\n    g = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if u not in g:\n            g[u] = []\n        if v not in g:\n            g[v] = []\n        g[u].append(v)\n        g[v].append(u)\n    h[1] = 1\n    dfs(1)\n    val = []\n    for i in range(1, n + 1):\n        val.append(h[i] - cnt[i])\n    val.sort(reverse=True)\n    ans = 0\n    for i in range(k):\n        ans = ans + val[i]\n    print(ans)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nimport collections\nimport threading\nimport heapq\nimport string\n\ndef DFS(tree, u, v, A, L, nc):\n    for i in tree[u]:\n        if i != v:\n            L[i] = L[u] + 1\n            nc[u] = nc[u] + 1\n            DFS(tree, i, u, A, L, nc)\n            nc[u] = nc[u] + nc[i]\n            A[u][0] = A[u][0] - A[i][1]\n    A[u][1] = A[u][1] + (nc[u] + 1) * L[u]\n    A[u][0] = A[u][1] + A[u][0]\n    return\n\ndef main():\n    (n, k) = map(int, input().split())\n    tree = {}\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        try:\n            tree[a].append(b)\n        except:\n            tree[a] = [b]\n        try:\n            tree[b].append(a)\n        except:\n            tree[b] = [a]\n    visited = [False for i in range(n + 1)]\n    A = [[0, 0] for i in range(n + 1)]\n    L = [0 for i in range(n + 1)]\n    nc = [0 for i in range(n + 1)]\n    DFS(tree, 1, 0, A, L, nc)\n    A.pop(0)\n    A.sort(reverse=True)\n    fc = 0\n    for i in range(min(k, len(A))):\n        fc = fc + A[i][0]\n    print(fc)\n    return 0\ninput = sys.stdin.readline\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "(n, k) = map(int, input().split())\ndict1 = {}\nfor i in range(1, n + 1):\n    dict1[i] = []\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    dict1[a].append(b)\n    dict1[b].append(a)\nlist1 = [1]\nfloor = [0] * (n + 1)\nfloor[1] = 1\nbaohan = [0] * (n + 1)\nwhile list1:\n    x = list1.pop()\n    for j in dict1[x]:\n        if not floor[j]:\n            list1.append(j)\n            floor[j] = floor[x] + 1\ndict2 = {}\ns = max(floor)\nset1 = set()\nfor i in range(1, s + 1):\n    dict2[i] = []\nfor i in range(1, n + 1):\n    dict2[floor[i]].append(i)\nfor x in reversed(sorted(list(dict2.keys()))):\n    for s in dict2[x]:\n        set1.add(s)\n        for m in dict1[s]:\n            if m in set1:\n                baohan[s] += baohan[m] + 1\nlist3 = [0] * n\nfor i in range(1, n + 1):\n    list3[i - 1] = floor[i] - baohan[i] - 1\nlist3.sort(reverse=True)\nprint(sum(list3[:k]))", "class node:\n\n    def __init__(self, num, depth, son, fa):\n        self.num = num\n        self.depth = depth\n        self.son = son\n        self.fa = fa\nls1 = []\nsum = 0\n\ndef bfs(now):\n    ls1.append(node(now, 0, 0, 0))\n    for i in ls1:\n        now = i.num\n        ls2[now - 1] = i\n        for j in ls[now]:\n            ls[j].remove(now)\n            ls1.append(node(j, i.depth + 1, 0, now))\n(n, k) = map(int, input().split())\nls = [[] for i in range(n + 1)]\nls2 = [node for i in range(n)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    ls[x].append(y)\n    ls[y].append(x)\nbfs(1)\nls1.reverse()\nfor i in ls1:\n    if i.fa:\n        ls2[i.fa - 1].son += ls2[i.num - 1].son + 1\nls2.sort(key=lambda x: -(x.depth - x.son))\nfor i in range(k):\n    sum += ls2[i].depth - ls2[i].son\nprint(sum)", "(N, K) = map(int, input().split())\ngraph = [[] for i in range(N + 1)]\nfor i in range(N - 1):\n    (a, b) = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nfrom collections import deque\nd = deque()\ne = deque()\nvisited = [False for _ in range(N + 1)]\ndistance = [-1 for i in range(N + 1)]\ndistance[1] = 0\npar = [-1 for i in range(N + 1)]\nvisited[1] = True\nd.append(1)\nwhile d:\n    while d:\n        x = d.popleft()\n        for node in graph[x]:\n            if visited[node] == False:\n                visited[node] = True\n                distance[node] = distance[x] + 1\n                par[node] = x\n                e.append(node)\n    if e:\n        d = e\n        e = deque()\nnode = []\nfor i in range(1, N + 1):\n    node.append((i, distance[i]))\nnode.sort(key=lambda x: -x[1])\ncnt = [1 for i in range(N + 1)]\nfor some in node:\n    (node, dis) = some\n    if par[node] > 0:\n        cnt[par[node]] += cnt[node]\nfor i in range(N + 1):\n    cnt[i] -= 1\nP = []\nfor i in range(1, N + 1):\n    P.append(cnt[i] - distance[i])\nP.sort(reverse=True)\nprint(sum(P[:N - K]))", "import sys\nsys.setrecursionlimit(10 ** 9)\ninput = sys.stdin.readline\nfrom collections import deque\n(n, k) = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\nq = deque([0])\nd = [-1] * n\nd[0] = 0\nw = [-1] * n\nww = [0] * n\nwhile q:\n    p = q.popleft()\n    for i in g[p]:\n        if d[i] == -1:\n            d[i] = d[p] + 1\n            q.append(i)\n            w[i] = p\ndp = [1] * n\nbb = []\nfor i in range(1, n):\n    bb.append([-d[i], i])\nbb.sort()\nfor i in range(n - 1):\n    dp[w[bb[i][1]]] += dp[bb[i][1]]\naa = []\nfor i in range(n):\n    aa.append(d[i] - dp[i] + 1)\naa.sort(reverse=True)\nprint(sum(aa[:k]))", "def dfs(t):\n    res = {}\n    visited = {1}\n    stack = [1]\n    depths = {1: 0}\n    pcTree = {}\n    while stack:\n        node = stack[-1]\n        if not node in pcTree:\n            pcTree[node] = []\n        for next_node in t[node]:\n            if not next_node in visited:\n                depths[next_node] = depths[node] + 1\n                stack.append(next_node)\n                visited.add(next_node)\n                pcTree[node].append(next_node)\n        if not t[node]:\n            res[node] = 0\n        if not node in res:\n            res[node] = -1\n        else:\n            res[node] = sum((res[n] + 1 for n in pcTree[node]))\n            stack.pop()\n    return (depths, res)\n(n, k) = [int(x) for x in input().split()]\ntree = {}\nfor i in range(n - 1):\n    (a, b) = [int(x) for x in input().split()]\n    if not a in tree:\n        tree[a] = []\n    if not b in tree:\n        tree[b] = []\n    tree[a].append(b)\n    tree[b].append(a)\n(depths, weights) = dfs(tree)\nres = [weights[i] - depths[i] for i in range(1, n + 1)]\nres.sort(reverse=True)\nans = sum(res[:n - k])\nprint(ans)", "class node:\n\n    def __init__(self, num, depth, son, fa):\n        self.num = num\n        self.depth = depth\n        self.son = son\n        self.fa = fa\nls1 = []\nsum = 0\n\ndef bfs(now):\n    ls1.append(node(now, 0, 0, 0))\n    for i in ls1:\n        now = i.num\n        for j in ls[now]:\n            ls[j].remove(now)\n            ls1.append(node(j, i.depth + 1, 0, now))\n(n, k) = map(int, input().split())\nls = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    ls[x].append(y)\n    ls[y].append(x)\nbfs(1)\nls1.reverse()\nls2 = sorted(ls1, key=lambda x: x.num)\nfor i in ls1:\n    if i.fa:\n        ls2[i.fa - 1].son += ls2[i.num - 1].son + 1\nls2.sort(key=lambda x: -(x.depth - x.son))\nfor i in range(k):\n    sum += ls2[i].depth - ls2[i].son\nprint(sum)", "import sys\nsys.setrecursionlimit(10 ** 9)\ninput = sys.stdin.readline\nfrom collections import deque\n(n, k) = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\nq = deque([0])\nd = [-1] * n\nd[0] = 0\nw = [-1] * n\nww = [0] * n\nwhile q:\n    p = q.popleft()\n    for i in g[p]:\n        if d[i] == -1:\n            d[i] = d[p] + 1\n            q.append(i)\n            w[i] = p\ndp = [1] * n\nbb = []\nfor i in range(1, n):\n    bb.append([-d[i], i])\nbb.sort()\nfor i in range(n - 1):\n    dp[w[bb[i][1]]] += dp[bb[i][1]]\naa = []\nfor i in range(n):\n    aa.append(d[i] - dp[i] + 1)\naa.sort(reverse=True)\nprint(sum(aa[:k]))", "(n, k) = map(int, input().split())\nG = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(lambda x: int(x) - 1, input().split())\n    G[u].append(v)\n    G[v].append(u)\norder = []\npar = [-1] * n\nstack = [0]\nwhile stack:\n    v = stack.pop()\n    order.append(v)\n    for c in G[v]:\n        if c != par[v]:\n            par[c] = v\n            stack.append(c)\npar_count = [0] * n\nchi_count = [0] * n\nfor v in order:\n    p = par[v]\n    if p != -1:\n        par_count[v] = par_count[p] + 1\nfor v in order[::-1]:\n    p = par[v]\n    if p != -1:\n        chi_count[p] += chi_count[v] + 1\nscore = [par_count[i] - chi_count[i] for i in range(n)]\nscore.sort(reverse=True)\nprint(sum(score[:k]))", "from collections import defaultdict\n(n, k) = map(int, input().split())\ng = {i: [] for i in range(n + 1)}\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\nvis = [0] * (n + 1)\nst = [[1, 0]]\nvis[1] = 1\nparent = [-1] * (n + 1)\nnon = [0] * (n + 1)\nnoe = defaultdict(int)\nwhile st:\n    u = st[-1][0]\n    l = st[-1][1]\n    ct = 0\n    for el in g[u]:\n        if vis[el] == 0:\n            vis[el] = 1\n            ct += 1\n            st.append([el, l + 1])\n            parent[el] = u\n    if ct == 0 and u != 1:\n        non[parent[u]] += 1 + non[u]\n        st.pop()\n        noe[l - non[u]] += 1\n    elif ct == 0 and u == 1:\n        break\nans = 0\nkeys = list(noe.keys())\nkeys.sort()\ni = -1\nwhile k > 0:\n    ans += keys[i] * min(k, noe[keys[i]])\n    k -= min(k, noe[keys[i]])\n    i -= 1\nprint(ans)", "(n, k) = map(int, input().split(' '))\nk = n - k\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = map(int, input().split(' '))\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\nvisited = [False] * n\nstack = [0]\nheight = [-1] * n\nheight[0] = 0\nwhile stack:\n    temp = stack.pop()\n    for i in arr[temp]:\n        if height[i] == -1:\n            height[i] = height[temp] + 1\n            stack.append(i)\nnochild = [0] * n\nheightsort = [0] * n\nfor i in range(n):\n    heightsort[i] = [height[i], i]\nheightsort.sort(reverse=True)\nfor node in heightsort:\n    count = 0\n    curr = node[1]\n    for i in arr[curr]:\n        if height[i] == height[curr] + 1:\n            count += nochild[i] + 1\n    nochild[curr] = count\nnochildsort = []\nfor i in range(n):\n    nochildsort.append(nochild[i] - height[i])\nnochildsort.sort(reverse=True)\nfinalans = 0\nfor i in range(k):\n    finalans += nochildsort[i]\nprint(finalans)", "import sys\nimport heapq as hq\nstdin = sys.stdin\nns = lambda : stdin.readline().rstrip()\nni = lambda : int(stdin.readline().rstrip())\nnm = lambda : map(int, stdin.readline().split())\nnl = lambda : list(map(int, stdin.readline().split()))\n(n, k) = nm()\ng = [list() for _ in range(n)]\nfor _ in range(n - 1):\n    (a, b) = nm()\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\nans = 0\nsize = [1] * n\ndep = [0] * n\npar = [-1] * n\ndfsl = []\nq = [0]\nwhile q:\n    v = q.pop()\n    dfsl.append(v)\n    for x in g[v]:\n        if x == par[v]:\n            continue\n        dep[x] = dep[v] + 1\n        par[x] = v\n        q.append(x)\nfor v in reversed(dfsl):\n    for x in g[v]:\n        if x == par[v]:\n            continue\n        size[v] += size[x]\nm = n - k\nans = 0\nq = [(-n + 1, 0)]\nfor _ in range(m):\n    (c, v) = hq.heappop(q)\n    ans += c\n    for x in g[v]:\n        if dep[x] < dep[v]:\n            continue\n        hq.heappush(q, (dep[x] - size[x] + 1, x))\nprint(-ans)", "import sys\nimport heapq as hq\nstdin = sys.stdin\nns = lambda : stdin.readline().rstrip()\nni = lambda : int(stdin.readline().rstrip())\nnm = lambda : map(int, stdin.readline().split())\nnl = lambda : list(map(int, stdin.readline().split()))\n(n, k) = nm()\ng = [list() for _ in range(n)]\nfor _ in range(n - 1):\n    (a, b) = nm()\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\nans = 0\nsize = [1] * n\ndep = [0] * n\npar = [-1] * n\ndfsl = []\nq = [0]\nwhile q:\n    v = q.pop()\n    dfsl.append(v)\n    for x in g[v]:\n        if x == par[v]:\n            continue\n        dep[x] = dep[v] + 1\n        par[x] = v\n        q.append(x)\nfor v in reversed(dfsl):\n    for x in g[v]:\n        if x == par[v]:\n            continue\n        size[v] += size[x]\nm = n - k\nans = 0\nq = [(-n + 1, 0)]\nfor _ in range(m):\n    (c, v) = hq.heappop(q)\n    ans += c\n    for x in g[v]:\n        if dep[x] < dep[v]:\n            continue\n        hq.heappush(q, (dep[x] - size[x] + 1, x))\nprint(-ans)", "class node:\n\n    def __init__(self, num, depth, son, fa):\n        self.num = num\n        self.depth = depth\n        self.son = son\n        self.fa = fa\nls1 = []\nsum = 0\n\ndef bfs(now):\n    ls1.append(node(now, 0, 0, 0))\n    for i in ls1:\n        now = i.num\n        for j in ls[now]:\n            ls[j].remove(now)\n            ls1.append(node(j, i.depth + 1, 0, now))\n(n, k) = map(int, input().split())\nls = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    ls[x].append(y)\n    ls[y].append(x)\nbfs(1)\nls1.reverse()\nls2 = sorted(ls1, key=lambda x: x.num)\nfor i in ls1:\n    if i.fa:\n        ls2[i.fa - 1].son += ls2[i.num - 1].son + 1\nls2.sort(key=lambda x: -(x.depth - x.son))\nfor i in range(k):\n    sum += ls2[i].depth - ls2[i].son\nprint(sum)", "import sys\nlines = sys.stdin.readlines()\n(n, k) = map(int, lines[0].strip().split(' '))\nedges = {}\nfor i in range(1, n):\n    (a, b) = map(int, lines[i].strip().split(' '))\n    if a not in edges:\n        edges[a] = []\n    if b not in edges:\n        edges[b] = []\n    edges[a].append(b)\n    edges[b].append(a)\nseen = set([1])\nstack = [1]\nlevel = {1: 0}\nparent = {1: 0}\nwhile stack:\n    node = stack.pop()\n    for adj in edges[node]:\n        if adj not in seen:\n            seen.add(adj)\n            level[adj] = level[node] + 1\n            stack.append(adj)\n            parent[adj] = node\nnoChild = {}\nstack = [1]\nwhile stack:\n    node = stack.pop()\n    all = True\n    for adj in edges[node]:\n        if adj != parent[node] and adj not in noChild:\n            all = False\n            break\n    if all:\n        tmp = 0\n        for adj in edges[node]:\n            if adj == parent[node]:\n                continue\n            tmp += noChild[adj] + 1\n        noChild[node] = tmp\n    else:\n        stack.append(node)\n        for adj in edges[node]:\n            if adj == parent[node]:\n                continue\n            if adj not in noChild:\n                stack.append(adj)\nres = [level[i] - noChild[i] for i in range(1, n + 1)]\nres.sort(reverse=True)\nprint(sum(res[:k]))", "(n, k) = map(int, input().split())\nl = {i + 1: [] for i in range(n)}\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    l[a].append(b)\n    l[b].append(a)\nd = {i + 1: -1 for i in range(n)}\nd[1] = 0\nq = [1]\nwhile q:\n    q1 = []\n    for a in q:\n        for b in l[a]:\n            if d[b] == -1:\n                d[b] = d[a] + 1\n                q1.append(b)\n    q = q1\nind = {i + 1: 0 for i in range(n)}\nind[1] = len(l[1])\nfor i in range(2, n + 1):\n    ind[i] = len(l[i]) - 1\nsize = {i + 1: 0 for i in range(n)}\nq = []\nfor i in range(1, n + 1):\n    if ind[i] == 0:\n        q.append(i)\n        ind[i] = -1\nwhile q:\n    q1 = []\n    for a in q:\n        for b in l[a]:\n            if d[a] == d[b] + 1:\n                size[b] += size[a] + 1\n                ind[b] -= 1\n                if ind[b] == 0:\n                    q1.append(b)\n    q = q1\nx = []\nfor i in range(1, n + 1):\n    x.append(d[i] - size[i])\nx = sorted(x)\nprint(sum(x[n - k:]))", "(n, k) = map(int, input().split())\nroads = {}\nnodes = {}\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    roads.setdefault(u, set()).add(v)\n    roads.setdefault(v, set()).add(u)\nproc = set()\nproc_stack = [1]\nin_stack = []\nchlds = {}\nwhile len(proc_stack) > 0:\n    node = proc_stack[-1]\n    if node not in proc:\n        proc.add(node)\n        rds = roads[node] - proc\n        chlds[node] = rds\n        proc_stack.extend(rds)\n        in_stack.append(node)\n    else:\n        proc_stack.pop()\n        in_stack.pop()\n        nodes[node] = (len(in_stack), sum((nodes[c][1] for c in chlds[node])) + len(chlds[node]))\nprint(sum(sorted((n[0] - n[1] for n in nodes.values()), reverse=True)[:k]))", "from sys import stdin\n(n, k) = map(int, stdin.readline().split(' '))\nk = n - k\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    (a, b) = map(int, stdin.readline().split(' '))\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\nvisited = [False] * n\nstack = [0]\nheight = [-1] * n\nheight[0] = 0\nwhile stack:\n    temp = stack.pop()\n    for i in arr[temp]:\n        if height[i] == -1:\n            height[i] = height[temp] + 1\n            stack.append(i)\nnochild = [0] * n\nheightsort = [0] * n\nfor i in range(n):\n    heightsort[i] = [height[i], i]\nheightsort.sort(reverse=True)\nfor node in heightsort:\n    count = 0\n    curr = node[1]\n    for i in arr[curr]:\n        if height[i] == height[curr] + 1:\n            count += nochild[i] + 1\n    nochild[curr] = count\nnochildsort = []\nfor i in range(n):\n    nochildsort.append([nochild[i] - height[i], i])\nnochildsort.sort(reverse=True)\nvisited = [False] * n\nfor i in range(k):\n    visited[nochildsort[i][1]] = True\nfinalans = 0\nfor i in range(k):\n    currnode = nochildsort[i][1]\n    for j in arr[currnode]:\n        if not visited[j]:\n            finalans += height[j] * (1 + nochild[j])\nprint(finalans)"]