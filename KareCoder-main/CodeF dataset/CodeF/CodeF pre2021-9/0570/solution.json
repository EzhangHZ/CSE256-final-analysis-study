["def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n(n, m) = map(int, input().split())\nmd = 998244353\nif n == 2:\n    print(0)\nelse:\n    ans = ncr(m, n - 1, md)\n    ans = ans * (n - 2) % md\n    ans = ans * pow(2, n - 3, md) % md\n    print(ans)", "M = 998244353\n(n, m) = map(int, input().split())\nf = []\nf.append(1)\nfor i in range(1, m + 1):\n    f.append(f[i - 1] * i % M)\nprint(f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) * (n - 2) * pow(2, n - 3, M) % M)", "(n, m) = map(int, input().split())\nf = [1]\nfor i in range(m):\n    f += (f[-1] * (i + 1) % 998244353,)\nprint((n - 2) * pow(2, n - 3, 998244353) * f[m] * pow(f[n - 1] * f[m - n + 1], 998244351, 998244353) % 998244353)", "(n, m) = map(int, input().split())\nf = [1]\nfor i in range(m):\n    f += (f[-1] * (i + 1) % 998244353,)\nprint((n - 2) * pow(2, n - 3, 998244353) * f[m] * pow(f[n - 1] * f[m - n + 1], 998244351, 998244353) % 998244353)", "fc = [1, 1]\nMOD = 998244353\nfor i in range(2, 2 * 10 ** 5 + 3):\n    fc.append(fc[-1] * i % MOD)\n\ndef slv(n, m):\n    if n == 2:\n        return 0\n    ans = 0\n    c = fc[m] * pow(fc[m - n + 1], MOD - 2, MOD) * pow(fc[n - 1], MOD - 2, MOD)\n    c %= MOD\n    c *= n - 2\n    c *= 2 ** (n - 3)\n    c %= MOD\n    ans += c\n    ans %= MOD\n    return ans\n(n, m) = map(int, input().split())\nprint(slv(n, m))", "from collections import Counter\nfrom collections import defaultdict as dfd\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial\nfrom heapq import heapify, heappush, heappop\nMOD = 998244353\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef facto():\n    N = 2 * 10 ** 5 + 1\n    facto = [0] * N\n    facto[0] = 1\n    i = 1\n    for i in range(1, N):\n        facto[i] = facto[i - 1] * i % MOD\n    return facto\n\ndef solve():\n    fact = facto()\n    (n, m) = read()\n    ans = fact[m] * pow(fact[m - n + 1] * fact[n - 1], MOD - 2, MOD) % MOD\n    ans *= (n - 2) * pow(2, n - 3, MOD) % MOD\n    ans %= MOD\n    ans_.append(ans)\nsolve()\nfor i in ans_:\n    print(i)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n(n, m) = map(int, input().split())\nans = ncr(m, n - 1, 998244353) * pow(2, n - 3, 998244353) * ((n - 2) % 998244353) % 998244353\nprint(ans)", "def power(x, y, p):\n    start = 1\n    answer = x\n    b = bin(y)[2:]\n    for i in range(len(b)):\n        d = b[len(b) - 1 - i]\n        if d == '1':\n            start = start * answer % p\n        answer = answer * answer % p\n    return start\n\ndef binom(x, y, p):\n    num = 1\n    den = 1\n    for i in range(y):\n        num = num * (x - i) % p\n        den = den * (y - i) % p\n    den_inverse = power(den, p - 2, p)\n    return num * den_inverse % p\n\ndef process(n, m, p=998244353):\n    a = binom(m, n - 1, p)\n    b = n - 2\n    c = power(2, n - 3, p)\n    return a * b * c % p\n(n, m) = [int(x) for x in input().split()]\nprint(process(n, m))", "import sys, math\n\ndef nCr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef ip():\n    (n, m) = map(int, input().split())\n    ans = 0\n    mod = 998244353\n    ans = nCr(m, n - 1, mod)\n    mul = pow(2, n - 3, mod)\n    print(ans * mul % mod * (n - 2) % mod)\nip()", "import math\nMOD = 998244353\n(n, m) = map(int, input().split())\nfact = [1]\nfor i in range(1, m + 2):\n    fact.append(fact[-1] * i % MOD)\nres = (n - 2) * fact[m] * pow(fact[n - 1] * fact[m - (n - 1)], MOD - 2, MOD) * pow(2, n - 3, MOD) % MOD\nprint(res)", "def power(x, a):\n    if a <= 0:\n        return 1\n    z = power(x, a // 2)\n    z = z * z % 998244353\n    if a % 2:\n        z = z * x % 998244353\n    return z\n\ndef ncr(n, r):\n    fact = [1]\n    for i in range(1, n + 1):\n        fact.append(i * fact[i - 1] % 998244353)\n    return fact[n] * power(fact[r], 998244351) * power(fact[n - r], 998244351)\n[n, m] = list(map(int, input().split()))\nans = ncr(m, n - 1) * (n - 2) % 998244353\nans = ans * power(2, n - 3) % 998244353\nprint(ans)", "import math\nM = 998244353\n\ndef count_the_arrays(n, m):\n    comb = c(m, n - 1, M)\n    result = comb * ((n - 2) % M) % M * pow(2, n - 3, M) % M\n    return result\n\ndef factorial(m):\n    facts = [1 for _ in range(m + 1)]\n    for n in range(1, m + 1):\n        facts[n] = facts[n - 1] * n % M\n    return facts\n\ndef c(n, k, M):\n    f = factorial(max(n, k))\n    (_, inv_n, _) = extended_euclidean_alg(f[k], M)\n    (_, inv_n_k, _) = extended_euclidean_alg(f[n - k], M)\n    return f[n] * (inv_n % M) % M * (inv_n_k % M) % M\n\ndef extended_euclidean_alg(a, b):\n    if not b:\n        return (0, 1, 0)\n    (u0, u1) = (1, 0)\n    (v0, v1) = (0, 1)\n    while b:\n        q = a // b\n        r = a - b * q\n        u = u0 - q * u1\n        v = v0 - q * v1\n        a = b\n        b = r\n        u0 = u1\n        u1 = u\n        v0 = v1\n        v1 = v\n    return (a, u0, v0)\n\ndef main():\n    (n, m) = [int(i) for i in input().split()]\n    count = count_the_arrays(n, m)\n    print(int(count))\nmain()", "M = 998244353\n\ndef count_the_arrays(n, m):\n    comb = c(m, n - 1)\n    result = comb * ((n - 2) % M) % M * pow(2, n - 3, M) % M\n    return result\n\ndef factorial(m):\n    facts = [1 for _ in range(m + 1)]\n    for n in range(1, m + 1):\n        facts[n] = facts[n - 1] * n % M\n    return facts\n\ndef c(n, k):\n    f = factorial(n)\n    inv_n = pow(f[k], M - 2, M)\n    inv_n_k = pow(f[n - k], M - 2, M)\n    return f[n] * (inv_n % M) % M * (inv_n_k % M) % M\n\ndef main():\n    (n, m) = [int(i) for i in input().split()]\n    count = count_the_arrays(n, m)\n    print(int(count))\nmain()", "import math\nM = 998244353\n\ndef count_the_arrays(n, m):\n    comb = c(m, n - 1)\n    result = comb * ((n - 2) % M) % M * pow(2, n - 3, M) % M\n    return result\n\ndef factorial(m):\n    facts = [1 for _ in range(m + 1)]\n    for n in range(1, m + 1):\n        facts[n] = facts[n - 1] * n % M\n    return facts\n\ndef c(n, k):\n    f = factorial(n)\n    inv_n = pow(f[k], M - 2, M)\n    inv_n_k = pow(f[n - k], M - 2, M)\n    return f[n] * (inv_n % M) % M * (inv_n_k % M) % M\n\ndef main():\n    (n, m) = [int(i) for i in input().split()]\n    count = count_the_arrays(n, m)\n    print(int(count))\nmain()", "num_inp = lambda : int(input())\narr_inp = lambda : list(map(int, input().split()))\nsp_inp = lambda : map(int, input().split())\nstr_inp = lambda : input()\nM = 998244353\n(n, m) = map(int, input().split())\nf = {}\nf[0] = 1\nfor i in range(1, m + 1):\n    f[i] = f[i - 1] * i % M\nans = (n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M\nprint(ans)", "(n, m) = map(int, input().split())\nM = 998244353\nf = [1]\nfor i in range(1, m + 1):\n    f.append(f[-1] * i % M)\nr = (n - 2) * pow(2, n - 3, M) % M * (f[m] * pow(f[n - 1] * f[m - n + 1] % M, -1, M) % M)\nprint(r % M)", "ma = 998244353\n(n, m) = map(int, input().split())\nfact = [1]\nfor i in range(1, m + 1):\n    fact.append(fact[-1] * i % ma)\nans = fact[m] * pow(fact[n - 1] * fact[m - n + 1], ma - 2, ma) * (n - 2) * pow(2, n - 3, ma) % ma\nprint(ans)", "z = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(1, m + 1):\n    f += (f[-1] * i % z,)\nans = f[m] * pow(2, n - 3, z) * pow(f[n - 1], z - 2, z) * pow(f[m - n + 1], z - 2, z) * (n - 2) % z\nprint(ans)", "M = 998244353\n\ndef count_the_arrays(n, m):\n    comb = c(m, n - 1)\n    result = comb * ((n - 2) % M) % M * pow(2, n - 3, M) % M\n    return result\n\ndef factorial(m):\n    facts = [1 for _ in range(m + 1)]\n    for n in range(1, m + 1):\n        facts[n] = facts[n - 1] * n % M\n    return facts\n\ndef c(n, k):\n    f = factorial(max(n, k))\n    inv_n = pow(f[k], M - 2, M)\n    inv_n_k = pow(f[n - k], M - 2, M)\n    return f[n] * (inv_n % M) % M * (inv_n_k % M) % M\n\ndef main():\n    (n, m) = [int(i) for i in input().split()]\n    count = count_the_arrays(n, m)\n    print(int(count))\nmain()", "import math\nmod = 998244353\n\ndef cal_comb(m, n):\n    numerator = 1\n    denominator = 1\n    for i in range(n):\n        numerator = numerator * (m - i) % mod\n        denominator = denominator * (i + 1) % mod\n    return numerator * pow(denominator, mod - 2, mod)\n(n, m) = map(int, input().split())\nprint(cal_comb(m, n - 1) * pow(2, n - 3, mod) % mod * (n - 2) % mod)", "import math\n\ndef powerMo(a, n, mo):\n    ans = 1\n    posi = a\n    while n > 0:\n        if n & 1:\n            ans *= posi\n            ans %= mo\n        n >>= 1\n        posi = posi * posi % mo\n    return ans\n\ndef modInv(a, mo):\n    phi = mo - 1\n    return powerMo(a, phi - 1, mo)\n\ndef combMo(n, a, mo):\n    numer = 1\n    for i in range(n - a + 1, n + 1):\n        numer *= i\n        numer %= mo\n    denom = 1\n    for i in range(1, a + 1):\n        denom *= i\n        denom %= mo\n    denomInv = modInv(denom, mo)\n    ans = numer * denomInv % mo\n    return ans\n\ndef f():\n    mo = 998244353\n    (n, m) = [int(s) for s in input().split()]\n    if n == 2:\n        print(0)\n        return\n    c = combMo(m, n - 1, mo)\n    c *= n - 2\n    a = powerMo(2, n - 3, mo)\n    res = a * c % mo\n    print(res)\nf()", "import sys\nread = lambda : list(map(int, sys.stdin.readline().strip().split()))\nmod = 998244353\n\ndef power(a, b):\n    val = 1\n    while b > 0:\n        if b % 2 == 1:\n            val = val * a % mod\n        b = b // 2\n        a = a * a % mod\n    return val\n(n, m) = read()\nfact = [1]\nfor i in range(1, m + 1):\n    fact.append(fact[i - 1] * i % mod)\nans = power(2, n - 3)\nans = ans * (n - 2) % mod\nres = fact[m] * power(fact[n - 1], mod - 2)\nres = res * power(fact[m - n + 1], mod - 2) % mod\nans = ans * res % mod\nprint(ans)", "M = 998244353\n(n, m) = map(int, input().split())\nf = []\nf.append(1)\nfor i in range(1, m + 1):\n    f.append(f[i - 1] * i % M)\nprint(f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) * (n - 2) * pow(2, n - 3, M) % M)", "M = 998244353\n(n, m) = map(int, input().split())\nf = []\nf.append(1)\nfor i in range(1, m + 1):\n    f.append(f[i - 1] * i % M)\nprint(f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) * (n - 2) * pow(2, n - 3, M) % M)", "import math\nmod = 998244353\nfact = [1]\n(n, m) = map(int, input().split(' '))\nfor i in range(1, m + 1):\n    fact.append(fact[-1] * i % mod)\nans = (n - 2) * fact[m] * pow(fact[n - 1] * fact[m - n + 1], mod - 2, mod) * pow(2, n - 3, mod)\nprint(ans % mod)", "MOD = 998244353\n\ndef pow(base, exp):\n    if exp == -1:\n        return pow(base, MOD - 2)\n    res = 1\n    base %= MOD\n    while exp > 0:\n        if exp % 2:\n            res = res * base % MOD\n        exp //= 2\n        base = base * base % MOD\n    res %= MOD\n    return res\n\ndef main():\n    (n, m) = map(int, input().split())\n    fact = [0] * (m + 1)\n    fact[0] = 1\n    for i in range(1, m + 1):\n        fact[i] = i * fact[i - 1] % MOD\n    ans = fact[m] * pow(2, n - 3) * (n - 2)\n    ans %= MOD\n    ans = ans * pow(fact[n - 1], MOD - 2)\n    ans %= MOD\n    ans = ans * pow(fact[m - n + 1], MOD - 2)\n    ans %= MOD\n    print(ans)\n    return\nmain()", "fc = [1, 1]\nMOD = 998244353\nfor i in range(2, 2 * 10 ** 5 + 3):\n    fc.append(fc[-1] * i % MOD)\n\ndef slv(n, m):\n    if n == 2:\n        return 0\n    ans = 0\n    c = fc[m] * pow(fc[m - n + 1], MOD - 2, MOD) * pow(fc[n - 1], MOD - 2, MOD)\n    c %= MOD\n    c *= n - 2\n    c *= 2 ** (n - 3)\n    c %= MOD\n    ans += c\n    ans %= MOD\n    return ans\n(n, m) = map(int, input().split())\nprint(slv(n, m))", "M = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(m):\n    f += (f[-1] * (i + 1) % M,)\nprint((n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\np = 998244353\n(n, m) = map(int, input().split())\nprint(ncr(m, n - 1, p) * (n - 2) * pow(2, n - 3, p) % p)", "def inverse(k, mod):\n    return pow(k, mod - 2, mod)\n\ndef solve():\n    mod = 998244353\n    line = input().split(' ')\n    n = int(line[0])\n    m = int(line[1])\n    fact = []\n    fact.append(1)\n    if n > m:\n        k = n + 1\n    else:\n        k = m + 1\n    for i in range(1, k):\n        fact.append(0)\n        fact[i] = fact[i - 1] * i\n        fact[i] = fact[i] % mod\n    if n - 1 > m:\n        combinaciones = 0\n    else:\n        combinaciones = fact[m] * inverse(fact[n - 1], mod) * inverse(fact[m - n + 1], mod)\n    ans = combinaciones * (n - 2) * pow(2, n - 3, mod)\n    while ans > mod:\n        ans = ans % mod\n    print(int(ans))\nsolve()", "MOD = 998244353\n\ndef factorial(n):\n    prod = 1\n    for i in range(1, n + 1):\n        prod *= i\n        prod %= MOD\n    return prod\n\ndef fastExp(base, exp):\n    if exp == 0:\n        return 1\n    ans = fastExp(base, exp // 2) ** 2\n    if exp % 2 == 1:\n        ans *= base\n    return ans % MOD\n\ndef modularInverse(n):\n    return fastExp(n, MOD - 2)\n\ndef nChooseK(n, k):\n    return factorial(n) * modularInverse(factorial(k)) * modularInverse(factorial(n - k))\n(n, m) = [int(i) for i in input().split()]\nif n == 2:\n    print(0)\nelse:\n    print(nChooseK(m, n - 1) * (n - 2) * fastExp(2, n - 3) % MOD)", "M = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(m):\n    f += (f[-1] * (i + 1) % M,)\nprint((n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M)", "MOD = 998244353\n\ndef pow_mod(n, k, mod):\n    if k == 0:\n        return 1\n    if k % 2 == 1:\n        return n * pow_mod(n, k - 1, mod) % mod\n    else:\n        r = pow_mod(n, k // 2, mod)\n        return r * r % mod\n\ndef mod_inverse(n, mod):\n    return pow_mod(n, mod - 2, mod)\n\ndef fact_mod(n, mod):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i % mod\n    return res\n\ndef choose_mod(n, k, mod):\n    return fact_mod(n, mod) * mod_inverse(fact_mod(k, mod), mod) * mod_inverse(fact_mod(n - k, mod), mod) % mod\n(n, m) = map(int, input().split())\nif n == 2:\n    print(0)\nelse:\n    res = choose_mod(m, n - 1, MOD) * ((n - 2) % MOD) * pow_mod(2, n - 3, MOD)\n    print(res % MOD)", "M = 998244353\n(n, m) = map(int, input().split())\nd = [1]\nfor i in range(m):\n    d += (d[-1] * (i + 1) % M,)\nprint((n - 2) * pow(2, n - 3, M) * d[m] * pow(d[n - 1] * d[m - n + 1], M - 2, M) % M)", "from sys import stdin\nmod = 998244353\nfact = [1, 1]\nfor i in range(2, 200001):\n    fact.append(fact[i - 1] * i % mod)\n\ndef ncr(n, r):\n    m = pow(fact[r] * fact[n - r], mod - 2, mod)\n    return fact[n] * m % mod\n(n, m) = map(int, stdin.readline().split())\nif n > 2:\n    ans = ncr(m, n - 1) * (n - 2) * pow(2, n - 3, mod)\n    print(ans % mod)\nelse:\n    print(0)", "MOD = 998244353\nfak = []\nfak.append(1)\nfor i in range(200005):\n    fak.append(fak[-1] * (i + 1) % MOD)\n\ndef brzo(x, y):\n    if not y:\n        return 1\n    if y % 2:\n        return brzo(x, y - 1) * x % MOD\n    k = brzo(x, y // 2)\n    return k * k % MOD\n\ndef inv(x):\n    return brzo(x, MOD - 2)\n(n, m) = map(int, input().split())\nif n <= 2:\n    print(0)\nelse:\n    print(fak[m] * inv(fak[n - 1] * fak[m - n + 1]) * (n - 2) * (1 << n - 3) % MOD)", "mod = 998244353\nfact = [1, 1]\nfor i in range(2, 200001):\n    fact.append(fact[i - 1] * i % mod)\n\ndef ncr(n, r):\n    m = pow(fact[r] * fact[n - r], mod - 2, mod)\n    return fact[n] * m % mod\n(n, m) = map(int, input().split())\nif n > 2:\n    ans = ncr(m, n - 1) * (n - 2) * pow(2, n - 3, mod)\n    print(ans % mod)\nelse:\n    print(0)", "MOD = 998244353\n\ndef inv_mod(k):\n    return pow(k, MOD - 2, MOD)\n\ndef comb(n, k):\n    return fact[n] * inv_mod(fact[k]) % MOD * inv_mod(fact[n - k]) % MOD\n(n, m) = map(int, input().split())\nfact = []\nfact.append(1)\nfor i in range(1, m + 1):\n    fact.append(fact[i - 1] * i % MOD)\nans = 0\nif n > 2:\n    ans = (n - 2) * comb(m, n - 1) % MOD * pow(2, n - 3, MOD) % MOD\nprint(ans)", "z = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(1, m + 1):\n    f += (f[-1] * i % z,)\nans = f[m] * pow(2, n - 3, z) * pow(f[n - 1], z - 2, z) * pow(f[m - n + 1], z - 2, z) * (n - 2) % z\nprint(ans)", "M = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(m):\n    f += (f[-1] * (i + 1) % M,)\nprint((n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M)", "M = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(m):\n    f += (f[-1] * (i + 1) % M,)\nprint((n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M)", "z = 998244353\n(n, m) = map(int, input().split())\nf = [1]\nfor i in range(1, m + 1):\n    f += (f[-1] * i % z,)\nans = f[m] * pow(2, n - 3, z) * pow(f[n - 1], z - 2, z) * pow(f[m - n + 1], z - 2, z) * (n - 2) % z\nprint(ans)", "(n, m) = map(int, input().split())\nM = 998244353\nf = [1]\nfor i in range(m):\n    f += [f[-1] * (i + 1) % M]\nprint((n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M)", "M = 998244353\n(n, m) = map(int, input().split())\nf = {}\nf[0] = 1\nfor i in range(1, m + 1):\n    f[i] = f[i - 1] * i % M\nans = (n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M\nprint(ans)", "def inverse(k, mod):\n    return pow(k, mod - 2, mod)\n\ndef solve():\n    mod = 998244353\n    line = input().split(' ')\n    n = int(line[0])\n    m = int(line[1])\n    fact = []\n    fact.append(1)\n    if n > m:\n        k = n + 1\n    else:\n        k = m + 1\n    for i in range(1, k):\n        fact.append(0)\n        fact[i] = fact[i - 1] * i\n        fact[i] = fact[i] % mod\n    if n - 1 > m:\n        combinaciones = 0\n    else:\n        combinaciones = fact[m] * inverse(fact[n - 1], mod) * inverse(fact[m - n + 1], mod)\n    ans = combinaciones * (n - 2) * pow(2, n - 3, mod)\n    ans = ans % mod\n    print(int(ans))\nsolve()", "import math\nmod = 998244353\n\ndef cal_comb(m, n):\n    num = den = 1\n    for i in range(n):\n        num = num * (m - i) % mod\n        den = den * (i + 1) % mod\n    return num * pow(den, mod - 2, mod)\n(n, m) = map(int, input().split())\nans = cal_comb(m, n - 1)\nprint(ans * pow(2, n - 3, mod) % mod * (n - 2) % mod)", "(n, m) = [int(x) for x in input().split()]\nmod = 998244353\nf = [1 for i in range(200002)]\nfor i in range(1, 200002):\n    f[i] = f[i - 1] * i % mod\n\ndef C(x, y):\n    if x >= y and y >= 0:\n        ans = f[x] * pow(f[x - y], mod - 2, mod)\n        ans %= mod\n        return ans * pow(f[y], mod - 2, mod) % mod\n    return 0\nif n == 2:\n    print(0)\nelse:\n    c = C(m, n - 1)\n    c = c * (n - 2) * pow(2, n - 3, mod)\n    c = c % mod\n    print(c)", "from collections import deque, Counter\nimport array\nfrom itertools import combinations, permutations\nfrom math import sqrt, factorial\n\ndef read_int():\n    return int(input().strip())\n\ndef read_int_array():\n    return [int(i) for i in input().strip().split(' ')]\nMOD = 998244353\n\ndef binpow(a, n, mod):\n    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    if n % 2 == 1:\n        return binpow(a, n - 1, mod) * a % mod\n    b = binpow(a, n // 2, mod)\n    return b * b % mod\n\ndef comb(n, k):\n    x = 1\n    for i in range(n - k + 1, n + 1):\n        x = x * i % MOD\n    y = 1\n    for i in range(2, k + 1):\n        y = y * i % MOD\n    y = binpow(y, MOD - 2, MOD)\n    return x * y % MOD\n\ndef mypow(a, x):\n    return a ** x % MOD\n\ndef solve():\n    (n, m) = read_int_array()\n    if n == 2:\n        print(0)\n        return\n    ans = comb(m, n - 1)\n    ans = ans * (n - 2) % MOD\n    ans = ans * mypow(2, n - 3) % MOD\n    print(int(ans))\nsolve()", "def mod_inverse(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef mod_comb(n, k, mod):\n    (numer, denom) = (1, 1)\n    for i in range(k):\n        numer = numer * ((n - i) % mod) % mod\n        denom = denom * ((i + 1) % mod) % mod\n    return numer * mod_inverse(denom, mod) % mod\n(n, m) = map(int, input().split())\nmod = 998244353\nans = mod_comb(m, n - 1, mod)\nans = ans * (n - 2) % mod\nans = ans * pow(2, n - 3, mod) % mod\nprint(ans)", "(n, m) = map(int, input().split())\nif n == 2:\n    print(0)\n    exit()\nmod = 998244353\nans = (n - 2) * pow(2, n - 3, mod) % mod\nfor i in range(m - n + 2, m + 1):\n    ans = ans * i % mod\nfact = 1\nfor i in range(2, n):\n    fact = fact * i % mod\nfact = pow(fact, mod - 2, mod)\nans = ans * fact % mod\nprint(ans)", "(n, m) = map(int, input().split())\nif n == 2:\n    print(0)\n    exit()\nmod = 998244353\nans = (n - 2) * pow(2, n - 3, mod) % mod\nfor i in range(m - n + 2, m + 1):\n    ans = ans * i % mod\nfact = 1\nfor i in range(2, n):\n    fact = fact * i % mod\nfact = pow(fact, mod - 2, mod)\nans = ans * fact % mod\nprint(ans)", "(n, m) = map(int, input().split())\nif n == 2:\n    print(0)\n    exit()\nmod = 998244353\nans = (n - 2) * pow(2, n - 3, mod) % mod\nfor i in range(m - n + 2, m + 1):\n    ans = ans * i % mod\nfact = 1\nfor i in range(2, n):\n    fact = fact * i % mod\nfact = pow(fact, mod - 2, mod)\nans = ans * fact % mod\nprint(ans)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n(n, m) = map(int, input().split())\np = 998244353\nprint(ncr(m, n - 1, p) * (n - 2) * pow(2, max(n - 3, 0), p) % p)", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\nfrom collections import defaultdict as dd, deque\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return map(int, data().split())\nmod = 998244353\n\ndef fac(x):\n    f = 1\n    for i in range(2, x + 1):\n        f = f * i % mod\n    return f\n(n, m) = mdata()\nans = fac(m) * (n - 2) * pow(2, n - 3, mod) * pow(fac(n - 1), mod - 2, mod) * pow(fac(m - n + 1), mod - 2, mod)\nprint(ans % mod)", "M = 998244353\nf = [1]\nfor i in range(4 ** 9):\n    f += (f[-1] * (i + 1) % M,)\n(n, m) = map(int, input().split())\nprint((n - 2) * pow(2, n - 3, M) * f[m] * pow(f[n - 1] * f[m - n + 1], M - 2, M) % M)", "def main():\n    import sys\n    input = sys.stdin.readline\n    N = 2 * 10 ** 5 + 3\n    mod = 998244353\n    fac = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fac[i] = fac[i - 1] * i % mod\n    inv_fac = [1] * (N + 1)\n    inv_fac[N] = pow(fac[N], mod - 2, mod)\n    for i in range(N - 1, 0, -1):\n        inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod\n\n    def nCr(n, r):\n        if n <= 0 or r < 0 or r > n:\n            return 0\n        return fac[n] * inv_fac[r] % mod * inv_fac[n - r] % mod\n    (n, m) = map(int, input().split())\n    ans = (n - 2) * pow(2, n - 3, mod=mod) % mod * nCr(m, n - 1) % mod\n    print(ans)\nmain()", "class FactMod:\n\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.f = [1] * (n + 1)\n        for j in range(1, n + 1):\n            self.f[j] = self.f[j - 1] * j % mod\n        self.inv = [pow(self.f[-1], mod - 2, mod)]\n        for i in range(1, n + 1)[::-1]:\n            self.inv.append(self.inv[-1] * i % mod)\n        self.inv.reverse()\n\n    def comb(self, n, r):\n        ret = self.f[n] * self.inv[n - r] * self.inv[r]\n        ret %= self.mod\n        return ret\n(N, M) = map(int, input().split())\nMOD = 998244353\nF = FactMod(M, MOD)\nif N == 2:\n    print(0)\nelse:\n    ans = F.comb(M, N - 1) * (N - 2) * pow(2, N - 3, MOD) % MOD\n    print(ans)", "class FactMod:\n\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.f = [1] * (n + 1)\n        for i in range(1, n + 1):\n            self.f[i] = self.f[i - 1] * i % mod\n        self.inv = [pow(self.f[-1], mod - 2, mod)]\n        for i in range(1, n + 1)[::-1]:\n            self.inv.append(self.inv[-1] * i % mod)\n        self.inv.reverse()\n\n    def comb(self, n, r):\n        ret = self.f[n] * self.inv[n - r] * self.inv[r]\n        ret %= self.mod\n        return ret\n(N, M) = map(int, input().split())\nMOD = 998244353\nF = FactMod(M, MOD)\nif N == 2:\n    print(0)\nelse:\n    ans = F.comb(M, N - 1) * (N - 2) * pow(2, N - 3, MOD) % MOD\n    print(ans)", "(n, m) = input().split()\nn = int(n)\nm = int(m)\nmod = 998244353\nx1 = x2 = 1\ni = m\nwhile i > m - n + 1:\n    x1 = x1 * i % mod\n    i -= 1\ni = 1\nwhile i < n:\n    x2 = x2 * i % mod\n    i += 1\nres = pow(x2, mod - 2, mod)\nprint(int(res * x1 * pow(2, n - 3, mod) * (n - 2)) % mod)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n(n, m) = map(int, input().split())\np = 998244353\nans = ncr(m, n - 1, p)\nans = ans * (n - 2) % p % p\nfor i in range(n - 3):\n    ans = ans * 2 % p\nprint(ans)", "(n, m) = map(int, input().split())\nmod = 998244353\nn_max = 2 * (10 ** 5 + 1)\n(F, FI) = ([0] * (n_max + 1), [0] * (n_max + 1))\n(F[0], FI[0]) = (1, 1)\nfor i in range(n_max):\n    F[i + 1] = F[i] * (i + 1) % mod\nFI[n_max - 1] = pow(F[n_max - 1], mod - 2, mod)\nfor i in reversed(range(n_max - 1)):\n    FI[i] = FI[i + 1] * (i + 1) % mod\n\ndef comb(x, y):\n    return F[x] * FI[x - y] * FI[y] % mod\nprint(comb(m, n - 1) * (n - 2) * pow(2, n - 3, mod) % mod)", "import sys\nmod = 998244353\nsys.setrecursionlimit(pow(10, 8))\n\ndef power(x, y):\n    if y == 0:\n        return 1\n    elif y == 1:\n        return x % mod\n    elif y % 2 == 0:\n        return power(x, y // 2) ** 2 % mod\n    else:\n        return power(x, (y - 1) // 2) ** 2 * x % mod\n\ndef mul(a, b):\n    return a % mod * (b % mod) % mod\n\ndef cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\nNNN = 2 * 10 ** 5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, NNN + 1):\n    g1.append(g1[-1] * i % mod)\n    inverse.append(-inverse[mod % i] * (mod // i) % mod)\n    g2.append(g2[-1] * inverse[-1] % mod)\n(N, M) = map(int, input().split())\nif N == 2:\n    print(0)\nelse:\n    print(mul(mul(cmb(M, N - 1, mod), power(2, N - 3)), N - 2))", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    MOD = 998244353\n    (N, M) = [int(x) for x in input().split()]\n    if N == 2:\n        print(0)\n        return\n    fact = [1, 1]\n    factinv = [1, 1]\n    inv = [0, 1]\n\n    def cmb(n, k, p):\n        if k < 0 or n < k:\n            return 0\n        r = min(k, n - k)\n        return fact[n] * factinv[k] * factinv[n - k] % p\n    for i in range(2, 2 * 10 ** 5):\n        fact.append(fact[-1] * i % MOD)\n        inv.append(-inv[MOD % i] * (MOD // i) % MOD)\n        factinv.append(factinv[-1] * inv[-1] % MOD)\n    ans = 0\n    for i in range(M, -1, -1):\n        if i - 1 < N - 2:\n            break\n        x = cmb(i - 1, N - 2, MOD)\n        y = pow(2, N - 3, MOD)\n        y = x * y * (N - 2) % MOD\n        ans = (ans + y) % MOD\n    print(ans)\nmain()", "import sys\nfrom math import *\nfrom collections import defaultdict\nfrom queue import deque\nfrom heapq import heappush, heappop\nM = 998244353\nlines = [line.strip() for line in sys.stdin.readlines()]\n(n, m) = list(map(int, lines[0].split()))\n\ndef gcdext(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (gcd, x, y) = gcdext(b % a, a)\n    return (gcd, y - b // a * x, x)\n\ndef modinv(a):\n    (g, x, y) = gcdext(a, M)\n    assert g == 1\n    return x % M\nfacts = [1]\nfactinvs = [1]\npows = [1]\nfor i in range(1, m + 1):\n    facts += [facts[-1] * i % M]\n    pows += [pows[-1] * 2 % M]\n    factinvs += [factinvs[-1] * modinv(i) % M]\n\ndef choose(a, b):\n    if a < b or b < 0:\n        return 0\n    if b == 0:\n        return 1\n    if b == 1:\n        return a\n    return facts[a] * factinvs[b] % M * factinvs[a - b] % M\nret = 0\nfor k in range(n - 1, m + 1):\n    ret = (ret + choose(k - 1, 1) * choose(k - 2, n - 3) % M * pows[n - 3]) % M\nprint(ret)", "import sys\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\np = 10 ** 9 + 7\ninf = 10 ** 20 + 7\nmod = 998244353\nfact = [1]\nfor i in range(1, 3 * 10 ** 5):\n    fact.append(fact[-1] * i % mod)\n\ndef comb(n, r):\n    if n < r:\n        return 0\n    return fact[n] * pow(fact[r], -1, mod) * pow(fact[n - r], -1, mod) % mod\n(n, m) = ints()\nans = 0\nfor i in range(2, m + 1):\n    ans = (ans + comb(i - 1, n - 2)) % mod\nANS = 0\nfor i in range(1, n - 1):\n    ANS = (ANS + ans * comb(n - 3, i - 1)) % mod\nprint(ANS * (n - 2) % mod)", "mod = 998244353\n\ndef C(n, m):\n    ans = 1\n    for i in range(1, m + 1):\n        ans = ans * (n - m + i) % mod\n        ans = ans * pow(i, mod - 2, mod)\n    return ans\n(n, m) = map(int, input().split())\nif n == 2:\n    print(0)\nelse:\n    ans = C(m, n - 1) * (n - 2) % mod * pow(2, n - 3, mod) % mod\n    print(ans)"]