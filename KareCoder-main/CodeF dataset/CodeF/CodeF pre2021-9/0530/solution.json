["from sys import stdin\ninput = stdin.readline\n\ndef f(ar):\n    ar = sorted(ar, reverse=True, key=lambda s: s[1])\n    (cost, cs, lo) = (0, 0, 0)\n    hi = len(ar) - 1\n    while lo <= hi:\n        if ar[hi][1] <= cs:\n            cost += ar[hi][0]\n            cs += ar[hi][0]\n            hi -= 1\n        elif ar[hi][1] - cs <= ar[lo][0]:\n            ar[lo][0] -= ar[hi][1] - cs\n            cost += 2 * (ar[hi][1] - cs)\n            cs += ar[hi][1] - cs\n            cs += ar[hi][0]\n            cost += ar[hi][0]\n            hi -= 1\n        else:\n            cs += ar[lo][0]\n            cost += ar[lo][0] * 2\n            lo += 1\n    return cost\nar = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    ar.append([a, b])\nprint(f(ar))", "from operator import itemgetter\n\ndef main() -> None:\n    n = int(input())\n    pairs = [[int(i) for i in input().split()] for _ in range(n)]\n    pairs.sort(key=itemgetter(1))\n    left = 0\n    right = len(pairs) - 1\n    total_bought = 0\n    total_cost = 0\n    while left <= right:\n        if pairs[left][1] <= total_bought:\n            total_cost += pairs[left][0]\n            total_bought += pairs[left][0]\n            left += 1\n        else:\n            to_buy = min(pairs[left][1] - total_bought, pairs[right][0])\n            total_cost += to_buy * 2\n            total_bought += to_buy\n            pairs[right][0] -= to_buy\n            if pairs[right][0] == 0:\n                right -= 1\n    print(total_cost)\nmain()", "from operator import itemgetter\n\ndef main() -> None:\n    n = int(input())\n    products = [[int(i) for i in input().split()] for _ in range(n)]\n    products.sort(key=itemgetter(1))\n    left = 0\n    right = len(products) - 1\n    total_bought = 0\n    total_cost = 0\n    while left <= right:\n        if products[left][1] <= total_bought:\n            total_cost += products[left][0]\n            total_bought += products[left][0]\n            left += 1\n        else:\n            to_buy = min(products[left][1] - total_bought, products[right][0])\n            total_cost += to_buy * 2\n            total_bought += to_buy\n            products[right][0] -= to_buy\n            if products[right][0] == 0:\n                right -= 1\n    print(total_cost)\nmain()", "prices = []\ncount = 0\nn = int(input())\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    prices.append((b, a))\n    count += a\nprices.sort()\ndiscount = 0\nfor i in range(n - 1, -1, -1):\n    x = prices[i]\n    if x[0] >= count:\n        continue\n    discount += min(count - discount - x[0], x[1])\nprint(2 * count - discount)", "import sys\nn = int(sys.stdin.readline())\ndata = []\nfor i in range(n):\n    temp = list(map(int, sys.stdin.readline().split()))\n    data.append(temp)\ndata.sort(key=lambda x: x[1])\n(left, right) = (0, n - 1)\n(ans, cnt) = (0, 0)\nwhile left <= right:\n    if cnt >= data[left][1]:\n        ans += data[left][0]\n        cnt += data[left][0]\n        left += 1\n    elif data[right][0] > data[left][1] - cnt:\n        data[right][0] -= data[left][1] - cnt\n        ans += (data[left][1] - cnt) * 2\n        cnt += data[left][1] - cnt\n    else:\n        cnt += data[right][0]\n        ans += data[right][0] * 2\n        right -= 1\nprint(ans)", "def solve(n, items):\n    items.sort(key=lambda x: x[1])\n    ans = 0\n    cnt = 0\n    l = 0\n    r = n - 1\n    while l <= r:\n        if items[l][1] <= cnt:\n            cnt += items[l][0]\n            ans += items[l][0]\n            items[l][0] = 0\n            l += 1\n        else:\n            diff = min(items[l][1] - cnt, items[r][0])\n            cnt += diff\n            ans += diff * 2\n            items[r][0] -= diff\n            if items[r][0] == 0:\n                r -= 1\n    return ans\nn = int(input())\nitems = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    items.append([a, b])\nprint(solve(n, items))", "def solve(n, items):\n    items.sort(key=lambda x: x[1])\n    ans = 0\n    cnt = 0\n    (l, r) = (0, n - 1)\n    while l <= r:\n        if items[l][1] <= cnt:\n            cnt += items[l][0]\n            ans += items[l][0]\n            items[l][0] = 0\n            l += 1\n        else:\n            diff = min(items[l][1] - cnt, items[r][0])\n            cnt += diff\n            ans += 2 * diff\n            items[r][0] -= diff\n            if items[r][0] == 0:\n                r -= 1\n    return ans\nn = int(input())\nitems = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    items.append([a, b])\nprint(solve(n, items))", "def func():\n    n = int(input())\n    arr = []\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n    arr.sort(key=lambda x: x[1])\n    cur_prod = 0\n    ans = 0\n    i = 0\n    j = n - 1\n    while i <= j:\n        while arr[i][1] > cur_prod and arr[i][0] > 0:\n            diff = arr[i][1] - cur_prod\n            d = max(arr[j][0] - diff, 0)\n            ans += (arr[j][0] - d) * 2\n            cur_prod += arr[j][0] - d\n            arr[j][0] = d\n            if d == 0:\n                j -= 1\n        cur_prod += arr[i][0]\n        ans += arr[i][0]\n        i += 1\n    print(ans)\nfor _ in range(1):\n    func()", "n = int(input())\ns = 0\nx = []\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    s += a\n    x.append([a, b])\nx.sort(key=lambda x: x[1])\ncnt = 0\ncur = 0\nfor (a, b) in x:\n    if cur < b:\n        cur = b\n    if b >= s:\n        break\n    if s - cur >= a:\n        cnt += a\n        cur += a\n    else:\n        cnt += s - cur\n        break\nprint(2 * s - cnt)", "from sys import stdin\ninput = stdin.readline\n\ndef f(ar):\n    ar = sorted(ar, key=lambda s: s[0], reverse=True)\n    ar = sorted(ar, reverse=True, key=lambda s: s[1])\n    (cost, cs, lo) = (0, 0, 0)\n    hi = len(ar) - 1\n    while lo <= hi:\n        if ar[hi][1] <= cs:\n            cost += ar[hi][0]\n            cs += ar[hi][0]\n            hi -= 1\n        elif ar[hi][1] - cs <= ar[lo][0]:\n            ar[lo][0] -= ar[hi][1] - cs\n            cost += 2 * (ar[hi][1] - cs)\n            cs += ar[hi][1] - cs\n            cs += ar[hi][0]\n            cost += ar[hi][0]\n            hi -= 1\n        else:\n            cs += ar[lo][0]\n            cost += ar[lo][0] * 2\n            lo += 1\n    return cost\nar = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    ar.append([a, b])\nprint(f(ar))", "import sys\nt = int(sys.stdin.readline())\nli = []\nfor _ in range(t):\n    (a, b) = map(int, sys.stdin.readline().split())\n    li.append([a, b])\nli.sort(key=lambda x: x[1])\n(l, r) = (0, len(li) - 1)\nn = 0\nans = 0\nwhile l <= r:\n    if li[l][1] <= n:\n        n += li[l][0]\n        ans += li[l][0]\n        l += 1\n    else:\n        while r >= l:\n            if li[l][1] > li[r][0] + n:\n                n += li[r][0]\n                ans += li[r][0] * 2\n                r -= 1\n            else:\n                ans += (li[l][1] - n) * 2\n                k = li[l][1] - n\n                n += k\n                li[r][0] -= k\n                break\nprint(ans)", "prices = []\ncount = 0\nn = int(input())\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    prices.append((b, a))\n    count += a\nprices.sort()\ndiscount = 0\nfor i in range(n - 1, -1, -1):\n    x = prices[i]\n    if x[0] >= count:\n        continue\n    discount += min(count - discount - x[0], x[1])\nprint(2 * count - discount)", "from operator import itemgetter\n\ndef solve(A, B):\n    buy = 0\n    cost = 0\n    l = []\n    for i in range(len(A)):\n        l.append([A[i], B[i]])\n    t = sorted(l, key=itemgetter(1))\n    i = len(t) - 1\n    j = 0\n    while i > j:\n        if buy < t[j][1]:\n            if t[i][0] - t[j][1] + buy >= 0:\n                cost += 2 * (t[j][1] - buy) + t[j][0]\n                t[i][0] += buy - t[j][1]\n                buy += t[j][1] - buy + t[j][0]\n                j += 1\n            else:\n                buy += t[i][0]\n                cost += 2 * t[i][0]\n                i += -1\n        elif buy >= t[j][1]:\n            buy += t[j][0]\n            cost += t[j][0]\n            j += 1\n    if buy > t[i][1]:\n        cost += t[i][0]\n    elif t[i][0] > 0 and t[i][1] - buy > t[i][0]:\n        cost += 2 * t[i][0]\n    elif t[i][0] > 0 and t[i][1] - buy <= t[i][0]:\n        cost += t[i][1] - buy + t[i][0]\n    return cost\nn = int(input())\nA = []\nB = []\nfor i in range(n):\n    t = list(map(int, input().strip().split()))\n    A.append(t[0])\n    B.append(t[1])\nprint(solve(A, B))", "n = int(input())\ndp = []\ncnt1 = 0\ncnt2 = 0\nfor i in range(n):\n    (a, b) = list(map(int, input().split()))\n    dp.append((b, a))\n    cnt2 += a\ndp.sort()\ndp = dp[::-1]\nfor i in range(n):\n    cnt1 += min(cnt2 - cnt1 - min(dp[i][0], cnt2), dp[i][1])\nprint(cnt2 * 2 - cnt1)", "n = int(input())\ndp = []\ncnt1 = 0\ncnt2 = 0\nfor i in range(n):\n    (a, b) = list(map(int, input().split()))\n    dp.append((b, a))\n    cnt2 += a\ndp.sort()\ndp = dp[::-1]\nfor i in range(n):\n    cnt1 += min(cnt2 - cnt1 - min(dp[i][0], cnt2), dp[i][1])\nprint(cnt2 * 2 - cnt1)", "prices = []\nfor _ in range(int(input())):\n    (ai, bi) = map(int, input().split())\n    prices.append([ai, bi])\nprices.sort(key=lambda x: x[1])\n(p, q) = (0, len(prices) - 1)\ncount = 0\nbought = 0\nwhile p <= q:\n    if bought < prices[p][1]:\n        tmp = min(prices[q][0], prices[p][1] - bought)\n        count += 2 * tmp\n        bought += tmp\n        prices[q][0] -= tmp\n        if prices[q][0] == 0:\n            q -= 1\n    else:\n        bought += prices[p][0]\n        count += prices[p][0]\n        p += 1\nprint(count)", "def solve(n: int, a) -> int:\n    a.sort(key=lambda x: x[1])\n    left = 0\n    right = n - 1\n    bought = 0\n    cost = 0\n    while left <= right:\n        if bought < a[left][1]:\n            buying = min(a[right][0], a[left][1] - bought)\n            a[right][0] -= buying\n            bought += buying\n            cost += 2 * buying\n            if not a[right][0]:\n                right -= 1\n        else:\n            buying = a[left][0]\n            bought += buying\n            cost += buying\n            left += 1\n    return cost\nn = int(input())\na = []\nfor _ in range(n):\n    a.append(list(map(int, input().split())))\nprint(solve(n, a))", "prices = []\ncount = 0\nn = int(input())\nfor _ in range(n):\n    (ai, bi) = map(int, input().split())\n    prices.append([bi, ai])\n    count += ai\nprices.sort()\ndiscount = 0\nfor p in range(n - 1, -1, -1):\n    x = prices[p]\n    if x[0] >= count:\n        continue\n    else:\n        discount += min(count - x[0] - discount, x[1])\nprint(count * 2 - discount)", "prices = []\ncount = 0\nn = int(input())\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    prices.append((b, a))\n    count += a\nprices.sort()\ndiscount = 0\nfor i in range(n - 1, -1, -1):\n    x = prices[i]\n    if x[0] >= count:\n        continue\n    discount += min(count - discount - x[0], x[1])\nprint(2 * count - discount)", "n = int(input())\narr = []\nfor w in range(n):\n    inp = input().split()\n    arr.append([int(inp[0]), int(inp[1])])\narr.sort(key=lambda x: x[1])\nanswer = 0\ncount = 0\ni = 0\nj = len(arr) - 1\nwhile i <= j:\n    if arr[i][1] <= count:\n        count += arr[i][0]\n        i += 1\n    elif arr[j][0] + count <= arr[i][1]:\n        answer += arr[j][0]\n        count += arr[j][0]\n        j -= 1\n    else:\n        arr[j][0] -= arr[i][1] - count\n        answer += arr[i][1] - count\n        count = arr[i][1]\nprint(answer + count)", "n = int(input())\na = []\nfor i in range(n):\n    (q, w) = [int(i) for i in input().split()]\n    a.append([q, w])\na.sort(key=lambda x: x[1])\ns = 0\nfor i in range(n):\n    s += a[i][0]\nM = 0\nN = 0\ni = 0\nwhile M + N < s:\n    if M + N < a[i][1]:\n        N += min(a[i][1] - N - M, s - N - M)\n    if M + N < s - a[i][0]:\n        M += a[i][0]\n    else:\n        M += s - (N + M)\n    i += 1\nprint(2 * N + M)", "n = int(input())\na = []\nfor _ in range(n):\n    (x, y) = map(int, input().split())\n    a.append([x, y])\na.sort(key=lambda k: k[1])\nneeded = a[0][1]\nitems = 0\ni = 0\nj = n - 1\nans = 0\nwhile True:\n    if i > j:\n        break\n    elif i == j:\n        if items >= a[i][1]:\n            ans += a[i][0]\n        else:\n            need = a[i][1] - items\n            if need > a[i][0]:\n                ans += 2 * a[i][0]\n            else:\n                ans += 2 * need\n                ans += a[i][0] - need\n            break\n    if a[j][0] + items < needed:\n        ans += 2 * a[j][0]\n        items += a[j][0]\n        j -= 1\n    elif a[j][0] + items == needed:\n        ans += 2 * a[j][0]\n        items += a[j][0]\n        a[j][0] = 0\n        while i <= j:\n            if a[i][1] <= items:\n                ans += a[i][0]\n                items += a[i][0]\n            else:\n                needed = a[i][1]\n                break\n            i += 1\n        j -= 1\n    else:\n        need = needed - items\n        ans += 2 * need\n        a[j][0] -= need\n        items += need\n        while i <= j:\n            if a[i][1] <= items:\n                ans += a[i][0]\n                items += a[i][0]\n            else:\n                needed = a[i][1]\n                break\n            i += 1\nprint(ans)", "from sys import stdin, stdout\nstdin.readline\n\ndef mp():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef it():\n    return int(stdin.readline().strip())\nfrom collections import defaultdict as dd, Counter as C, deque\nfrom math import ceil, gcd, sqrt, factorial, log2, floor\nimport heapq\nn = it()\nv = []\nfor _ in range(n):\n    v.append(mp())\nv.sort(key=lambda x: x[1])\n(i, j) = (0, n - 1)\nans = 0\ncurr = 0\nwhile i <= j:\n    if curr < v[i][1]:\n        target = v[i][1] - curr\n        if v[j][0] < target:\n            curr += v[j][0]\n            ans += 2 * v[j][0]\n            j -= 1\n        else:\n            v[j][0] -= target\n            curr += target\n            ans += 2 * target\n    else:\n        ans += v[i][0]\n        curr += v[i][0]\n        i += 1\nprint(ans)", "a = sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:]))\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    x = (_, y) = a[j]\n    d = min(a[i][0] - c, y)\n    if d > 0:\n        x[1] -= d\n        r += d\n        j -= d == y\n    else:\n        d = a[i][1]\n        i += 1\n    c += d\nprint(c + r)", "N = int(input())\nA = [0] * N\nB = [0] * N\nfor i in range(N):\n    (A[i], B[i]) = map(int, input().split())\nindices = list(range(N))\nindices.sort(key=lambda i: B[i])\nlow = 0\nhigh = N - 1\nbought = 0\ncost = 0\nwhile low <= high:\n    l = indices[low]\n    h = indices[high]\n    if bought >= B[l]:\n        bought += A[l]\n        cost += A[l]\n        A[l] = 0\n        low += 1\n    elif B[l] - bought >= A[h]:\n        bought += A[h]\n        cost += 2 * A[h]\n        A[h] = 0\n        high -= 1\n    else:\n        need = B[l] - bought\n        bought += need\n        cost += 2 * need\n        A[h] -= need\nassert sum(A) == 0\nprint(cost)", "arr = []\nfor _ in range(int(input())):\n    arr.append(list(map(int, input().split())))\narr = sorted(arr, key=lambda x: x[1], reverse=True)\np = 0\nc = 0\ni = 0\nj = len(arr) - 1\nwhile i <= j:\n    need = arr[j][1]\n    if need <= c:\n        p += arr[j][0]\n        c += arr[j][0]\n        j -= 1\n        continue\n    diff = need - c\n    ext = arr[i][0]\n    if ext <= diff:\n        p += ext * 2\n        c += ext\n        i += 1\n    elif ext > diff:\n        arr[i][0] -= diff\n        p += diff * 2\n        c += diff\nprint(p)", "import sys\nn = int(sys.stdin.readline())\ndata = []\nfor i in range(n):\n    temp = list(map(int, sys.stdin.readline().split()))\n    data.append(temp)\ndata.sort(key=lambda x: x[1])\n(cnt, ans) = (0, 0)\n(left, right) = (0, len(data) - 1)\nwhile left <= right:\n    if data[left][1] <= cnt:\n        ans += data[left][0]\n        cnt += data[left][0]\n        data[left][0] = 0\n        left += 1\n    else:\n        buy = min(data[right][0], data[left][1] - cnt)\n        data[right][0] -= buy\n        cnt += buy\n        ans += buy * 2\n        if data[right][0] == 0:\n            right -= 1\nprint(ans)", "from collections import deque\nn = int(input())\nvalues = []\nfor i in range(n):\n    (a, b) = list(map(int, input().split()))\n    values.append([a, b])\nvalues.sort(key=lambda x: x[1], reverse=True)\nvalues = deque(values)\ntotal = 0\ncost = 0\nwhile len(values) > 1:\n    if total >= values[-1][1]:\n        total += values[-1][0]\n        cost += values[-1][0]\n        values.pop()\n    elif values[0][0] > values[-1][1] - total:\n        values[0][0] -= values[-1][1] - total\n        cost = cost + (values[-1][1] - total) * 2\n        total += values[-1][1] - total\n    elif values[0][0] < values[-1][1] - total:\n        cost = cost + values[0][0] * 2\n        total += values[0][0]\n        values.popleft()\n    elif values[0][0] == values[-1][1] - total:\n        cost = cost + values[0][0] * 2\n        total += values[0][0]\n        values.popleft()\nif total + values[0][0] < values[0][1]:\n    cost += values[0][0] * 2\nelif total > values[0][1]:\n    cost += values[0][0]\nelse:\n    cost = cost + (values[0][1] - total) * 2 + values[0][0] - (values[0][1] - total)\nprint(cost)", "from collections import deque\nn = int(input())\nvalues = []\nfor i in range(n):\n    (a, b) = list(map(int, input().split()))\n    values.append([a, b])\nvalues.sort(key=lambda x: x[1], reverse=True)\nvalues = deque(values)\ntotal = 0\ncost = 0\nwhile len(values) > 1:\n    if total >= values[-1][1]:\n        total += values[-1][0]\n        cost += values[-1][0]\n        values.pop()\n    elif values[0][0] > values[-1][1] - total:\n        values[0][0] -= values[-1][1] - total\n        cost = cost + (values[-1][1] - total) * 2\n        total += values[-1][1] - total\n    elif values[0][0] < values[-1][1] - total:\n        cost = cost + values[0][0] * 2\n        total += values[0][0]\n        values.popleft()\n    elif values[0][0] == values[-1][1] - total:\n        cost = cost + values[0][0] * 2\n        total += values[0][0]\n        values.popleft()\nif total + values[0][0] < values[0][1]:\n    cost += values[0][0] * 2\nelif total > values[0][1]:\n    cost += values[0][0]\nelse:\n    cost = cost + (values[0][1] - total) * 2 + values[0][0] - (values[0][1] - total)\nprint(cost)", "n = int(input())\nproduct = []\nfor i in range(n):\n    product.append(list(map(int, input().split())))\nproduct.sort(key=lambda x: x[1], reverse=True)\nsum = 0\ni = 0\nj = n - 1\nanswer = 0\nwhile j >= i:\n    if sum >= product[j][1]:\n        answer += product[j][0]\n        sum += product[j][0]\n        product[j][0] = 0\n        j -= 1\n    elif product[i][0] >= product[j][1] - sum:\n        answer += 2 * (product[j][1] - sum)\n        product[i][0] -= product[j][1] - sum\n        sum += product[j][1] - sum\n    else:\n        sum += product[i][0]\n        answer += product[i][0] * 2\n        product[i][0] = 0\n        i += 1\nprint(answer)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    arr = [list(map(int, input().split())) for _ in range(n)]\n    arr.sort(key=lambda x: (x[1], x[0]))\n    j = n - 1\n    cnt = ans = 0\n    for i in range(n):\n        (a, b) = arr[i]\n        if cnt >= b:\n            cnt += a\n            ans += a\n        else:\n            while j > i and cnt < b:\n                v = min(arr[j][0], b - cnt)\n                cnt += v\n                ans += 2 * v\n                arr[j][0] -= v\n                if arr[j][0] == 0:\n                    j -= 1\n            if cnt >= b:\n                ans += a\n            else:\n                ans += min(b - cnt, a) * 2 + max(cnt + a - b, 0)\n            cnt += a\n    return ans\nprint(solve())", "n = int(input())\na = [0] * n\nb = [0] * n\nbb = []\nfor i in range(n):\n    (a[i], b[i]) = map(int, input().split())\n    bb.append((i, a[i], b[i]))\nbb.sort(key=lambda x: x[2])\ntot = sum(a)\nlg = n - 1\nrm = bb[lg][1]\nbought = 0\nwhile rm == 0:\n    lg -= 1\n    rm = bb[lg][1]\nres = 0\nfg = 0\nwhile bb[fg][1] == 0:\n    fg += 1\nwhile bought < tot:\n    lim = bb[fg][2]\n    while bought < lim and bought < tot:\n        q = min(rm, lim - bought)\n        rm -= q\n        bought += q\n        res += 2 * q\n        while rm == 0 and bought < tot:\n            lg -= 1\n            rm = bb[lg][1]\n    if lim <= bought < tot:\n        if fg == lg:\n            q = rm\n        else:\n            q = bb[fg][1]\n            fg += 1\n        bought += q\n        res += q\nprint(res)", "n = int(input())\nu = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    u.append([a, b])\nu.sort(key=lambda x: x[1])\ni1 = 0\ni2 = -1\nans = 0\nk = 0\nfor _ in range(n):\n    while i2 < len(u) - 1 and u[i2 + 1][1] <= k:\n        i2 += 1\n    if i1 > i2:\n        if u[-1][0] < u[i2 + 1][1] - k:\n            ans += 2 * u[-1][0]\n            k += u[-1][0]\n            u.pop()\n        else:\n            ans += 2 * (u[i2 + 1][1] - k)\n            u[-1][0] -= u[i2 + 1][1] - k\n            k = u[i2 + 1][1]\n            i2 += 1\n            ans += 1 * u[i1][0]\n            k += u[i1][0]\n            i1 += 1\n    else:\n        ans += 1 * u[i1][0]\n        k += u[i1][0]\n        i1 += 1\nprint(ans)", "R = lambda : map(int, input().split())\nn = int(input())\narr = sorted([list(R()) for i in range(n)], key=lambda x: x[1], reverse=True)\nrem = tot = sum((x[0] for x in arr))\ncnt = 0\nfor item in arr:\n    discnt = max(0, min(item[0], rem - item[1]))\n    cnt += discnt\n    rem -= discnt\nprint(2 * tot - cnt)", "n = int(input())\nT = []\nfor _ in range(n):\n    (a, b) = map(int, input().split(' '))\n    T.append([a, b])\nT.sort(key=lambda e: e[1])\nprice = 0\ntotal = 0\n(l, r) = (0, len(T) - 1)\nwhile l < r:\n    (a, b) = T[l]\n    if total >= b:\n        price += a\n        total += a\n        T[l][0] = 0\n        l += 1\n    else:\n        d = b - total\n        while l < r and d > 0:\n            (ar, br) = T[r]\n            if ar > d:\n                price += 2 * d\n                T[r][0] -= d\n                total += d\n                d = 0\n            else:\n                price += 2 * ar\n                T[r][0] = 0\n                r -= 1\n                total += ar\n                d -= ar\n(a, b) = T[l]\nif a != 0:\n    if total >= b:\n        price += a\n    elif a + total >= b:\n        price += 2 * (b - total) + (a + total - b)\n    else:\n        price += 2 * a\nprint(price)", "n = int(input())\nitem = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    item.append([a, b])\nitem.sort(key=lambda x: x[1])\ni = 0\nj = n - 1\ncount = 0\nans = 0\nwhile i <= j:\n    if item[i][1] <= count:\n        temp = item[i][0]\n        item[i][0] = 0\n        ans += temp\n        count += temp\n        i += 1\n    elif item[i][1] - count <= item[j][0]:\n        temp = item[i][1] - count\n        item[j][0] -= temp\n        count += temp\n        ans += temp * 2\n        temp = item[i][0]\n        item[i][0] = 0\n        ans += temp\n        count += temp\n        i += 1\n    else:\n        temp = item[j][0]\n        item[j][0] = 0\n        count += temp\n        ans += temp * 2\n        j -= 1\nprint(ans)", "n = int(input())\nl = []\nfor i in range(n):\n    (x, y) = map(int, input().split())\n    l.append([x, y])\nl.sort(key=lambda l: l[1])\ni = 0\nj = n - 1\nans = 0\nx = 0\nwhile i <= j:\n    if x >= l[i][1]:\n        ans += l[i][0]\n        x += l[i][0]\n        i += 1\n    elif x + l[j][0] <= l[i][1]:\n        ans += 2 * l[j][0]\n        x += l[j][0]\n        j -= 1\n    else:\n        l[j][0] -= l[i][1] - x\n        ans += 2 * (l[i][1] - x)\n        x += l[i][1] - x\nprint(ans)", "n = int(input())\nl = []\nfor i in range(n):\n    (x, y) = map(int, input().split())\n    l.append([x, y])\nl.sort(key=lambda l: l[1])\ni = 0\nj = n - 1\nans = 0\nx = 0\nwhile i <= j:\n    if x >= l[i][1]:\n        ans += l[i][0]\n        x += l[i][0]\n        i += 1\n    elif x + l[j][0] <= l[i][1]:\n        ans += 2 * l[j][0]\n        x += l[j][0]\n        j -= 1\n    else:\n        l[j][0] -= l[i][1] - x\n        ans += 2 * (l[i][1] - x)\n        x += l[i][1] - x\nprint(ans)", "(b, a) = zip(*sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:])))\n(*a,) = a\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    if (d := min(b[i] - c, a[j])) > 0:\n        a[j] -= d\n        e = 2 * d\n        j -= a[j] < 1\n    else:\n        d = e = a[i]\n        i += 1\n    c += d\n    r += e\nprint(r)", "a = sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:]))\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    x = a[j]\n    d = min(a[i][0] - c, x[1])\n    if d > 0:\n        x[1] -= d\n        r += d\n        j -= x[1] < 1\n    else:\n        d = a[i][1]\n        i += 1\n    c += d\nprint(c + r)", "n = int(input())\nal = []\nfor _ in range(n):\n    (ai, bi) = map(int, input().split())\n    al.append([ai, bi])\nal = sorted(al, key=lambda x: x[1])\np1 = 0\np2 = len(al) - 1\nquan = 0\ncost = 0\nwhile p2 >= p1:\n    diff = al[p1][1] - quan\n    while diff > 0:\n        tmp = min(diff, al[p2][0])\n        diff -= tmp\n        al[p2][0] -= tmp\n        quan += tmp\n        cost += 2 * tmp\n        if al[p2][0] == 0:\n            p2 -= 1\n        if p2 < p1:\n            break\n    if p2 < p1:\n        break\n    cost += al[p1][0]\n    quan += al[p1][0]\n    al[p1][0] = 0\n    p1 += 1\nprint(cost)", "a = sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:]))\ni = j = c = r = 0\nwhile i + j < len(a):\n    x = (_, y) = a[~j]\n    d = min(a[i][0] - c, y)\n    if d > 0:\n        x[1] -= d\n        r += d\n        j += d == y\n    else:\n        d = a[i][1]\n        i += 1\n    c += d\nprint(c + r)", "p = int(input())\narr = []\nfor product in range(p):\n    (a, b) = map(int, input().split())\n    arr.append([a, b])\narr.sort(key=lambda x: x[1])\nl = 0\nr = p - 1\nc = 0\ntotal = 0\nwhile l <= r:\n    if arr[l][1] <= c:\n        c += arr[l][0]\n        total += arr[l][0]\n        l += 1\n    else:\n        need = arr[l][1] - c\n        if need < arr[r][0]:\n            c += need\n            total += need * 2\n            arr[r][0] -= need\n        else:\n            c += arr[r][0]\n            total += arr[r][0] * 2\n            arr[r][0] = 0\n            r -= 1\nprint(total)", "n = int(input())\na = []\nans = 0\nsm = 0\nfor i in range(n):\n    (g, h) = [int(x) for x in input().split()]\n    a.append([h, g])\n    sm += g\na.sort()\nfor i in range(n - 1, -1, -1):\n    x = a[i]\n    k = min(x[0], sm)\n    ans += min(sm - ans - k, x[1])\nprint(sm * 2 - ans)", "n = int(input())\nA = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    A.append((b, a))\nA.sort()\nl = 0\nr = n - 1\nc = 0\nres = 0\nwhile l <= r:\n    if c < A[l][0]:\n        x = A[l][0] - c\n        if x < A[r][1]:\n            res += x * 2\n            c += x\n            A[r] = (A[r][0], A[r][1] - x)\n        else:\n            res += A[r][1] * 2\n            c += A[r][1]\n            r -= 1\n    else:\n        res += A[l][1]\n        c += A[l][1]\n        l += 1\nprint(res)", "n = int(input())\na = []\nans = 0\nsm = 0\nfor i in range(n):\n    (g, h) = [int(x) for x in input().split()]\n    a.append([h, g])\n    sm += g\na.sort()\nfor i in range(n - 1, -1, -1):\n    x = a[i]\n    k = min(x[0], sm)\n    ans += min(sm - ans - k, x[1])\nprint(sm * 2 - ans)", "from collections import Counter\nfrom collections import defaultdict as dfd\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial\nfrom heapq import heapify, heappush, heappop\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef solve():\n    n = nin()\n    arr = [read() for i in range(n)]\n    arr.sort(key=lambda x: x[1])\n    s = 0\n    for i in arr:\n        s += i[0]\n    ans = 0\n    b = 0\n    for i in arr:\n        if i[1] > b:\n            ans += min(s - b, i[1] - b) * 2\n            b += min(s - b, i[1] - b)\n        ans += min(s - b, i[0])\n        b += min(s - b, i[0])\n    ans_.append(ans)\nsolve()\nfor i in ans_:\n    print(i)", "l = []\nn = int(input())\nfor i in range(n):\n    l.append(list(map(int, input().split())))\nl.sort(key=lambda x: x[1], reverse=True)\nc = 0\ni = 0\nj = n - 1\nout = 0\nwhile j >= i:\n    if c >= l[j][1]:\n        out += l[j][0]\n        c += l[j][0]\n        l[j][0] = 0\n        j -= 1\n    elif l[i][0] >= l[j][1] - c:\n        out += 2 * (l[j][1] - c)\n        l[i][0] -= l[j][1] - c\n        c += l[j][1] - c\n    else:\n        c += l[i][0]\n        out += l[i][0] * 2\n        l[i][0] = 0\n        i += 1\nprint(out)", "(b, a) = zip(*sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:])))\n(*a,) = a\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    if (d := min(b[i] - c, a[j])) > 0:\n        a[j] -= d\n        c += d\n        r += 2 * d\n        j -= a[j] < 1\n    else:\n        c += a[i]\n        r += a[i]\n        i += 1\nprint(r)", "(b, a) = zip(*sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:])))\n(*a,) = a\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    if (d := min(b[i] - c, a[j])) > 0:\n        a[j] -= d\n        r += d\n        j -= a[j] < 1\n    else:\n        d = a[i]\n        i += 1\n    c += d\nprint(c + r)", "from math import *\n\ndef read(type=int):\n    return list(map(type, input().split()))\nn = read()[0]\ndata = [read() for _ in range(n)]\ndata.sort(key=lambda x: x[1])\n(l_cur, r_cur, cnt, price) = (0, n - 1, 0, 0)\nwhile l_cur <= r_cur:\n    if cnt >= data[l_cur][1]:\n        cnt += data[l_cur][0]\n        price += data[l_cur][0]\n        l_cur += 1\n    else:\n        req = data[l_cur][1] - cnt\n        if data[r_cur][0] <= req:\n            cnt += data[r_cur][0]\n            price += data[r_cur][0] * 2\n            r_cur -= 1\n        else:\n            cnt += req\n            price += req * 2\n            data[r_cur][0] -= req\nprint(price)", "n = int(input())\narr = []\nans = 0\nfor i in range(n):\n    arr.append(list(map(int, input().split())))\n    ans += 2 * arr[-1][0]\narr.sort(key=lambda x: x[1], reverse=True)\n(i, j, curr) = (0, n - 1, 0)\nwhile i <= j:\n    tar = arr[j][1]\n    if i == j:\n        can = arr[i][0]\n        to = max(0, arr[i][1] - curr)\n        cantake = max(0, can - to)\n        ans -= cantake\n        break\n    elif curr >= tar:\n        curr += arr[j][0]\n        ans -= arr[j][0]\n        j -= 1\n    elif curr + arr[i][0] <= arr[j][1]:\n        curr += arr[i][0]\n        arr[i][0] = 0\n        i += 1\n    else:\n        totake = arr[j][1] - curr\n        curr += totake\n        curr += arr[j][0]\n        arr[i][0] -= totake\n        ans -= arr[j][0]\n        j -= 1\nprint(ans)", "def f(ar):\n    ar = sorted(ar, key=lambda s: s[0], reverse=True)\n    ar = sorted(ar, reverse=True, key=lambda s: s[1])\n    cost = 0\n    cs = 0\n    lo = 0\n    hi = len(ar) - 1\n    while lo <= hi:\n        if ar[hi][1] <= cs:\n            cost += ar[hi][0]\n            cs += ar[hi][0]\n            ar[hi][0] = 0\n            hi -= 1\n        elif ar[hi][1] - cs <= ar[lo][0]:\n            ar[lo][0] -= ar[hi][1] - cs\n            cost += 2 * (ar[hi][1] - cs)\n            cs += ar[hi][1] - cs\n            cs += ar[hi][0]\n            cost += ar[hi][0]\n            ar[hi][0] = 0\n            hi -= 1\n        else:\n            cs += ar[lo][0]\n            cost += ar[lo][0] * 2\n            ar[lo][0] = 0\n            lo += 1\n    return cost\nar = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    ar.append([a, b])\nprint(f(ar))", "def f(ar):\n    ar = sorted(ar, key=lambda s: s[0], reverse=True)\n    ar = sorted(ar, reverse=True, key=lambda s: s[1])\n    cost = 0\n    cs = 0\n    lo = 0\n    hi = len(ar) - 1\n    while lo <= hi:\n        if ar[hi][1] <= cs:\n            cost += ar[hi][0]\n            cs += ar[hi][0]\n            ar[hi][0] = 0\n            hi -= 1\n        elif ar[hi][1] - cs <= ar[lo][0]:\n            ar[lo][0] -= ar[hi][1] - cs\n            cost += 2 * (ar[hi][1] - cs)\n            cs += ar[hi][1] - cs\n            cs += ar[hi][0]\n            cost += ar[hi][0]\n            ar[hi][0] = 0\n            hi -= 1\n        else:\n            cs += ar[lo][0]\n            cost += ar[lo][0] * 2\n            ar[lo][0] = 0\n            lo += 1\n    return cost\nar = []\nfor _ in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    ar.append([a, b])\nprint(f(ar))", "(b, a) = zip(*sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:])))\n(*a,) = a\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    if (d := min(b[i] - c, a[j])) > 0:\n        a[j] -= d\n        c += d\n        r += d\n        j -= a[j] < 1\n    else:\n        c += a[i]\n        i += 1\nprint(c + r)", "for u in range(1):\n    n = int(input())\n    ans = 0\n    x = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x.append([a, b])\n        ans += 2 * a\n    x = sorted(x, key=lambda y: y[1])\n    x = x[::-1]\n    i = 0\n    j = n - 1\n    k = 0\n    while i <= j:\n        temp = x[j][1]\n        if i == j:\n            a = x[i][0]\n            b = max(0, x[i][1] - k)\n            a = max(0, a - b)\n            ans -= a\n            break\n        elif k >= temp:\n            k += x[j][0]\n            ans -= x[j][0]\n            j -= 1\n        elif k + x[i][0] <= x[j][1]:\n            k += x[i][0]\n            x[i][0] = 0\n            i += 1\n        else:\n            b = x[j][1] - k\n            k += b\n            k += x[j][0]\n            x[i][0] -= b\n            ans -= x[j][0]\n            j -= 1\n    print(ans)", "R = lambda : map(int, input().split())\nn = int(input())\narr = [list(R()) for i in range(n)]\narr.sort(key=lambda x: (-x[1], x[0]))\ntoto = tot = sum((x[0] for x in arr))\nacc = 0\nfor (req, thr) in arr:\n    if tot > thr:\n        taken = min(req, tot - thr)\n        tot -= taken\n        acc += taken\nprint(toto * 2 - acc)", "from collections import defaultdict, Counter\nfrom queue import PriorityQueue, Queue\nimport math\nn = int(input())\na = sorted(list((list(map(int, input().split()))[::-1] for i in range(n))))\nans = 0\ni = 0\nj = n - 1\np = 0\nwhile i <= j:\n    if p < a[i][0]:\n        while j > i:\n            if a[j][1] > a[i][0] - p:\n                a[j][1] -= a[i][0] - p\n                ans += (a[i][0] - p) * 2\n                p = a[i][0]\n                break\n            p += a[j][1]\n            ans += a[j][1] * 2\n            j -= 1\n        if j == i:\n            x = min(a[j][1], max(0, a[j][0] - p))\n            ans += 2 * x\n            ans += a[j][1] - x\n            break\n        ans += a[i][1]\n        p += a[i][1]\n        i += 1\n    else:\n        ans += a[i][1]\n        p += a[i][1]\n        i += 1\nprint(ans)", "from collections import defaultdict\nfor tt in range(1):\n    n = int(input())\n    ans = 0\n    arr = []\n    for i in range(n):\n        (x, y) = map(int, input().split())\n        arr.append([x, y])\n        ans += 2 * arr[i][0]\n    arr.sort(key=lambda x: x[1], reverse=True)\n    i = 0\n    j = n - 1\n    curr = 0\n    while i <= j:\n        tar = arr[j][1]\n        if i == j:\n            tem1 = arr[i][0]\n            tem2 = max(0, arr[i][1] - curr)\n            tem1 = max(0, tem1 - tem2)\n            ans -= tem1\n            break\n        elif curr >= tar:\n            curr += arr[j][0]\n            ans -= arr[j][0]\n            j -= 1\n        elif curr + arr[i][0] <= arr[j][1]:\n            curr += arr[i][0]\n            arr[i][0] = 0\n            i += 1\n        else:\n            tem2 = arr[j][1] - curr\n            curr += tem2\n            curr += arr[j][0]\n            arr[i][0] -= tem2\n            ans -= arr[j][0]\n            j -= 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = [tuple(reversed(tuple(map(int, input().split())))) for i in range(n)]\n    a.sort()\n    b = [0] * n\n    have = 0\n    j = len(a) - 1\n    r = 0\n    for i in range(len(a)):\n        (c, d) = a[i]\n        while c > have and j > i:\n            if b[j] < a[j][1]:\n                w = min(c - have, a[j][1] - b[j])\n                r += w * 2\n                have += w\n                b[j] += w\n            else:\n                j -= 1\n        if c <= have:\n            w = d - b[i]\n            b[i] += w\n            have += w\n            r += w\n        else:\n            w = c - have\n            if w + b[i] <= d:\n                b[i] += w\n                r += w * 2\n                have += w\n                w = d - b[i]\n                b[i] += w\n                r += w\n                have += w\n            else:\n                w = d - b[i]\n                b[i] += w\n                r += w * 2\n                have += w\n    print(r)\nsolve()", "n = int(input())\nm = []\nfor i in range(n):\n    a = list(map(int, input().split()))\n    m.append([a[1], a[0]])\nm.sort()\nx = 0\nfor i in range(n):\n    x += m[i][1]\nans = x * 2\nfor i in range(n - 1, -1, -1):\n    y = x - m[i][0]\n    if y >= m[i][1]:\n        ans -= m[i][1]\n        x -= m[i][1]\n    elif y > 0:\n        ans -= y\n        x -= y\nprint(ans)", "from collections import deque\nn = int(input())\nx = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    x.append([b, a])\nx.sort(reverse=True)\nx = deque(x)\nans = 0\ncc = 0\nwhile x:\n    if x[-1][0] <= cc:\n        ans += x[-1][1]\n        cc += x[-1][1]\n        x.pop()\n    elif x[0][1] > x[-1][0] - cc:\n        need = x[-1][0] - cc\n        x[0][1] -= need\n        ans += need * 2\n        cc += need\n    else:\n        ans += x[0][1] * 2\n        cc += x[0][1]\n        x.popleft()\nprint(ans)", "t = int(input())\na = []\nfor T in range(t):\n    b = list(map(int, input().split()))\n    a.append(b)\nh = sorted(a, key=lambda x: x[1])\ns = 0\nj = 0\ni = len(h) - 1\ncost = 0\nwhile j <= i:\n    k = h[i][0]\n    if k + s < h[j][1]:\n        s = s + k\n        i = i - 1\n        cost = cost + 2 * k\n    elif k + s == h[j][1]:\n        s = s + k\n        i = i - 1\n        cost = cost + 2 * k\n        while s >= h[j][1] and j < i:\n            cost = cost + h[j][0]\n            s = s + h[j][0]\n            j = j + 1\n            if j > i:\n                break\n    elif j != i:\n        his = h[j][1] - s\n        cost = cost + his * 2\n        s = s + his\n        h[i][0] = k - his\n        while s >= h[j][1] and j < i:\n            cost = cost + h[j][0]\n            s = s + h[j][0]\n            j = j + 1\n            if j > i:\n                break\n    else:\n        if s + k > h[i][1]:\n            hi = s + k - h[i][1]\n            if hi >= k:\n                cost = cost + k\n            else:\n                cost = cost + hi\n                cost = cost + (k - hi) * 2\n        j = j + 1\n        i = i - 1\nif cost > 2 * 10 ** 14:\n    print(2 * 10 ** 14)\nelse:\n    print(cost)", "n = int(input())\nab = []\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    ab.append([a, b])\nab = sorted(ab, key=lambda c: c[1])\ntotal = sum([c[0] for c in ab])\nanswer = 0\ncnt = 0\ni = 0\nj = n - 1\nwhile cnt < total:\n    if cnt >= ab[i][1]:\n        cnt += ab[i][0]\n        answer += ab[i][0]\n        ab[i][0] = 0\n        i += 1\n    else:\n        q = min(ab[i][1] - cnt, ab[j][0])\n        cnt += q\n        answer += q * 2\n        ab[j][0] -= q\n        if ab[j][0] == 0:\n            j -= 1\nprint(answer)", "(b, a) = zip(*sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:])))\n(*a,) = a\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    if (d := min(b[i] - c, a[j])) > 0:\n        a[j] -= d\n        c += d\n        r += 2 * d\n        j -= a[j] < 1\n    else:\n        c += a[i]\n        r += a[i]\n        i += 1\nprint(r)", "a = sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:]))\ni = j = c = r = 0\nwhile i + j < len(a):\n    x = (_, y) = a[~j]\n    d = min(a[i][0] - c, y)\n    if d > 0:\n        x[1] -= d\n        r += d\n        j += d == y\n    else:\n        d = a[i][1]\n        i += 1\n    c += d\nprint(c + r)", "n = int(input())\nab = []\nfor i in range(n):\n    ab.append([int(x) for x in input().split()])\nab.sort(key=lambda x: x[1])\ni = 0\nj = n - 1\ncnt = 0\nans = 0\nwhile i <= j:\n    if ab[i][1] <= cnt:\n        ans += ab[i][0]\n        cnt += ab[i][0]\n        ab[i][0] = 0\n        i += 1\n    else:\n        k = min(ab[j][0], ab[i][1] - cnt)\n        ab[j][0] -= k\n        cnt += k\n        ans += k * 2\n        if ab[j][0] == 0:\n            j -= 1\nprint(ans)", "n = int(input())\nlists = []\nfor i in range(n):\n    (a, req) = list(map(int, input().split()))\n    lists.append([a, req])\n\ndef last(n):\n    return n[1]\nqua = sorted(lists, key=last)\nlow = 0\nhigh = n - 1\nans = 0\nbought = 0\nwhile low <= high:\n    if qua[low][-1] <= bought:\n        ans += qua[low][0]\n        bought += qua[low][0]\n        low += 1\n    else:\n        req = min(qua[low][-1] - bought, qua[high][0])\n        bought += req\n        ans += 2 * req\n        qua[high][0] -= req\n        if qua[high][0] == 0:\n            high -= 1\nprint(ans)", "n = int(input())\nitems = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    items.append([b, a])\nitems.sort()\nhead = 0\ntail = len(items) - 1\ncount = 0\npay = 0\nwhile head != tail:\n    (head_need, head_left) = items[head]\n    (tail_need, tail_left) = items[tail]\n    if count >= head_need:\n        count += head_left\n        pay += head_left\n        head += 1\n    elif tail_left > head_need - count:\n        items[tail][1] -= head_need - count\n        pay += 2 * (head_need - count)\n        count += head_need - count\n    else:\n        count += tail_left\n        pay += 2 * tail_left\n        tail -= 1\n(head_need, head_left) = items[head]\nif head_need - count >= head_left:\n    pay += 2 * head_left\nelse:\n    pay += max(head_need - count, 0) * 2 + head_left - max(head_need - count, 0)\nprint(pay)", "from collections import deque\n\ndef solve(N, arr):\n    arr.sort(reverse=True)\n    arr = deque(arr)\n    cost = 0\n    cnt = 0\n    while arr:\n        if cnt >= arr[-1][0]:\n            (b, a) = arr.pop()\n            cnt += a\n            cost += a\n        else:\n            aa = min(arr[0][1], arr[-1][0] - cnt)\n            arr[0][1] -= aa\n            cnt += aa\n            cost += aa << 1\n            if arr[0][1] == 0:\n                arr.popleft()\n    return cost\nN = int(input())\narr = []\nfor n in range(N):\n    (a, b) = tuple(map(int, input().split()))\n    arr.append([b, a])\nprint(solve(N, arr))", "n = int(input())\na = [''] * n\nans = 0\nsm = 0\nfor i in range(n):\n    (g, h) = [int(x) for x in input().split()]\n    a[i] = [h, g]\n    sm += g\na.sort()\nfor i in range(n - 1, -1, -1):\n    x = a[i]\n    k = min(x[0], sm)\n    ans += min(sm - ans - k, x[1])\nprint(sm * 2 - ans)", "n = int(input())\nli = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    temp = [b, a]\n    li.append(temp)\nli.sort()\na = 0\nb = n - 1\ncost = 0\ncount = 0\nwhile a <= b:\n    if count >= li[a][0]:\n        count += li[a][1]\n        cost += li[a][1]\n        a += 1\n    else:\n        c = li[a][0] - count\n        if c >= li[b][1]:\n            count += li[b][1]\n            cost += 2 * li[b][1]\n            b -= 1\n        else:\n            li[b][1] -= c\n            count += c\n            cost += 2 * c\nprint(cost)", "n = int(input())\na = []\nfor i in range(n):\n    temp = [int(x) for x in input().split()]\n    a.append(temp)\na = sorted(a, key=lambda x: x[1])\nrubels = 0\nxp = 0\ni = 0\nj = n - 1\nwhile i < j:\n    if a[j][1] <= xp or a[j][0] == 0:\n        xp += a[j][0]\n        rubels += a[j][0]\n        j -= 1\n    elif a[i][1] <= xp:\n        xp += a[i][0]\n        rubels += a[i][0]\n        i += 1\n    else:\n        required = a[i][1] - xp\n        purchase = min(required, a[j][0])\n        xp += purchase\n        rubels += 2 * purchase\n        a[j][0] -= purchase\nif a[i][1] <= xp:\n    xp += a[i][0]\n    rubels += a[i][0]\nelse:\n    required = a[i][1] - xp\n    purchase = min(required, a[j][0])\n    xp += purchase\n    rubels += 2 * purchase\n    a[i][0] -= purchase\n    if a[i][0] > 0:\n        rubels += a[i][0]\n        xp += a[i][0]\nprint(rubels)", "arr = []\nans = 0\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    arr.append([a, b])\narr.sort(key=lambda a: a[1])\nstart = 0\nend = len(arr) - 1\ncurr = 0\nans = 0\nwhile start <= end:\n    if arr[start][1] > curr:\n        temp = min(arr[start][1] - curr, arr[end][0])\n        curr += temp\n        ans += 2 * temp\n        arr[end][0] -= temp\n    else:\n        temp = arr[start][0]\n        curr += temp\n        ans += 1 * temp\n        arr[start][0] = 0\n    if arr[start][0] == 0:\n        start += 1\n    if arr[end][0] == 0:\n        end -= 1\nprint(ans)", "from operator import itemgetter\nn = int(input())\na = []\nfor i in range(n):\n    temp = [int(x) for x in input().split()]\n    a.append(temp)\na = sorted(a, key=itemgetter(1))\nrubels = 0\nxp = 0\ni = 0\nj = n - 1\nwhile i < j:\n    if a[j][1] <= xp or a[j][0] == 0:\n        xp += a[j][0]\n        rubels += a[j][0]\n        j -= 1\n    elif a[i][1] <= xp:\n        xp += a[i][0]\n        rubels += a[i][0]\n        i += 1\n    else:\n        required = a[i][1] - xp\n        purchase = min(required, a[j][0])\n        xp += purchase\n        rubels += 2 * purchase\n        a[j][0] -= purchase\nif a[i][1] <= xp:\n    xp += a[i][0]\n    rubels += a[i][0]\nelse:\n    required = a[i][1] - xp\n    purchase = min(required, a[j][0])\n    xp += purchase\n    rubels += 2 * purchase\n    a[i][0] -= purchase\n    if a[i][0] > 0:\n        rubels += a[i][0]\n        xp += a[i][0]\nprint(rubels)", "arr = []\nans = 0\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    arr.append([a, b])\narr.sort(key=lambda a: a[1])\nstart = 0\nend = len(arr) - 1\ncurr = 0\nans = 0\nwhile start <= end:\n    if arr[start][1] > curr:\n        temp = min(arr[start][1] - curr, arr[end][0])\n        curr += temp\n        ans += 2 * temp\n        arr[end][0] -= temp\n    else:\n        temp = arr[start][0]\n        curr += temp\n        ans += 1 * temp\n        arr[start][0] = 0\n    if arr[start][0] == 0:\n        start += 1\n    if arr[end][0] == 0:\n        end -= 1\nif start == end:\n    if arr[start][1] > curr:\n        temp = min(arr[start][1] - curr, arr[start][0])\n        curr += temp\n        ans += 2 * temp\n        arr[start][0] -= temp\n    ans += arr[start][0]\nprint(ans)", "t = int(input())\na = []\nfor T in range(t):\n    b = list(map(int, input().split()))\n    a.append(b)\nh = sorted(a, key=lambda x: x[1])\ns = 0\nj = 0\ni = len(h) - 1\ncost = 0\nwhile j <= i:\n    k = h[i][0]\n    if k + s < h[j][1]:\n        s = s + k\n        i = i - 1\n        cost = cost + 2 * k\n    elif k + s == h[j][1]:\n        s = s + k\n        i = i - 1\n        cost = cost + 2 * k\n        while s >= h[j][1] and j < i:\n            cost = cost + h[j][0]\n            s = s + h[j][0]\n            j = j + 1\n            if j > i:\n                break\n    elif j != i:\n        his = h[j][1] - s\n        cost = cost + his * 2\n        s = s + his\n        h[i][0] = k - his\n        while s >= h[j][1] and j < i:\n            cost = cost + h[j][0]\n            s = s + h[j][0]\n            j = j + 1\n            if j > i:\n                break\n    else:\n        if s + k > h[i][1]:\n            hi = s + k - h[i][1]\n            if hi >= k:\n                cost = cost + k\n            else:\n                cost = cost + hi\n                cost = cost + (k - hi) * 2\n        j = j + 1\n        i = i - 1\nprint(cost)", "(b, a) = zip(*sorted(([*map(int, s.split())][::-1] for s in [*open(0)][1:])))\n(*a,) = a\ni = c = r = 0\nj = len(a) - 1\nwhile i <= j:\n    if (d := min(b[i] - c, a[j])) > 0:\n        a[j] -= d\n        e = 2 * d\n        j -= a[j] < 1\n    else:\n        d = e = a[i]\n        i += 1\n    c += d\n    r += e\nprint(r)", "n = int(input())\na = [''] * n\nans = 0\nsm = 0\nfor i in range(n):\n    (g, h) = [int(x) for x in input().split()]\n    a[i] = [h, g]\n    sm += g\na.sort()\nfor i in range(n - 1, -1, -1):\n    x = a[i]\n    k = min(x[0], sm)\n    ans += min(sm - ans - k, x[1])\nprint(sm * 2 - ans)", "n = int(input())\nl = []\nneeded = 0\nfor _ in range(n):\n    (a, b) = map(int, input().split())\n    needed += a\n    l.append([b, a])\nl.sort()\n(items, total) = (0, 0)\n(i, j) = (0, n - 1)\nwhile items < needed:\n    if l[i][0] <= items:\n        buy = l[i][1]\n        l[i][1] = 0\n        items += buy\n        total += buy\n        i += 1\n    elif l[j][1] >= l[i][0] - items:\n        buy = l[i][0] - items\n        l[j][1] -= buy\n        items += buy\n        total += buy * 2\n        if l[j][1] == 0:\n            j -= 1\n    else:\n        buy = l[j][1]\n        l[j][1] = 0\n        items += buy\n        total += buy * 2\n        j -= 1\nprint(total)", "n = int(input())\nitems = []\nneeded = 0\nfor i in range(n):\n    x = input().split()\n    items.append([int(x[1]), int(x[0])])\n    needed += int(x[0])\nitems.sort()\nl = 0\nr = n - 1\ntotal = 0\nspent = 0\nwhile total < needed:\n    if items[l][0] <= total:\n        cur = items[l][1]\n        total += cur\n        spent += cur\n        l += 1\n    else:\n        if l == r and items[r][0] < needed:\n            taking1 = needed - items[r][0]\n            taking2 = items[r][0] - total\n            spent += taking2 * 2 + taking1\n            items[r][1] -= taking1 + taking2\n            total += taking1 + taking2\n            r -= 1\n            continue\n        taking = min(items[l][0] - total, items[r][1])\n        items[r][1] -= taking\n        spent += 2 * taking\n        total += taking\n        if items[r][1] == 0:\n            r -= 1\nprint(spent)", "n = int(input())\narr = []\nfor i in range(n):\n    (a, b) = map(int, input().split())\n    arr.append([b, a])\narr.sort()\nl = 0\nr = n - 1\nc = 0\ns = 0\nwhile l <= r:\n    if arr[l][0] <= c:\n        c += arr[l][1]\n        s += arr[l][1]\n        l += 1\n    else:\n        need = arr[l][0]\n        if need - c < arr[r][1]:\n            q = need - c\n            c += q\n            s += q * 2\n            arr[r][1] -= q\n        else:\n            c += arr[r][1]\n            s += arr[r][1] * 2\n            r -= 1\nprint(s)", "arr = []\nans = 0\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    arr.append([a, b])\narr.sort(key=lambda a: a[1])\nstart = 0\nend = len(arr) - 1\ncurr = 0\nans = 0\nwhile start <= end:\n    if arr[start][1] > curr:\n        temp = min(arr[start][1] - curr, arr[end][0])\n        curr += temp\n        ans += 2 * temp\n        arr[end][0] -= temp\n    else:\n        temp = arr[start][0]\n        curr += temp\n        ans += 1 * temp\n        arr[start][0] = 0\n    if arr[start][0] == 0:\n        start += 1\n    if arr[end][0] == 0:\n        end -= 1\nprint(ans)", "N = int(input())\nA = [0] * N\nfor i in range(N):\n    A[i] = list(map(int, input().split()))\nA.sort(key=lambda a: a[1])\nlow = 0\nhigh = N - 1\nbought = 0\ncost = 0\nwhile low <= high:\n    if bought >= A[low][1]:\n        bought += A[low][0]\n        cost += A[low][0]\n        A[low][0] = 0\n        low += 1\n    elif A[low][1] - bought >= A[high][0]:\n        bought += A[high][0]\n        cost += 2 * A[high][0]\n        A[high][0] = 0\n        high -= 1\n    else:\n        need = A[low][1] - bought\n        bought += need\n        cost += 2 * need\n        A[high][0] -= need\nassert all([A[i][0] == 0 for i in range(N)])\nprint(cost)", "from typing import List\nfrom collections import namedtuple\nProduct = namedtuple('Product', ['a', 'b'])\nN: int = int(input())\nto_buy: int = 0\nproducts: List[Product] = []\nfor _ in range(N):\n    (a, b) = map(int, input().split(' '))\n    products.append(Product(a, b))\n    to_buy += a\nproducts.sort(key=lambda p: p.b)\nn_bought: int = 0\ncost: int = 0\nfor p in products:\n    n_expensive: int = min(max(0, p.b - n_bought), to_buy - n_bought)\n    n_bought += n_expensive\n    cheap = min(to_buy - n_bought, p.a)\n    n_bought += cheap\n    cost += 2 * n_expensive + cheap\n    if to_buy == 0:\n        break\nprint(cost)", "n = int(input())\nli = []\nfor case in range(n):\n    tp = list(map(int, input().split()))\n    li.append(tp)\nli.sort(key=lambda x: (x[1], x[0]))\n(l, r) = (0, len(li) - 1)\ntotalBought = 0\ntotalCost = 0\nwhile l <= r:\n    minNeedForDisc = max(li[l][1] - totalBought, 0)\n    if not minNeedForDisc:\n        totalBought += li[l][0]\n        totalCost += li[l][0]\n        li[l][0] = 0\n        l += 1\n    else:\n        buy = min(minNeedForDisc, li[r][0])\n        totalBought += buy\n        totalCost += 2 * buy\n        li[r][0] -= buy\n        if not li[r][0]:\n            r -= 1\nprint(totalCost)", "events = []\n\ndef solve():\n    events.sort(key=lambda x: x[1])\n    l = 0\n    r = len(events) - 1\n    moneyNeeded = 0\n    productsBought = 0\n    while l <= r:\n        if productsBought < events[l][1]:\n            delta = events[l][1] - productsBought\n            cost = min(events[r][0], delta) * 2\n            productsBought += min(events[r][0], delta)\n            events[r][0] -= min(events[r][0], delta)\n            moneyNeeded += cost\n            if events[r][0] == 0:\n                r -= 1\n        else:\n            productsBought += events[l][0]\n            moneyNeeded += events[l][0]\n            l += 1\n    return moneyNeeded\nt = int(input())\nfor test in range(1, t + 1):\n    (required, discount) = list(map(int, input().split()))\n    events.append([required, discount])\nprint(f'{solve()}')", "n = int(input())\nmerch = []\nfor i in range(n):\n    m = list(map(int, input().split(' ')))\n    merch.append(m)\nmerch = sorted(merch, key=lambda x: x[1])\nl = 0\nr = len(merch) - 1\nres = 0\nnum = 0\nwhile l <= r:\n    if merch[l][1] <= num:\n        num += merch[l][0]\n        res += merch[l][0]\n        l += 1\n    else:\n        count = min(merch[r][0], merch[l][1] - num)\n        res += count * 2\n        num += count\n        if count == merch[r][0]:\n            r -= 1\n        else:\n            merch[r][0] -= count\nprint(res)", "from sys import stdin\ninput = stdin.readline\nrn = lambda : int(input())\nrns = lambda : map(int, input().split())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nYN = lambda x: print('YES') if x else print('NO')\nmod = 10 ** 9 + 7\nn = rn()\nitems = []\nt = 0\nfor i in range(n):\n    items.append(rl())\n    t += items[-1][0]\nitems.sort(key=lambda x: (x[1], x[0]))\nans = 0\nacc = 0\nstart = 0\nwhile acc < t:\n    if items[start][1] <= acc:\n        ans += items[start][0]\n        acc += items[start][0]\n        start += 1\n    else:\n        sub = min(items[start][1] - acc, items[-1][0])\n        ans += sub * 2\n        acc += sub\n        items[-1][0] -= sub\n        if items[-1][0] == 0:\n            items.pop()\nprint(ans)", "n = int(input())\narr = []\nfor i in range(n):\n    (a, b) = list(map(int, input().split()))\n    arr.append([b, a])\narr.sort()\n(i, j) = (0, n - 1)\nans = 0\ncnt = 0\nwhile i <= j:\n    if arr[i][0] <= cnt:\n        cnt += arr[i][1]\n        ans += arr[i][1]\n        i += 1\n    else:\n        req = min(arr[i][0] - cnt, arr[j][1])\n        cnt += req\n        arr[j][1] -= req\n        ans += 2 * req\n        if arr[j][1] == 0:\n            j -= 1\nprint(ans)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nlinp = lambda : list(minp())\nminp = lambda : map(int, input().split())\nfrom math import inf, ceil, sqrt, log2\nfrom collections import defaultdict\ndd = lambda x: defaultdict(lambda : x)\nn = int(input())\nr = [None for _ in range(n)]\nfor i in range(n):\n    r[i] = list(minp())\nr.sort(key=lambda x: (x[1], -x[0]))\n(i, j) = (0, n - 1)\ncost = items = 0\nwhile i <= j:\n    while r[i][1] > items and i <= j:\n        if r[j][0] + items <= r[i][1]:\n            items += r[j][0]\n            cost += 2 * r[j][0]\n            j -= 1\n        else:\n            val = r[i][1] - items\n            r[j][0] -= val\n            items = r[i][1]\n            cost += 2 * val\n    if i <= j:\n        items += r[i][0]\n        cost += r[i][0]\n        i += 1\nprint(cost)", "n = int(input())\nli = []\nfor case in range(n):\n    tp = list(map(int, input().split()))\n    li.append(tp)\nli.sort(key=lambda x: (x[1], x[0]))\n(l, r) = (0, len(li) - 1)\n(totalBought, totalCost) = (0, 0)\nwhile l <= r:\n    minNeededForDiscount = max(li[l][1] - totalBought, 0)\n    if not minNeededForDiscount:\n        totalBought += li[l][0]\n        totalCost += 1 * li[l][0]\n        li[l][0] = 0\n        l += 1\n    else:\n        buy = min(minNeededForDiscount, li[r][0])\n        totalBought += buy\n        totalCost += 2 * buy\n        li[r][0] -= buy\n        if not li[r][0]:\n            r -= 1\nprint(totalCost)", "def answer():\n    (s, ans) = (0, 0)\n    a.sort(key=lambda x: x[1], reverse=True)\n    (i, j) = (0, n - 1)\n    while i <= j:\n        if a[j][1] >= s + a[i][0]:\n            ans += 2 * a[i][0]\n            s += a[i][0]\n            i += 1\n        else:\n            a[i][0] -= max(0, a[j][1] - s)\n            ans += 2 * max(0, a[j][1] - s)\n            s += max(0, a[j][1] - s)\n            ans += a[j][0]\n            s += a[j][0]\n            j -= 1\n    return ans\nn = int(input())\na = []\nfor i in range(n):\n    (p, q) = map(int, input().split())\n    a.append([p, q])\nprint(answer())"]