["import itertools as it\n(n, k) = map(int, input().split())\nbushes = [tuple(map(int, input().split())) for i in range(n)]\nred = sum((bush[0] for bush in bushes))\nblue = sum((bush[1] for bush in bushes))\nr0 = red % k\nr1 = blue % k\nmax_ = (red + blue) // k\nif r0 + r1 < k:\n    print(max_)\n    exit()\nr0_required = set(range(r0 + r1 - k + 1))\nr0_available = {r0}\nfor (red, blue) in bushes:\n    if red + blue < k:\n        continue\n    max_red = min(k - 1, red)\n    min_red = max(0, k - blue)\n    for (ex_r, diff) in it.product(list(r0_available), range(min_red, max_red + 1)):\n        new_r = ex_r - diff\n        if new_r < 0:\n            new_r += k\n        if new_r in r0_required:\n            print(max_)\n            exit()\n        r0_available.add(new_r)\nprint(max_ - 1)", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    (n, k) = MI()\n    ab = LLI(n)\n    pre = 1\n    sa = sb = 0\n    mask = (1 << k) - 1\n    for (a, b) in ab:\n        sa += a\n        sb += b\n        if a + b < k:\n            continue\n        mn = max(k - b, 0)\n        mx = min(a, k - 1)\n        now = pre\n        for s in range(mn, mx + 1):\n            now |= pre << s\n        now |= now >> k\n        now &= mask\n        pre = now\n    ans = 0\n    for r in range(k):\n        if pre >> r & 1:\n            ans = max(ans, (sa - r) // k + (sb + r) // k)\n    print(ans)\nmain()"]