["from collections import Counter\n\ndef ispalindrom(n, a):\n    for i in range(n // 2):\n        if a[i] != a[n - 1 - i]:\n            return False\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    if n % 2 == 1 and a[n // 2] != b[n // 2]:\n        print('No')\n        continue\n    a_ord = []\n    b_ord = []\n    for i in range(n // 2):\n        a_ord.append((min(a[i], a[n - 1 - i]), max(a[i], a[n - 1 - i])))\n        b_ord.append((min(b[i], b[n - 1 - i]), max(b[i], b[n - 1 - i])))\n    a_ord.sort()\n    b_ord.sort()\n    if a_ord == b_ord:\n        print('yes')\n    else:\n        print('No')", "def result(a, b, n):\n    set1 = {}\n    set2 = {}\n    for i in range(n // 2):\n        if (max(a[i], a[n - 1 - i]), min(a[i], a[n - 1 - i])) in set1:\n            set1[max(a[i], a[n - 1 - i]), min(a[i], a[n - 1 - i])] += 1\n        else:\n            set1[max(a[i], a[n - 1 - i]), min(a[i], a[n - 1 - i])] = 1\n        if (max(b[i], b[n - 1 - i]), min(b[i], b[n - 1 - i])) in set2:\n            set2[max(b[i], b[n - 1 - i]), min(b[i], b[n - 1 - i])] += 1\n        else:\n            set2[max(b[i], b[n - 1 - i]), min(b[i], b[n - 1 - i])] = 1\n    if n % 2 == 1 and a[n // 2] != b[n // 2]:\n        print('No')\n    elif set1 == set2:\n        print('yes')\n    else:\n        print('No')\nm = int(input())\nfor _ in range(m):\n    n = int(input())\n    a = list(map(lambda x: int(x), input().split(' ')))\n    b = list(map(lambda x: int(x), input().split(' ')))\n    result(a, b, n)", "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom math import *\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nsys.setrecursionlimit(int(pow(10, 6)))\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef out(*var, end='\\n'):\n    sys.stdout.write(' '.join(map(str, var)) + end)\n\ndef l():\n    return list(sp())\n\ndef sl():\n    return list(ssp())\n\ndef sp():\n    return map(int, data().split())\n\ndef ssp():\n    return map(str, data().split())\n\ndef l1d(n, val=0):\n    return [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n    return [l1d(n, val) for j in range(m)]\nt = 1\nt = int(input())\nfor _ in range(t):\n    n = l()[0]\n    A = l()\n    B = l()\n    d1 = []\n    d2 = []\n    for i in range(n):\n        d1.append(sorted([A[i], A[n - i - 1]]))\n        d2.append(sorted([B[i], B[n - i - 1]]))\n    d1.sort()\n    d2.sort()\n    if d1 != d2:\n        print('No')\n    else:\n        print('yes')", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    pair = dict()\n    possible = 1\n    if n % 2 == 1:\n        if a[n // 2] != b[n // 2]:\n            possible = 0\n    for i in range(n // 2):\n        (M, m) = (max(a[i], a[n - i - 1]), min(a[i], a[n - i - 1]))\n        try:\n            pair[str(m) + ' ' + str(M)] += 1\n        except:\n            pair[str(m) + ' ' + str(M)] = 1\n    for i in range(n // 2):\n        (M, m) = (max(b[i], b[n - i - 1]), min(b[i], b[n - i - 1]))\n        x = str(m) + ' ' + str(M)\n        if x not in pair:\n            possible = 0\n            break\n        elif pair[x] >= 1:\n            pair[x] -= 1\n        else:\n            possible = 0\n            break\n    if possible:\n        print('yes')\n    else:\n        print('No')"]