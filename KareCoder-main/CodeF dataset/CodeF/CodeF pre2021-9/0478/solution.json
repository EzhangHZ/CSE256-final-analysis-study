["import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nclass Problem:\n\n    def __init__(self):\n        pass\n\n    def solve(self):\n        ans = 0\n        ans = 0\n        n = int(input())\n        A = list(map(int, input().split()))\n        dqs = deque()\n        dql = deque()\n        a = 1\n        while a < A[0]:\n            dqs.append(a)\n            dql.append(a)\n            a += 1\n        ans = [[A[0]], [A[0]]]\n        for i in range(1, n):\n            if A[i] == A[i - 1]:\n                ans[0].append(dqs.popleft())\n                ans[1].append(dql.pop())\n            else:\n                a = A[i - 1] + 1\n                while a < A[i]:\n                    dqs.append(a)\n                    dql.append(a)\n                    a += 1\n                ans[0].append(A[i])\n                ans[1].append(A[i])\n        ans[0] = list(map(str, ans[0]))\n        ans[1] = list(map(str, ans[1]))\n        print(' '.join(ans[0]))\n        print(' '.join(ans[1]))\n\ndef main():\n    p = Problem()\n    t = int(input())\n    while t:\n        p.solve()\n        t -= 1\nmain()", "from collections import deque\n\ndef odwroc(n, l):\n    ustalone = [l[0]]\n    maks = l[0]\n    for i in range(1, n):\n        if l[i] == maks:\n            ustalone.append('x')\n        else:\n            ustalone.append(l[i])\n            maks = l[i]\n    return ustalone\n\ndef maxmin(n, p):\n    (mi, ma) = (p.copy(), p.copy())\n    (maxx, minn) = (deque(), deque())\n    maks = 0\n    for i in range(n):\n        ob = ma[i]\n        if ob == 'x':\n            ma[i] = maxx.pop()\n            mi[i] = minn.popleft()\n        else:\n            maxx.extend(range(maks + 1, ma[i]))\n            minn.extend(range(maks + 1, ma[i]))\n            maks = ma[i]\n    print(' '.join(list(map(str, mi))))\n    print(' '.join(list(map(str, ma))))\n    return\n\ndef main():\n    t = input()\n    for i in range(int(t)):\n        n = int(input())\n        maxmin(n, odwroc(n, list(map(int, input().split()))))\n    return\nmain()", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    q = [*map(int, input().split())]\n    x = [0] * n\n    u = []\n    p = 0\n    for i in range(n):\n        v = q[i]\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(' '.join(map(str, x)))\n    print(' '.join(map(str, y)))", "import sys\nfrom collections import deque\n\ndef print_arr(arr):\n    print(' '.join([str(n) for n in arr]))\n\ndef solve(nums):\n    i = 0\n    stack_max = []\n    dq_min = deque()\n    cur = 1\n    mins = [0] * len(nums)\n    maxs = [0] * len(nums)\n    while i < len(nums):\n        if i == 0 or nums[i] != nums[i - 1]:\n            while cur < nums[i]:\n                stack_max.append(cur)\n                dq_min.append(cur)\n                cur += 1\n            cur += 1\n            mins[i] = nums[i]\n            maxs[i] = nums[i]\n            i += 1\n        else:\n            while i < len(nums) and nums[i] == nums[i - 1]:\n                mins[i] = dq_min.popleft()\n                maxs[i] = stack_max.pop()\n                i += 1\n    return (mins, maxs)\nt = int(sys.stdin.readline().strip())\nfor _ in range(t):\n    line = sys.stdin.readline().strip()\n    n = list(map(int, line.split()))[0]\n    line = sys.stdin.readline().strip()\n    nums = list(map(int, line.split()))\n    (minimum, maximum) = solve(nums)\n    print_arr(minimum)\n    print_arr(maximum)", "import heapq\n\ndef get_min_max(arr, n):\n    min_val = [str(arr[0])]\n    max_val = [str(arr[0])]\n    current_max = arr[0]\n    min_heap = [i for i in range(1, arr[0])]\n    max_heap = [-i for i in range(1, arr[0])]\n    heapq.heapify(min_heap)\n    heapq.heapify(max_heap)\n    for i in arr[1:]:\n        if i > current_max:\n            for j in range(current_max + 1, i):\n                heapq.heappush(min_heap, j)\n                heapq.heappush(max_heap, -j)\n            current_max = i\n            min_val.append(str(i))\n            max_val.append(str(i))\n        else:\n            min_val.append(str(heapq.heappop(min_heap)))\n            max_val.append(str(-heapq.heappop(max_heap)))\n    return (' '.join(min_val), ' '.join(max_val))\nt = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    (min_val, max_val) = get_min_max(arr, n)\n    print(min_val)\n    print(max_val)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    q = [a[0]]\n    p[a[0]] = 1\n    k = 1\n    for j in range(1, n):\n        if a[j] == a[j - 1]:\n            while p[k] == 1:\n                k = k + 1\n            q.append(k)\n            p[k] = 1\n        else:\n            q.append(a[j])\n            p[a[j]] = 1\n    r = [a[0]]\n    p = [j + 1 for j in range(a[0] - 1)]\n    m = a[0]\n    for j in range(1, n):\n        if a[j] == a[j - 1]:\n            r.append(p[-1])\n            del p[-1]\n        else:\n            r.append(a[j])\n            for k in range(m + 1, a[j]):\n                p.append(k)\n            m = a[j]\n    print(' '.join(map(str, q)))\n    print(' '.join(map(str, r)))", "import collections\nimport heapq\n\ndef mnp(n, q):\n    res = []\n    taken = [0] * (n + 1)\n    last = None\n    missed = 1\n    for i in range(n):\n        if q[i] != last:\n            taken[q[i]] = 1\n            res.append(q[i])\n        else:\n            while taken[missed] != 0:\n                missed += 1\n            taken[missed] = 1\n            res.append(missed)\n            missed += 1\n        last = q[i]\n    return res\n\ndef mxp(n, q):\n    res = []\n    taken = [0] * (n + 1)\n    last = None\n    heap = []\n    missed = 1\n    for i in range(n):\n        if q[i] != last:\n            taken[q[i]] = 1\n            res.append(q[i])\n            while missed < q[i]:\n                if taken[missed] == 0:\n                    heapq.heappush(heap, -missed)\n                missed += 1\n        else:\n            v = heapq.heappop(heap)\n            taken[-v] = 1\n            res.append(-v)\n        last = q[i]\n    return res\n\ndef process(n, q):\n    print(' '.join(map(str, mnp(n, q))))\n    print(' '.join(map(str, mxp(n, q))))\ntcs = int(input())\nfor tc in range(tcs):\n    n = int(input())\n    q = list(map(int, input().split()))\n    process(n, q)", "t = int(input())\nfor i in range(t):\n    abc = set()\n    n = int(input())\n    w = list(range(1, n + 1))\n    mw = w[::-1]\n    q = [int(j) for j in input().split()]\n    res = []\n    mres = []\n    j = 0\n    for k in q:\n        if k not in abc:\n            abc |= {k}\n            res.append(k)\n        else:\n            while w[j] in abc:\n                j += 1\n            res.append(w[j])\n            abc |= {w[j]}\n    j = 0\n    abc = set()\n    qwe = 0\n    stack = []\n    for k in q:\n        if k not in abc:\n            abc |= {k}\n            mres.append(k)\n            for y in range(qwe + 1, k):\n                stack.append(y)\n            qwe = k\n        else:\n            zxc = stack.pop()\n            while zxc in abc:\n                pass\n            mres.append(zxc)\n            abc |= {zxc}\n    print(' '.join([str(k) for k in res]))\n    print(' '.join([str(k) for k in mres]))", "import math\nfrom collections import deque\nt = int(input())\n\ndef get_answer(n, q):\n    s1 = deque()\n    s2 = deque()\n    ans1 = [0] * n\n    ans2 = [0] * n\n    s = 0\n    i = 0\n    while i < n:\n        num = q[i]\n        if num == s:\n            ans1[i] = s1.popleft()\n            ans2[i] = s2.pop()\n        else:\n            ans1[i] = num\n            ans2[i] = num\n            a = s + 1\n            while a < num:\n                s1.append(a)\n                s2.append(a)\n                a += 1\n            s = num\n        i += 1\n    print(*ans1)\n    print(*ans2)\nfor _ in range(t):\n    n = int(input())\n    q = list(map(int, input().split()))\n    get_answer(n, q)", "def ints():\n    return [int(x) for x in input().split(' ')]\n\ndef find_index(ranges, x):\n    for i in range(len(ranges) - 1, -1, -1):\n        if ranges[i][0] <= x:\n            return i\n    return 0\n\ndef remove_item(ranges, x):\n    i = find_index(ranges, x)\n    (a, b) = ranges[i]\n    if a == b:\n        ranges.pop(i)\n        return ranges\n    if x == a:\n        ranges[i][0] += 1\n        return ranges\n    if x == b:\n        ranges[i][1] -= 1\n        return ranges\n    return ranges[0:i] + [[a, x - 1], [x + 1, b]] + ranges[i + 1:]\nfor _ in range(int(input())):\n    n = int(input())\n    q = ints()\n    up = set([i + 1 for i in range(n)])\n    down = [[1, n]]\n    last = None\n    for i in range(n):\n        if q[i] == last:\n            q[i] = 0\n        else:\n            up.remove(q[i])\n            down = remove_item(down, q[i])\n            last = q[i]\n    up = list(up)\n    up.sort()\n    p = q[:]\n    j = 0\n    last = q[0]\n    for i in range(n):\n        if p[i] == 0:\n            p[i] = up[j]\n            j += 1\n            k = find_index(down, last)\n            (a, b) = down[k]\n            q[i] = b\n            if a == b:\n                down.pop(k)\n            else:\n                down[k][1] -= 1\n        else:\n            last = q[i]\n    print(' '.join([str(x) for x in p]))\n    print(' '.join([str(x) for x in q]))", "import sys\nimport heapq\nfrom collections import Counter\nimport bisect\n\ndef load_sys():\n    return sys.stdin.readlines()\n\ndef load_local():\n    with open('input.txt', 'r') as f:\n        input = f.readlines()\n    return input\n\ndef f(n, arr):\n    ans = [-1] * n\n    seen = [False] * (n + 1)\n    for i in range(n):\n        if i == 0 or arr[i] != arr[i - 1]:\n            ans[i] = arr[i]\n            seen[arr[i]] = True\n    mn = ans[:]\n    mx = ans[:]\n    pq = []\n    mn_pq = []\n    i = 0\n    j = 0\n    cur_mx = 1\n    while i < n:\n        lo = ans[i]\n        i += 1\n        i0 = i\n        while i < n and ans[i] == -1:\n            i += 1\n        for x in range(cur_mx, lo, 1):\n            if not seen[x]:\n                heapq.heappush(pq, -x)\n                heapq.heappush(mn_pq, x)\n        ss = i - i0\n        for _ in range(ss):\n            mx[i0] = -heapq.heappop(pq)\n            mn[i0] = heapq.heappop(mn_pq)\n            i0 += 1\n        cur_mx = lo\n    return (mn, mx)\ninput = load_sys()\nfor i in range(1, len(input), 2):\n    n = int(input[i])\n    arr = [int(x) for x in input[i + 1].split()]\n    (mn, mx) = f(n, arr)\n    print(' '.join((str(x) for x in mn)))\n    print(' '.join((str(x) for x in mx)))", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    s1 = deque()\n    s2 = deque()\n    ans1 = []\n    ans2 = []\n    s = 0\n    for num in q:\n        if num == s:\n            ans1.append(s1.popleft())\n            ans2.append(s2.pop())\n        else:\n            ans1.append(num)\n            ans2.append(num)\n            a = s + 1\n            while a < num:\n                s1.append(a)\n                s2.append(a)\n                a += 1\n            s = num\n    print(*ans1)\n    print(*ans2)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    s1 = deque()\n    s2 = deque()\n    ans1 = []\n    ans2 = []\n    s = 0\n    for num in q:\n        if num == s:\n            ans1.append(s1.popleft())\n            ans2.append(s2.pop())\n        else:\n            ans1.append(num)\n            ans2.append(num)\n            a = s + 1\n            while a < num:\n                s1.append(a)\n                s2.append(a)\n                a += 1\n            s = num\n    print(*ans1)\n    print(*ans2)", "from collections import deque\nfor i in range(int(input())):\n    x = int(input())\n    massiv = list(map(int, input().split()))\n    min_x = []\n    max_x = []\n    maxs = 0\n    ochered_min = deque()\n    ochered_max = deque()\n    for j in massiv:\n        if j > maxs:\n            for k in range(maxs + 1, j):\n                ochered_min.append(k)\n                ochered_max.append(k)\n            maxs = j\n            min_x.append(maxs)\n            max_x.append(maxs)\n        else:\n            min_x.append(ochered_min.popleft())\n            max_x.append(ochered_max.pop())\n    print(*min_x)\n    print(*max_x)", "Z = input\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in map(int, Z().split()):\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "from sys import stdin\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    prev_max = 0\n    min_ans = []\n    temp = []\n    max_ans = []\n    temp2 = []\n    index = 0\n    for i in arr:\n        if i > prev_max:\n            min_ans.append(i)\n            max_ans.append(i)\n            for j in range(prev_max + 1, i):\n                temp.append(j)\n                temp2.append(j)\n            prev_max = i\n        else:\n            min_ans.append(temp[index])\n            index += 1\n            max_ans.append(temp2[-1])\n            temp2.pop()\n    print(*min_ans)\n    print(*max_ans)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nclass Problem:\n\n    def __init__(self):\n        pass\n\n    def solve(self):\n        ans = [[], []]\n        n = int(input())\n        A = [0]\n        A.extend(list(map(int, input().split())))\n        (dqs, dql) = (deque(), deque())\n        for i in range(1, n + 1):\n            if A[i] == A[i - 1]:\n                nxts = dqs.popleft()\n            else:\n                a = A[i - 1] + 1\n                while a <= A[i]:\n                    dqs.append(a)\n                    dql.append(a)\n                    a += 1\n                nxts = dqs.pop()\n            nxtl = dql.pop()\n            ans[0].append(nxts)\n            ans[1].append(nxtl)\n        print(*ans[0])\n        print(*ans[1])\n\ndef main():\n    p = Problem()\n    t = int(input())\n    while t:\n        p.solve()\n        t -= 1\nmain()", "class Queue:\n    stack1 = []\n    stack2 = []\n\n    def add(self, el):\n        self.stack1.append(el)\n\n    def pop(self):\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            length = len(self.stack1)\n            for i in range(length):\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n\ndef permute(list_num):\n    min_mem = Queue()\n    for el in range(1, list_num[0]):\n        min_mem.add(el)\n    min_perm = [list_num[0]]\n    max_mem = [el for el in range(1, list_num[0])]\n    max_perm = [list_num[0]]\n    for i in range(1, len(list_num)):\n        if list_num[i] == list_num[i - 1]:\n            val = min_mem.pop()\n            min_perm.append(val)\n            val = max_mem.pop()\n            max_perm.append(val)\n        else:\n            min_perm.append(list_num[i])\n            max_perm.append(list_num[i])\n            for el in range(list_num[i - 1] + 1, list_num[i]):\n                min_mem.add(el)\n                max_mem.append(el)\n    print(*min_perm)\n    print(*max_perm)\nnum = int(input())\nfor i in range(num):\n    s = input()\n    list_num = [int(el) for el in input().split()]\n    permute(list_num)", "from collections import deque\nI = input\nIN = lambda x: map(int, x.split())\nL = lambda x: list(IN(x))\nfor _ in range(int(I())):\n    n = int(I())\n    q = L(I())\n    mx = 0\n    i = 0\n    maxl = []\n    reml = deque()\n    remh = deque()\n    minl = []\n    while i < n:\n        if q[i] > mx:\n            for j in range(mx + 1, q[i]):\n                reml.append(j)\n                remh.append(j)\n            mx = q[i]\n            maxl += [mx]\n            minl += [mx]\n        else:\n            maxl += [remh.pop()]\n            minl += [reml.popleft()]\n        i += 1\n    print(*minl, '\\n', *maxl)", "def solve():\n    n = int(input())\n    q = [int(x) for x in input().split()]\n    amin = []\n    used = [False for _ in range(n + 1)]\n    l = 1\n    for i in range(n):\n        if i == 0 or q[i] > q[i - 1]:\n            amin.append(q[i])\n            used[q[i]] = True\n        else:\n            while used[l]:\n                l += 1\n            amin.append(l)\n            l += 1\n    amax = []\n    l = 1\n    z = []\n    for i in range(n):\n        if i == 0 or q[i] > q[i - 1]:\n            while l <= q[i]:\n                z.append(l)\n                l += 1\n        amax.append(z.pop())\n    print(*amin)\n    print(*amax)\nt = int(input())\nfor _ in range(t):\n    solve()", "Z = input\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in map(int, Z().split()):\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "import math\nimport heapq\n\ndef S():\n    return input()\n\ndef M():\n    return map(int, input().split())\n\ndef I():\n    return int(S())\n\ndef L():\n    return list(M())\nfor _ in range(I()):\n    n = I()\n    l = L()\n    (s, sr) = ([], [])\n    (h, hr) = ([], [])\n    t = 0\n    for i in range(n):\n        if i == 0:\n            s.append(l[i])\n            h.append(l[i])\n            for j in range(1, l[i]):\n                sr.append(j)\n                hr.append(j)\n        elif l[i - 1] == l[i]:\n            s.append(sr[t])\n            t += 1\n            h.append(hr[-1])\n            hr.pop(-1)\n        else:\n            s.append(l[i])\n            h.append(l[i])\n            for j in range(l[i - 1] + 1, l[i]):\n                sr.append(j)\n                hr.append(j)\n    print(*s)\n    print(*h)", "from collections import deque\nimport sys\ninf = float('inf')\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    s1 = deque()\n    s2 = deque()\n    ans1 = [0] * n\n    ans2 = [0] * n\n    s = 0\n    i = 0\n    while i < n:\n        num = arr[i]\n        if num == s:\n            ans1[i] = s1.popleft()\n            ans2[i] = s2.pop()\n        else:\n            ans1[i] = num\n            ans2[i] = num\n            a = s + 1\n            while a < num:\n                s1.append(a)\n                s2.append(a)\n                a += 1\n            s = num\n        i += 1\n    print(*ans1)\n    print(*ans2)", "Z = input\nr = range\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    q = [*map(int, Z().split())]\n    x = [0] * n\n    u = []\n    p = 0\n    for i in r(n):\n        v = q[i]\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in r(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*r(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "Z = input\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in map(int, Z().split()):\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "Z = input\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in map(int, Z().split()):\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "Z = input\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in map(int, Z().split()):\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "Z = input\nfor _ in [0] * int(Z()):\n    n = int(Z())\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in map(int, Z().split()):\n        if v != p:\n            x[i] = v\n            u += [v]\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in range(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*range(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "from collections import deque\nt = int(input())\nfor i in range(t):\n    och = deque()\n    n = int(input())\n    d = list(map(int, input().split()))\n    pos = 0\n    ans = []\n    for j in d:\n        if j > pos:\n            ans.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            ans.append(och.popleft())\n        pos = j\n    print(*ans)\n    pos = 0\n    ans = []\n    for j in d:\n        if j > pos:\n            ans.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            ans.append(och.pop())\n        pos = j\n    print(*ans)", "n = int(input())\nfrom collections import deque\nfor i in range(n):\n    a = int(input())\n    b = list(map(int, input().split()))\n    min_comb = [b[0]]\n    max_comb = [b[0]]\n    min_dec = deque([i for i in range(1, b[0])])\n    max_dec = deque([i for i in range(1, b[0])])\n    for i in range(1, len(b)):\n        if b[i - 1] == b[i]:\n            min_comb.append(min_dec.popleft())\n            max_comb.append(max_dec.pop())\n        if b[i - 1] != b[i]:\n            min_comb.append(b[i])\n            max_comb.append(b[i])\n            for i in range(b[i - 1] + 1, b[i]):\n                min_dec.append(i)\n                max_dec.append(i)\n    print(*min_comb)\n    print(*max_comb)", "import queue\nimport math\nimport sys\nfrom collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    Q = list(map(int, input().split(' ')))\n    L1 = [None for i in range(n)]\n    L2 = [None for i in range(n)]\n    q0 = Q[0]\n    (L1[0], L2[0]) = (q0, q0)\n    assign_from1 = deque(range(1, q0))\n    assign_from2 = deque(range(1, q0))\n    maxx = q0\n    for j in range(1, n):\n        qj = Q[j]\n        if maxx < qj:\n            (L1[j], L2[j]) = (qj, qj)\n            for i in range(maxx + 1, qj):\n                assign_from1.append(i)\n                assign_from2.append(i)\n            maxx = max(maxx, qj)\n        else:\n            L1[j] = assign_from1.popleft()\n            L2[j] = assign_from2.pop()\n    print(*L1)\n    print(*L2)", "from collections import deque\nt = int(input())\nfor i in range(t):\n    och = deque()\n    n = int(input())\n    d = list(map(int, input().split()))\n    pos = 0\n    ans = []\n    for j in d:\n        if j > pos:\n            ans.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            ans.append(och.popleft())\n        pos = j\n    print(*ans)\n    pos = 0\n    ans = []\n    for j in d:\n        if j > pos:\n            ans.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            ans.append(och.pop())\n        pos = j\n    print(*ans)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (minq, maxq) = (deque([]), deque([]))\n    (minarr, maxarr) = ([], [])\n    maxSeen = 0\n    for i in range(n):\n        already = arr[i] == maxSeen\n        while maxSeen < arr[i]:\n            maxSeen += 1\n            minq.append(maxSeen)\n            maxq.append(maxSeen)\n        if already:\n            minarr.append(minq.popleft())\n            maxarr.append(maxq.pop())\n        else:\n            minarr.append(minq.pop())\n            maxarr.append(maxq.pop())\n    print(*minarr)\n    print(*maxarr)", "from collections import deque\nfor t in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (minn, maxx, a, p1, p2) = ([], [], 0, deque(), deque())\n    for i in range(n):\n        c = q[i]\n        if c == a:\n            (minn.append(p1.popleft()), maxx.append(p2.pop()))\n        else:\n            (minn.append(c), maxx.append(c))\n            for j in range(a + 1, c):\n                p1.append(j)\n                p2.append(j)\n            a = c\n    print(*minn)\n    print(*maxx)", "I = lambda : map(int, input().split())\nr = range\nfor _ in r(*I()):\n    (n,) = I()\n    x = [0] * n\n    u = []\n    p = 0\n    i = 0\n    for v in I():\n        if v != p:\n            x[i] = v\n            u += (v,)\n            p = v\n        i += 1\n    y = x[:]\n    e = []\n    p = 0\n    u = u[::-1]\n    l = 1\n    for i in r(n):\n        if x[i] < 1:\n            while l and l == u[-1]:\n                l += 1\n                u.pop()\n            x[i] = l\n            l += 1\n            y[i] = e.pop()\n        else:\n            e += [*r(p + 1, x[i])]\n            p = x[i]\n    print(*x, '\\n', *y)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (pmn, pmx) = (deque(), [])\n    (mn, mx) = ([], [])\n    cur = 1\n    i = 0\n    while i < n:\n        mn.append(q[i])\n        mx.append(q[i])\n        while cur < q[i]:\n            pmn.append(cur)\n            pmx.append(cur)\n            cur += 1\n        cur += 1\n        j = i + 1\n        while j < n and q[i] == q[j]:\n            j += 1\n        for _ in range(j - i - 1):\n            mn.append(pmn.popleft())\n            mx.append(pmx.pop())\n        i = j\n    print(*mn)\n    print(*mx)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = list(map(int, input().split()))\n    (pmn, pmx) = (deque(), [])\n    (mn, mx) = ([], [])\n    cur = 1\n    i = 0\n    while i < n:\n        mn.append(q[i])\n        mx.append(q[i])\n        while cur < q[i]:\n            pmn.append(cur)\n            pmx.append(cur)\n            cur += 1\n        cur += 1\n        j = i + 1\n        while j < n and q[i] == q[j]:\n            j += 1\n        for _ in range(j - i - 1):\n            mn.append(pmn.popleft())\n            mx.append(pmx.pop())\n        i = j\n    print(*mn)\n    print(*mx)", "T = int(input())\nminn = 1\nans1 = []\nans2 = []\nfor _ in range(T):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    d = {}\n    val = [0] * (n + 1)\n    p = 1\n    min_per = []\n    for i in arr:\n        d[i] = d.get(i, 0) + 1\n    for i in d:\n        freq = d[i]\n        min_per.append(i)\n        val[i] = 1\n        j = 0\n        while j != freq - 1:\n            if val[p] == 0:\n                min_per.append(p)\n                val[p] = 1\n                p += 1\n                j += 1\n            else:\n                p += 1\n    max_per = []\n    rem = []\n    prev = 0\n    for i in d:\n        freq = d[i]\n        max_per.append(i)\n        for j in range(prev + 1, i):\n            rem.append(j)\n        prev = i\n        for _ in range(freq - 1):\n            max_per.append(rem.pop())\n    print(*min_per)\n    print(*max_per)", "from bisect import bisect_left\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = set(a)\n    left = []\n    for i in range(1, n + 1):\n        if i not in s:\n            left.append(i)\n    small = [a[0]]\n    j = 0\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            small.append(left[j])\n            j += 1\n        else:\n            small.append(a[i])\n    large = [a[0]]\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            j = bisect_left(left, a[i]) - 1\n            large.append(left[j])\n            left.pop(j)\n        else:\n            large.append(a[i])\n    print(*small)\n    print(*large)", "for ad in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    key = l[0]\n    x = [key]\n    z = [i for i in range(1, key)]\n    for i in range(1, n):\n        if key != l[i]:\n            z += [i for i in range(key + 1, l[i])]\n            key = l[i]\n            x.append(key)\n        else:\n            x.append(z.pop())\n    a = list(set(l))\n    a.sort()\n    j = 0\n    b = []\n    for i in range(1, n + 1):\n        if i == a[j]:\n            j += 1\n        else:\n            b.append(i)\n    key = l[0]\n    j = 0\n    for i in range(1, n):\n        if l[i] == key:\n            l[i] = b[j]\n            j += 1\n        else:\n            key = l[i]\n    print(*l)\n    print(*x)", "from collections import defaultdict\nr = lambda : list(map(int, input().split()))\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = r()\n    a = []\n    b = []\n    x = 0\n    small = 1\n    used = defaultdict(lambda : 0)\n    for i in arr:\n        if i != x:\n            used[i] = 1\n            a.append(i)\n            x = i\n        else:\n            while used[small]:\n                small += 1\n            used[small] = 1\n            a.append(small)\n    print(*a)\n    a = []\n    x = 0\n    small = 0\n    prev = 0\n    used = defaultdict(lambda : 0)\n    for i in arr:\n        if i != x:\n            used[i] = 1\n            a.append(i)\n            x = i\n            if x - 1 > small and (not used[x - 1]):\n                small = i - 1\n        else:\n            while small and used[small]:\n                small -= 1\n            used[small] = 1\n            a.append(small)\n    print(*a)", "from heapq import heappush, heappop\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    maximal = [0] * n\n    minimal = [0] * n\n    minrem = []\n    maxrem = []\n    last = 0\n    for i in range(n):\n        if a[i] == last:\n            maximal[i] = -heappop(maxrem)\n            minimal[i] = heappop(minrem)\n        else:\n            (maximal[i], minimal[i]) = (a[i], a[i])\n            for j in range(last + 1, a[i]):\n                heappush(maxrem, -j)\n                heappush(minrem, j)\n            last = a[i]\n    print(*minimal)\n    print(*maximal)", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    s_t = set(s)\n    st = list((i for i in range(1, n + 1) if i not in s_t))\n    ar = [s[0]] + [0 for i in range(n - 1)]\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            ar[i] = s[i]\n    st1 = st\n    st2 = st\n    ar1 = ar.copy()\n    x = 0\n    for i in range(n):\n        if ar1[i] == 0:\n            ar1[i] = st1[x]\n            x += 1\n    print(*ar1)\n    for i in range(1, n):\n        if ar[i] == 0:\n            pos = bisect.bisect_left(st2, ar[i - 1])\n            if pos == 0:\n                ar[i] = st2[pos + 1]\n                st2.pop(pos - 1)\n            else:\n                ar[i] = st2[pos - 1]\n                st2.pop(pos - 1)\n    print(*ar)", "def per(l, arr):\n    if arr[0] == arr[-1]:\n        lex_min = [arr[0]] + [i for i in range(1, arr[0])]\n        lex_max = [arr[0]] + [i for i in range(arr[0] - 1, 0, -1)]\n    else:\n        (lex_min, lex_max) = ([arr[0]] + [0] * (l - 1), [arr[0]] + [0] * (l - 1))\n        (ls_min, ls_max) = ([i for i in range(1, arr[0])], [i for i in range(arr[0] - 1, 0, -1)])\n        ind = 0\n        for i in range(1, l):\n            if arr[i - 1] == arr[i]:\n                (lex_min[i], lex_max[i]) = (ls_min[ind], ls_max[ind])\n                ind += 1\n            else:\n                (lex_min[i], lex_max[i]) = (arr[i], arr[i])\n                x = len(lex_min)\n                ls_min[x:x] = [i for i in range(arr[i - 1] + 1, arr[i])]\n                ls_max[ind:ind] = [i for i in range(arr[i] - 1, arr[i - 1], -1)]\n    print(*lex_min)\n    print(*lex_max)\nfor test in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().strip().split()))\n    per(n, lst)", "import sys\nfrom heapq import *\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nMOD = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    Q = tuple(map(int, input().split()))\n    min_que = []\n    min_res = []\n    p = 0\n    for q in Q:\n        if p < q:\n            for num in range(p + 1, q):\n                heappush(min_que, num)\n            min_res.append(q)\n            p = q\n        else:\n            a = heappop(min_que)\n            min_res.append(a)\n    print(*min_res)\n    max_que = []\n    max_res = []\n    p = 0\n    for q in Q:\n        if p < q:\n            for num in range(p + 1, q):\n                heappush(max_que, -num)\n            max_res.append(q)\n            p = q\n        else:\n            a = heappop(max_que) * -1\n            max_res.append(a)\n    print(*max_res)\nt = int(input())\nfor _ in range(t):\n    solve()", "import heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    maxi = []\n    mini = []\n    maxHeap = []\n    minHeap = []\n    lastMax = 0\n    visited = set()\n    for (i, val) in enumerate(arr):\n        if val not in visited:\n            mini.append(val)\n            maxi.append(val)\n            for j in range(lastMax + 1, val):\n                heapq.heappush(minHeap, j)\n                heapq.heappush(maxHeap, -j)\n            lastMax = val\n        else:\n            mini.append(heapq.heappop(minHeap))\n            maxi.append(-heapq.heappop(maxHeap))\n        visited.add(val)\n    print(*mini)\n    print(*maxi)", "from sys import stdin\ninput = stdin.readline\n\ndef per(l, arr):\n    if arr[0] == arr[-1]:\n        lex_min = [arr[0]] + [i for i in range(1, arr[0])]\n        lex_max = [arr[0]] + [i for i in range(arr[0] - 1, 0, -1)]\n    else:\n        (lex_min, lex_max) = ([arr[0]] + [0] * (l - 1), [arr[0]] + [0] * (l - 1))\n        (ls_min, ls_max) = ([i for i in range(1, arr[0])], [i for i in range(arr[0] - 1, 0, -1)])\n        ind = 0\n        for i in range(1, l):\n            if arr[i - 1] == arr[i]:\n                (lex_min[i], lex_max[i]) = (ls_min[ind], ls_max[ind])\n                ind += 1\n            else:\n                (lex_min[i], lex_max[i]) = (arr[i], arr[i])\n                x = len(lex_min)\n                ls_min[x:x] = [i for i in range(arr[i - 1] + 1, arr[i])]\n                ls_max[ind:ind] = [i for i in range(arr[i] - 1, arr[i - 1], -1)]\n    print(*lex_min)\n    print(*lex_max)\nfor test in range(int(input())):\n    n = int(input())\n    lst = list(map(int, input().strip().split()))\n    per(n, lst)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    used = set(a)\n    k = 1\n    print(a[0], end=' ')\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            print(a[i], end=' ')\n            continue\n        while k in used:\n            k += 1\n        print(k, end=' ')\n        k += 1\n    print()\n    print(a[0], end=' ')\n    connect = {a[0]: a[0] - 1}\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            print(a[i], end=' ')\n            if a[i] - 1 in connect:\n                connect[a[i]] = connect[a[i] - 1]\n            else:\n                connect[a[i]] = a[i] - 1\n            continue\n        print(connect[a[i]], end=' ')\n        if connect[a[i]] - 1 in connect:\n            connect[a[i]] = connect[connect[a[i]] - 1]\n        else:\n            connect[a[i]] -= 1\n    print()", "from heapq import heapify, heappush, heappop\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split(' ')))\n    mnp = [0] * n\n    mxp = [0] * n\n    mnp[0] = arr[0]\n    mxp[0] = arr[0]\n    p = []\n    per = []\n    for i in range(1, arr[0]):\n        heappush(p, i)\n        heappush(per, -i)\n    for i in range(1, n):\n        if arr[i] != arr[i - 1]:\n            for j in range(arr[i - 1] + 1, arr[i]):\n                heappush(p, j)\n                heappush(per, -j)\n            mnp[i] = arr[i]\n            mxp[i] = arr[i]\n        else:\n            mxp[i] = -1 * heappop(per)\n            mnp[i] = heappop(p)\n    print(*mnp)\n    print(*mxp)", "from queue import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    q = list(map(int, input().split()))\n    mi = 0\n    l = [None] * n\n    v = [None] * n\n    d = deque()\n    for i in range(n):\n        if i == 0:\n            l[i] = q[i]\n            for j in range(mi + 1, q[i]):\n                d.append(j)\n            mi = q[i]\n            continue\n        if q[i] != q[i - 1]:\n            l[i] = q[i]\n            for j in range(mi + 1, q[i]):\n                d.append(j)\n            mi = q[i]\n        else:\n            l[i] = d.popleft()\n    mi = 0\n    d = deque()\n    for i in range(n):\n        if i == 0:\n            v[i] = q[i]\n            for j in range(mi + 1, q[i]):\n                d.append(j)\n            mi = q[i]\n            continue\n        if q[i] != q[i - 1]:\n            v[i] = q[i]\n            for j in range(mi + 1, q[i]):\n                d.append(j)\n            mi = q[i]\n        else:\n            v[i] = d.pop()\n    print(*l)\n    print(*v)", "from collections import deque\ncas = int(input())\nwhile cas:\n    cas -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans1 = []\n    tmp1 = deque()\n    ans2 = []\n    tmp2 = deque()\n    for i in range(n):\n        if i == 0:\n            for j in range(1, a[i]):\n                tmp1.append(j)\n                tmp2.append(j)\n            ans1.append(a[i])\n            ans2.append(a[i])\n        elif a[i] != a[i - 1]:\n            for j in range(a[i - 1] + 1, a[i]):\n                tmp1.append(j)\n                tmp2.append(j)\n            ans1.append(a[i])\n            ans2.append(a[i])\n        else:\n            ans1.append(tmp1.pop())\n            ans2.append(tmp2.popleft())\n    for i in range(n):\n        if i == n - 1:\n            print(ans2[i])\n        else:\n            print(ans2[i], end=' ')\n    for i in range(n):\n        if i == n - 1:\n            print(ans1[i])\n        else:\n            print(ans1[i], end=' ')", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    temp = list(arr)\n    val = [i for i in range(1, n + 1)]\n    s = set(arr)\n    x = set(val)\n    elem = list(x - s)\n    flag = 0\n    ind_val = temp[0]\n    for i in range(1, n):\n        if temp[i] == ind_val:\n            temp[i] = elem[flag]\n            flag += 1\n        else:\n            ind_val = temp[i]\n    ind_val = arr[0]\n    for i in range(1, n):\n        if arr[i] == ind_val:\n            el = bisect.bisect_left(elem, arr[i]) - 1\n            arr[i] = elem[el]\n            elem.pop(el)\n        else:\n            ind_val = arr[i]\n    print(*temp)\n    print(*arr)", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    s = list(map(int, input().split()))\n    s_t = set(s)\n    st = list((i for i in range(1, n + 1) if i not in s_t))\n    ar = [s[0]] + [0 for i in range(n - 1)]\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            ar[i] = s[i]\n    st1 = st\n    st2 = st\n    ar1 = ar.copy()\n    x = 0\n    for i in range(n):\n        if ar1[i] == 0:\n            ar1[i] = st1[x]\n            x += 1\n    print(*ar1)\n    for i in range(1, n):\n        if ar[i] == 0:\n            pos = bisect.bisect_left(st2, ar[i - 1])\n            if pos == 0:\n                ar[i] = st2[pos + 1]\n                st2.pop(pos - 1)\n            else:\n                ar[i] = st2[pos - 1]\n                st2.pop(pos - 1)\n    print(*ar)", "import heapq\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    s = set()\n    e = []\n    for i in l:\n        if i in s:\n            continue\n        s.add(i)\n    for i in range(1, n + 1):\n        if i in s:\n            continue\n        e.append(i)\n    a = e[::-1]\n    am = [0] * n\n    for i in range(n):\n        x = l[i]\n        if x in s:\n            am[i] = x\n            s.remove(x)\n        else:\n            am[i] = a.pop()\n    h = []\n    ama = [0] * n\n    heapq.heapify(h)\n    i = 0\n    prev = 0\n    while i < n:\n        j = i\n        while j < n:\n            if l[j] == l[i]:\n                pass\n            else:\n                break\n            j = j + 1\n        w = j\n        ama[i] = am[i]\n        k = i + 1\n        cnt = l[i] - 1\n        er = prev\n        prev = am[i]\n        while cnt > er:\n            heapq.heappush(h, -1 * cnt)\n            cnt -= 1\n        while k < w:\n            cnt = -1 * heapq.heappop(h)\n            ama[k] = cnt\n            k += 1\n        i = w\n    print(*am)\n    print(*ama)", "import heapq\nt = int(input())\nfor _ in range(t):\n    _ = input()\n    arr = [int(it) for it in input().split(' ')]\n    max_perm_arr = []\n    max_perm_arr.append(arr[0])\n    min_perm_arr = []\n    min_perm_arr.append(arr[0])\n    max_q = []\n    min_q = []\n    for i in range(1, arr[0]):\n        heapq.heappush(max_q, -i)\n        heapq.heappush(min_q, i)\n    vis_max = set([arr[0]])\n    vis_min = set([arr[0]])\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            max_perm_arr.append(arr[i])\n            vis_max.add(arr[i])\n            min_perm_arr.append(arr[i])\n            vis_min.add(arr[i])\n            for j in range(arr[i - 1], arr[i]):\n                if j in vis_max:\n                    pass\n                else:\n                    heapq.heappush(max_q, -j)\n                if j in vis_min:\n                    pass\n                else:\n                    heapq.heappush(min_q, j)\n        else:\n            max_perm_arr.append(-heapq.heappop(max_q))\n            vis_max.add(max_perm_arr[-1])\n            min_perm_arr.append(heapq.heappop(min_q))\n            vis_min.add(min_perm_arr[-1])\n    print(*min_perm_arr)\n    print(*max_perm_arr)", "def count():\n    for i in a:\n        c[i] += 1\n\ndef l_min():\n    (ml, q) = ([a[0]], [])\n    ind = 0\n    for i in range(1, n):\n        if not c[i]:\n            q.append(i)\n        if a[i - 1] != a[i]:\n            for j in range(i - 1, i - c[a[i - 1]], -1):\n                ml.append(q[ind])\n                ind += 1\n            ml.append(a[i])\n    for i in range(n - 1, n - c[a[-1]], -1):\n        ml.append(q[ind])\n        ind += 1\n    return ml\n\ndef l_max():\n    (mal, s) = ([a[0]], [])\n    prev = 0\n    for i in range(1, n):\n        if a[i - 1] != a[i]:\n            for j in range(i - 1, i - c[a[i - 1]], -1):\n                mal.append(s[-1])\n                s.pop()\n            mal.append(a[i])\n        if prev != a[i - 1]:\n            for j in range(prev + 1, a[i - 1]):\n                s.append(j)\n            prev = a[i - 1]\n    if prev != a[-1]:\n        for j in range(prev + 1, a[-1]):\n            s.append(j)\n    for i in range(n - 1, n - c[a[-1]], -1):\n        mal.append(s[-1])\n        s.pop()\n    return mal\nfor T in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    c = [0] * (n + 1)\n    count()\n    print(*l_min())\n    print(*l_max())", "import math\nfrom collections import Counter\nimport bisect\n\ndef tis():\n    return map(int, input().split(' '))\n\ndef tl():\n    return list(map(int, input().split(' ')))\nfor _ in range(int(input())):\n    n = int(input())\n    q = tl()\n    mn = [0 for i in range(n)]\n    mx = [0 for i in range(n)]\n    mn[0] = q[0]\n    mx[0] = q[0]\n    array = [q[0]]\n    for i in range(1, n):\n        if q[i] != q[i - 1]:\n            mn[i] = q[i]\n            mx[i] = q[i]\n            array.append(q[i])\n    nUsed = [i for i in range(1, n + 1)]\n    for k in array:\n        nUsed[k - 1] = -1\n    ptr = 0\n    for i in range(n):\n        if mn[i] == 0:\n            while nUsed[ptr] == -1:\n                ptr += 1\n            mn[i] = nUsed[ptr]\n            ptr += 1\n    print(*mn)\n    maxx = [0] * n\n    maxx[0] = q[0]\n    for i in range(1, n):\n        if q[i] != q[i - 1]:\n            maxx[i] = q[i]\n    s = set(maxx)\n    curr = n\n    left = []\n    prev = 0\n    for i in range(n):\n        if maxx[i] == 0:\n            maxx[i] = left.pop()\n        else:\n            for j in range(prev + 1, maxx[i]):\n                left.append(j)\n            prev = maxx[i]\n    print(*maxx)", "import sys\ninput = sys.stdin.readline\nimport heapq\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    q = list(map(int, input().split()))\n    ans_min = [0] * n\n    (Max, Min) = (0, 1)\n    ok = []\n    heapq.heapify(ok)\n    for i in range(n):\n        if q[i] > Max:\n            ans_min[i] = q[i]\n            Max = q[i]\n            for i in range(Min, Max):\n                heapq.heappush(ok, i)\n            Min = Max + 1\n        else:\n            v = heapq.heappop(ok)\n            ans_min[i] = v\n    ans_max = [0] * n\n    (Max, Min) = (0, 1)\n    ok = []\n    heapq.heapify(ok)\n    for i in range(n):\n        if q[i] > Max:\n            ans_max[i] = q[i]\n            Max = q[i]\n            for i in range(Min, Max):\n                heapq.heappush(ok, -i)\n            Min = Max + 1\n        else:\n            v = heapq.heappop(ok)\n            ans_max[i] = -v\n    print(*ans_min)\n    print(*ans_max)", "from collections import deque\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    q = input().split()\n    q = list(map(int, q))\n    q.insert(0, 0)\n    nxt = deque()\n    for i in range(1, n + 1):\n        if q[i] > q[i - 1]:\n            print(q[i], end=' ')\n            nxt.extend([j for j in range(q[i - 1] + 1, q[i])])\n        else:\n            print(nxt[0], end=' ')\n            nxt.popleft()\n    print()\n    for i in range(1, n + 1):\n        if q[i] > q[i - 1]:\n            print(q[i], end=' ')\n            nxt.extend([j for j in range(q[i - 1] + 1, q[i])])\n        else:\n            print(nxt[-1], end=' ')\n            nxt.pop()\n    print()", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    q = [int(ea) for ea in input().split(' ')]\n    maxP = [0 for i in range(n)]\n    minP = [0 for i in range(n)]\n    prev = -1\n    numsLeft = set(range(1, n + 1))\n    lowerThanMe = {ea: ea - 1 for ea in range(1, n + 1)}\n    higherThanMe = {ea: ea + 1 for ea in range(1, n + 1)}\n    for i in range(n):\n        if q[i] != prev:\n            cur = q[i]\n            maxP[i] = cur\n            minP[i] = cur\n            numsLeft.remove(cur)\n        prev = q[i]\n    numsLeftForMin = sorted(list(numsLeft))\n    ni = 0\n    for i in range(n):\n        if minP[i] == 0:\n            minP[i] = numsLeftForMin[ni]\n            ni += 1\n    for i in range(n):\n        if maxP[i] == 0:\n            cur = maxP[i - 1]\n            while cur not in numsLeft:\n                higherThanMe[lowerThanMe[cur]] = higherThanMe[cur]\n                lowerThanMe[higherThanMe[cur]] = lowerThanMe[cur]\n                cur = lowerThanMe[cur]\n            maxP[i] = cur\n            numsLeft.remove(cur)\n    print(*minP)\n    print(*maxP)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    q = [int(ea) for ea in input().split(' ')]\n    maxP = [0 for i in range(n)]\n    minP = [0 for i in range(n)]\n    prev = -1\n    numsLeft = set(range(1, n + 1))\n    lowerThanMe = {ea: ea - 1 for ea in range(1, n + 1)}\n    higherThanMe = {ea: ea + 1 for ea in range(1, n + 1)}\n    for i in range(n):\n        if q[i] != prev:\n            cur = q[i]\n            maxP[i] = cur\n            minP[i] = cur\n            numsLeft.remove(cur)\n        prev = q[i]\n    numsLeftForMin = sorted(list(numsLeft))\n    ni = 0\n    for i in range(n):\n        if minP[i] == 0:\n            minP[i] = numsLeftForMin[ni]\n            ni += 1\n    for i in range(n):\n        if maxP[i] == 0:\n            cur = maxP[i - 1]\n            while cur not in numsLeft:\n                higherThanMe[lowerThanMe[cur]] = higherThanMe[cur]\n                lowerThanMe[higherThanMe[cur]] = lowerThanMe[cur]\n                cur = lowerThanMe[cur]\n            maxP[i] = cur\n            numsLeft.remove(cur)\n    print(*minP)\n    print(*maxP)", "for _ in range(int(input())):\n    n = int(input())\n    l = list(map(int, input().split()))\n    b = l.copy()\n    d = {l[0]: 0}\n    ans = [l[0]]\n    a = []\n    for i in range(1, n):\n        d.setdefault(l[i], i)\n        if b[i] == b[i - 1]:\n            l[i] = 'X'\n        else:\n            ans.append(l[i])\n    for i in range(1, n + 1):\n        d.setdefault(i, -1)\n        if d[i] == -1:\n            a.append(i)\n    ans1 = l.copy()\n    i = 0\n    k = 0\n    while i < len(ans):\n        j = d[ans[i]] + 1\n        if j < n:\n            while ans1[j] == 'X':\n                ans1[j] = a[k]\n                k += 1\n                j += 1\n                if j == n:\n                    break\n        i += 1\n    k = 1\n    ans2 = l.copy()\n    i = 0\n    s = []\n    while i < len(ans):\n        j = d[ans[i]] + 1\n        if j < n:\n            while ans2[j] == 'X':\n                while k < ans[i]:\n                    if d[k] == -1:\n                        s.append(k)\n                        d[k] = -2\n                    k += 1\n                ans2[j] = s.pop()\n                j += 1\n                if j == n:\n                    break\n        i += 1\n    print(*ans1)\n    print(*ans2)", "def cf_710E(n: int, numbers: list):\n    const = [None] * n\n    temp = set()\n    for (index, num) in enumerate(numbers):\n        if num not in temp:\n            const[index] = num\n            temp.add(num)\n    remainig = sorted(set(range(1, n + 1)).difference(temp))\n    if not len(remainig):\n        print(*const)\n        print(*const)\n        return\n    i = 0\n    MIN = const.copy()\n    for (index, val) in enumerate(MIN):\n        if val is None:\n            MIN[index] = remainig[i]\n            i += 1\n    MAX = const.copy()\n    currMax = -1\n    for (index, val) in enumerate(MAX):\n        if val is not None:\n            currMax = val\n            continue\n        x = lowerBound(remainig, currMax)\n        MAX[index] = remainig.pop(x)\n    print(*MIN)\n    print(*MAX)\n\ndef lowerBound(arr: list, element: int):\n    answer = -1\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < element:\n            answer = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return answer\nfor _ in range(int(input())):\n    n = int(input())\n    cf_710E(n, list(map(int, input().split())))", "from queue import Queue\n\ndef task1():\n    p = []\n    buffer = Queue()\n    p.append(q[0])\n    for x in range(1, q[0]):\n        buffer.put(x)\n    for i in range(n - 1):\n        if q[i + 1] == q[i]:\n            temp = buffer.get()\n            p.append(temp)\n        else:\n            p.append(q[i + 1])\n            for x in range(q[i] + 1, q[i + 1]):\n                buffer.put(x)\n    for val in p:\n        print(val, end=' ')\n    print()\n\ndef task2():\n    p = []\n    buffer = []\n    p.append(q[0])\n    for x in range(1, q[0]):\n        buffer.append(x)\n    for i in range(n - 1):\n        if q[i + 1] == q[i]:\n            temp = buffer.pop()\n            p.append(temp)\n        else:\n            p.append(q[i + 1])\n            for x in range(q[i] + 1, q[i + 1]):\n                buffer.append(x)\n    for val in p:\n        print(val, end=' ')\n    print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    q = list(map(int, input().strip().split()))\n    task1()\n    task2()"]