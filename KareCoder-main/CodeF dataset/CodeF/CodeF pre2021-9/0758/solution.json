["def smallest_winner(matrix):\n    starting_x = 1\n    x = 1\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p):\n    maxi = matrix[-1]\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        temp = matrix[i + p - 1] - i\n        maxi = min(maxi, temp)\n    return maxi\n\ndef check_multiple(matrix):\n    count = 0\n    maxi = 0\n    for i in range(1, len(matrix)):\n        if matrix[i] == matrix[i - 1]:\n            count += 1\n        else:\n            count = 1\n        maxi = max(maxi, count)\n    return maxi\n\ndef solve(n, p, matrix):\n    matrix = sorted(matrix)\n    min_x = smallest_winner(matrix)\n    max_x = biggest_winner(matrix, p) - 1\n    return [i for i in range(min_x, max_x + 1)]\n(n, p) = map(int, input().split())\nmatrix = map(int, input().split())\nres = solve(n, p, matrix)\nprint(len(res))\nprint(' '.join(map(str, res)))", "def smallest_winner(matrix, starting_x, x):\n    for m in matrix:\n        if m > x:\n            starting_x += m - x\n            x += m - x\n        x += 1\n    return starting_x\n\ndef biggest_winner(matrix, p, maxi):\n    for i in range(len(matrix)):\n        if i + p - 1 >= len(matrix):\n            break\n        maxi = min(maxi, matrix[i + p - 1] - i)\n    return maxi\n(n, p) = map(int, input().split())\nmatrix = sorted(list(map(int, input().split())))\nres = [i for i in range(smallest_winner(matrix, 1, 1), biggest_winner(matrix, p, matrix[-1]))]\nprint(len(res))\nprint(' '.join(map(str, res)))", "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque, defaultdict\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000000 + 7\nmod2 = 998244353\n(n, p) = M()\na = sorted(L())\nfor i in range(n):\n    a[i] -= i\nm1 = max(a)\nfor i in range(n):\n    a[i] += p - 1\nm2 = min(a[p - 1:])\nprint(max(0, m2 - m1))\nprint(*list(range(m1, m2)))", "(n, p) = map(int, input().split())\narr = list(map(int, input().split()))\n(l, r) = (0, float('inf'))\narr.sort()\nfor i in range(len(arr)):\n    l = max(l, arr[i] - i)\n    if i + 1 >= p:\n        r = min(r, arr[i] - i + p - 1)\nprint(max(0, r - l))\nres = []\nfor i in range(l, r):\n    res.append(i)\nprint(*res)", "(n, p) = map(int, input().split())\narr = list(map(int, input().split()))\n(l, r) = (0, float('inf'))\narr.sort()\nfor i in range(len(arr)):\n    l = max(l, arr[i] - i)\n    if i + 1 >= p:\n        r = min(r, arr[i] - i + p - 1)\nprint(max(0, r - l))\nres = []\nfor i in range(l, r):\n    res.append(i)\nprint(*res)", "import math\nimport collections\nfrom sys import stdin, stdout, setrecursionlimit\nfrom bisect import bisect_left as bsl\nfrom bisect import bisect_right as bsr\nimport heapq as hq\nsetrecursionlimit(2 ** 20)\nt = 1\nd = {}\n\ndef bin(a, k):\n    cnt = bsr(a, k)\n    for i in range(n):\n        if cnt >= p:\n            return True\n        cnt -= 1\n        k += 1\n        if k in d:\n            cnt += d[k]\n    return False\ndp = [1] * 100001\nfor _ in range(t):\n    (n, p) = list(map(int, stdin.readline().rstrip().split()))\n    a = list(map(int, stdin.readline().rstrip().split()))\n    a.sort()\n    for i in range(n):\n        a[i] -= i\n    mi = max(a)\n    for i in range(n):\n        a[i] += p - 1\n    ma = min(a[p - 1:])\n    print(max(ma - mi, 0))\n    print(*list(range(mi, ma)))", "lis = input().split()\n(n, p) = (int(lis[0]), int(lis[1]))\nlis = input().split()\na = [0] * n\nfor i in range(n):\n    a[i] = int(lis[i])\na.sort()\nxminn = a[0]\nfor i in range(1, n):\n    xminn = max(a[i] - i, xminn)\nfor i in range(n):\n    a[i] = min(xminn - a[i] + 1 + i, i + 1)\nlenn = n\ni = p\nwhile i <= n:\n    lenn = min(i - a[i - 1], lenn)\n    i += p\nif lenn == 0:\n    print(0)\nelse:\n    notAllowed = [False] * lenn\n    for i in range(n):\n        uplim = min(a[i] + lenn - 1, i + 1)\n        val = ((a[i] - 1) // p + 1) * p\n        if val <= uplim:\n            notAllowed[val - a[i]] = True\n    good = []\n    for i in range(lenn):\n        if not notAllowed[i]:\n            good.append(xminn + i)\n    print(len(good))\n    for i in good:\n        print(i, end=' ')\n    print()"]