["def calc(x):\n    if x == 0:\n        return (0, 1)\n    else:\n        (k, kplusone) = calc(int(x // 2))\n        twok = k * pow(2 * kplusone - k + r, 1, r)\n        twokplusone = pow(pow(k ** 2, 1, r) + pow(kplusone ** 2, 1, r), 1, r)\n        if x % 2 == 0:\n            return (twok, twokplusone)\n        else:\n            return (twokplusone, pow(twok + twokplusone, 1, r))\n(n, r) = (int(input()), 998244353)\ntop = calc(n)[0] % r\nbottom = pow(2 ** n, -1, r)\nprint(top * bottom % r)", "p = 998244353\n\ndef multiply(a, b):\n    mul = [[0 for i in range(2)] for j in range(2)]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                mul[i][j] += a[i][k] * b[k][j] % p\n    for i in range(2):\n        for j in range(2):\n            a[i][j] = mul[i][j] % p\n\ndef power(F, n):\n    M = [[0, 1], [1, 1]]\n    if n == 1:\n        return (F[0][0] + F[0][1]) % p\n    power(F, n // 2)\n    multiply(F, F)\n    if n % 2 == 1:\n        multiply(F, M)\n    return (F[0][0] + F[0][1]) % p\n\ndef fib(n):\n    F = [[0, 1], [1, 1]]\n    if n == 1 or n == 2:\n        return 1\n    return power(F, n - 1) % p\nn = int(input())\nprint(fib(n) * pow(2 ** n, -1, p) % p)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nm = 998244353\n(f0, f1) = (0, 1)\nfor _ in range(2, n + 1):\n    (f0, f1) = (f1, (f0 + f1) % m)\nprint(f1 * pow(2 ** n, m - 2, m) % m)", "n = int(input())\nmod = 998244353\ntotientMod = 998244352\ntotalWays = pow(2, n, mod)\ntotalWaysInv = pow(totalWays, totientMod - 1, mod)\nif n == 1:\n    ways = 1\nelif n == 2:\n    ways = 1\nelse:\n    (a, b) = (1, 1)\n    for i in range(2, n):\n        (a, b) = (b, (a + b) % mod)\n    ways = b\nprint(ways * totalWaysInv % mod)", "def Huge_Fib(n, m):\n    (v1, v2, v3) = (1, 1, 0)\n    for rec in bin(n)[3:]:\n        calc = v2 * v2 % m\n        (v1, v2, v3) = ((v1 * v1 + calc) % m, (v1 + v3) * v2 % m, (calc + v3 * v3) % m)\n        if rec == '1':\n            (v1, v2, v3) = ((v1 + v2) % m, v1, v2)\n    return v2\nn = int(input())\np = 998244353\nif n <= 2:\n    f = 1\nelse:\n    f = Huge_Fib(n, p)\nmul = (p + 1) // 2\ns = 0\nwhile f % 2 == 0:\n    s = s + 1\n    f = f // 2\nbase = pow(mul, n - s, p)\nprint(base * f % p)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nm = 998244353\n(f0, f1) = (0, 1)\nfor _ in range(2, n + 1):\n    (f0, f1) = (f1, (f0 + f1) % m)\nprint(f1 * pow(2 ** n, -1, m) % m)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nm = 998244353\n(f0, f1) = (0, 1)\nfor _ in range(2, n + 1):\n    (f0, f1) = (f1, (f0 + f1) % m)\nprint(f1 * pow(2 ** n, m - 2, m) % m)", "n = int(input())\nM = 998244353\n(a1, a2) = (1, 1)\nif n > 2:\n    for i in range(n - 2):\n        (a2, a1) = ((a1 + a2) % M, a2 % M)\n    ans = a2 % M\nelse:\n    ans = a2 % M\nprint(ans * pow(2, M - n - 1, M) % M)", "n = int(input())\n\ndef fun(n):\n    (v1, v2, v3) = (1, 1, 0)\n    for rec in bin(n)[3:]:\n        calc = v2 * v2\n        (v1, v2, v3) = (v1 * v1 + calc, (v1 + v3) * v2, calc + v3 * v3)\n        if rec == '1':\n            (v1, v2, v3) = (v1 + v2, v1, v2)\n    return v2\nans = fun(n)\nans1 = pow(pow(2, n), 998244351, 998244353)\nprint(ans1 * ans % 998244353)", "from collections import Counter, defaultdict, deque\nimport math\nimport sys\ninput = sys.stdin.readline\nMOD = 998244353\n\ndef solve():\n    n = int(input())\n    f = [1, 1]\n    for i in range(n):\n        f.append((f[-1] + f[-2]) % MOD)\n    den = pow(2, n, MOD)\n    den = pow(den, MOD - 2, MOD)\n    res = f[n - 1] * den % MOD\n    print(res)\ntt = 1\nfor test in range(tt):\n    solve()", "import sys\n\ndef main():\n    inp = [int(x) for x in sys.stdin.read().split()]\n    ii = 0\n    n = inp[ii]\n    ii += 1\n    MOD = 998244353\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for x in range(2, n + 1):\n        dp[x] = (dp[x - 1] + dp[x - 2]) % MOD\n    de = pow(2, -n, MOD)\n    print(dp[n] * de % MOD)\nmain()", "M = 998244353\nn = int(input())\nF = [1, 1, 1]\nfor i in range(n - 2):\n    F.append((F[-1] + F[-2]) % M)\nprint(F[-1] * pow(2, M - n - 1, M) % M)", "M = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(2, n * (M - 2), M) % M)", "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    constn_1 = 1\n    constn_2 = 1\n    for i in range(3, n + 1):\n        const = (constn_1 + constn_2) % 998244353\n        constn_2 = constn_1 % 998244353\n        constn_1 = const % 998244353\n    return const % 998244353\n\ndef tower(n):\n    x = fib(n)\n    return x * pow(2 ** n, -1, 998244353) % 998244353\nprint(tower(int(input())))", "def Fibonacci(n):\n    a1 = 0\n    a2 = 1\n    for i in range(n):\n        a2 = (a2 + a1) % 998244353\n        a1 = a2 - a1\n    return a1\n\ndef Denominador(n):\n    MOD = 998244353\n    return pow(2, -n, MOD)\n\ndef Func(n):\n    return Fibonacci(n) * Denominador(n) % 998244353\nn = int(input())\nprint(Func(n))", "n = int(input())\nm = 998244353\n(f0, f1) = (0, 1)\nfor _ in range(2, n + 1):\n    (f0, f1) = (f1, (f0 + f1) % m)\nprint(f1 * pow(2 ** n, m - 2, m) % m)", "mod = 998244353\n\ndef qpow(a, b):\n    ans = 1\n    base = a\n    while b:\n        if b & 1:\n            ans = (ans * base % mod + mod) % mod\n        base = (base * base % mod + mod) % mod\n        b = b >> 1\n    return ans\nn = input()\nn = int(n)\na = b = 1\nc = 0\nif n == 1 or n == 2:\n    c = 1\nelse:\n    for i in range(3, n + 1):\n        c = (a + b) % mod\n        a = b\n        b = c\nprint(b * qpow(qpow(2, n), mod - 2) % mod)", "M = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(2, n * (M - 2), M) % M)", "M = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(2, n * (M - 2), M) % M)", "n = int(input())\nm = 998244353\n(x, y) = (0, 1)\nfor i in range(n - 1):\n    (x, y) = (y, x + y)\n    x %= m\n    y %= m\nr = pow(2, n, m)\nprint(y * pow(r, m - 2, m) % m)", "import sys\nimport math\nmod = 998244353\nLI = lambda : [int(k) for k in input().split()]\ninput = lambda : sys.stdin.readline().rstrip()\nIN = lambda : int(input())\nS = lambda : input()\nr = range\nif 1:\n    n = int(input())\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n    den = pow(2, n, mod)\n    deninv = pow(den, mod - 2, mod)\n    print(dp[n] * deninv % mod)", "MOD = 998244353\n\ndef powr(n, N):\n    temp = 1\n    while N > 0:\n        if N % 2 != 0:\n            temp = temp * n % MOD\n        n = n * n % MOD\n        N = N // 2\n    return temp % MOD\nn = int(input())\nL = [0, 1]\nfor i in range(2, n + 1):\n    L.append((L[-1] + L[-2]) % MOD)\nnum = L[-1] % MOD\ndem = powr(2, n) % MOD\ntt = pow(dem, MOD - 2, MOD) % MOD\nans = num * tt % MOD\nprint(ans)", "M = 998244353\n\ndef inv2(a, mod=998244353):\n    (res, b) = (1, mod - 2)\n    while b != 0:\n        if b & 1:\n            res = res * a % mod\n        (a, b) = (a * a % mod, b >> 1)\n    return res\nn = int(input())\n(a, b) = (1, 1)\nfor i in range(3, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * inv2(2 ** n) % M)", "M = 998244353\n\ndef inv2(a, mod):\n    (res, b) = (1, mod - 2)\n    while b != 0:\n        if b & 1:\n            res = res * a % mod\n        (a, b) = (a * a % mod, b >> 1)\n    return res\nn = int(input())\n(a, b) = (1, 1)\nfor i in range(3, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * inv2(pow(2, n, M), M) % M)", "M = 998244353\nn = int(input())\n(a, b) = (1, 1)\nfor i in range(3, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(pow(2, n, M), M - 2, M) % M)", "M = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(2, n * (M - 2), M) % M)", "def fibonacci(n, m):\n    if n < 2:\n        return n\n    a = 0\n    b = 1\n    for i in range(n - 1):\n        c = b\n        b = (a + b) % m\n        a = c\n    return b\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef pow(a, b, m):\n    if b < 0:\n        raise Exception('bad')\n    ret = 1\n    for i in range(b):\n        ret *= a\n        ret %= m\n    return ret\ninp = int(input())\np = 998244353\nprint(fibonacci(inp, p) * modinv(pow(2, inp, p), p) % p)", "M = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(2, n * (M - 2), M) % M)", "MOD = 998244353\nn = int(input())\nmult = pow(2, MOD - 1 - n, MOD)\n(a, b) = (0, 1)\nfor i in range(n):\n    (a, b) = (b, (a + b) % MOD)\nprint(a * mult % MOD)", "M = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(2, n * (M - 2), M) % M)", "from sys import stdin\nstdin.readline\n\ndef mp():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef it():\n    return int(stdin.readline().strip())\nn = it()\nmod = 998244353\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % mod)\nprint(b * pow(2 ** n, mod - 2, mod) % mod)", "p = 998244353\nn = int(input())\nar = [0] * (n + 10)\nar[0] = 1\nar[1] = 1\nar[2] = 1\nfor i in range(3, n + 1):\n    ar[i] = (ar[i - 1] + ar[i - 2]) % p\nd = int(pow(2, n, p))\nd = int(pow(d, p - 2, p))\nprint(ar[n] * d % p)", "p = 998244353\nn = int(input())\ndp = [1 for i in range(n + 1)]\n(odd, even) = (1, 1)\nfor i in range(2, n + 1):\n    if i % 2 == 0:\n        dp[i] = odd\n        even = (even + odd) % p\n    else:\n        dp[i] = even\n        odd = (odd + even) % p\nways = dp[n]\nden = pow(2, n, p)\nans = ways * pow(den, p - 2, p) % p\nprint(ans)", "def power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nn = int(input())\nmod = 998244353\nif n == 1 or n == 2:\n    x = 1\nelse:\n    a = 1\n    b = 1\n    for i in range(n - 2):\n        c = (a + b) % mod\n        a = b\n        b = c\n    x = c\ny = power(pow(2, n, mod), mod - 2, mod)\nprint(x * y % mod)", "M = 998244353\nn = int(input())\n(a, b) = (1, 1)\nfor i in range(3, n + 1):\n    (a, b) = (b, (a + b) % M)\nprint(b * pow(pow(2, n, M), M - 2, M) % M)", "p = 998244353\nn = int(input())\nar = [0] * (n + 10)\nar[0] = 1\nar[1] = 1\nar[2] = 1\nfor i in range(3, n + 1):\n    ar[i] = (ar[i - 1] + ar[i - 2]) % p\nd = int(pow(2, n, p))\nd = int(pow(d, p - 2, p))\nprint(ar[n] * d % p)", "p = 998244353\nn = int(input())\nar = [0] * (n + 10)\nar[0] = 1\nar[1] = 1\nar[2] = 1\nfor i in range(3, n + 1):\n    ar[i] = (ar[i - 1] + ar[i - 2]) % p\nd = int(pow(2, n, p))\nd = int(pow(d, p - 2, p))\nprint(ar[n] * d % p)", "n = int(input(''))\nmod = 998244353\ndp = [1, 1]\nfor i in range(2, n):\n    dp.append((dp[-1] + dp[-2]) % mod)\nprint(pow(pow(2, n, mod), mod - 2, mod) * dp[n - 1] % mod)", "import sys\nimport math\nfrom collections import Counter, defaultdict\nLI = lambda : list(map(int, input().split()))\nMAP = lambda : map(int, input().split())\nIN = lambda : int(input())\nS = lambda : input()\nmod = 998244353\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    res = binpow(a, b // 2)\n    if b % 2:\n        return res * res * a % mod\n    else:\n        return res * res % mod\n\ndef inverse(n):\n    return binpow(n, mod - 2)\n\ndef case():\n    n = IN()\n    fi = [0] * (n + 2)\n    fi[1] = 1\n    fi[2] = 1\n    for i in range(3, n + 1):\n        fi[i] = (fi[i - 1] + fi[i - 2]) % mod\n    ans = inverse(binpow(2, n))\n    print(ans * fi[n] % mod)\nfor _ in range(1):\n    case()", "import sys\nimport math\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef SI():\n    return sys.stdin.readline().strip()\n\ndef FACT(n, mod):\n    s = 1\n    facts = [1]\n    for i in range(1, n + 1):\n        s *= i\n        s %= mod\n        facts.append(s)\n    return facts[n]\n\ndef C(n, k, mod):\n    return FACT(n, mod) * pow(FACT(k, mod) * FACT(n - k, mod) % mod, mod - 2, mod) % mod\nn = II()\nmod = 998244353\ndp = [1, 1, 1]\nfor i in range(2, n):\n    dp.append((dp[-1] + dp[-2]) % mod)\nans = dp[-1]\nprint(ans * pow(pow(2, n, mod), mod - 2, mod) % mod)", "mod = 998244353\n\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    res = binpow(a, b // 2)\n    if b % 2:\n        return res * res * a % mod\n    else:\n        return res * res % mod\n\ndef inverse(n):\n    return binpow(n, mod - 2)\n\ndef case():\n    n = int(input())\n    fi = [0] * (n + 2)\n    fi[1] = 1\n    fi[2] = 1\n    for i in range(3, n + 1):\n        fi[i] = (fi[i - 1] + fi[i - 2]) % mod\n    ans = inverse(binpow(2, n))\n    print(ans * fi[n] % mod)\nfor _ in range(1):\n    case()", "def modInverse(a, m):\n    m0 = m\n    (y, x) = (0, 1)\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        return x + m0\n    else:\n        return x\nn = int(input())\nmod = 998244353\nif n <= 2:\n    print(modInverse(pow(2, n, mod), mod))\nelse:\n    l = 1\n    r = 1\n    for _ in range(n - 2):\n        mem = r\n        r = (l + r) % mod\n        l = mem\n    print(r * modInverse(pow(2, n, mod), mod) % mod)", "mod = 998244353\nn = int(input())\na = 1\nb = 1\nm = pow(2, n)\nn -= 2\nwhile n > 0:\n    (a, b) = (b % mod, (a + b) % mod)\n    n -= 1\nwhile b % 2 == 0:\n    b = b >> 1\n    m = m >> 1\nprint(b * pow(m, mod - 2, mod) % mod)", "n = int(input())\n(x, y) = (0, 1)\nmod = 998244353\nfor i in range(n - 1):\n    (x, y) = (y, x + y)\n    x %= mod\n    y %= mod\nt = pow(2, n, mod)\nprint(y * pow(t, mod - 2, mod) % mod)", "M = 998244353\nn = int(input())\nF = [1, 1, 1]\nfor i in range(n - 2):\n    F.append((F[-1] + F[-2]) % M)\nprint(F[-1] * pow(2, M - n - 1, M) % M)", "import sys\nimport math, bisect\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\nn = I()\nm = 998244353\n\ndef fib(n):\n    F = [[1, 1], [1, 0]]\n    if n == 0:\n        return 0\n    power(F, n - 1)\n    return F[0][0]\n\ndef multiply(F, M):\n    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]\n    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]\n    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]\n    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]\n    F[0][0] = x\n    F[0][1] = y\n    F[1][0] = z\n    F[1][1] = w\n\ndef power(F, n):\n    if n == 0 or n == 1:\n        return\n    M = [[1, 1], [1, 0]]\n    power(F, n // 2)\n    multiply(F, F)\n    if n % 2 != 0:\n        multiply(F, M)\nprint(fib(n) * pow(2 ** n, m - 2, m) % m)", "import sys\n\ndef minp():\n    return sys.stdin.readline().strip()\n\ndef mint():\n    return int(minp())\n\ndef mints():\n    return map(int, minp().split())\n\ndef solve():\n    n = mint()\n    dp = [1] * (n + 1)\n    dp1 = [1] * (n + 1)\n    MOD = 998244353\n    for i in range(1, n + 1):\n        dp[i] = dp1[i - 1]\n        dp1[i] = (dp[i] + (dp1[i - 2] if i - 2 >= 0 else 0)) % MOD\n    print(dp[n] * pow(2, (MOD - 2) * n, MOD) % MOD)\nsolve()", "import math\nimport sys\nm = 998244353\ninput = sys.stdin.readline\nfibo = [1, 1]\nfor i in range(200002):\n    fibo.append(fibo[-1] + fibo[-2])\n    fibo[-1] %= m\nn = int(input())\ndeno = 1 << n\ninv = pow(deno, m - 2, m)\nans = fibo[n - 1] * inv % m\nprint(ans)", "n = int(input(''))\nmod = 998244353\ndp = [1, 1]\nfor i in range(2, n):\n    dp.append((dp[-1] + dp[-2]) % mod)\nprint(pow(pow(2, n, mod), mod - 2, mod) * dp[n - 1] % mod)", "import math\nt = 1\nl = [1, 1]\nfor i in range(2, 200001):\n    l.append((l[i - 1] + l[i - 2]) % 998244353)\nwhile t:\n    t -= 1\n    n = int(input())\n    x = l[n - 1]\n    y = pow(2, n)\n    print(x * pow(y, 998244351, 998244353) % 998244353)", "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nsys.setrecursionlimit(99999)\nmod = 998244353\nn = int(input())\n(a, b) = (0, 1)\nfor i in range(2, n + 1):\n    (a, b) = (b, (a + b) % mod)\nprint(b * pow(2, n * (mod - 2), mod) % mod)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nb = 1\ng = [0] * (n + 1)\ng[1] = 1\nfor j in range(2, n + 1):\n    g[j] = (g[j - 1] + g[j - 2]) % 998244353\nc = 0\nk = g[n]\nwhile k % 2 == 0:\n    c = c + 1\n    k = k // 2\nfor j in range(n - c):\n    b = b * 2 % 998244353\nprint(k * modInverse(b, 998244353) % 998244353)", "mod = 998244353\n\ndef modInverse(a, m):\n    g = gcd(a, m)\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nn = int(input())\nl = []\nl.append(0)\nl.append(1)\ni = 2\nwhile i <= n:\n    l.append((l[i - 1] + l[i - 2]) % mod)\n    i += 1\ny = modInverse(pow(2, n), mod)\nprint(l[n] * y % mod)", "n = int(input())\nfib = [0, 1, 1]\ntotal = [1, 2, 4]\nMOD = 998244353\nfor i in range(3, n + 1):\n    fib.append((fib[i - 1] + fib[i - 2]) % MOD)\n    total.append(total[i - 1] * 2 % MOD)\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nprint(fib[n] * modInverse(total[n], MOD) % MOD)", "def modinv(a, m):\n    b = m\n    u = 1\n    v = 0\n    while b:\n        t = a // b\n        a -= t * b\n        (a, b) = (b, a)\n        u -= t * v\n        (u, v) = (v, u)\n    u %= m\n    return u\nn = int(input())\nMOD = 998244353\ndpsum = [0] * (n + 1)\ndp = 1\nfor i in range(n):\n    dpsum[i + 1] = (dp + dpsum[i]) % MOD\n    dp = dpsum[i] % MOD\nans = dpsum[n]\ndiv = modinv(2, MOD)\nfor _ in range(n):\n    ans *= div\n    ans %= MOD\nprint(ans)", "import sys\nfrom functools import lru_cache, cmp_to_key\nfrom heapq import merge, heapify, heappop, heappush\nfrom collections import defaultdict as dd, deque, Counter as C\nfrom itertools import combinations as comb, permutations as perm\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nfrom time import perf_counter\nfrom fractions import Fraction\nimport copy\nimport time\nstarttime = time.time()\nmod = int(pow(10, 9) + 7)\nmod2 = 998244353\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef out(*var, end='\\n'):\n    sys.stdout.write(' '.join(map(str, var)) + end)\n\ndef L():\n    return list(sp())\n\ndef sl():\n    return list(ssp())\n\ndef sp():\n    return map(int, data().split())\n\ndef ssp():\n    return map(str, data().split())\n\ndef l1d(n, val=0):\n    return [val for i in range(n)]\n\ndef l2d(n, m, val=0):\n    return [l1d(n, val) for j in range(m)]\ntry:\n    sys.stdin = open('input.txt', 'r')\nexcept:\n    pass\nn = L()[0]\nF = [0, 1]\nwhile len(F) != n + 1:\n    F.append((F[-1] + F[-2]) % mod2)\ndeno = pow(2, n, mod2)\ndeno = pow(deno, mod2 - 2, mod2)\nprint(F[-1] * deno % mod2)\nendtime = time.time()", "n = int(input())\nm = 998244353\nd = [1] * (n + 1)\ne = [1] * 2\nc = 0\nfor i in range(2, n + 1):\n    d[i] = d[i - 1]\n    if i > 2:\n        d[i] = (d[i] + e[(i + 1) % 2] - d[i - 1]) % m\n    e[i % 2] = (e[i % 2] + d[i]) % m\nx = d[-1]\ny = pow(2, n, m)\nprint(x * pow(y, m - 2, m) % m)", "def gcd_extended(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (gcd, x1, y1) = gcd_extended(b % a, a)\n    x = y1 - b // a * x1\n    y = x1\n    return (gcd, x, y)\n\ndef power(a, n, p):\n    if n == 0:\n        return 1\n    x = power(a, n // 2, p)\n    x = x * x % p\n    if n % 2 == 1:\n        x = x * a % p\n    return x % p\np = 998244353\nn = int(input())\nrev_2 = gcd_extended(2, p)[1] % p\na = [1, rev_2]\nc = [1, rev_2]\npowers = [1]\nrev_powers = [1]\nfor i in range(1, 2 * 10 ** 5 + 1):\n    powers.append(powers[-1] * 2 % p)\n    rev_powers.append(rev_powers[-1] * rev_2 % p)\nfor k in range(2, n + 1):\n    l = 1\n    s = 0\n    maxp = k if k % 2 == 1 else k - 1\n    if k < 3:\n        while l <= k:\n            s += a[k - l] * powers[maxp - l] % p\n            l += 2\n        c.append(int(s * rev_2 ** (k - 1)) % p)\n    else:\n        c.append(int((c[k - 2] * rev_2 * rev_2 + c[k - 1] * rev_2) % p))\nprint(c[n])", "lim = 2 * 10 ** 5 + 10\nmod = 998244353\nf = [1] * lim\nfor i in range(2, lim):\n    f[i] = i * f[i - 1] % mod\n\ndef C(n, r):\n    num = f[n]\n    den = f[n - r] * f[r] % mod\n    ans = num * pow(den, mod - 2, mod)\n    return ans\n\ndef solve(n):\n    (N, R) = (n // 2, 1)\n    if n % 2:\n        R -= 1\n    ans = 0\n    while N >= R:\n        ans += C(N, R)\n        ans %= mod\n        N += 1\n        R += 2\n    ans = ans * pow(2, n * (mod - 2) % (mod - 1), mod) % mod\n    return ans\nn = int(input())\nprint(solve(n))", "mod = 998244353\nlim = 2 * 10 ** 5 + 10\nf = [1] * lim\nfor i in range(2, lim):\n    f[i] = i * f[i - 1] % mod\n\ndef c(n, r):\n    num = f[n]\n    den = f[n - r] * f[r] % mod\n    ans = num * pow(den, mod - 2, mod) % mod\n    return ans\n\ndef solve(n):\n    (N, R) = (0, 0)\n    ans = 0\n    if n % 2:\n        N = (n - 1) // 2\n        R = 0\n    else:\n        N = n // 2\n        R = 1\n    while N >= R:\n        ans += c(N, R)\n        N += 1\n        R += 2\n        ans %= mod\n    ans = ans * pow(2, N * (mod - 2) % (mod - 1), mod) % mod\n    return ans\nn = int(input())\nans = solve(n)\nprint(ans)"]