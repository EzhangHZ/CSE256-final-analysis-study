["from sys import stdin\n\nclass Problem:\n\n    def __init__(self, n, a, b, da, db, e):\n        self.n = n\n        self.a = a - 1\n        self.b = b - 1\n        self.da = da\n        self.db = db\n        self.g = [[] for i in range(n)]\n        for (u, v) in e:\n            self.g[u - 1].append(v - 1)\n            self.g[v - 1].append(u - 1)\n\n    def dfs(self, v, dist=0):\n        self.d[v] = dist\n        for u in self.g[v]:\n            if self.d[u] == None:\n                self.dfs(u, dist + 1)\n\n    def solve(self):\n        if self.da * 2 >= self.db:\n            return 'Alice'\n        self.d = [None for i in range(self.n)]\n        self.dfs(self.a)\n        if self.d[self.b] <= self.da:\n            return 'Alice'\n        f = self.d.index(max(self.d))\n        self.d = [None for i in range(self.n)]\n        self.dfs(f)\n        d = max(self.d)\n        if self.da * 2 >= d:\n            return 'Alice'\n        return 'Bob'\n\ndef test_cases():\n    cases = int(stdin.readline())\n    for case in range(cases):\n        (n, a, b, da, db) = list(map(int, stdin.readline().split()))\n        e = [list(map(int, stdin.readline().split())) for i in range(n - 1)]\n        yield Problem(n, a, b, da, db, e)\nfor test in test_cases():\n    ans = test.solve()\n    print(ans)", "from collections import deque\nfrom sys import stdin\n\ndef input():\n    return stdin.readline().strip()\nt = int(input())\nfor case in range(t):\n    (n, a, b, da, db) = map(int, input().split())\n    graph = dict()\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    if db <= 2 * da:\n        print('Alice')\n        continue\n    dist = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(a)\n    visited[a] = True\n    while q:\n        curr = q.popleft()\n        for neighbor in graph[curr]:\n            if visited[neighbor] == False:\n                visited[neighbor] = True\n                q.append(neighbor)\n                dist[neighbor] = dist[curr] + 1\n    if dist[b] <= da:\n        print('Alice')\n        continue\n    maxDist = 0\n    nodeMax = -1\n    for i in range(1, n + 1):\n        if dist[i] > maxDist:\n            maxDist = dist[i]\n            nodeMax = i\n    q = deque()\n    dist = [0] * (n + 1)\n    q.append(nodeMax)\n    visited = [False] * (n + 1)\n    visited[nodeMax] = True\n    while q:\n        curr = q.popleft()\n        for neighbor in graph[curr]:\n            if visited[neighbor] == False:\n                visited[neighbor] = True\n                q.append(neighbor)\n                dist[neighbor] = dist[curr] + 1\n    if max(dist) <= 2 * da:\n        print('Alice')\n        continue\n    print('Bob')", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, a, b, da, db) = map(int, input().split())\n    a -= 1\n    b -= 1\n    adj = [[] for i in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    if db <= 2 * da:\n        print('Alice')\n    else:\n        works = True\n        dist = [-1] * n\n        q = deque()\n        q.append(a)\n        dist[a] = 0\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if dist[u] == -1:\n                    dist[u] = dist[v] + 1\n                    q.append(u)\n        if dist[b] <= da:\n            works = False\n        last = v\n        dist = [-1] * n\n        q = deque()\n        q.append(last)\n        dist[last] = 0\n        while q:\n            v = q.popleft()\n            for u in adj[v]:\n                if dist[u] == -1:\n                    dist[u] = dist[v] + 1\n                    q.append(u)\n        lorg = max(dist)\n        if lorg >= 2 * da + 1 and works:\n            print('Bob')\n        else:\n            print('Alice')", "from heapq import heappush, heappop\nfrom collections import defaultdict, Counter, deque\nimport threading\nimport sys\nimport bisect\ninput = sys.stdin.readline\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    for _ in range(ri()):\n        (n, a, b, da, db) = rl()\n        g = defaultdict(list)\n        for e in range(n - 1):\n            (u, v) = rl()\n            g[u].append(v)\n            g[v].append(u)\n        dis = [0] * (n + 1)\n        dia = [0]\n        dis[a] = 0\n\n        def dfs(cn, p):\n            mx = 0\n            for nn in g[cn]:\n                if nn != p:\n                    dis[nn] = dis[cn] + 1\n                    cur = 1 + dfs(nn, cn)\n                    dia[0] = max(dia[0], cur + mx)\n                    mx = max(mx, cur)\n            return mx\n        dfs(a, -1)\n        if dis[b] <= da:\n            pos = 1\n        elif 2 * da >= dia[0]:\n            pos = 1\n        elif db > 2 * da:\n            pos = 0\n        elif db <= 2 * da:\n            pos = 1\n        print(['Bob', 'Alice'][pos])\n    pass\nthreading.Thread(target=main).start()", "from collections import deque\nt = int(input())\nfor case in range(t):\n    (n, a, b, da, db) = map(int, input().split())\n    graph = dict()\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    if db <= 2 * da:\n        print('Alice')\n        continue\n    dist = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(a)\n    visited[a] = True\n    while q:\n        curr = q.popleft()\n        for neighbor in graph[curr]:\n            if visited[neighbor] == False:\n                visited[neighbor] = True\n                q.append(neighbor)\n                dist[neighbor] = dist[curr] + 1\n    if dist[b] <= da:\n        print('Alice')\n        continue\n    maxDist = 0\n    nodeMax = -1\n    for i in range(1, n + 1):\n        if dist[i] > maxDist:\n            maxDist = dist[i]\n            nodeMax = i\n    q = deque()\n    dist = [0] * (n + 1)\n    q.append(nodeMax)\n    visited = [False] * (n + 1)\n    visited[nodeMax] = True\n    while q:\n        curr = q.popleft()\n        for neighbor in graph[curr]:\n            if visited[neighbor] == False:\n                visited[neighbor] = True\n                q.append(neighbor)\n                dist[neighbor] = dist[curr] + 1\n    if max(dist) <= 2 * da:\n        print('Alice')\n        continue\n    print('Bob')", "import sys\nfrom collections import deque\n\ndef dist(G, n, s):\n    D = [None] * n\n    Q = deque()\n    Q.append(s)\n    D[s] = 0\n    while Q:\n        f = Q.popleft()\n        for t in G[f]:\n            if D[t] is None:\n                D[t] = D[f] + 1\n                Q.append(t)\n    return D\n\ndef main():\n    for ti in range(int(input())):\n        (n, a, b, da, db) = map(int, input().split())\n        a -= 1\n        b -= 1\n        G = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = map(int, input().split())\n            G[u - 1].append(v - 1)\n            G[v - 1].append(u - 1)\n        Da = dist(G, n, a)\n        me = max(enumerate(Da), key=lambda x: x[1])[0]\n        print('Alice') if Da[b] <= da or db <= 2 * da or max(dist(G, n, me)) <= 2 * da else print('Bob')\nmain()", "import sys\nfrom collections import deque\n\ndef dist(G, n, s):\n    D = [None] * n\n    Q = deque()\n    Q.append(s)\n    D[s] = 0\n    while Q:\n        f = Q.popleft()\n        for t in G[f]:\n            if D[t] is None:\n                D[t] = D[f] + 1\n                Q.append(t)\n    return D\n\ndef main():\n    for ti in range(int(input())):\n        (n, a, b, da, db) = map(int, input().split())\n        a -= 1\n        b -= 1\n        G = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = map(int, input().split())\n            G[u - 1].append(v - 1)\n            G[v - 1].append(u - 1)\n        Da = dist(G, n, a)\n        me = max(enumerate(Da), key=lambda x: x[1])[0]\n        print('Alice') if Da[b] <= da or db <= 2 * da or max(dist(G, n, me)) <= 2 * da else print('Bob')\nmain()", "def dfs(x, p):\n    l = 0\n    for i in graph[x]:\n        if i != p:\n            depth[i] = depth[x] + 1\n            cur = 1 + dfs(i, x)\n            diam[0] = max(diam[0], cur + l)\n            l = max(l, cur)\n    return l\nfor _ in range(int(input())):\n    (n, a, b, da, db) = [int(i) for i in input().split()]\n    global graph\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (uu, vv) = [int(i) - 1 for i in input().split()]\n        graph[uu].append(vv)\n        graph[vv].append(uu)\n    depth = [0] * n\n    global diam\n    diam = [0]\n    temp = dfs(a - 1, -1)\n    if 2 * da >= min(diam[0], db) or depth[b - 1] <= da:\n        print('Alice')\n    else:\n        print('Bob')", "import sys\nsys.setrecursionlimit(10 ** 6 + 5)\nfrom collections import defaultdict as dft, deque\nmxn = 10 ** 9\n\ndef mp():\n    return map(int, input().split())\n\ndef solve():\n\n    def diss(u, v):\n        if u == v:\n            return 0\n        vis[u] = 1\n        m = mxn\n        for lnk in dct[u]:\n            if vis[lnk]:\n                continue\n            m = min(m, diss(lnk, v))\n        return m + 1\n\n    def dist(n, s):\n        D = [-1] * (n + 5)\n        Q = deque()\n        Q.append(s)\n        D[s] = 0\n        while Q:\n            f = Q.popleft()\n            for t in dct[f]:\n                if D[t] == -1:\n                    D[t] = D[f] + 1\n                    Q.append(t)\n        return D\n    (n, a, b, da, db) = map(int, input().split())\n    dct = dft(list)\n    for i in range(n - 1):\n        (u, v) = mp()\n        dct[u].append(v)\n        dct[v].append(u)\n    vis = [0] * (n + 5)\n    d = diss(a, b)\n    if d <= da:\n        return True\n    Da = dist(n, a)\n    me = max(enumerate(Da), key=lambda x: x[1])[0]\n    if max(dist(n, me)) <= 2 * da:\n        return True\n    if db <= 2 * da:\n        return True\n    return False\nfor _ in range(int(input())):\n    if solve():\n        print('Alice')\n    else:\n        print('Bob')", "import sys\nfrom collections import deque\n\ndef dist(G, n, s):\n    D = [None] * n\n    Q = deque()\n    Q.append(s)\n    D[s] = 0\n    while Q:\n        f = Q.popleft()\n        for t in G[f]:\n            if D[t] is None:\n                D[t] = D[f] + 1\n                Q.append(t)\n    return D\nfor ti in range(int(input())):\n    (n, a, b, da, db) = map(int, input().split())\n    a -= 1\n    b -= 1\n    G = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    Da = dist(G, n, a)\n    me = max(enumerate(Da), key=lambda x: x[1])[0]\n    print('Alice') if Da[b] <= da or db <= 2 * da or max(dist(G, n, me)) <= 2 * da else print('Bob')", "from collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [defaultdict() for _ in range(vertices)]\n        self.V = vertices\n\n    def add_edge(self, u, v, w=1):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def dfs(self, u, dist, d=0):\n        dist[u] = d\n        for v in self.graph[u]:\n            if dist[v] == None:\n                self.dfs(v, dist, d + 1)\nfor _ in range(int(input())):\n    (n, a, b, da, db) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g = Graph(n)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g.add_edge(u - 1, v - 1)\n    dist = [None] * n\n    g.dfs(a, dist)\n    if dist[b] <= da:\n        print('Alice')\n    else:\n        f = dist.index(max(dist))\n        dist_n = [None] * n\n        g.dfs(f, dist_n)\n        dia = max(dist_n)\n        if 2 * da >= dia:\n            print('Alice')\n        elif db <= 2 * da:\n            print('Alice')\n        else:\n            print('Bob')", "def dfs(x, p):\n    l = 0\n    for i in graph[x]:\n        if i != p:\n            depth[i] = depth[x] + 1\n            cur = 1 + dfs(i, x)\n            diam[0] = max(diam[0], cur + l)\n            l = max(l, cur)\n    return l\nfor _ in range(int(input())):\n    (n, a, b, da, db) = [int(i) for i in input().split()]\n    graph = [[] for i in range(n)]\n    for i in range(n - 1):\n        (uu, vv) = [int(i) - 1 for i in input().split()]\n        graph[uu].append(vv)\n        graph[vv].append(uu)\n    depth = [0] * n\n    diam = [0]\n    temp = dfs(a - 1, -1)\n    if 2 * da >= min(diam[0], db) or depth[b - 1] <= da:\n        print('Alice')\n    else:\n        print('Bob')", "import sys\nfrom collections import deque\n\ndef dist(G, n, s):\n    D = [None] * n\n    Q = deque()\n    Q.append(s)\n    D[s] = 0\n    while Q:\n        f = Q.popleft()\n        for t in G[f]:\n            if D[t] is None:\n                D[t] = D[f] + 1\n                Q.append(t)\n    return D\n\ndef main():\n    tn = int(input())\n    for ti in range(tn):\n        (n, a, b, da, db) = map(int, input().split())\n        a -= 1\n        b -= 1\n        G = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            (u, v) = map(int, input().split())\n            G[u - 1].append(v - 1)\n            G[v - 1].append(u - 1)\n        Da = dist(G, n, a)\n        me = max(enumerate(Da), key=lambda x: x[1])[0]\n        Dm = dist(G, n, me)\n        if Da[b] <= da or db <= 2 * da or max(Dm) <= 2 * da:\n            print('Alice')\n        else:\n            print('Bob')\nmain()", "from collections import deque\n\ndef dist(G, n, s):\n    D = [None] * n\n    Q = deque()\n    Q.append(s)\n    D[s] = 0\n    while Q:\n        f = Q.popleft()\n        for t in G[f]:\n            if D[t] is None:\n                D[t] = D[f] + 1\n                Q.append(t)\n    return D\nfor ti in range(int(input())):\n    (n, a, b, da, db) = map(int, input().split())\n    a -= 1\n    b -= 1\n    G = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    Da = dist(G, n, a)\n    me = max(enumerate(Da), key=lambda x: x[1])[0]\n    print('Alice') if Da[b] <= da or db <= 2 * da or max(dist(G, n, me)) <= 2 * da else print('Bob')", "from collections import defaultdict\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [defaultdict() for _ in range(vertices)]\n        self.V = vertices\n\n    def add_edge(self, u, v, w=1):\n        self.graph[u][v] = w\n        self.graph[v][u] = w\n\n    def dfs(self, u, dist, d=0):\n        dist[u] = d\n        for v in self.graph[u]:\n            if dist[v] == None:\n                self.dfs(v, dist, d + 1)\nfor _ in range(int(input())):\n    (n, a, b, da, db) = map(int, input().split())\n    a -= 1\n    b -= 1\n    g = Graph(n)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g.add_edge(u - 1, v - 1)\n    dist = [None] * n\n    g.dfs(a, dist)\n    if dist[b] <= da:\n        print('Alice')\n    else:\n        f = dist.index(max(dist))\n        dist_n = [None] * n\n        g.dfs(f, dist_n)\n        dia = max(dist_n)\n        if 2 * da >= dia:\n            print('Alice')\n        elif db <= 2 * da:\n            print('Alice')\n        else:\n            print('Bob')", "from collections import deque\n\ndef dfs(neighbours, x, n):\n    parents = [None for i in range(n)]\n    dq = deque()\n    dq.append(x)\n    parents[x] = 0\n    while len(dq) != 0:\n        ret = dq.popleft()\n        for i in neighbours[ret]:\n            if parents[i] == None:\n                parents[i] = parents[ret] + 1\n                dq.append(i)\n    return parents\nans = []\ntest_cases = int(input())\nfor i in range(test_cases):\n    (n, a, b, da, db) = [int(j) for j in input().split()]\n    a = a - 1\n    b = b - 1\n    neighbours = [[] for j in range(n)]\n    for i in range(n - 1):\n        (x, y) = [int(node) - 1 for node in input().split()]\n        neighbours[x].append(y)\n        neighbours[y].append(x)\n    distances = dfs(neighbours, a, n)\n    distw = max(distances)\n    w = distances.index(distw)\n    diam = max(dfs(neighbours, w, n))\n    if distances[b] <= da:\n        ans.append('Alice')\n    elif diam <= 2 * da:\n        ans.append('Alice')\n    elif db <= 2 * da:\n        ans.append('Alice')\n    else:\n        ans.append('Bob')\nfor i in range(test_cases):\n    print(ans[i])", "from collections import deque\n\ndef dfs(x):\n    length[x] = 0\n    queue = deque()\n    queue.append(x)\n    while queue:\n        y = queue.popleft()\n        for z in t[y]:\n            if length[z] is None:\n                length[z] = length[y] + 1\n                queue.append(z)\nfor _ in range(int(input())):\n    (n, a, b, da, db) = list(map(int, input().split()))\n    t = [[] for i in range(n)]\n    for x in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        t[u - 1].append(v - 1)\n        t[v - 1].append(u - 1)\n    length = [None] * n\n    dfs(a - 1)\n    lb = length[b - 1]\n    mx = max(length)\n    nex = length.index(mx)\n    length = [None] * n\n    dfs(nex)\n    if da >= lb or 2 * da >= db or 2 * da >= max(length):\n        print('Alice')\n    else:\n        print('Bob')", "from collections import deque\n\ndef get_(d, a):\n    l = [-1] * (n + 1)\n    q = deque()\n    q.append(a)\n    l[a] = 0\n    while q:\n        x = q.popleft()\n        for y in d[x]:\n            if l[y] == -1:\n                l[y] = l[x] + 1\n                flag = 1\n                q.append(y)\n    return l\nt = int(input())\nfor _ in range(t):\n    (n, a, b, da, db) = list(map(int, input().split()))\n    d = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = list(map(int, input().split()))\n        d[x].append(y)\n        d[y].append(x)\n    l = get_(d, a)\n    index = max(enumerate(l), key=lambda x: x[1])[0]\n    l_ = get_(d, index)\n    if max(l_) <= 2 * da or db <= 2 * da or l[b] <= da:\n        print('Alice')\n    else:\n        print('Bob')", "def melysegi(x):\n    latatlan.remove(int(x))\n    for i in ellista[x]:\n        if i in latatlan:\n            melyseg[i] = melyseg[x] + 1\n            melysegi(i)\n\ndef melysegi2(x):\n    latatlan2.remove(int(x))\n    for i in ellista[x]:\n        if i in latatlan2:\n            melyseg2[i] = melyseg2[x] + 1\n            melysegi2(i)\n\ndef fa_atmero():\n    vegpont = melyseg.index(max(melyseg))\n    melysegi2(vegpont)\n    atmero = max(melyseg2)\n    return atmero\nfor _ in range(int(input())):\n    (n, a, b, da, db) = list(map(int, input().split(' ')))\n    ellista = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(i) - 1 for i in input().split()]\n        ellista[u].append(v)\n        ellista[v].append(u)\n    ellista = tuple(ellista)\n    latatlan = set([i for i in range(0, n)])\n    latatlan2 = set([i for i in range(0, n)])\n    melyseg = [0] * n\n    melyseg2 = [0] * n\n    melysegi(a - 1)\n    atmero = fa_atmero()\n    if 2 * da < atmero and 2 * da < db and (melyseg[b - 1] > da):\n        print('Bob')\n    else:\n        print('Alice')", "from collections import deque\ntests = int(input())\nfor testnum in range(tests):\n    [n, a, b, da, db] = list(map(int, input().split()))\n    edges = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        [u, v] = list(map(int, input().split()))\n        edges[u].append(v)\n        edges[v].append(u)\n\n    def shortestpath_bf(start, end):\n        q = deque()\n        indicators = [None for _ in range(n + 1)]\n        q.append(start)\n        indicators[start] = 0\n        maxnode = None\n        maxdist = -1\n        while len(q) > 0:\n            node = q.pop()\n            for nebors in edges[node]:\n                if indicators[nebors] is None:\n                    indicators[nebors] = indicators[node] + 1\n                    q.append(nebors)\n                    if indicators[nebors] > maxdist:\n                        maxdist = indicators[nebors]\n                        maxnode = nebors\n        return (maxnode, maxdist, indicators[end])\n    temp = shortestpath_bf(a, b)\n    separation = temp[2]\n    temp = shortestpath_bf(temp[0], 0)\n    diameter = temp[1]\n    if db <= 2 * da:\n        print('Alice')\n    elif separation <= da:\n        print('Alice')\n    elif diameter <= 2 * da:\n        print('Alice')\n    else:\n        print('Bob')", "def melysegi(x):\n    latatlan.remove(int(x))\n    for i in ellista[x]:\n        if i in latatlan:\n            melyseg[i] = melyseg[x] + 1\n            melysegi(i)\n\ndef melysegi2(x):\n    latatlan2.remove(int(x))\n    for i in ellista[x]:\n        if i in latatlan2:\n            melyseg2[i] = melyseg2[x] + 1\n            melysegi2(i)\n\ndef fa_atmero():\n    vegpont = melyseg.index(max(melyseg))\n    melysegi2(vegpont)\n    atmero = max(melyseg2)\n    return atmero\nfor _ in range(int(input())):\n    (n, a, b, da, db) = list(map(int, input().split(' ')))\n    ellista = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(i) - 1 for i in input().split()]\n        ellista[u].append(v)\n        ellista[v].append(u)\n    ellista = tuple(ellista)\n    latatlan = set([i for i in range(0, n)])\n    latatlan2 = set([i for i in range(0, n)])\n    melyseg = [0] * n\n    melyseg2 = [0] * n\n    melysegi(a - 1)\n    atmero = fa_atmero()\n    if 2 * da < atmero and 2 * da < db and (melyseg[b - 1] > da):\n        print('Bob')\n    else:\n        print('Alice')", "import sys\nsys.setrecursionlimit(10 ** 5)\n\ndef search(tree, cur, find, was):\n    was.add(cur)\n    for i in tree[cur]:\n        if i == find:\n            return (1, True)\n        elif not i in was:\n            a = search(tree, i, find, was)\n            if a[1]:\n                return (a[0] + 1, a[1])\n    return (-1, False)\n\ndef max_depth(tree, cur, was_2):\n    was_2.add(cur)\n    dist = 0\n    dot = cur\n    for i in tree[cur]:\n        if not i in was_2:\n            (new_dist, new_dot) = max_depth(tree, i, was_2)\n            if max(new_dist, dist) == new_dist:\n                dist = max(new_dist, dist)\n                dot = new_dot\n    return (dist + 1, dot)\n\ndef main():\n    was = set()\n    was_2 = set()\n    (n, a, b, da, db) = map(int, input().split())\n    tree = dict()\n    for i in range(1, n):\n        (u, v) = map(int, input().split())\n        if not u in tree:\n            tree[u] = set()\n        if not v in tree:\n            tree[v] = set()\n        tree[u].add(v)\n        tree[v].add(u)\n    dist = search(tree, a, b, was)\n    (far, dot) = max_depth(tree, a, was_2)\n    was_2 = set()\n    ln = max_depth(tree, dot, was_2)\n    if dist[0] <= da or db <= 2 * da or ln[0] - 1 <= 2 * da:\n        print('Alice')\n        return\n    else:\n        print('Bob')\n        return\nt = int(input())\nfor i in range(t):\n    main()", "from collections import deque\n\ndef dfs(neighbours, x, n):\n    parents = [None for i in range(n)]\n    dq = deque()\n    dq.append(x)\n    parents[x] = 0\n    while len(dq) != 0:\n        ret = dq.popleft()\n        for i in neighbours[ret]:\n            if parents[i] == None:\n                parents[i] = parents[ret] + 1\n                dq.append(i)\n    return parents\nans = []\ntest_cases = int(input())\nfor i in range(test_cases):\n    (n, a, b, da, db) = [int(j) for j in input().split()]\n    a = a - 1\n    b = b - 1\n    neighbours = [[] for j in range(n)]\n    for i in range(n - 1):\n        (x, y) = [int(node) - 1 for node in input().split()]\n        neighbours[x].append(y)\n        neighbours[y].append(x)\n    distances = dfs(neighbours, a, n)\n    distw = max(distances)\n    w = distances.index(distw)\n    diam = max(dfs(neighbours, w, n))\n    if distances[b] <= da:\n        ans.append('Alice')\n    elif diam <= 2 * da:\n        ans.append('Alice')\n    elif db <= 2 * da:\n        ans.append('Alice')\n    else:\n        ans.append('Bob')\nfor i in range(test_cases):\n    print(ans[i])", "def Diameter(x):\n    v[x] = True\n    stack = [x]\n    while stack:\n        a = stack.pop()\n        for i in d[a]:\n            if not v[i]:\n                v[i] = True\n                stack.append(i)\n                dis[i] = dis[a] + 1\n\ndef BFS(a):\n    v[a] = True\n    q = [a]\n    while q:\n        p = q.pop(0)\n        for i in d[p]:\n            if not v[i]:\n                q.append(i)\n                v[i] = True\n                distance[i] = distance[p] + 1\nfor _ in range(int(input())):\n    (n, a, b, da, db) = map(int, input().split())\n    d = {i: [] for i in range(1, n + 1)}\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        d[x].append(y)\n        d[y].append(x)\n    dis = [0 for i in range(n + 1)]\n    v = [False for i in range(n + 1)]\n    Diameter(1)\n    ans = float('-inf')\n    for i in range(len(dis)):\n        if dis[i] > ans:\n            ans = dis[i]\n            node = i\n    dis = [0 for i in range(n + 1)]\n    v = [False for i in range(n + 1)]\n    Diameter(node)\n    dia = float('-inf')\n    for i in range(len(dis)):\n        if dis[i] > dia:\n            dia = dis[i]\n    distance = [0 for i in range(n + 1)]\n    v = [False for i in range(n + 1)]\n    BFS(a)\n    if distance[b] > da and 2 * da < dia and (db > 2 * da):\n        print('Bob')\n    else:\n        print('Alice')"]