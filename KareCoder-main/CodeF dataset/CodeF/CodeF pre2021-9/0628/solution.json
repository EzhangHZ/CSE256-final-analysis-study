["from math import gcd, factorial\nfrom collections import defaultdict as dd\nMOD = 10 ** 9 + 7\n\ndef R(type=int):\n    line = input().rstrip()\n    try:\n        return type(line)\n    except:\n        pass\n    return line\nRL = lambda type=int: list(map(type, input().rstrip().split()))\nRLL = lambda N, type=int: [RL(type) for _ in range(N)]\nRLS = lambda N, type=int: [R(type) for _ in range(N)]\n\ndef solve():\n    (N, K) = RL()\n    if N < 62 and K > 2 ** (N - 1):\n        print(-1)\n        return\n    K -= 1\n    r = []\n    perm = []\n    for i in range(N, 0, -1):\n        if K % 2 == 1:\n            perm += [i]\n        elif perm:\n            perm += [i]\n            r += perm[::-1]\n            perm = []\n        else:\n            r += [i]\n        K //= 2\n    print(' '.join(map(str, r[::-1])))\nT = R()\nfor t in range(T):\n    solve()", "def dfs(l, r, k, dir):\n    if l == r:\n        dir.append(1)\n        return\n    mid = l + r >> 1\n    if k > mid:\n        dir.append(-1)\n        dfs(mid + 1, r, k, dir)\n    else:\n        dir.append(1)\n        dfs(l, mid, k, dir)\n\ndef test():\n    (n, k) = [int(i) for i in input().split()]\n    if 2 ** (n - 1) < k:\n        return -1\n    dir = [0]\n    x = n\n    while x > 64:\n        x -= 1\n        dir.append(1)\n    dfs(1, 2 ** (x - 1), k, dir)\n    result = []\n    buf = []\n    i = 1\n    while i <= n:\n        if dir[i] == 1:\n            result.append(i)\n            i += 1\n        else:\n            j = i\n            while j <= n and dir[j] == -1:\n                j += 1\n            result += list(range(j, i - 1, -1))\n            i = j + 1\n    return ' '.join([str(i) for i in result])\nt = int(input())\nwhile t > 0:\n    t -= 1\n    print(test())", "def dfs(x, n, k):\n    if x > n:\n        return []\n    if k == 0:\n        return [i for i in range(x, n + 1)]\n    if n - x > 64:\n        buf = []\n        while n - x > 64:\n            buf += [x]\n            x += 1\n        return buf + dfs(x, n, k)\n    if 2 ** (n - x) == k + 1:\n        return [i for i in range(n, x - 1, -1)]\n    buf = [x]\n    x += 1\n    cnt = 2 ** (n - x)\n    while k >= cnt:\n        buf += [x]\n        x += 1\n        k -= cnt\n        cnt //= 2\n    return buf[::-1] + dfs(x, n, k)\n\ndef test():\n    (n, k) = [int(i) for i in input().split()]\n    if 2 ** (n - 1) < k:\n        return -1\n    return ' '.join([str(i) for i in dfs(1, n, k - 1)])\nt = int(input())\nwhile t > 0:\n    t -= 1\n    print(test())", "def solve(n, k):\n    Exp = n - 1\n    resp = ''\n    respAux = ''\n    expK = CalcularExponente(k)\n    restoK = k - 2 ** expK\n    if expK > Exp or (expK == Exp and restoK > 0):\n        return -1\n    for i in range(n):\n        Exp -= 1\n        respAux = ' ' + str(i + 1) + respAux\n        if expK > Exp or (expK == Exp and restoK > 0):\n            recalculoK = 2 ** expK - 2 ** Exp + restoK\n            expK = CalcularExponente(recalculoK)\n            restoK = recalculoK - 2 ** expK\n        else:\n            resp += respAux\n            respAux = ''\n    resp += respAux\n    return resp[1:]\n\ndef CalcularExponente(k):\n    kValue = k\n    expK = -1\n    while k > 0:\n        expK += 1\n        k = k // 2\n    return expK\n\ndef main():\n    t = int(input())\n    for i in range(int(t)):\n        (n, k) = input().split(' ')\n        print(solve(int(n), int(k)))\nmain()", "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    b = bin(k - 1)[2:]\n    if k - 1 > 0:\n        b = b + '0'\n    if len(b) > n:\n        print(-1)\n    else:\n        b = '0' * (n - len(b)) + b\n        p = []\n        temp = []\n        for i in range(n):\n            temp += [str(i + 1)]\n            if b[i] == '0':\n                p += temp[::-1]\n                temp = []\n        print(*p)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    val = bin(k - 1)[2:]\n    if k - 1:\n        val += '0'\n    if len(val) > n:\n        print(-1)\n    else:\n        val = '0' * (n - len(val)) + val\n        ans = []\n        t = []\n        for i in range(n):\n            t += [str(i + 1)]\n            if val[i] == '0':\n                ans += t[::-1]\n                t = []\n        print(*ans)", "for s in [*open(0)][1:]:\n    (n, k) = map(int, s.split())\n    v = bin(k - 1)[2:]\n    if k > 1:\n        v += '0'\n    if len(v) > n:\n        print(-1)\n        continue\n    v = v.rjust(n, '0')\n    a = []\n    t = []\n    for i in range(n):\n        t += (str(i + 1),)\n        if v[i] < '1':\n            a += t[::-1]\n            t = []\n    print(*a)", "for s in [*open(0)][1:]:\n    (n, k) = map(int, s.split())\n    v = bin(k - 1)[2:]\n    if k > 1:\n        v += '0'\n    if len(v) > n:\n        print(-1)\n        continue\n    v = v.rjust(n, '0')\n    a = []\n    t = []\n    for i in range(n):\n        t += (str(i + 1),)\n        if v[i] < '1':\n            a += t[::-1]\n            t = []\n    print(*a)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    val = bin(k - 1)[2:]\n    if k - 1:\n        val += '0'\n    if len(val) > n:\n        print(-1)\n    else:\n        val = '0' * (n - len(val)) + val\n        ans = []\n        t = []\n        for i in range(n):\n            t += [str(i + 1)]\n            if val[i] == '0':\n                ans += t[::-1]\n                t = []\n        print(*ans)", "for s in [*open(0)][1:]:\n    (n, k) = map(int, s.split())\n    v = bin(k - 1)[2:]\n    if k > 1:\n        v += '0'\n    if len(v) > n:\n        print(-1)\n        continue\n    v = v.rjust(n, '0')\n    a = []\n    t = []\n    for i in range(n):\n        t += (str(i + 1),)\n        if v[i] < '1':\n            a += t[::-1]\n            t = []\n    print(*a)", "for s in [*open(0)][1:]:\n    (n, k) = map(int, s.split())\n    v = bin(k - 1)[2:]\n    if k > 1:\n        v += '0'\n    if len(v) > n:\n        print(-1)\n        continue\n    v = v.rjust(n, '0')\n    a = []\n    t = []\n    for i in range(n):\n        t += (str(i + 1),)\n        if v[i] < '1':\n            a += t[::-1]\n            t = []\n    print(*a)", "for s in [*open(0)][1:]:\n    (n, k) = map(int, s.split())\n    v = bin(k - 1)[2:]\n    if k > 1:\n        v += '0'\n    if len(v) > n:\n        print(-1)\n        continue\n    v = v.rjust(n, '0')\n    a = []\n    t = []\n    for i in range(n):\n        t += (str(i + 1),)\n        if v[i] < '1':\n            a += t[::-1]\n            t = []\n    print(*a)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    cnt = 0\n    pow2 = 1\n    ans = []\n    fn = 1\n    ln = 1\n    while k > pow2:\n        pow2 *= 2\n        cnt += 1\n    if cnt > n - 1:\n        print(-1)\n    else:\n        k -= 1\n        filled = 0\n        while filled < n:\n            c = filled + 1\n            if n - c - 1 < 66:\n                while k >= pow(2, n - c - 1):\n                    fn += 1\n                    k -= pow(2, n - c - 1)\n                    c += 1\n                tmp = fn\n                while tmp >= ln:\n                    ans.append(tmp)\n                    filled += 1\n                    tmp -= 1\n                fn += 1\n                ln = fn\n            else:\n                ans.append(fn)\n                fn += 1\n                filled += 1\n                ln = fn\n        for i in ans:\n            print(i, end=' ')\n        print()", "def leftmost_off(num):\n    last_off = 0\n    i = 1\n    while num != 0:\n        if num & 1 == 0:\n            last_off = i\n        i += 1\n        num >>= 1\n    return last_off\n\ndef get_start(num, n):\n    power2 = int((1 << n - 1) // 2)\n    p2 = power2\n    i = 0\n    offset = 0\n    l = 0\n    if power2 == 0:\n        return (1, 0, 0)\n    while num > 0:\n        offset += l\n        l = power2\n        num -= power2\n        power2 >>= 1\n        i += 1\n        if power2 == 0:\n            power2 = 1\n    return (i, offset, p2)\n\ndef almost_sorted_lexi(n, pos):\n    b = 1\n    e = n\n    res = ''\n    tmp = 0\n    while b <= n:\n        (start, offset, power2) = get_start(pos, e - b + 1)\n        cnt = 0\n        while power2 > pos and b <= n:\n            res += str(b) + ' '\n            b += 1\n            cnt += 1\n            power2 >>= 1\n        if cnt != 0:\n            tmp += cnt\n            continue\n        tmp += start\n        start = tmp\n        while start >= b:\n            res += str(start) + ' '\n            start -= 1\n        b = tmp + 1\n        pos -= offset\n    print(res)\n\ndef main():\n    t = int(input(''))\n    for i in range(t):\n        (n, k) = tuple(map(int, input('').split(' ')))\n        if k > 1 << n - 1:\n            print('-1')\n        elif n == 1:\n            print('1')\n        else:\n            almost_sorted_lexi(n, k)\nmain()"]