["import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    a = []\n    b = []\n    for i in range(m):\n        (v1, v2) = map(int, input().split())\n        a.append(v1)\n        b.append((v2, v1))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c = 0\n    l = 0\n    summ = 0\n    act = 0\n    for i in range(m):\n        tot = n - l\n        while tot and c < m and (a[c] > b[i][0]):\n            tot -= 1\n            l += 1\n            summ += a[c]\n            c += 1\n        if tot:\n            act = max(act, summ + min(b[i]) + b[i][0] * (tot - 1))\n        else:\n            act = max(act, summ)\n    print(act)", "import sys\nfrom bisect import bisect\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef solve():\n    aa = []\n    for (a, b) in sorted(ab, reverse=True):\n        aa.append(a)\n    cs = [0]\n    for a in aa:\n        cs.append(cs[-1] + a)\n    aa.reverse()\n    cs.reverse()\n    ans = cs[m - n] if m - n >= 0 else 0\n    for (a, b) in ab:\n        i = bisect(aa, b)\n        if n - (m - i) - 1 < 0:\n            continue\n        if a > b:\n            cur = cs[i] + (n - (m - i)) * b\n        else:\n            cur = cs[i] + a + (n - (m - i) - 1) * b\n        ans = max(ans, cur)\n    print(ans)\ncase = II()\nfor q in range(case):\n    (n, m) = MI()\n    ab = LLI(m)\n    if q < case - 1:\n        SI()\n    solve()", "for _ in range(int(input())):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    fs = sorted((tuple(map(int, input().split())) for _ in range(m)), reverse=True)\n    fy = sorted(fs, key=lambda x: x[1], reverse=True)\n    fs.append((0, 0))\n    curx = 0\n    cursum = 0\n    ans = 0\n    for (x, y) in fy:\n        while curx < n - 1 and fs[curx][0] > y:\n            cursum += fs[curx][0]\n            curx += 1\n        if x > y and fs[curx][0] < x:\n            cans = cursum + (n - curx) * y\n        else:\n            cans = cursum + x + (n - curx - 1) * y\n        ans = max(ans, cans)\n    print(ans, flush=False)", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    a = []\n    b = []\n    for i in range(m):\n        (v1, v2) = map(int, input().split())\n        a.append(v1)\n        b.append((v2, v1))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c = 0\n    l = 0\n    summ = 0\n    act = 0\n    for i in range(m):\n        tot = n - l\n        while tot and c < m and (a[c] > b[i][0]):\n            tot -= 1\n            l += 1\n            summ += a[c]\n            c += 1\n        if tot:\n            act = max(act, summ + min(b[i]) + b[i][0] * (tot - 1))\n        else:\n            act = max(act, summ)\n    print(act)", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    a = []\n    b = []\n    for i in range(m):\n        (v1, v2) = map(int, input().split())\n        a.append(v1)\n        b.append((v2, v1))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c = 0\n    l = 0\n    summ = 0\n    act = 0\n    for i in range(m):\n        tot = n - l\n        while tot and c < m and (a[c] > b[i][0]):\n            tot -= 1\n            l += 1\n            summ += a[c]\n            c += 1\n        if tot:\n            act = max(act, summ + min(b[i]) + b[i][0] * (tot - 1))\n        else:\n            act = max(act, summ)\n    print(act)", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    a = []\n    b = []\n    for i in range(m):\n        (v1, v2) = map(int, input().split())\n        a.append(v1)\n        b.append((v2, v1))\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c = 0\n    l = 0\n    summ = 0\n    act = 0\n    for i in range(m):\n        tot = n - l\n        while tot and c < m and (a[c] > b[i][0]):\n            tot -= 1\n            l += 1\n            summ += a[c]\n            c += 1\n        if tot:\n            act = max(act, summ + min(b[i]) + b[i][0] * (tot - 1))\n        else:\n            act = max(act, summ)\n    print(act)", "from bisect import bisect_left\nfrom itertools import accumulate\n\ndef main():\n    (n, m) = map(int, input().split())\n    (a, b) = zip(*sorted((tuple((int(x) for x in input().split())) for _ in range(m))))\n    sums = list(reversed(list(accumulate(reversed(a)))))\n    sums.append(0)\n    ans = 0\n    for i in range(m):\n        pos = bisect_left(a, b[i])\n        if m - pos > n:\n            pos = m - n\n        if m - pos == n and pos > i:\n            pos += 1\n        suf = sums[pos]\n        cnt = m - pos\n        if pos > i:\n            suf += a[i]\n            cnt += 1\n        res = suf + (n - cnt) * b[i]\n        ans = max(ans, res)\n    print(ans)\ntests = int(input())\nfor t in range(tests):\n    if t > 0:\n        input()\n    main()", "for _ in range(int(input())):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    fs = sorted((tuple(map(int, input().split())) for _ in range(m)), reverse=True)\n    fy = sorted(fs, key=lambda x: x[1], reverse=True)\n    fs.append((0, 0))\n    curx = 0\n    cursum = 0\n    ans = 0\n    for (x, y) in fy:\n        while curx < n - 1 and fs[curx][0] > y:\n            cursum += fs[curx][0]\n            curx += 1\n        ans = max(ans, cursum + (n - curx) * y if x > y and fs[curx][0] < x else cursum + x + (n - curx - 1) * y)\n    print(ans, flush=False)", "for _ in range(int(input())):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    fs = sorted((tuple(map(int, input().split())) for _ in range(m)), reverse=True)\n    fy = sorted(fs, key=lambda x: x[1], reverse=True)\n    fs.append((0, 0))\n    curx = 0\n    cursum = 0\n    ans = 0\n    for (x, y) in fy:\n        while curx < n - 1 and fs[curx][0] > y:\n            cursum += fs[curx][0]\n            curx += 1\n        cans = cursum + (n - curx) * y if x > y and fs[curx][0] < x else cursum + x + (n - curx - 1) * y\n        ans = max(ans, cans)\n    print(ans, flush=False)", "from bisect import bisect_left\nfrom itertools import accumulate\n\ndef main():\n    (n, m) = map(int, input().split())\n    (a, b) = zip(*sorted((tuple((int(x) for x in input().split())) for _ in range(m))))\n    sums = list(reversed(list(accumulate(reversed(a)))))\n    sums.append(0)\n\n    def compute(i):\n        pos = bisect_left(a, b[i])\n        if m - pos > n:\n            pos = m - n\n        if m - pos == n and pos > i:\n            pos += 1\n        suf = sums[pos]\n        cnt = m - pos\n        if pos > i:\n            suf += a[i]\n            cnt += 1\n        res = suf + (n - cnt) * b[i]\n        return res\n    ans = max((compute(i) for i in range(m)))\n    print(ans)\ntests = int(input())\nfor t in range(tests):\n    if t > 0:\n        input()\n    main()", "for _ in range(int(input())):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    a1 = sorted((tuple(map(int, input().split())) for i in range(m)), reverse=True)\n    a2 = sorted(a1, key=lambda x: x[1], reverse=True)\n    a1.append((0, 0))\n    r = 0\n    s = 0\n    ans = 0\n    for (x, y) in a2:\n        while r < n - 1 and a1[r][0] > y:\n            s += a1[r][0]\n            r += 1\n        if x > y and a1[r][0] < x:\n            cs = s + (n - r) * y\n        else:\n            cs = s + x + (n - r - 1) * y\n        ans = max(cs, ans)\n    print(ans, flush=False)", "from bisect import bisect_left\nfrom itertools import accumulate\n\ndef main():\n    (n, m) = map(int, input().split())\n    (a, b) = zip(*sorted((tuple((int(x) for x in input().split())) for _ in range(m))))\n    sums = list(reversed(list(accumulate(reversed(a)))))\n    sums.append(0)\n\n    def compute(i):\n        pos = bisect_left(a, b[i])\n        if m - pos > n:\n            pos = m - n\n        if m - pos == n and pos > i:\n            pos += 1\n        suf = sums[pos]\n        cnt = m - pos\n        if pos > i:\n            suf += a[i]\n            cnt += 1\n        res = suf + max(0, n - cnt) * b[i]\n        return res\n    ans = max((compute(i) for i in range(m)))\n    print(ans)\ntests = int(input())\nfor t in range(tests):\n    if t > 0:\n        input()\n    main()", "from bisect import bisect_left\nt = int(input())\nfor case in range(t):\n    (n, m) = map(int, input().split())\n    ab = [list(map(int, input().split())) for _ in range(m)]\n    aa = [e for (e, _) in ab]\n    aa.sort()\n    acc = [0] * (m + 1)\n    for i in range(m, 0, -1):\n        acc[i - 1] = acc[i] + aa[i - 1]\n    if n > m:\n        ans = 0\n    else:\n        ans = sum(aa[-n:])\n    for (a, b) in ab:\n        i = bisect_left(aa, b)\n        cnt = min(m - i, n)\n        sm = acc[m - cnt]\n        sm += b * (n - cnt)\n        if a < b:\n            sm -= b\n            sm += a\n        ans = max(ans, sm)\n    print(ans)\n    if case != t - 1:\n        input()", "from bisect import bisect_left\nt = int(input())\nfor case in range(t):\n    (n, m) = map(int, input().split())\n    ab = [list(map(int, input().split())) for _ in range(m)]\n    aa = [e for (e, _) in ab]\n    aa.sort()\n    acc = [0] * (m + 1)\n    for i in range(m, 0, -1):\n        acc[i - 1] = acc[i] + aa[i - 1]\n    if n > m:\n        ans = 0\n    else:\n        ans = sum(aa[-n:])\n    for (a, b) in ab:\n        i = bisect_left(aa, b)\n        cnt = min(m - i, n)\n        sm = acc[m - cnt]\n        sm += b * (n - cnt)\n        if a < b:\n            sm -= b\n            sm += a\n        ans = max(ans, sm)\n    print(ans)\n    if case != t - 1:\n        input()", "import sys\ninput = sys.stdin.readline\nt = int(input())\nfor tc in range(t):\n    if tc:\n        input()\n    (n, m) = map(int, input().split())\n    a = [-1] * m\n    b = [-1] * m\n    for j in range(m):\n        (a[j], b[j]) = map(int, input().split())\n    l = [(a[i], 0, i) for i in range(m)] + [(b[i], 1, i) for i in range(m)]\n    l.sort(reverse=True)\n    used = [False] * m\n    count = 0\n    tot = 0\n    best = 0\n    for (good, typ, ind) in l:\n        if typ == 0:\n            count += 1\n            tot += good\n            used[ind] = True\n            if count == n:\n                best = max(best, tot)\n                break\n        else:\n            curr = tot\n            curr += good * (n - count)\n            if not used[ind]:\n                curr -= good\n                curr += a[ind]\n            best = max(curr, best)\n    print(best)", "import bisect as bi, sys\nimport math as mt\nimport collections as cc\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\nfor tc in range(int(input())):\n    if tc > 0:\n        input()\n    (n, m) = I()\n    a = [0] * m\n    b = [0] * m\n    sor = []\n    for i in range(m):\n        (a[i], b[i]) = I()\n        sor.append((a[i], 0, i))\n        sor.append((b[i], 1, i))\n    sor.sort(reverse=True)\n    ans = 0\n    cur = 0\n    cnt = 0\n    visi = [0] * m\n    for (x, ty, ind) in sor:\n        if ty == 0:\n            cur += x\n            cnt += 1\n            visi[ind] = 1\n            if cnt == n:\n                ans = max(ans, cur)\n                break\n        else:\n            temp = cur + x * (n - cnt)\n            if not visi[ind]:\n                temp -= x\n                temp += a[ind]\n            ans = max(ans, temp)\n    print(ans)", "t = int(input())\nfor test in range(t):\n    if test != 0:\n        s = input()\n    (n, m) = map(int, input().split())\n    (a, b) = ([0] * m, [0] * m)\n    sor = []\n    for i in range(m):\n        (a[i], b[i]) = map(int, input().split())\n        sor.append((a[i], 0, i))\n        sor.append((b[i], 1, i))\n    sor.sort(reverse=True)\n    (ans, cur, cnt) = (0, 0, 0)\n    vis = [0] * m\n    for (x, typ, i) in sor:\n        if typ == 0:\n            cur += x\n            cnt += 1\n            vis[i] = 1\n            if cnt == n:\n                ans = max(ans, cur)\n                break\n        else:\n            temp = cur + x * (n - cnt)\n            if not vis[i]:\n                temp -= x\n                temp += a[i]\n            ans = max(ans, temp)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    ls = []\n    lst = []\n    for __ in range(m):\n        (a, b) = map(int, input().split())\n        ls.append(a)\n        z = (b, a)\n        lst.append(z)\n    ls.sort(reverse=True)\n    lst.sort(reverse=True)\n    (mx, ll, ii, happy) = (0, 0, 0, 0)\n    for i in range(m):\n        j = n - ll\n        while ii < m and j and (ls[ii] > lst[i][0]):\n            mx += ls[ii]\n            ii += 1\n            ll += 1\n            j -= 1\n        if j:\n            happy = max(happy, mx + min(lst[i]) + (j - 1) * lst[i][0])\n        else:\n            happy = max(mx, happy)\n        if n == ll:\n            break\n    print(happy)\n    if _ != t - 1:\n        input()", "for _ in range(int(input())):\n    if _:\n        input()\n    (n, m) = map(int, input().split())\n    fs = sorted((tuple(map(int, input().split())) for _ in range(m)), reverse=True)\n    fy = sorted(fs, key=lambda x: x[1], reverse=True)\n    fs.append((0, 0))\n    curx = 0\n    cursum = 0\n    ans = 0\n    for (x, y) in fy:\n        while curx < n - 1 and fs[curx][0] > y:\n            cursum += fs[curx][0]\n            curx += 1\n        if x > y and fs[curx][0] < x:\n            cans = cursum + (n - curx) * y\n        else:\n            cans = cursum + x + (n - curx - 1) * y\n        ans = max(ans, cans)\n    print(ans, flush=False)", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    flowers = []\n    flowers_a = []\n    max_b = 0\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        flowers.append((a, b))\n    flowers.sort()\n    flowers_b = []\n    for i in range(m):\n        flowers_a.append(flowers[i][0])\n        flowers_b.append(flowers[i][1])\n    val = 0\n    prefix_sum = [0]\n    for x in flowers_a:\n        prefix_sum.append(prefix_sum[-1] + x)\n    for i in range(m):\n        idx = bisect.bisect_left(flowers_a, flowers_b[i])\n        options = m - idx\n        if options >= n:\n            temp = prefix_sum[-1] - prefix_sum[-n - 1]\n            val = max(val, temp)\n            continue\n        else:\n            temp = prefix_sum[-1] - prefix_sum[-options - 1]\n            remaining = n - options\n            if idx <= i:\n                temp += flowers_b[i] * remaining\n            else:\n                temp += flowers_a[i] + flowers_b[i] * (remaining - 1)\n            val = max(val, temp)\n    print(val)\n    if _ != t - 1:\n        blank_line = input()", "from math import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    b = []\n    cost = []\n    pc = []\n    vis = [0] * m\n    ans = -1\n    for i in range(m):\n        (ai, bi) = map(int, input().split())\n        pc.append((ai, bi))\n        cost.append((ai, bi, i, -1))\n        cost.append((bi, ai, i, -2))\n    if _ < t - 1:\n        input()\n    cost.sort(reverse=True)\n    val = 0\n    bt = 0\n    for i in range(len(cost)):\n        if bt >= n:\n            break\n        if cost[i][-1] == -1:\n            ans = max(ans, val + cost[i][0] + max(0, n - bt - 1) * cost[i][1])\n            val += cost[i][0]\n            vis[cost[i][2]] = 1\n            bt += 1\n        elif cost[i][-1] == -2 and vis[cost[i][2]] == 1:\n            ans = max(ans, val + (n - bt) * cost[i][0])\n        else:\n            ans = max(ans, val + cost[i][1] + (n - bt - 1) * cost[i][0])\n    print(ans)", "t = int(input())\nfor q in range(t):\n    (n, m) = list(map(int, input().split()))\n    arr = []\n    brr = []\n    for i in range(m):\n        (a, b) = list(map(int, input().split()))\n        arr.append([a, 0, i])\n        brr.append([b, 1, i])\n    if q != t - 1:\n        x = input()\n    vis = [False for i in range(m)]\n    l = arr + brr\n    l.sort(reverse=True)\n    cnt = 0\n    ans = 0\n    mex = 0\n    for (val, p, ind) in l:\n        if p == 0:\n            ans += val\n            cnt += 1\n            vis[ind] = True\n            if cnt == n:\n                mex = max(mex, ans)\n                break\n        else:\n            now = ans\n            if vis[ind] == False:\n                now = now + arr[ind][0]\n                now = now + (n - cnt - 1) * val\n            else:\n                now = now + (n - cnt) * val\n            mex = max(now, mex)\n    print(mex)", "import sys\ninput = sys.stdin.readline\n\ndef binary_search(list, item):\n    low = 0\n    high = len(list) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        guess = list[mid][0]\n        if guess == item:\n            return mid\n        if guess < item:\n            high = mid - 1\n        else:\n            low = mid + 1\n    else:\n        return low\nfor i in range(int(input())):\n    if i:\n        input()\n    (n, m) = list(map(int, input().split()))\n    d = [0] * m\n    for j in range(m):\n        d[j] = tuple(map(int, input().split()))\n    d.sort(reverse=True)\n    pre_d = [0] * m\n    pre_d[0] = d[0][0]\n    for j in range(1, m):\n        pre_d[j] = pre_d[j - 1] + d[j][0]\n    s = 0\n    b_max = 0\n    for j in range(m):\n        if d[j][1] > b_max:\n            fin = binary_search(d, d[j][1])\n            if fin:\n                if fin > j:\n                    if fin <= n:\n                        s_temp = pre_d[fin - 1] + d[j][1] * (n - fin)\n                    else:\n                        s_temp = pre_d[n - 1]\n                elif fin <= n - 1:\n                    s_temp = pre_d[fin - 1] + d[j][0] + d[j][1] * (n - 1 - fin)\n                else:\n                    s_temp = pre_d[n - 1]\n            else:\n                s_temp = d[j][0] + d[j][1] * (n - 1)\n            if s_temp > s:\n                s = s_temp\n                b_max = d[j][1]\n    print(s)"]