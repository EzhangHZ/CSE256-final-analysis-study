["import sys\nfrom collections import defaultdict\nimport bisect\n\ndef f(s, t):\n    A = defaultdict(list)\n    S = set(s)\n    T = set(t)\n    for i in T:\n        if i not in S:\n            return -1\n    n = len(s)\n    for i in range(n):\n        A[s[i]].append(i)\n    i = 0\n    j = 0\n    U = len(t)\n    ans = 1\n    while j < U:\n        c = t[j]\n        k = bisect.bisect_left(A[c], i)\n        if k >= len(A[c]):\n            i = 0\n            ans += 1\n        else:\n            j += 1\n            i = A[c][k] + 1\n    return ans\nn = int(input())\nfor i in range(n):\n    s = input()\n    t = input()\n    print(f(s, t))", "from collections import defaultdict\nimport bisect\nimport sys\n\ndef load_sys():\n    return sys.stdin.readlines()\n\ndef load_local():\n    with open('input.txt', 'r') as f:\n        input = f.readlines()\n    return input\n\ndef f(s, t):\n    (S, T) = (set(s), set(t))\n    for c in T:\n        if c not in S:\n            return -1\n    nxt = defaultdict(list)\n    for i in range(len(s)):\n        nxt[s[i]].append(i)\n    i = j = ans = 0\n    ans += 1\n    while j < len(t):\n        c = t[j]\n        k = bisect.bisect_left(nxt[c], i)\n        if k == len(nxt[c]):\n            i = 0\n            ans += 1\n        else:\n            j += 1\n            i = nxt[c][k] + 1\n    return ans\ndata = load_sys()\nfor i in range(1, len(data), 2):\n    s = data[i].strip()\n    t = data[i + 1].strip()\n    print(f(s, t))", "import math\nimport functools\n\n@functools.lru_cache(maxsize=8128)\ndef quick_find(s, letter, start_index):\n    return s.find(letter, start_index)\n\ndef convert(s, t):\n    start_index = 0\n    steps = 1\n    i = 0\n    while i < len(t):\n        letter = t[i]\n        index = quick_find(s, letter, start_index)\n        if index == -1 and start_index == 0:\n            return -1\n        if index == -1:\n            start_index = 0\n            steps += 1\n            i -= 1\n        start_index = index + 1\n        i += 1\n    return steps\nT = int(input())\nfor i in range(T):\n    s = input()\n    t = input()\n    steps = convert(s, t)\n    print(steps)", "import os\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    for t in range(int(input())):\n        s = input()\n        t = input()\n        sd = {i: [] for i in range(26)}\n        for i in range(len(s)):\n            sd[ord(s[i]) - ord('a')].append(i)\n        res = 1\n        last = -1\n        for i in t:\n            a = ord(i) - ord('a')\n            if sd[a] == []:\n                res = -1\n                break\n            temp = bisect_right(sd[a], last)\n            if temp >= len(sd[a]):\n                res = res + 1\n                last = sd[a][0]\n            else:\n                last = sd[a][temp]\n        print(res)\nmain()", "import bisect\nt = int(input())\nwhile t:\n    t -= 1\n    s = input()\n    target = input()\n    j = 0\n    d = {}\n    for i in s:\n        if i in d:\n            d[i].append(j)\n        else:\n            d[i] = [j]\n        j += 1\n    count = 0\n    if target[0] in d:\n        last = d[target[0]][0]\n    else:\n        print(-1)\n        continue\n    flag = False\n    for i in target[1:]:\n        if i in d:\n            g = bisect.bisect(d[i], last)\n            if g >= len(d[i]):\n                count += 1\n                last = d[i][0]\n            else:\n                last = d[i][g]\n        else:\n            flag = True\n            break\n    if flag:\n        print(-1)\n    else:\n        print(count + 1)", "from bisect import bisect_right as br\nfor t in range(int(input())):\n    s = input()\n    t = input()\n    alp = 'abcdefghijklmnopqrstuvwxyz'\n    dic = {}\n    for i in alp:\n        dic[i] = []\n    for i in range(len(s)):\n        dic[s[i]].append(i)\n    prev = -1\n    ans = 1\n    for i in t:\n        idx = br(dic[i], prev)\n        if len(dic[i]) == 0:\n            ans = -1\n            break\n        if idx == len(dic[i]):\n            ans += 1\n            prev = dic[i][0]\n        else:\n            prev = dic[i][idx]\n    print(ans)", "def solve(s: str, t: str):\n    import collections, bisect\n    d = collections.defaultdict(list)\n    for (i, ch) in enumerate(s):\n        d[ch].append(i)\n    ptr = [-1] * len(t)\n    for (i, ch) in enumerate(t):\n        if not ch in d:\n            return -1\n        if i == 0:\n            ptr[i] = d[ch][0]\n        else:\n            x = bisect.bisect_left(d[ch], ptr[i - 1] + 1)\n            if x == len(d[ch]):\n                ptr[i] = d[ch][0]\n            else:\n                ptr[i] = d[ch][x]\n    ans = 1\n    for i in range(len(ptr) - 1):\n        if ptr[i] >= ptr[i + 1]:\n            ans += 1\n    return ans\nT = int(input())\nfor _ in range(T):\n    s = input()\n    t = input()\n    print(solve(s, t))", "import sys\nimport math as mt\nimport bisect as bi\nimport collections as cc\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\nfor tc in range(int(input())):\n    f = cc.defaultdict(list)\n    s = input().strip()\n    t = input().strip()\n    if set(t) - set(s):\n        print(-1)\n        continue\n    for i in range(len(s)):\n        f[s[i]].append(i)\n    mx = f[t[0]][0]\n    ans = 1\n    for i in range(1, len(t)):\n        temp = bi.bisect_right(f[t[i]], mx)\n        if temp == len(f[t[i]]):\n            ans += 1\n            mx = f[t[i]][0]\n        else:\n            mx = f[t[i]][temp]\n    print(ans)", "import sys\n\ndef minp():\n    return sys.stdin.readline().strip()\n\ndef mint():\n    return int(minp())\n\ndef mints():\n    return map(int, minp().split())\n\ndef solve():\n    s = minp()\n    t = minp()\n    n = len(s)\n    m = len(t)\n    h = [None] * n\n    hh = [None] * 26\n    hh[ord(s[-1]) - ord('a')] = n - 1\n    h[-1] = hh\n    for i in range(n - 2, -1, -1):\n        hh = hh.copy()\n        hh[ord(s[i]) - ord('a')] = i\n        h[i] = hh\n    hh = [None] * 26\n    z = None\n    res = 0\n    for i in range(len(t)):\n        c = ord(t[i]) - ord('a')\n        if z == None:\n            z = 0\n            res += 1\n        ok = False\n        if h[z][c] != None:\n            z = h[z][c] + 1\n            ok = True\n            if z == n:\n                z = None\n        if not ok:\n            if h[0][c] == None:\n                print(-1)\n                return\n            res += 1\n            z = h[0][c] + 1\n    print(res)\nfor i in range(mint()):\n    solve()", "from bisect import bisect_left\nt = int(input())\nfor _ in range(t):\n    s = input()\n    t = input()\n    d = {}\n    for i in range(len(s)):\n        if s[i] not in d:\n            d[s[i]] = []\n        d[s[i]].append(i)\n    ans = 1\n    j = 0\n    for i in range(len(t)):\n        if t[i] not in d:\n            print(-1)\n            break\n        nxt = bisect_left(d[t[i]], j)\n        if nxt != len(d[t[i]]):\n            j = d[t[i]][nxt] + 1\n        else:\n            j = d[t[i]][0] + 1\n            ans += 1\n    else:\n        print(ans)", "from bisect import bisect\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    (d, di) = ({}, {})\n    for (i, x) in enumerate(s):\n        if d.get(x) == None:\n            d[x] = []\n            di[x] = 0\n        d[x].append(i)\n        di[x] += 1\n    (last, res, k) = (100005, 0, 0)\n    for (i, x) in enumerate(t):\n        if d.get(x) == None:\n            k = 1\n            break\n        a = bisect(d[x], last)\n        if a == di[x]:\n            res += 1\n            last = d[x][0]\n        else:\n            last = d[x][a]\n    if k == 1:\n        print(-1)\n    else:\n        print(res)", "for T in range(int(input())):\n    s = input()\n    t = input()\n    if s == t:\n        print(1)\n        continue\n    hsh1 = [0 for i in range(30)]\n    hsh2 = hsh1[:]\n    for i in s:\n        hsh1[ord(i) - 97] += 1\n    for i in t:\n        hsh2[ord(i) - 97] += 1\n    bad = 0\n    for (i, j) in zip(hsh1, hsh2):\n        if j > 0 and i == 0:\n            print(-1)\n            bad = 1\n            break\n    if bad:\n        continue\n    from collections import defaultdict as dd\n    d = dd(list)\n    for i in range(len(s)):\n        d[s[i]].append(i)\n    from bisect import bisect_right as br\n    move = 1\n    idx = -1\n    k = 0\n    while k != len(t):\n        need = t[k]\n        idx = br(d[need], idx)\n        if idx >= len(d[need]):\n            idx = -1\n            move += 1\n        else:\n            idx = d[need][idx]\n            k += 1\n    print(move)", "from collections import defaultdict\nimport bisect\n\ndef list_difference(list1, list2):\n    result = list1.copy()\n    for value in list2:\n        if value in result:\n            result.remove(value)\n    return result\nN = int(input())\nfor i in range(N):\n    s = input()\n    t = input()\n    if set(list(t)) - set(list(s)):\n        print(-1)\n    elif len(t) == 1:\n        print(1)\n    else:\n        count = 1\n        sc = defaultdict(list)\n        for (i, v) in enumerate(list(s)):\n            sc[v].append(i)\n        now = sc[t[0]][0]\n        t = t[1:]\n        for i in t:\n            if now >= sc[i][-1]:\n                count += 1\n                now = sc[i][0]\n            else:\n                now = sc[i][bisect.bisect_right(sc[i], now)]\n        print(count)", "from bisect import bisect_right\nfor t in range(int(input())):\n    s = input()\n    t = input()\n    sd = {i: [] for i in range(26)}\n    for i in range(len(s)):\n        sd[ord(s[i]) - ord('a')].append(i)\n    res = 1\n    last = -1\n    for i in t:\n        a = ord(i) - ord('a')\n        if sd[a] == []:\n            res = -1\n            break\n        temp = bisect_right(sd[a], last)\n        if temp >= len(sd[a]):\n            res += 1\n            last = sd[a][0]\n        else:\n            last = sd[a][temp]\n    print(res)", "import string\nimport bisect\n\ndef getNextLarger(arr, val):\n    index = bisect.bisect_right(arr, val)\n    if index == len(arr):\n        return None\n    return arr[index]\n\ndef isImpossible(s, t):\n    s = set(s)\n    for letter in t:\n        if letter not in s:\n            return True\n    return False\n\ndef solve(s, t):\n    if isImpossible(s, t):\n        return -1\n    letterOccurrences = {letter: [] for letter in string.ascii_lowercase}\n    for (index, letter) in enumerate(s):\n        letterOccurrences[letter].append(index)\n    t = list(t)\n    t.reverse()\n    numOperations = 0\n    while t:\n        lastUsedIndexInS = -1\n        numOperations += 1\n        while t:\n            nextLetter = t[-1]\n            nextAppearanceOfLetter = getNextLarger(letterOccurrences[nextLetter], lastUsedIndexInS)\n            if nextAppearanceOfLetter is None:\n                break\n            t.pop()\n            lastUsedIndexInS = nextAppearanceOfLetter\n    return numOperations\nn = int(input())\nfor _ in range(n):\n    s = input()\n    t = input()\n    print(solve(s, t))", "from bisect import bisect_right\nfor t in range(int(input())):\n    s = input()\n    t = input()\n    sd = {i: [] for i in range(26)}\n    for i in range(len(s)):\n        sd[ord(s[i]) - ord('a')].append(i)\n    res = 1\n    last = -1\n    for i in t:\n        a = ord(i) - ord('a')\n        if sd[a] == []:\n            res = -1\n            break\n        temp = bisect_right(sd[a], last)\n        if temp >= len(sd[a]):\n            res += 1\n            last = sd[a][0]\n        else:\n            last = sd[a][temp]\n    print(res)", "import sys\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    inds = defaultdict(list)\n    for i in range(len(s)):\n        inds[s[i]].append(i)\n    cnt = 1\n    ti = 0\n    si = 0\n    for ti in range(len(t)):\n        if t[ti] not in inds:\n            print(-1)\n            break\n        ci = bisect_left(inds[t[ti]], si)\n        if ci != len(inds[t[ti]]):\n            si = inds[t[ti]][ci] + 1\n        else:\n            si = inds[t[ti]][0] + 1\n            cnt += 1\n    else:\n        print(cnt)", "import bisect\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    s = str(input())\n    t = str(input())\n    l = defaultdict(list)\n    j = 0\n    for i in s:\n        j += 1\n        l[i].append(j)\n    g = -1\n    ans = 0\n    h = 0\n    for i in t:\n        if len(l[i]) != 0:\n            x = bisect.bisect_right(l[i], g)\n            if x >= len(l[i]):\n                g = l[i][0]\n                ans += 1\n            else:\n                g = l[i][x]\n        else:\n            h = 1\n            break\n    if h == 1:\n        print(-1)\n    else:\n        print(ans + 1)", "import bisect\nt = int(input())\nfor i in range(t):\n    s = input()\n    t = input()\n    dic = {}\n    for j in range(len(s)):\n        if s[j] in dic:\n            dic[s[j]].append(j)\n        else:\n            dic[s[j]] = [j]\n    count = 0\n    prev = -1\n    flag = False\n    for j in range(len(t)):\n        char = t[j]\n        if char not in dic:\n            flag = True\n            break\n        index = bisect.bisect_right(dic[char], prev, 0, len(dic[char]))\n        if index >= len(dic[char]):\n            index = bisect.bisect_right(dic[char], -1, 0, len(dic[char]))\n            count += 1\n        prev = dic[char][index]\n    if flag:\n        print(-1)\n    else:\n        print(count + 1)", "import sys\nimport bisect\ninput = sys.stdin.readline\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        S = input().strip()\n        A = [[] for _ in range(27)]\n        for (i, s) in enumerate(S):\n            A[ord(s) - ord('a')].append(i)\n        T = input().strip()\n        prev = -1\n        ans = 1\n        for t in T:\n            if len(A[ord(t) - ord('a')]) == 0:\n                print(-1)\n                break\n            else:\n                next = bisect.bisect_right(A[ord(t) - ord('a')], prev)\n                if next > len(A[ord(t) - ord('a')]) - 1:\n                    ans += 1\n                    prev = A[ord(t) - ord('a')][0]\n                else:\n                    prev = A[ord(t) - ord('a')][next]\n        else:\n            print(ans)\nmain()", "import sys, bisect\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t -= 1\n    s1 = input().strip()\n    s2 = input().strip()\n    locations = {}\n    for i in range(len(s1)):\n        if s1[i] in locations:\n            locations[s1[i]].append(i)\n        else:\n            locations[s1[i]] = [i]\n    a = i = len(s1)\n    j = len(s2) - 1\n    ans = 1\n    while j >= 0:\n        if s2[j] not in locations:\n            ans = -1\n            break\n        i = bisect.bisect_right(locations[s2[j]], i) - 1\n        if i < 0:\n            i = a\n            ans += 1\n        else:\n            i = locations[s2[j]][i] - 1\n            j -= 1\n    print(ans)", "import bisect\nfrom collections import *\nn = int(input())\nwhile n != 0:\n    s = input()\n    t = input()\n    dic = defaultdict(list)\n    for i in range(len(s)):\n        dic[s[i]].append(i)\n    i = 0\n    pos = -1\n    ans = 1\n    while i < len(t):\n        if len(dic[t[i]]) == 0:\n            ans = -1\n            break\n        x = bisect.bisect_right(dic[t[i]], pos)\n        if x >= len(dic[t[i]]):\n            ans += 1\n            pos = -1\n        else:\n            pos = dic[t[i]][x]\n            i += 1\n    print(ans)\n    n -= 1", "from bisect import bisect_right\nfor _ in range(int(input())):\n    s = list(input())\n    t = list(input())\n    flag = 1\n    d = {}\n    for i in range(len(s)):\n        if s[i] in d:\n            d[s[i]].append(i)\n        else:\n            d[s[i]] = [i]\n    z = [-1]\n    count = 1\n    x = 0\n    for i in range(len(t)):\n        if t[i] not in d:\n            flag = 0\n            break\n        else:\n            x = bisect_right(d[t[i]], z[-1])\n            if x == len(d[t[i]]):\n                x = 0\n            z.append(d[t[i]][x])\n    if flag == 1:\n        i = 1\n        t = len(z)\n        while i < t - 1:\n            if z[i] < z[i + 1]:\n                i += 1\n            elif z[i] > z[i + 1]:\n                count += 1\n                i += 1\n            else:\n                count += 1\n                i += 1\n    if flag == 0:\n        print(-1)\n    else:\n        print(count)", "import bisect\nt = int(input())\nwhile t:\n    s = input()\n    x = input()\n    apr = [[] for _ in range(26)]\n    for i in range(len(s)):\n        apr[ord(s[i]) - ord('a')].append(i)\n    ans = 0\n    px = 0\n    ps = 0\n    inv = False\n    while px < len(x):\n        moved = False\n        while px < len(x) and ps < len(s):\n            apr_pos = ord(x[px]) - ord('a')\n            pos_found = bisect.bisect_left(apr[apr_pos], ps)\n            if pos_found == len(apr[apr_pos]):\n                break\n            else:\n                moved = True\n                ps = apr[apr_pos][pos_found] + 1\n                px += 1\n        if not moved:\n            inv = True\n            break\n        else:\n            ans += 1\n            ps = 0\n    if inv:\n        print(-1)\n    else:\n        print(ans)\n    t -= 1", "from bisect import bisect\nfor k in range(int(input())):\n    d = {}\n    for i in range(97, 123):\n        d[chr(i)] = []\n    s = input()\n    for j in range(len(s)):\n        d[s[j]].append(j)\n    t = input()\n    (cou, st, p, r) = (1, -1, 0, 0)\n    while r < len(t):\n        q = bisect(d[t[r]], st)\n        if d[t[r]] == []:\n            p = 1\n            break\n        try:\n            if d[t[r]][q] == st:\n                q += 1\n            st = d[t[r]][q]\n            r += 1\n        except:\n            cou += 1\n            st = -1\n    if p == 1:\n        print(-1)\n    else:\n        print(cou)", "import bisect\nT = int(input())\nfor tt in range(T):\n    s = input()\n    t = input()\n    len_s = len(s)\n    len_t = len(t)\n    ans = 0\n    record = [[] for i in range(26)]\n    for i in range(len_s):\n        record[ord(s[i]) - ord('a')].append(i)\n    len_record = [0 for i in range(26)]\n    for i in range(26):\n        len_record[i] = len(record[i])\n    tj = 0\n    while tj < len_t:\n        si = 0\n        while si < len_s:\n            if tj >= len_t:\n                break\n            now = ord(t[tj]) - ord('a')\n            if not record[now]:\n                ans = -1\n                break\n            left = bisect.bisect_left(record[now], si, 0, len_record[now])\n            if left == len_record[now]:\n                break\n            else:\n                tj += 1\n                si = record[now][left] + 1\n        if ans == -1:\n            break\n        else:\n            ans += 1\n    print(ans)", "import bisect\nfrom collections import *\nn = int(input())\nwhile n != 0:\n    s = input()\n    t = input()\n    f = 9\n    dic = defaultdict(list)\n    for i in range(len(s)):\n        dic[s[i]].append(i)\n    i = 0\n    pos = -1\n    ans = 1\n    while i < len(t):\n        if len(dic[t[i]]) == 0:\n            ans = -1\n            break\n        x = bisect.bisect_right(dic[t[i]], pos)\n        if x >= len(dic[t[i]]):\n            ans += 1\n            pos = -1\n        else:\n            pos = dic[t[i]][x]\n            i += 1\n    print(ans)\n    n -= 1", "import bisect\nfrom collections import *\nn = int(input())\nwhile n != 0:\n    s = input()\n    t = input()\n    dic = defaultdict(list)\n    for i in range(len(s)):\n        dic[s[i]].append(i)\n    i = 0\n    pos = -1\n    ans = 1\n    while i < len(t):\n        if len(dic[t[i]]) == 0:\n            ans = -1\n            break\n        x = bisect.bisect_right(dic[t[i]], pos)\n        if x >= len(dic[t[i]]):\n            ans += 1\n            pos = -1\n        else:\n            pos = dic[t[i]][x]\n            i += 1\n    print(ans)\n    n -= 1", "import bisect\n\ndef mini_idex(d, ele, prev):\n    t = bisect.bisect_right(d[ele], prev)\n    if t >= len(d[ele]):\n        return -1\n    else:\n        return d[ele][t]\ntt = int(input())\nwhile tt != 0:\n    s = input()\n    t = input()\n    d = {}\n    for i in range(26):\n        d[chr(ord('a') + i)] = []\n    for i in range(len(s)):\n        d[s[i]].append(i)\n    f = 0\n    i = 0\n    count = 0\n    prev = -1\n    while i < len(t):\n        if len(d[t[i]]) == 0:\n            f = 1\n            break\n        else:\n            temp = mini_idex(d, t[i], prev)\n            if temp == -1:\n                count += 1\n                prev = -1\n            else:\n                prev = temp\n                i += 1\n    if f == 1:\n        print(-1)\n    else:\n        count += 1\n        print(count)\n    tt -= 1", "from collections import defaultdict\nimport bisect\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    d = defaultdict(list)\n    for i in range(len(s)):\n        d[s[i]].append(i)\n    ans = 1\n    k = 0\n    curr = -1\n    while k < len(t):\n        if len(d[t[k]]) == 0:\n            ans = -1\n            break\n        curr = bisect.bisect_right(d[t[k]], curr)\n        if curr >= len(d[t[k]]):\n            curr = -1\n            ans += 1\n        else:\n            curr = d[t[k]][curr]\n            k += 1\n    print(ans)", "import bisect\nfrom collections import *\nn = int(input())\nwhile n != 0:\n    s = input()\n    t = input()\n    dic = defaultdict(list)\n    for i in range(len(s)):\n        dic[s[i]].append(i)\n    i = 0\n    pos = -1\n    ans = 1\n    while i < len(t):\n        if len(dic[t[i]]) == 0:\n            ans = -1\n            break\n        x = bisect.bisect_right(dic[t[i]], pos)\n        if x >= len(dic[t[i]]):\n            ans += 1\n            pos = -1\n        else:\n            pos = dic[t[i]][x]\n            i += 1\n    print(ans)\n    n -= 1", "import bisect\nfrom collections import *\nn = int(input())\nwhile n != 0:\n    s = input()\n    t = input()\n    dic = defaultdict(list)\n    for i in range(len(s)):\n        dic[s[i]].append(i)\n    i = 0\n    pos = -1\n    ans = 1\n    while i < len(t):\n        if len(dic[t[i]]) == 0:\n            ans = -1\n            break\n        x = bisect.bisect_right(dic[t[i]], pos)\n        if x >= len(dic[t[i]]):\n            ans += 1\n            pos = -1\n        else:\n            pos = dic[t[i]][x]\n            i += 1\n    print(ans)\n    n -= 1", "from collections import defaultdict\nimport bisect\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    d = defaultdict(list)\n    ans = 1\n    for i in range(len(s)):\n        d[s[i]].append(i)\n    k = 0\n    curr = -1\n    while k != len(t):\n        if len(d[t[k]]) == 0:\n            ans = -1\n            break\n        curr = bisect.bisect_right(d[t[k]], curr)\n        if curr >= len(d[t[k]]):\n            curr = -1\n            ans += 1\n        else:\n            curr = d[t[k]][curr]\n            k += 1\n    print(ans)", "from collections import defaultdict\nimport bisect\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    d = defaultdict(list)\n    ans = 1\n    for i in range(len(s)):\n        d[s[i]].append(i)\n    k = 0\n    curr = -1\n    while k != len(t):\n        if len(d[t[k]]) == 0:\n            ans = -1\n            break\n        curr = bisect.bisect_right(d[t[k]], curr)\n        if curr >= len(d[t[k]]):\n            curr = -1\n            ans += 1\n        else:\n            curr = d[t[k]][curr]\n            k += 1\n    print(ans)", "import sys\nimport math\nfrom bisect import bisect_right as br\nfrom collections import deque\nfrom itertools import combinations as cb\n\ndef int_arr():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef str_arr():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef input():\n    return sys.stdin.readline().strip()\nfor _ in range(int(input())):\n    st = input()\n    made = input()\n    ind = [[-1 for i in range(26)]]\n    prev = st[0]\n    for i in range(1, len(st) + 1):\n        x = ind[-1].copy()\n        x[ord(prev) - 97] = i - 1\n        ind.append(x)\n        if i < len(st):\n            prev = st[i]\n    i = len(made) - 1\n    j = len(st)\n    ans = 0\n    flag = 1\n    while i >= 0 and flag == 1:\n        j = len(st)\n        ans += 1\n        while j > 0 and i >= 0:\n            val = made[i]\n            f = ord(val) - 97\n            z = ind[j][f]\n            if z == -1:\n                if j == len(st):\n                    print(-1)\n                    flag = 0\n                    break\n                else:\n                    j = len(st)\n                    break\n            else:\n                j = z\n                i -= 1\n    if flag:\n        print(ans)", "from collections import defaultdict\nimport bisect\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    s_dict = defaultdict(list)\n    for (index, l) in enumerate(s):\n        s_dict[l].append(index)\n    t = input().strip()\n    ans = 0\n    has = True\n    cur_index = 0\n    while cur_index < len(t):\n        s_index = -1\n        fin = True\n        for i in range(cur_index, len(t)):\n            if t[i] not in s_dict:\n                has = False\n                break\n            else:\n                s_result = bisect.bisect_right(s_dict[t[i]], s_index)\n                if s_result == len(s_dict[t[i]]) or s_dict[t[i]][s_result] <= s_index:\n                    fin = False\n                    break\n                s_index = s_dict[t[i]][s_result]\n        cur_index = i\n        ans += 1\n        if not has or fin:\n            break\n    if not has:\n        print(-1)\n    else:\n        print(ans)", "for _ in range(int(input())):\n    s = list(map(lambda x: ord(x) - 97, input()))\n    t = list(map(lambda x: ord(x) - 97, input()))\n    if len(set(t) - set(s)) > 0:\n        print(-1)\n        continue\n    dp = [[-1] * 26 for i in range(len(s))]\n    nextt = [-1] * 26\n    for i in range(len(s) - 1, -1, -1):\n        nextt[s[i]] = i\n    for i in range(len(s) - 1, -1, -1):\n        dp[i] = nextt[:]\n        nextt[s[i]] = i\n    (pos, ans) = (-1, 1)\n    for i in t:\n        if pos >= dp[pos][i]:\n            ans += 1\n        pos = dp[pos][i]\n    print(ans)", "def s_map(s):\n    m = [[None] * 26] + [[None] * 26 for _ in s]\n    for (prev_i, (prev_x, prev_col, cur_col)) in reversed(list(enumerate(zip(s, m[1:], m), 1))):\n        cur_col[:] = prev_col\n        cur_col[prev_x] = prev_i\n    return m\n\ndef solve(s, t):\n    if not set(t).issubset(set(s)):\n        return -1\n    s = [ord(c) - ord('a') for c in s]\n    t = [ord(c) - ord('a') for c in reversed(t)]\n    m = s_map(s)\n    n = 0\n    while t:\n        i = 0\n        while t and m[i][t[-1]]:\n            i = m[i][t[-1]]\n            t.pop()\n        n += 1\n    return n\nT = int(input())\nfor _ in range(T):\n    s = input().strip()\n    t = input().strip()\n    print(solve(s, t))", "import random\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    pos = {}\n    for i in range(len(s)):\n        if s[i] in pos:\n            pos[s[i]].append(i)\n        else:\n            pos[s[i]] = [i]\n\n    def find(arr, target):\n        l = 0\n        r = len(arr) - 1\n        while l < r:\n            mid = l + r >> 1\n            if arr[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n    ans = 1\n    last = -1\n    for (i, let) in enumerate(t):\n        if let in pos:\n            ind = find(pos[let], last)\n            if pos[let][ind] <= last:\n                ans += 1\n                last = pos[let][0]\n            else:\n                last = pos[let][ind]\n        else:\n            print(-1)\n            break\n    else:\n        print(ans)", "import random\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    pos = {}\n    for i in range(len(s)):\n        if s[i] in pos:\n            pos[s[i]].append(i)\n        else:\n            pos[s[i]] = [i]\n\n    def find(arr, target):\n        l = 0\n        r = len(arr) - 1\n        while l < r:\n            mid = l + r >> 1\n            if arr[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n    ans = 1\n    last = -1\n    for (i, let) in enumerate(t):\n        if let in pos:\n            ind = find(pos[let], last)\n            if pos[let][ind] <= last:\n                ans += 1\n                last = pos[let][0]\n            else:\n                last = pos[let][ind]\n        else:\n            print(-1)\n            break\n    else:\n        print(ans)", "import math\nfrom collections import Counter, deque\nfrom sys import stdout\nimport time\nfrom math import factorial, log, gcd\nimport sys\nfrom decimal import Decimal\nimport heapq\n\ndef S():\n    return sys.stdin.readline().split()\n\ndef I():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef IS():\n    return sys.stdin.readline().replace('\\n', '')\n\ndef main():\n    s = IS()\n    n = len(s)\n    t = IS()\n    alphabet = set(s)\n    if alphabet | set(t) != alphabet:\n        print(-1)\n        return\n    suf_m = dict([(i, [-1] * n) for i in alphabet])\n    suf_m[s[-1]][-1] = n - 1\n    for i in range(n - 2, -1, -1):\n        el = s[i]\n        for a in alphabet:\n            if a != el:\n                suf_m[a][i] = suf_m[a][i + 1]\n            else:\n                suf_m[el][i] = i\n    idx = -1\n    op = 0\n    for i in range(len(t)):\n        el = t[i]\n        idx = suf_m[el][idx + 1]\n        if idx == n - 1:\n            op += 1\n            idx = -1\n        elif idx == -1:\n            op += 1\n            idx = suf_m[el][0]\n    if idx != -1:\n        op += 1\n    print(op)\nfor _ in range(II()):\n    main()", "def bsearch(a, x):\n    l = 0\n    r = len(a)\n    while l < r:\n        mid = (l + r) // 2\n        if a[mid] > x:\n            r = mid\n        else:\n            l = mid + 1\n    return l\nfor _ in range(int(input())):\n    s = input()\n    t = input()\n    Map = {}\n    for i in range(len(s)):\n        if s[i] not in Map:\n            Map[s[i]] = []\n        Map[s[i]].append(i)\n    flag = 0\n    c = 1\n    n = len(t)\n    i = 0\n    maxInd = -1\n    while i < n:\n        if t[i] not in Map:\n            flag = 1\n            print('-1')\n            break\n        if Map[t[i]][0] > maxInd:\n            maxInd = Map[t[i]][0]\n            i += 1\n        else:\n            find = bsearch(Map[t[i]], maxInd)\n            if find < len(Map[t[i]]):\n                maxInd = Map[t[i]][find]\n                i += 1\n            else:\n                c += 1\n                maxInd = -1\n    if flag == 0:\n        print(c)", "LETTERS = set(list('abcdefghijklmnopqrstuvwxyz'))\n\ndef PrepareLettersIndices(s):\n    s_letters = dict()\n    for letters in LETTERS:\n        s_letters[letters] = []\n    for i in range(len(s)):\n        s_letters[s[i]].append(i)\n    return s_letters\n\ndef BinSearch(num, numbers):\n    if num >= numbers[-1]:\n        return -1\n    if num < numbers[0]:\n        return numbers[0]\n    left = 0\n    right = len(numbers) - 1\n    mid = (left + right) // 2\n    while not numbers[mid] <= num < numbers[mid + 1]:\n        if numbers[mid] <= num:\n            left = mid\n        else:\n            right = mid\n        mid = (left + right) // 2\n    return numbers[mid + 1]\n\ndef main():\n    T = int(input())\n    for i in range(T):\n        s = list(input())\n        t = list(input())\n        s_set = set(s)\n        t_set = set(t)\n        if not t_set.issubset(s_set):\n            print(-1)\n            continue\n        letters_dict = PrepareLettersIndices(s)\n        result = 1\n        current = -1\n        j = 0\n        while j < len(t):\n            new = BinSearch(current, letters_dict[t[j]])\n            if new == -1:\n                result += 1\n                current = -1\n            else:\n                current = new\n                j += 1\n        print(result)\n    return 0\nmain()", "def binarySearch(seq, a):\n    if not seq:\n        return -2\n    n = len(seq)\n    l = 0\n    r = len(seq)\n    while l < r:\n        m = (l + r) // 2\n        if seq[m] > a:\n            r = m\n        if seq[m] < a:\n            l = m + 1\n        if seq[m] == a:\n            if m == n - 1:\n                return -1\n            return seq[m + 1]\n    if l == n:\n        return -1\n    return seq[l]\n\ndef minOp(S, T):\n    letters = [[] for _ in range(26)]\n    for (i, c) in enumerate(S):\n        letters[ord(c) - ord('a')].append(i)\n    op = 1\n    pre = -1\n    for (i, t) in enumerate(T):\n        t_pos = letters[ord(t) - ord('a')]\n        t_index = binarySearch(t_pos, pre)\n        if t_index == -1:\n            op += 1\n            pre = t_pos[0]\n        elif t_index == -2:\n            return -1\n        else:\n            pre = t_index\n    return op\nt = int(input())\nfor _ in range(t):\n    S = input()\n    T = input()\n    print(minOp(S, T))", "for _ in range(int(input())):\n    s = input()\n    t = input()\n    nxt = [[-1] * 26 for _ in range(len(s))]\n    exist = [False] * 26\n    get_code = lambda c: ord(c) - ord('a')\n    last = [-1] * 26\n    first = [-1] * 26\n    for i in range(len(s)):\n        c = s[i]\n        code = get_code(c)\n        exist[code] = True\n        if first[code] == -1:\n            first[code] = i\n        for j in range(i - 1, max(last[code] - 1, -1), -1):\n            nxt[j][code] = i\n        last[code] = i\n    if exist[get_code(t[0])]:\n        cur = len(s) - 1\n        loop = 0\n        for c in t:\n            code = get_code(c)\n            if not exist[code]:\n                loop = -1\n                break\n            if nxt[cur][code] == -1:\n                loop += 1\n                cur = -1\n            else:\n                cur = nxt[cur][code]\n            if cur == -1:\n                cur = first[code]\n        print(loop)\n    else:\n        print(-1)", "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy\ncases = int(input().strip())\nfor case in range(cases):\n    s = list(input().strip())\n    t = list(input().strip())\n    ss = set(s)\n    tt = list(set(t))\n    can = True\n    for i in range(len(tt)):\n        if not tt[i] in ss:\n            can = False\n    if not can:\n        print(-1)\n    else:\n        n = len(s)\n        nxt = [{} for i in range(n)]\n        for i in range(n - 1, -1, -1):\n            if i + 1 < n:\n                for (k, v) in nxt[i + 1].items():\n                    nxt[i][k] = v\n            nxt[i][s[i]] = i\n        ans = 1\n        pos = 0\n        for i in range(len(t)):\n            if pos >= n or not t[i] in nxt[pos]:\n                pos = 0\n                ans += 1\n            pos = nxt[pos][t[i]] + 1\n        print(ans)", "import string\nt = int(input())\nfor ti in range(t):\n    a = input()\n    b = input()\n    c = {key: list() for key in string.ascii_lowercase}\n    for i in range(len(a)):\n        c[a[i]].append(i)\n    ans = 1\n    pos = -1\n    for j in b:\n        cur = c[j]\n        if len(cur) == 0:\n            print(-1)\n            break\n        (li, ri) = (-1, len(cur))\n        while ri - li > 1:\n            mi = (ri + li) // 2\n            if cur[mi] > pos:\n                ri = mi\n            else:\n                li = mi\n        if ri == len(cur):\n            ans += 1\n            pos = cur[0]\n        else:\n            pos = cur[ri]\n    else:\n        print(ans)", "def solve_simple(source, target):\n    if not set(source) >= set(target):\n        return -1\n    operations = 0\n    target_index = 0\n    while target_index < len(target):\n        operations += 1\n        source_index = 0\n        while source_index < len(source) and target_index < len(target):\n            if source[source_index] == target[target_index]:\n                target_index += 1\n            source_index += 1\n    return operations\n\ndef solve_optimal(source, target):\n    if not set(source) >= set(target):\n        return -1\n    positions = {}\n    next_positions = {}\n    i = len(source) - 1\n    while i >= 0:\n        positions[source[i]] = i\n        for (char, position) in positions.items():\n            next_positions[i, char] = position\n        i -= 1\n    operations = 0\n    target_index = 0\n    while target_index < len(target):\n        operations += 1\n        position = 0\n        while target_index < len(target):\n            position = next_positions.get((position, target[target_index]))\n            if position is None:\n                break\n            position += 1\n            target_index += 1\n    return operations\nsolve = solve_optimal\nfor T in range(int(input())):\n    print(solve(input(), input()))"]