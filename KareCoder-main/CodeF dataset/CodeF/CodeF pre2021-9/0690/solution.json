["from sys import stdin, stdout\nimport collections, heapq, bisect, math\ninput = stdin.readline\n\ndef rint():\n    return int(input())\n\ndef rstr():\n    return input().strip()\n\ndef rlstr():\n    return list(input().strip().split())\n\ndef rlint():\n    return list(map(int, input().split()))\n\ndef main():\n    n = rlint()\n    a = rlint()\n    b = rlint()\n    c = rlint()\n    d = rlint()\n    price = [a, b, c, d]\n    inc = [{} for _ in range(3)]\n    for i in range(3):\n        m = rint()\n        for _ in range(m):\n            (x, y) = rlint()\n            x -= 1\n            y -= 1\n            if x not in inc[i]:\n                inc[i][x] = set([y])\n            else:\n                inc[i][x].add(y)\n    dp = price[-1][:]\n    for step in range(3, 0, -1):\n        dp2 = dp[:]\n        dp = [float('inf')] * n[step - 1]\n        index = sorted(range(n[step]), key=lambda i: dp2[i])\n        for i in range(n[step - 1]):\n            ind = 0\n            while i in inc[step - 1] and ind < n[step] and (index[ind] in inc[step - 1][i]):\n                ind += 1\n            if ind < n[step]:\n                dp[i] = price[step - 1][i] + dp2[index[ind]]\n    res = min(dp)\n    if res < float('inf'):\n        print(res)\n    else:\n        print(-1)\nmain()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    prices = [a, b, c, d]\n    inc = [{} for _ in range(3)]\n    for i in range(3):\n        ni = int(input())\n        for _ in range(ni):\n            (k, l) = map(int, input().split())\n            if k - 1 in inc[i]:\n                inc[i][k - 1].add(l - 1)\n            else:\n                inc[i][k - 1] = set([l - 1])\n    step = 3\n    mem2 = prices[3][:]\n    for step in range(3, 0, -1):\n        mem = mem2[:]\n        index_sorted = sorted(range(n[step]), key=lambda x: mem[x])\n        mem2 = [float('inf')] * n[step - 1]\n        for i in range(n[step - 1]):\n            index = 0\n            while i in inc[step - 1] and index < n[step] and (index_sorted[index] in inc[step - 1][i]):\n                index += 1\n            if index < n[step]:\n                mem2[i] = prices[step - 1][i] + mem[index_sorted[index]]\n    rep = min(mem2)\n    if rep < float('inf'):\n        print(rep)\n    else:\n        print(-1)\nmain()", "def main():\n    n = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    prices = [a, b, c, d]\n    inc = [{} for _ in range(3)]\n    for i in range(3):\n        ni = int(input())\n        for _ in range(ni):\n            (k, l) = map(int, input().split())\n            if k - 1 in inc[i]:\n                inc[i][k - 1].add(l - 1)\n            else:\n                inc[i][k - 1] = set([l - 1])\n    step = 3\n    mem2 = prices[3][:]\n    for step in range(3, 0, -1):\n        mem = mem2[:]\n        index_sorted = sorted(range(n[step]), key=lambda x: mem[x])\n        mem2 = [float('inf')] * n[step - 1]\n        for i in range(n[step - 1]):\n            index = 0\n            while i in inc[step - 1] and index < n[step] and (index_sorted[index] in inc[step - 1][i]):\n                index += 1\n            if index < n[step]:\n                mem2[i] = prices[step - 1][i] + mem[index_sorted[index]]\n    rep = min(mem2)\n    print(rep) if rep < float('inf') else print(-1)\nmain()", "def main():\n    n = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    prices = [a, b, c, d]\n    inc = [{} for _ in range(3)]\n    for i in range(3):\n        ni = int(input())\n        for _ in range(ni):\n            (k, l) = map(int, input().split())\n            if k - 1 in inc[i]:\n                inc[i][k - 1].add(l - 1)\n            else:\n                inc[i][k - 1] = set([l - 1])\n    step = 3\n    mem2 = prices[3][:]\n    for step in range(3, 0, -1):\n        mem = mem2[:]\n        index_sorted = sorted(range(n[step]), key=lambda x: mem[x])\n        mem2 = [float('inf')] * n[step - 1]\n        for i in range(n[step - 1]):\n            index = 0\n            while i in inc[step - 1] and index < n[step] and (index_sorted[index] in inc[step - 1][i]):\n                index += 1\n            if index < n[step]:\n                mem2[i] = prices[step - 1][i] + mem[index_sorted[index]]\n    rep = min(mem2)\n    if rep < float('inf'):\n        print(rep)\n    else:\n        print(-1)\nmain()", "import sys\ninput = lambda : sys.stdin.readline().strip()\nn = list(map(int, input().split()))\na = []\nfor i in range(4):\n    a.append(list(map(int, input().split())))\n\ndef solve(l1, l2):\n    m = int(input())\n    not_together = [[i, set()] for i in range(n[l1])]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        not_together[x][1].add(y)\n    not_together = sorted(not_together, key=lambda x: a[l1][x[0]])\n    for i in range(n[l2]):\n        ans = float('inf')\n        for j in range(len(not_together)):\n            if i not in not_together[j][1]:\n                ans = a[l1][not_together[j][0]]\n                break\n        a[l2][i] += ans\nsolve(0, 1)\nsolve(1, 2)\nsolve(2, 3)\nans = min(a[3])\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)", "import sys\nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().strip()\nn = list(map(int, input().split()))\na = []\nfor i in range(4):\n    a.append(list(map(int, input().split())))\n\ndef solve_pair(i1, i2):\n    m = int(input())\n    not_together = [[i, set()] for i in range(n[i1])]\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        x -= 1\n        y -= 1\n        not_together[x][1].add(y)\n    not_together = [v for v in sorted(not_together, key=lambda x: a[i1][x[0]])]\n    for i in range(n[i2]):\n        add = float('inf')\n        for j in range(len(not_together)):\n            if i not in not_together[j][1]:\n                add = a[i1][not_together[j][0]]\n                break\n        a[i2][i] += add\nsolve_pair(0, 1)\nsolve_pair(1, 2)\nsolve_pair(2, 3)\nans = min(a[3])\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)", "import collections\n(n1, n2, n3, n4) = map(int, input().split())\narr = []\nfor _ in range(4):\n    arr.append(list(map(int, input().split())))\nd = collections.defaultdict(set)\nfor i in range(3):\n    m = int(input())\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        d[i, x - 1].add(y - 1)\nfor i in range(2, 0, -1):\n    a = arr[i + 1]\n    p = sorted(list(range(len(a))), key=lambda x: a[x])\n    for c in range(len(arr[i])):\n        j = 0\n        while j < len(a) and p[j] in d[i, c] and (arr[i + 1][p[j]] < float('inf')):\n            j += 1\n        if j == len(a) or arr[i + 1][p[j]] == float('inf'):\n            arr[i][c] = float('inf')\n        else:\n            arr[i][c] += arr[i + 1][p[j]]\nans = float('inf')\na = arr[1]\nap = sorted(list(range(len(a))), key=lambda x: a[x])\nb = arr[0]\nbp = sorted(list(range(len(b))), key=lambda x: b[x])\nfor c in bp:\n    if b[c] >= ans:\n        break\n    if ap and a[ap[0]] + b[c] >= ans:\n        break\n    else:\n        while ap and a[ap[-1]] >= ans:\n            ap.pop()\n        j = 0\n        while j < len(ap) and ap[j] in d[0, c]:\n            j += 1\n        if j < len(ap):\n            ans = min(ans, a[ap[j]] + b[c])\nprint(-1 if ans == float('inf') else ans)"]