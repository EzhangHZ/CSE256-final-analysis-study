["import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List, Mapping\nsys.setrecursionlimit(999999)\nn = int(input())\narr = list(map(int, input().split()))\ns = set()\nq = collections.deque()\nq.append([arr, 0])\nwhile q:\n    (aas, cnt) = q.popleft()\n    if aas[0] == 1:\n        if aas == list(range(1, 2 * n + 1)):\n            print(cnt)\n        else:\n            print(-1)\n        break\n    if aas[0] in s:\n        continue\n    s.add(aas[0])\n    at1 = aas[n:] + aas[:n]\n    q.append([at1, cnt + 1])\n    at2 = [0] * (2 * n)\n    (at2[0::2], at2[1::2]) = (aas[1::2], aas[0::2])\n    q.append([at2, cnt + 1])\nelse:\n    print(-1)", "def jum(x, n):\n    for i in range(0, n, 2):\n        p = x[i]\n        x[i] = x[i + 1]\n        x[i + 1] = p\n    return x\n\ndef shift(x, n):\n    x = x[n // 2:] + x[:n // 2]\n    return x\nn = int(input())\na = list(map(int, input().split()))\nreq = list(range(1, 2 * n + 1))\nif n % 2 == 0:\n    k = 4\nelse:\n    k = 2 * n\ni = 0\nwhile i < k and a != req:\n    if i & 1 == 1:\n        a = shift(a, 2 * n)\n    else:\n        a = jum(a, 2 * n)\n    i = i + 1\nif a == req:\n    print(min(i, k - i))\nelse:\n    print(-1)", "import sys\nimport math\nfrom math import factorial, inf, gcd\nfrom heapq import *\nfrom functools import *\nfrom itertools import *\nfrom collections import *\nfrom typing import *\nfrom bisect import *\nimport random\nsys.setrecursionlimit(10 ** 5)\n\ndef rarray():\n    return [int(i) for i in input().split()]\n\ndef is_sorted(a):\n    for i in range(1, len(a)):\n        if a[i] <= a[i - 1]:\n            return False\n    return True\n\ndef g1(a):\n    ans = []\n    for i in range(0, len(a), 2):\n        ans.append(a[i + 1])\n        ans.append(a[i])\n    return ans\n\ndef g2(a):\n    n = len(a) // 2\n    return a[n:] + a[:n]\n\ndef f1(a, f):\n    for i in range(1000):\n        if f:\n            a = g1(a)\n        else:\n            a = g2(a)\n        if is_sorted(a):\n            return i + 1\n        f = not f\n    return inf\nt = 1\nfor ii in range(t):\n    n = int(input())\n    a = rarray()\n    if is_sorted(a):\n        print(0)\n    else:\n        ans = min(f1(a, True), f1(a, False))\n        print(ans if ans != inf else -1)", "import math as m\n\ndef p1(arr):\n    n = len(arr)\n    new = []\n    for i in range(0, n, 2):\n        new += [arr[i + 1], arr[i]]\n    return new\n\ndef p2(arr):\n    n = len(arr) // 2\n    return arr[n:] + arr[:n]\n\ndef isSorted(arr):\n    prev = arr[0]\n    for i in arr[1:]:\n        if i < prev:\n            return False\n        prev = i\n    return True\n\ndef logic(arr):\n    n = len(arr)\n    if isSorted(arr):\n        return 0\n    a = arr[:]\n    c = 0\n    while not isSorted(a):\n        if c == n:\n            c += 1\n            break\n        c += 1\n        a = p1(a)\n        if isSorted(a):\n            break\n        c += 1\n        a = p2(a)\n    d = 0\n    while not isSorted(arr):\n        if d == n:\n            d += 1\n            break\n        d += 1\n        arr = p2(arr)\n        if isSorted(arr):\n            break\n        d += 1\n        arr = p1(arr)\n    x = min(c, d)\n    if x > n:\n        return -1\n    return x\ninput()\narr = [int(x) for x in input().split()]\nprint(logic(arr))", "n = int(input())\nli = list(map(int, input().split()))\nsli = list(range(1, 2 * n + 1))\nans = float('inf')\nm = sli[-1]\nfor j in range(2):\n    ali = li[:]\n    cnt = 0\n    while ali[-1] != m:\n        if j:\n            for i in range(0, 2 * n, 2):\n                (ali[i], ali[i + 1]) = (ali[i + 1], ali[i])\n        else:\n            ali = ali[n:] + ali[:n]\n        j = not j\n        cnt += 1\n    if ali == sli:\n        ans = min(cnt, ans)\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)", "n = int(input())\nli = list(map(int, input().split()))\nsli = list(range(1, 2 * n + 1))\nans = float('inf')\nm = sli[-1]\nfor j in range(2):\n    ali = li[:]\n    cnt = 0\n    while ali[-1] != m:\n        if j:\n            for i in range(0, 2 * n, 2):\n                (ali[i], ali[i + 1]) = (ali[i + 1], ali[i])\n        else:\n            ali = ali[n:] + ali[:n]\n        j = not j\n        cnt += 1\n    if ali == sli:\n        ans = min(cnt, ans)\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in range(2):\n    b = list(a)\n    d = 0\n    while b[-1] != 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nm = 2 * n\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < m:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(m)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, m + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\na = (*map(int, input().split()),)\nc = 9000000000.0\nfor j in [0, 1]:\n    b = list(a)\n    d = 0\n    while b[-1] < 2 * n:\n        b = [b[n:] + b[:n], [b[i ^ 1] for i in range(0, 2 * n)]][j]\n        j ^= 1\n        d += 1\n    if b < list(range(1, 2 * n + 2)):\n        c = min(d, c)\nprint([-1, c][c < 9000000000.0])", "n = int(input())\nls = list(map(int, input().split()))\nideal = list(range(1, 2 * n + 1))\narr = [ideal]\nnew = []\nold = ideal\nj = 1\nwhile new != ideal:\n    if j % 2 == 0:\n        new = old[n:] + old[:n]\n        old = new\n        arr.append(new)\n        j += 1\n    else:\n        new = []\n        for i in range(0, n):\n            new.append(old[2 * i + 1])\n            new.append(old[2 * i])\n        old = new\n        arr.append(new)\n        j += 1\nif ls in arr:\n    if arr.index(ls) > len(arr) / 2:\n        print(len(arr) - arr.index(ls) - 1)\n    else:\n        print(arr.index(ls))\nelse:\n    print(-1)", "def ii():\n    return int(input())\n\ndef li():\n    return [int(i) for i in input().split()]\n\ndef op1(a, n):\n    for i in range(1, 2 * n, 2):\n        (a[i], a[i + 1]) = (a[i + 1], a[i])\n\ndef op2(a, n):\n    for i in range(1, n + 1):\n        (a[i], a[n + i]) = (a[n + i], a[i])\n\ndef check(a):\n    for i in range(1, len(a)):\n        if a[i] != i:\n            return 0\n    return 1\nn = ii()\na = li()\nb = [-1]\na.insert(0, -1)\nfor i in range(1, 2 * n + 1):\n    b.append(a[i])\nans = -1\nfor i in range(n + 1):\n    if check(a) == 1:\n        ans = i\n        break\n    if i % 2 == 0:\n        op1(a, n)\n    else:\n        op2(a, n)\nans1 = -1\nfor i in range(n + 1):\n    if check(b) == 1:\n        ans1 = i\n        break\n    if i % 2 == 1:\n        op1(b, n)\n    else:\n        op2(b, n)\nif ans == -1 and ans1 == -1:\n    print(-1)\nelif ans == -1 and ans1 != -1:\n    print(ans1)\nelif ans != -1 and ans1 == -1:\n    print(ans)\nelse:\n    print(min(ans, ans1))", "n = input()\nline = input()\nnums = line.split(' ')\n\ndef isSorted(arr):\n    lastNum = int(arr[0])\n    for i in arr:\n        if int(i) < lastNum:\n            return False\n        lastNum = int(i)\n    return True\n\ndef op1(arr):\n    for i in range(0, len(arr) - 1, 2):\n        temp = arr[i]\n        arr[i] = arr[i + 1]\n        arr[i + 1] = temp\n    return arr\n\ndef op2(arr):\n    n = int(len(arr) / 2)\n    return arr[n:] + arr[0:n]\ncount = 0\narr = nums[:]\nlast_op = 1\nis_sort = False\nfinal_count = 9999\nfor i in range(len(nums)):\n    if isSorted(arr):\n        is_sort = True\n        final_count = count\n        break\n    if last_op == 2:\n        arr = op1(arr)\n        last_op = 1\n        count += 1\n        continue\n    if last_op == 1:\n        arr = op2(arr)\n        last_op = 2\n    count += 1\ncount2 = 0\narr = nums[:]\nlast_op = 2\nfor i in range(len(nums)):\n    if isSorted(arr):\n        is_sort = True\n        final_count = min(count2, final_count)\n        break\n    if last_op == 2:\n        arr = op1(arr)\n        last_op = 1\n        count2 += 1\n        continue\n    if last_op == 1:\n        arr = op2(arr)\n        last_op = 2\n    count2 += 1\nif is_sort:\n    print(final_count)\nelse:\n    print(-1)", "def func(x, t, n):\n    if t == 1:\n        for i in range(0, 2 * n - 1, 2):\n            (x[i], x[i + 1]) = (x[i + 1], x[i])\n    if t == 2:\n        x = x[n:] + x[:n]\n    return x\nfor u in range(1):\n    n = int(input())\n    x = [int(w) for w in input().split()]\n    y = sorted(x)\n    z = x[:]\n    w = x[:]\n    if x == y:\n        print(0)\n    else:\n        if n % 2:\n            s = 2 * n\n        else:\n            s = 4\n        t = 1\n        f = False\n        a1 = 0\n        for i in range(s):\n            a1 += 1\n            if t == 1:\n                x = func(x, t, n)\n                t = 2\n            else:\n                x = func(x, t, n)\n                t = 1\n            if x == z:\n                a1 = -1\n                f = True\n                break\n            if x == y:\n                break\n        t = 2\n        f = False\n        a2 = 0\n        for i in range(s):\n            a2 += 1\n            if t == 1:\n                w = func(w, t, n)\n                t = 2\n            else:\n                w = func(w, t, n)\n                t = 1\n            if w == z:\n                a2 = -1\n                f = True\n                break\n            if w == y:\n                break\n        print(min(a1, a2))", "def doOpt1(lst, n):\n    for i in range(0, 2 * n, 2):\n        (lst[i], lst[i + 1]) = (lst[i + 1], lst[i])\n\ndef doOpt2(lst, n):\n    for i in range(n):\n        (lst[i], lst[i + n]) = (lst[i + n], lst[i])\nn = int(input())\ntheList = list(map(int, input().split()))\nsortedList = [i + 1 for i in range(2 * n)]\nans = float('inf')\nfor opt in range(2):\n    step = 0\n    temList = theList[:]\n    while temList[-1] != sortedList[-1]:\n        if opt:\n            doOpt1(temList, n)\n        else:\n            doOpt2(temList, n)\n        opt = not opt\n        step += 1\n    if temList == sortedList:\n        ans = min(ans, step)\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)", "def getNum(nums):\n    return int(''.join(map(str, nums)))\n\ndef op1(n, nums):\n    for i in range(0, 2 * n, 2):\n        (nums[i], nums[i + 1]) = (nums[i + 1], nums[i])\n    return nums\n\ndef op2(n, nums):\n    for i in range(0, n, 1):\n        (nums[i], nums[i + n]) = (nums[i + n], nums[i])\n    return nums\n\ndef solve(n, nums):\n    moves = 0\n    sortedNums = sorted(nums[:])\n    list1 = nums[:]\n    list2 = nums[:]\n    while list1[:] != sortedNums and list2 != sortedNums:\n        list1 = op1(n, list1[:])\n        list2 = op2(n, list2[:])\n        moves += 1\n        if list1[:] == sortedNums or list2[:] == sortedNums:\n            break\n        list1 = op2(n, list1[:])\n        list2 = op1(n, list2[:])\n        moves += 1\n        if moves > n:\n            return -1\n    return moves\nt = int(input())\nts = list(map(int, input().split(' ')))\nprint(solve(t, ts))", "def op1(thelist, n):\n    for i in range(0, 2 * n - 1, 2):\n        temp = thelist[i + 1]\n        thelist[i + 1] = thelist[i]\n        thelist[i] = temp\n    return thelist\n\ndef op2(thelist, n):\n    for i in range(n):\n        temp2 = thelist[i]\n        thelist[i] = thelist[n + i]\n        thelist[n + i] = temp2\n    return thelist\nnum = int(input())\nmylist = list(map(int, input().split()))\nsortedlist = list(range(1, 2 * num + 1))\nfirst = mylist.copy()\nsecond = mylist.copy()\nsteps = 0\nif mylist == sortedlist:\n    print(0)\nelse:\n    while steps < num:\n        first = op1(first, num)\n        second = op2(second, num)\n        (first, second) = (second, first)\n        steps += 1\n        if first == sortedlist or second == sortedlist:\n            print(steps)\n            steps = num + 1\n    if steps == num:\n        print(-1)", "n = int(input())\ny = list(map(int, input().split()))\nl = y\na = 0\nx = 0\nflag = 0\nwhile x <= 2 * n:\n    if l == sorted(l):\n        a = 1\n        break\n    if flag == 0:\n        t = []\n        for i in range(1, 2 * n, 2):\n            t.append(l[i])\n            t.append(l[i - 1])\n        flag = 1\n        l = t\n        x += 1\n    else:\n        b = l[:n]\n        c = l[n:]\n        l = c + b\n        flag = 0\n        x += 1\nif a == 0:\n    print(-1)\nelse:\n    l = y\n    a = 0\n    x1 = 0\n    flag = 0\n    while x1 <= 2 * n:\n        if l == sorted(l):\n            print(min(x1, x))\n            a = 1\n            break\n        if flag == 1:\n            t = []\n            for i in range(1, 2 * n, 2):\n                t.append(l[i])\n                t.append(l[i - 1])\n            flag = 0\n            l = t\n            x1 += 1\n        else:\n            b = l[:n]\n            c = l[n:]\n            l = c + b\n            flag = 1\n            x1 += 1", "def op1(n, array):\n    for x in range(n):\n        (array[2 * x], array[2 * x + 1]) = (array[2 * x + 1], array[2 * x])\n\ndef op2(n, array):\n    for x in range(n):\n        (array[x], array[n + x]) = (array[n + x], array[x])\n\ndef kingsTask(n, array):\n    ans = sorted(array)\n    if ans == array:\n        return 0\n    if n % 2 == 0:\n        f = 0\n        arri = array.copy()\n        for x in range(3):\n            if x % 2 == 0:\n                op1(n, array)\n            else:\n                op2(n, array)\n            if array == ans:\n                f = 1\n                break\n        for y in range(3):\n            if y % 2 == 0:\n                op2(n, arri)\n            else:\n                op1(n, arri)\n            if arri == ans:\n                f = 1\n                break\n        if f == 1:\n            return min(x, y) + 1\n        return -1\n    else:\n        for x in range(2 * n - 1):\n            if x % 2 == 0:\n                op1(n, array)\n            else:\n                op2(n, array)\n            if array == ans:\n                return min(x + 1, 2 * n - (x + 1))\n        return -1\nn = int(input())\nl = list(map(int, input().split()))\nprint(kingsTask(n, l))", "def op1(l, n):\n    for i in range(n):\n        (l[2 * i], l[2 * i + 1]) = (l[2 * i + 1], l[2 * i])\n    return l\n\ndef op2(l, n):\n    for i in range(n):\n        (l[i], l[n + i]) = (l[n + i], l[i])\n    return l\nn = int(input())\nperms = [int(x) for x in input().split(' ')]\nsorted_p = list(range(1, 2 * n + 1))\nans = 0\nfound = False\nis_1 = True\ntmp = perms.copy()\nfor _ in range(2 * n):\n    if sorted_p == tmp:\n        found = True\n        break\n    tmp = op1(tmp, n) if is_1 else op2(tmp, n)\n    is_1 = not is_1\n    ans += 1\nif not found:\n    print(-1)\nelse:\n    new_ans = 0\n    is_1 = False\n    tmp = perms.copy()\n    for _ in range(2 * n):\n        if sorted_p == tmp:\n            break\n        tmp = op1(tmp, n) if is_1 else op2(tmp, n)\n        is_1 = not is_1\n        new_ans += 1\n    print(min(ans, new_ans))", "import copy\nn = int(input())\nA = list(map(int, input().split()))\nG = sorted(A)\n\ndef change1(A):\n    for i in range(n):\n        j = 2 * i\n        a = A[j]\n        b = A[j + 1]\n        A[j] = b\n        A[j + 1] = a\n    return A\n\ndef change2(A):\n    a = A[0:n]\n    b = A[n:]\n    A[0:n] = b\n    A[n:] = a\n    return A\nA2 = copy.copy(A)\ncount1 = 0\nfor i in range(1000):\n    A3 = change1(A2)\n    count1 += 1\n    if A3 == G:\n        break\n    A4 = change2(A3)\n    count1 += 1\n    if A4 == G:\n        break\n    A2 = A4\nA2 = copy.copy(A)\ncount2 = 0\nfor i in range(1000):\n    A3 = change2(A2)\n    count2 += 1\n    if A3 == G:\n        break\n    A4 = change1(A3)\n    count2 += 1\n    if A4 == G:\n        break\n    A2 = A4\nif A == G:\n    print(0)\nelif A2 != G:\n    print(-1)\nelse:\n    print(min(count1, count2))", "import sys\nread = sys.stdin.readline\nn = int(input())\na = [int(_) for _ in read().split()]\nbound = 1000 * 2 + 1\ninf = 10 ** 10\n\ndef solve(a):\n    init = a[:]\n    i = 0\n    while True:\n        if a == list(range(1, 2 * n + 1)):\n            return i\n        if i % 2 == 0:\n            for j in range(0, 2 * n, 2):\n                (a[j], a[j + 1]) = (a[j + 1], a[j])\n        else:\n            a = a[n:] + a[:n]\n        if a == init:\n            return inf\n        i += 1\n    return inf\nans = min(solve(a[:]), 1 + solve(a[n:] + a[:n]))\nif ans >= inf:\n    ans = -1\nprint(ans)", "input()\nn = [int(n, 0) for n in input().split()]\nm = n[:]\non = n[:]\nm.sort()\ncount = -1\nsize = 0\n\ndef same(m, n):\n    for i in range(len(m)):\n        if m[i] != n[i]:\n            return False\n    return True\n\ndef swap(l, mode=0):\n    if mode == 0:\n        for i in range(0, len(l), 2):\n            t = l[i]\n            l[i] = l[i + 1]\n            l[i + 1] = t\n    else:\n        for i in range(0, len(l) // 2):\n            t = l[i]\n            l[i] = l[len(l) // 2 + i]\n            l[len(l) // 2 + i] = t\nwhile True:\n    if count == -1 and same(m, n):\n        count = size\n    swap(n, size & 1)\n    size += 1\n    if same(on, n):\n        break\nif count < 0:\n    print(-1)\nelse:\n    print(min(size - count, count))", "def pare_reverse(m, n):\n    for i in range(n):\n        (m[2 * i], m[2 * i + 1]) = (m[2 * i + 1], m[2 * i])\n\ndef half_reverse(m, n):\n    for i in range(n):\n        (m[i], m[n + i]) = (m[n + i], m[i])\nn = int(input())\nm = list(map(int, input().split()))\nm_copy = [m[i] for i in range(len(m))]\nm_copy_2 = [m[i] for i in range(len(m))]\ns = sorted(m)\ni = 0\nwhile m_copy != s:\n    if i % 2 == 0:\n        pare_reverse(m_copy, n)\n    else:\n        half_reverse(m_copy, n)\n    i += 1\n    if m_copy == m:\n        print(-1)\n        exit()\nj = 0\nwhile m_copy_2 != s:\n    if j % 2 == 0:\n        half_reverse(m_copy_2, n)\n    else:\n        pare_reverse(m_copy_2, n)\n    j += 1\nprint(min(i, j))", "n = int(input())\nl = list(map(int, input().split()))\nsorted_l = sorted(l)\n\ndef swap(arr):\n    swapped = []\n    for i in range(0, 2 * n, 2):\n        swapped.append(arr[i + 1])\n        swapped.append(arr[i])\n    return swapped\n\ndef realoc(arr):\n    realoc = []\n    for i in range(0, 2 * n):\n        realoc.append(arr[(i + n) % (2 * n)])\n    return realoc\nif l == sorted_l:\n    print(0)\nelse:\n    count_swap = count_realoc = 0\n    arr = swap(l)\n    flag_swap = False\n    while True:\n        count_swap += 1\n        if arr == sorted_l:\n            break\n        if arr == l:\n            count_swap = -1\n            break\n        if flag_swap:\n            arr = swap(arr)\n        else:\n            arr = realoc(arr)\n        flag_swap = not flag_swap\n    if count_swap != -1:\n        arr = realoc(l)\n        flag_realoc = False\n        while True:\n            count_realoc += 1\n            if arr == sorted_l:\n                break\n            if flag_realoc:\n                arr = realoc(arr)\n            else:\n                arr = swap(arr)\n            flag_realoc = not flag_realoc\n    print(min(count_swap, count_realoc))", "def swap1(l):\n    for i in range(0, len(l), 2):\n        a = l[i]\n        l[i] = l[i + 1]\n        l[i + 1] = a\n\ndef swap2(l):\n    for i in range(0, len(l) // 2):\n        a = l[i]\n        l[i] = l[i + len(l) // 2]\n        l[i + len(l) // 2] = a\nn = int(input())\nl = list(map(int, input().split()))\noriginal = l.copy()\ns = l.copy()\ns.sort()\ncount = 0\nwhile True:\n    if s == l:\n        break\n    swap2(l)\n    count += 1\n    if original == l:\n        print('-1')\n        count = -1\n        break\n    if s == l:\n        break\n    swap1(l)\n    count += 1\n    if original == l:\n        print('-1')\n        count = -1\n        break\nc = 0\nl = original.copy()\nif count == -1:\n    exit(0)\nwhile True:\n    if s == l:\n        break\n    swap1(l)\n    c += 1\n    if original == l:\n        print('-1')\n        break\n    if s == l:\n        break\n    swap2(l)\n    c += 1\n    if original == l:\n        print('-1')\n        break\nprint(min(count, c))", "n = int(input())\narr = list(map(int, input().split()))\nsteps = 2 * n if n % 2 else 4\nans = -1\nfor i in range(steps):\n    if arr == sorted(arr):\n        ans = i\n        break\n    if i % 2:\n        for j in range(0, n):\n            (arr[j], arr[j + n]) = (arr[j + n], arr[j])\n    else:\n        for j in range(0, 2 * n, 2):\n            (arr[j], arr[j + 1]) = (arr[j + 1], arr[j])\nprint(min(ans, steps - ans))", "n = int(input())\nm = list(map(int, input().split()))\nms = sorted(m)\nk = n\ncount0 = 0\ncount1 = 0\nm1 = m.copy()\nwhile k > 0:\n    if m != ms:\n        ppp = 0\n        if m == ms:\n            break\n        for i in range(0, 2 * n, 2):\n            (m[i], m[i + 1]) = (m[i + 1], m[i])\n        count0 += 1\n        if m == ms:\n            break\n        m = m[n:] + m[:n]\n        count0 += 1\n        if m == ms:\n            break\n        m1 = m1[n:] + m1[:n]\n        count1 += 1\n        if m1 == ms:\n            break\n        for i in range(0, 2 * n, 2):\n            (m1[i], m1[i + 1]) = (m1[i + 1], m1[i])\n        count1 += 1\n        if m1 == ms:\n            break\n    else:\n        break\n    k -= 1\nif m == ms:\n    print(count0)\nelif m1 == ms:\n    print(count1)\nelse:\n    print(-1)", "from sys import stdin\nfrom copy import deepcopy\n\ndef solve():\n    var_1 = deepcopy(mas)\n    var_2 = deepcopy(mas)\n    ans = float('inf') if ans_mas != mas else 0\n    for i in range(1, 2 * n + 1):\n        for j in range(0, 2 * n, 2):\n            (var_1[j], var_1[j + 1]) = (var_1[j + 1], var_1[j])\n        for j in range(n):\n            (var_2[j], var_2[n + j]) = (var_2[n + j], var_2[j])\n        if var_1 == ans_mas or var_2 == ans_mas:\n            ans = min(ans, i)\n        (var_1, var_2) = (var_2, var_1)\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\nn = int(stdin.readline())\nmas = [int(s) for s in stdin.readline().split()]\nans_mas = sorted(mas)\nsolve()", "from collections import defaultdict\nimport bisect\nimport sys\nimport math\nimport os\nimport random\nimport re\n\ndef load_sys():\n    return sys.stdin.readlines()\n\ndef load_local():\n    with open('input.txt', 'r') as f:\n        input = f.readlines()\n    return input\n\ndef type1(n, arr):\n    ans = []\n    for i in range(0, 2 * n, 2):\n        ans.append(arr[i + 1])\n        ans.append(arr[i])\n    return ans\n\ndef type2(n, arr):\n    return arr[n:] + arr[:n]\n\ndef f(n, arr):\n    if arr == sorted(arr):\n        return 0\n    ans = 1 << 32\n    mx = 4 if n % 2 == 0 else 2 * n\n    A = arr[:]\n    for i in range(mx):\n        A = type1(n, A) if i % 2 == 0 else type2(n, A)\n        if A == sorted(A):\n            ans = min(ans, i + 1)\n    A = arr[:]\n    for i in range(mx):\n        A = type2(n, A) if i % 2 == 0 else type1(n, A)\n        if A == sorted(A):\n            ans = min(ans, i + 1)\n    return ans if ans != 1 << 32 else -1\ninput = load_sys()\n(n, arr) = (int(input[0]), [int(x) for x in input[1].split(' ')])\nprint(f(n, arr))", "import copy\nn = int(input())\nl = list(map(int, input().split()))\nls = sorted(l)\nla = l.copy()\ncnt = 0\nwhile l != ls:\n    if cnt >= max(2 * n, 4):\n        print(-1)\n        break\n    elif l[0] < l[n]:\n        for i in range(0, 2 * n, 2):\n            a = l[i]\n            b = l[i + 1]\n            l[i] = b\n            l[i + 1] = a\n        cnt += 1\n    else:\n        for i in range(n):\n            a = l[i]\n            b = l[n + i]\n            l[i] = b\n            l[i + n] = a\n        cnt += 1\nelse:\n    print(cnt)", "def op1(arra, n):\n    for i in range(0, 2 * n, 2):\n        (arra[i], arra[i + 1]) = (arra[i + 1], arra[i])\n\ndef op2(arra, n):\n    for j in range(n):\n        (arra[j], arra[j + n]) = (arra[j + n], arra[j])\nn = int(input())\nar = list(map(int, input().split()))\narr1 = [i for i in range(1, 2 * n + 1)]\narr2 = [i for i in range(1, 2 * n + 1)]\ncount = 0\ntest = True\nfor i in range(2 * n):\n    if ar == arr1 or ar == arr2:\n        print(count)\n        break\n    if test:\n        op1(arr1, n)\n        op2(arr2, n)\n        test = not test\n    else:\n        op1(arr2, n)\n        op2(arr1, n)\n        test = not test\n    count += 1\nelse:\n    print(-1)", "import sys\nread = sys.stdin.readline\nn = int(input())\na = [int(_) for _ in read().split()]\ninf = 10 ** 10\n\ndef solve(a):\n    init = a[:]\n    i = 0\n    while 1:\n        if a == list(range(1, 2 * n + 1, 1)):\n            return i\n        if i % 2 == 0:\n            for j in range(n):\n                (a[2 * j], a[2 * j + 1]) = (a[2 * j + 1], a[2 * j])\n        else:\n            a = a[n:] + a[:n]\n        if a == init:\n            return inf\n        i += 1\n    return inf\nans = min(solve(a[:]), 1 + solve(a[n:] + a[:n]))\nif ans >= inf:\n    ans = -1\nprint(ans)", "def op1(arr, n):\n    for i in range(0, 2 * n, 2):\n        (arr[i], arr[i + 1]) = (arr[i + 1], arr[i])\n\ndef op2(arr, n):\n    for i in range(n):\n        (arr[i], arr[i + n]) = (arr[i + n], arr[i])\nn = int(input())\narr = [int(d) for d in input().split(' ')]\narr1 = [i + 1 for i in range(2 * n)]\narr2 = [i + 1 for i in range(2 * n)]\nb = True\nstep = 0\nfor i in range(2 * n):\n    if arr1 == arr or arr2 == arr:\n        print(min(step, 2 * n - step))\n        exit()\n    if b:\n        op1(arr1, n)\n        op2(arr2, n)\n        b = not b\n    else:\n        op1(arr2, n)\n        op2(arr1, n)\n        b = not b\n    step += 1\nprint(-1)", "def check(l):\n    for i in range(2 * n):\n        if l[i] != i + 1:\n            return 0\n    return 1\nn = int(input())\no = tuple(map(int, input().split()))\nl = list(o)\nk = 0\nflag = 0\nwhile k <= n:\n    if check(l):\n        break\n    else:\n        k += 1\n        if flag == 0:\n            for i in range(n):\n                t = l[i]\n                l[i] = l[i + n]\n                l[i + n] = t\n            flag = 1\n        else:\n            for i in range(0, 2 * n, 2):\n                t = l[i]\n                l[i] = l[i + 1]\n                l[i + 1] = t\n            flag = 0\nans = -1\nif check(l):\n    ans = k\nl = list(o)\nk = 0\nflag = 1\nwhile k <= n + 1:\n    if check(l):\n        break\n    else:\n        k += 1\n        if flag == 0:\n            for i in range(n):\n                t = l[i]\n                l[i] = l[i + n]\n                l[i + n] = t\n            flag = 1\n        else:\n            for i in range(0, 2 * n, 2):\n                t = l[i]\n                l[i] = l[i + 1]\n                l[i + 1] = t\n            flag = 0\nif check(l) == 0 and ans == -1:\n    print(-1)\nelif check(l) == 0:\n    print(ans)\nelif ans == -1:\n    print(k)\nelse:\n    print(min(ans, k))", "def op1(arr, n):\n    for i in range(0, 2 * n, 2):\n        (arr[i], arr[i + 1]) = (arr[i + 1], arr[i])\n\ndef op2(arr, n):\n    for i in range(n):\n        (arr[i], arr[i + n]) = (arr[i + n], arr[i])\nn = int(input())\narr = [int(d) for d in input().split(' ')]\narr1 = [i + 1 for i in range(2 * n)]\narr2 = [i + 1 for i in range(2 * n)]\nb = True\nstep = 0\nfor i in range(2 * n):\n    if arr1 == arr or arr2 == arr:\n        print(step)\n        exit()\n    if b:\n        op1(arr1, n)\n        op2(arr2, n)\n        b = not b\n    else:\n        op1(arr2, n)\n        op2(arr1, n)\n        b = not b\n    step += 1\nprint(-1)", "import math, sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\ninp_arr = list(map(int, input().split()))\nx = [i for i in inp_arr]\ny = [i for i in inp_arr]\n\ndef verify(arr):\n    for i in range(1, 2 * n):\n        if arr[i] < arr[i - 1]:\n            return False\n    return True\n\ndef helper(arr, flag, allo):\n    if verify(arr):\n        return 0\n    elif arr == x:\n        if allo == 1:\n            return math.inf\n        allo += 1\n    if flag:\n        for i in range(n):\n            (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n    else:\n        for i in range(0, 2 * n, 2):\n            (arr[i], arr[i + 1]) = (arr[i + 1], arr[i])\n    return 1 + helper(arr, 1 - flag, allo)\nx = min(helper(inp_arr, 0, 0), helper(y, 1, 0))\nprint(-1) if x == math.inf else print(x)", "n = int(input())\nb = list(map(int, input().split()))\nc = sorted(b)\nr = 0\nwhile b != c:\n    if r > 3 * n:\n        r = -1\n        break\n    elif b[0] < b[n]:\n        for i in range(0, 2 * n, 2):\n            (b[i], b[i + 1]) = (b[i + 1], b[i])\n        r += 1\n    else:\n        for i in range(0, n):\n            (b[i], b[n + i]) = (b[n + i], b[i])\n        r += 1\nprint(r)", "def sorted(permutation):\n    for i in range(0, len(permutation) - 1):\n        if permutation[i] > permutation[i + 1]:\n            return False\n    return True\n\ndef move1(permutation):\n    result = [0] * len(permutation)\n    for i in range(0, len(permutation), 2):\n        result[i] = permutation[i + 1]\n        result[i + 1] = permutation[i]\n    return result\n\ndef move2(permutation):\n    n = len(permutation)\n    result = [0] * n\n    m = n // 2\n    for i in range(0, m):\n        result[i] = permutation[m + i]\n        result[m + i] = permutation[i]\n    return result\n\ndef search(permutation, n=0):\n    sort = permutation\n    for i in range(n, len(permutation)):\n        if sorted(sort):\n            return i\n        elif i % 2 == 0:\n            sort = move1(sort)\n        else:\n            sort = move2(sort)\n    return -1\n\ndef main(permutation):\n    res1 = search(permutation, n=0)\n    res2 = search(permutation, n=1)\n    if res2 > 0:\n        res2 -= 1\n    if res1 < 0 and res2 < 0:\n        return -1\n    if res1 < 0 or res2 < 0:\n        return max(res1, res2)\n    else:\n        return min(res1, res2)\nimport sys\nfor line in sys.stdin:\n    numbers = [int(x) for x in line.rstrip().split()]\nprint(main(numbers))", "import math\nfrom collections import *\nimport math\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    if a == sorted(a):\n        print(0)\n        return\n    b = a.copy()\n    (c, d) = (0, 0)\n    for i in range(max(2 * n, 4)):\n        if i % 2 == 0:\n            for j in range(0, 2 * n - 1, 2):\n                (b[j], b[j + 1]) = (b[j + 1], b[j])\n        else:\n            for j in range(n):\n                (b[j], b[n + j]) = (b[n + j], b[j])\n        if b == sorted(b):\n            c = i + 1\n            break\n    b = a.copy()\n    for i in range(max(2 * n, 4)):\n        if i % 2 != 0:\n            for j in range(0, 2 * n - 1, 2):\n                (b[j], b[j + 1]) = (b[j + 1], b[j])\n        else:\n            for j in range(n):\n                (b[j], b[n + j]) = (b[n + j], b[j])\n        if b == sorted(b):\n            d = i + 1\n            break\n    if c == 0 and d == 0:\n        print(-1)\n    else:\n        print(min(c, d))\nsolve()", "def big_swap(num: list):\n    return num[len(num) // 2:] + num[:len(num) // 2]\n\ndef alt_swap(num: list):\n    alt_num = num.copy()\n    for i in range(0, len(alt_num) - 1, 2):\n        (alt_num[i], alt_num[i + 1]) = (alt_num[i + 1], alt_num[i])\n    return alt_num\nn = int(input())\nnums = list(map(int, input().split()))\ncount_a = 0\ncount_b = 0\ncopy_nums = nums.copy()\nref_nums = nums.copy()\nwhile copy_nums != sorted(copy_nums):\n    if copy_nums == sorted(ref_nums):\n        break\n    copy_nums = big_swap(copy_nums)\n    count_b += 1\n    if copy_nums == sorted(copy_nums):\n        break\n    if copy_nums == ref_nums:\n        count_b = -1\n        break\n    copy_nums = alt_swap(copy_nums)\n    count_b += 1\n    if copy_nums == sorted(copy_nums):\n        break\n    if copy_nums == ref_nums:\n        count_b = -1\n        break\nwhile nums != sorted(nums):\n    if nums == sorted(ref_nums):\n        break\n    nums = alt_swap(nums)\n    count_a += 1\n    if nums == sorted(nums):\n        break\n    if nums == ref_nums:\n        count_b = -1\n        break\n    nums = big_swap(nums)\n    count_a += 1\n    if nums == sorted(nums):\n        break\n    if nums == ref_nums:\n        count_b = -1\n        break\nprint(min(count_a, count_b))", "import sys\n\ndef p1(ls):\n    for i in range(1, n + 1):\n        temp = ls[2 * i - 1]\n        ls[2 * i - 1] = ls[2 * i - 2]\n        ls[2 * i - 2] = temp\n    return ls\n\ndef p2(ls):\n    ls1 = ls[n:] + ls[0:n]\n    ls = ls1\n    return ls\n\ndef check(ls, flag):\n    if ls == sorted(ls):\n        flag = 1\n    return flag\nn = int(input())\nls = []\ncount = 0\nflag = 0\nls = list(map(int, input().split()))\nlsc = ls.copy()\nif check(ls, flag):\n    print(count)\n    sys.exit()\nwhile True:\n    ls = p1(ls)\n    count += 1\n    if check(ls, flag):\n        flag = check(ls, flag)\n        break\n    if ls == lsc:\n        break\n    ls = p2(ls)\n    count += 1\n    if check(ls, flag):\n        flag = check(ls, flag)\n        break\n    if ls == lsc:\n        break\ncount1 = count\ncount = 0\nflag1 = 0\nls.clear()\nls = lsc\nwhile True:\n    ls = p2(ls)\n    count += 1\n    if check(ls, flag1):\n        flag1 = check(ls, flag1)\n        break\n    if ls == lsc:\n        break\n    ls = p1(ls)\n    count += 1\n    if check(ls, flag1):\n        flag1 = check(ls, flag1)\n        break\n    if ls == lsc:\n        break\ncount2 = count\nif flag == 0 and flag1 == 0:\n    print(-1)\nelse:\n    print(min(count1, count2))", "n = input()\nasu1 = [int(k) for k in input().split()]\n\ndef op1(a):\n    for i in range(0, len(a), 2):\n        temp = a[i]\n        a[i] = a[i + 1]\n        a[i + 1] = temp\n    return a\n\ndef op2(a):\n    for i in range(0, len(a) // 2):\n        temp = a[i]\n        a[i] = a[i + len(a) // 2]\n        a[i + len(a) // 2] = temp\n    return a\n\ndef function(b, one):\n    l = 0\n    original = b.copy()\n    sorted = original.copy()\n    sorted.sort()\n    while b != sorted:\n        l += 1\n        if one:\n            b = op2(b)\n            one = False\n        else:\n            b = op1(b)\n            one = True\n        if b == original:\n            return -1\n    return l\n(c, d) = (function(asu1.copy(), False), function(asu1, True))\nif c == -1 and d == -1:\n    print(-1)\nelif c == -1:\n    print(d)\nelif d == -1:\n    print(c)\nelse:\n    print(min(c, d))", "n = int(input())\na = list(map(int, input().split()))\na1 = a[:]\n(c, x) = (0, 0)\nb = sorted(a)\nwhile a != b and c <= 2 * n:\n    if x == 0:\n        for i in range(0, 2 * n, 2):\n            (a[i], a[i + 1]) = (a[i + 1], a[i])\n        c += 1\n        x = 1\n    else:\n        for i in range(n):\n            (a[i], a[n + i]) = (a[n + i], a[i])\n        c += 1\n        x = 0\n(c1, x) = (0, 0)\nwhile a1 != b and c1 <= 2 * n:\n    if x == 0:\n        for i in range(n):\n            (a1[i], a1[n + i]) = (a1[n + i], a1[i])\n        c1 += 1\n        x = 1\n    else:\n        for i in range(0, 2 * n, 2):\n            (a1[i], a1[i + 1]) = (a1[i + 1], a1[i])\n        c1 += 1\n        x = 0\nif min(c, c1) < 2 * n:\n    print(min(c, c1))\nelse:\n    print(-1)", "n = int(input())\nmatriz = list(map(int, input().split()))\nlistaA = []\nlistaB = []\nfor i in range(n * 2):\n    listaA.append(i + 1)\n    listaB.append(i + 1)\nflag = True\ncounter = 0\nfor i in range(2 * n):\n    if matriz == listaA or matriz == listaB:\n        print(counter)\n        exit()\n    if flag == True:\n        for i in range(0, 2 * n, 2):\n            (listaA[i], listaA[i + 1]) = (listaA[i + 1], listaA[i])\n        for i in range(n):\n            (listaB[i], listaB[i + n]) = (listaB[i + n], listaB[i])\n        flag = not flag\n    else:\n        for i in range(0, 2 * n, 2):\n            (listaB[i], listaB[i + 1]) = (listaB[i + 1], listaB[i])\n        for i in range(n):\n            (listaA[i], listaA[i + n]) = (listaA[i + n], listaA[i])\n        flag = not flag\n    counter += 1\nprint(-1)", "def swap1(arr1):\n    for i in range(0, len(arr1) - 1, 2):\n        (arr1[i], arr1[i + 1]) = (arr1[i + 1], arr1[i])\n    return arr1\n\ndef swap2(arr):\n    for i in range(0, len(arr) // 2):\n        (arr[i], arr[i + len(arr) // 2]) = (arr[i + len(arr) // 2], arr[i])\n    return arr\nn = int(input())\nper = list(map(int, input().split()))\nper1 = [] + per\nmas = list(range(1, 2 * n + 1, 1))\ni = 0\nwhile per != mas and per1 != mas:\n    if i > 2 * n:\n        i = -1\n        break\n    if i % 2 == 0:\n        per = swap1(per)\n        per1 = swap2(per1)\n    else:\n        per = swap2(per)\n        per1 = swap1(per1)\n    i += 1\nprint(i)", "def sigma(x):\n    if x % 2 == 1:\n        return x + 1\n    else:\n        return x - 1\n\ndef tau(x, n):\n    if x <= n:\n        return x + n\n    if x > n:\n        return x - n\nn = int(input())\neingabe = [int(x) for x in input().split()]\nziel = sorted(eingabe)\nanzahl = []\nfor i in range(2 * n - 1):\n    durchlauf = 0\n    wert1 = eingabe[i]\n    wert2 = eingabe[i]\n    zielwert = ziel[i]\n    if wert1 == zielwert:\n        anzahl.append(0)\n    else:\n        while durchlauf < 2 * n:\n            durchlauf += 1\n            if durchlauf % 2 != 0:\n                wert1 = sigma(wert1)\n                wert2 = tau(wert2, n)\n            else:\n                wert1 = tau(wert1, n)\n                wert2 = sigma(wert2)\n            if wert1 == zielwert or wert2 == zielwert:\n                anzahl.append(durchlauf)\n                break\n        if wert1 != zielwert and wert2 != zielwert or (anzahl != [] and durchlauf != anzahl[0]):\n            print(str(-1))\n            anzahl = []\n            break\nif anzahl != []:\n    print(anzahl[0])", "def rec(copy, t):\n    count = 0\n    while copy != list(sorted(arr)):\n        if copy == arr and count:\n            return -1\n        if count % 2 == t:\n            for i in range(n):\n                (copy[i], copy[i + n]) = (copy[i + n], copy[i])\n        else:\n            for i in range(0, 2 * n, 2):\n                (copy[i], copy[i + 1]) = (copy[i + 1], copy[i])\n        count += 1\n    return count\nn = int(input())\narr = [int(x) for x in input().split()]\nres1 = rec(arr.copy(), 0)\nres2 = rec(arr.copy(), 1)\nif res1 > -1 and res2 > -1:\n    print(min(res1, res2))\nelse:\n    print(max(res1, res2))", "def main():\n    n = int(input())\n    list_p = list(map(int, input().split()))\n    result = sorted(list_p)\n    list_should_be_visited = [list_p]\n    list_dist = [0]\n    list_visited = list()\n    while len(list_should_be_visited) != 0:\n        permutation_current = list_should_be_visited.pop(0)\n        dist_current = list_dist.pop(0)\n        if permutation_current == result:\n            print(dist_current)\n            return\n        permutation_1 = [None for _ in range(2 * n)]\n        for i in range(n):\n            (permutation_1[2 * i], permutation_1[2 * i + 1]) = (permutation_current[2 * i + 1], permutation_current[2 * i])\n        permutation_2 = [None for _ in range(2 * n)]\n        for i in range(n):\n            (permutation_2[i], permutation_2[n + i]) = (permutation_current[n + i], permutation_current[i])\n        if permutation_1 == result or permutation_2 == result:\n            print(dist_current + 1)\n            return\n        else:\n            if permutation_1 not in list_visited and permutation_1 not in list_should_be_visited:\n                list_should_be_visited.append(permutation_1)\n                list_dist.append(dist_current + 1)\n            if permutation_2 not in list_visited and permutation_2 not in list_should_be_visited:\n                list_should_be_visited.append(permutation_2)\n                list_dist.append(dist_current + 1)\n        list_visited.append(permutation_current)\n    print(-1)\nmain()", "n = int(input())\na1 = [int(k) for k in input().split()]\nb = list(range(1, 2 * n + 1))\na2 = list(a1)\nz = 0\nif a1 == b:\n    print(0)\nelse:\n    for i in range(2 * n):\n        if a1 == b or a2 == b:\n            print(i)\n            break\n        else:\n            for j in range(n):\n                if i % 2 == 0:\n                    (a1[2 * j], a1[2 * j + 1]) = (a1[2 * j + 1], a1[2 * j])\n                    (a2[j], a2[n + j]) = (a2[n + j], a2[j])\n                else:\n                    (a2[2 * j], a2[2 * j + 1]) = (a2[2 * j + 1], a2[2 * j])\n                    (a1[j], a1[n + j]) = (a1[n + j], a1[j])\n    else:\n        print(-1)", "def sigma(x):\n    if x % 2 == 1:\n        return x + 1\n    else:\n        return x - 1\n\ndef tau(x, n):\n    if x <= n:\n        return x + n\n    if x > n:\n        return x - n\nn = int(input())\neingabe = [int(x) for x in input().split()]\nziel = sorted(eingabe)\nanzahl = []\nfor i in range(2 * n - 1):\n    durchlauf = 0\n    wert1 = eingabe[i]\n    wert2 = eingabe[i]\n    zielwert = ziel[i]\n    if wert1 == zielwert:\n        anzahl.append(0)\n    else:\n        while durchlauf < 2 * n:\n            durchlauf += 1\n            if durchlauf % 2 != 0:\n                wert1 = sigma(wert1)\n                wert2 = tau(wert2, n)\n            else:\n                wert1 = tau(wert1, n)\n                wert2 = sigma(wert2)\n            if wert1 == zielwert or wert2 == zielwert:\n                anzahl.append(durchlauf)\n                break\n        if wert1 != zielwert and wert2 != zielwert or (anzahl != [] and durchlauf != anzahl[0]):\n            print(str(-1))\n            anzahl = []\n            break\nif anzahl != []:\n    print(anzahl[0])", "n = int(input())\nl = list(map(int, input().split()))\nl1 = l.copy()\nl2 = l.copy()\n(c, c1) = (0, 0)\nans = 0\nf = True\nwhile l != l1 or f:\n    f = False\n    if l1 == sorted(l):\n        break\n    if c % 2 == 0:\n        for i in range(1, 2 * n, 2):\n            (l1[i], l1[i - 1]) = (l1[i - 1], l1[i])\n    else:\n        for i in range(n):\n            (l1[i], l1[n + i]) = (l1[n + i], l1[i])\n    c += 1\nf = True\nwhile l != l2 or f:\n    f = False\n    if l2 == sorted(l):\n        break\n    if c1 % 2 != 0:\n        for i in range(1, 2 * n, 2):\n            (l2[i], l2[i - 1]) = (l2[i - 1], l2[i])\n    else:\n        for i in range(n):\n            (l2[i], l2[n + i]) = (l2[n + i], l2[i])\n    c1 += 1\nif l == l1 and c != 0:\n    print(-1)\nelse:\n    print(min(c, c1))", "def swapA(B):\n    for i in range(0, 2 * n, 2):\n        swapval = B[i]\n        B[i] = B[i + 1]\n        B[i + 1] = swapval\n    return B\n\ndef swapB(C):\n    L = C[0:n]\n    C[0:n] = C[n:2 * n]\n    C[n:2 * n] = L\n    return C\nn = int(input())\narray = list(map(int, input().split()))\nA = [i for i in range(1, 2 * n + 1)]\nB = A[:]\ncount = 0\ncount1 = 0\nflag = False\nfor i in range(2 * 2 * n):\n    if A == array:\n        flag = True\n        break\n    A = swapA(A)\n    count += 1\n    if A == array:\n        flag = True\n        break\n    A = swapB(A)\n    count += 1\n    if A == array:\n        flag = True\n        break\nfor i in range(2 * 2 * n):\n    if B == array:\n        flag = True\n        break\n    B = swapB(B)\n    count1 += 1\n    if B == array:\n        flag = True\n        break\n    B = swapA(B)\n    count1 += 1\n    if B == array:\n        flag = True\n        break\ncnt = min(count, count1)\nif flag == False:\n    print(-1)\nelse:\n    print(cnt)", "n = int(input())\na1 = list(map(int, input().split()))\na2 = list(a1)\nb = list(range(1, 2 * n + 1))\nfor i in range(2 * n):\n    if a1 == b or a2 == b:\n        print(i)\n        break\n    for j in range(n):\n        if i % 2 == 0:\n            (a1[2 * j], a1[2 * j + 1]) = (a1[2 * j + 1], a1[2 * j])\n            (a2[j], a2[n + j]) = (a2[n + j], a2[j])\n        else:\n            (a2[2 * j], a2[2 * j + 1]) = (a2[2 * j + 1], a2[2 * j])\n            (a1[j], a1[n + j]) = (a1[n + j], a1[j])\nelse:\n    print(-1)", "def pone(a):\n    for i in range(0, len(a), 2):\n        (a[i], a[i + 1]) = (a[i + 1], a[i])\n    return a\n\ndef ptwo(a):\n    for i in range(0, len(a) // 2):\n        (a[i], a[len(a) // 2 + i]) = (a[len(a) // 2 + i], a[i])\n    return a\n\ndef onetwo(n, l):\n    for i in range(4 * n):\n        if i % 2 == 0:\n            l = pone(l)\n            if l == ans:\n                return i + 1\n        else:\n            l = ptwo(l)\n            if l == ans:\n                return i + 1\n    return -1\n\ndef twoone(n, l):\n    for i in range(4 * n):\n        if i % 2 == 0:\n            l = ptwo(l)\n            if l == ans:\n                return i + 1\n        else:\n            l = pone(l)\n            if l == ans:\n                return i + 1\n    return -1\nn = int(input())\nl = list(map(int, input().split()))\nans = [x for x in range(1, 2 * n + 1)]\nif ans == l:\n    print(0)\nelse:\n    ans1 = onetwo(n, l[:])\n    ans2 = twoone(n, l[:])\n    if ans1 == -1 or ans2 == -1:\n        print(-1)\n    else:\n        print(min(ans1, ans2))", "def check(a: list) -> bool:\n    return all([a[i] == i + 1 for i in range(len(a))])\n\ndef swapa(a: list, n: int):\n    for i in range(n):\n        (a[2 * i], a[2 * i + 1]) = (a[2 * i + 1], a[2 * i])\n\ndef swapb(a: list, n: int):\n    for i in range(n):\n        (a[i], a[i + n]) = (a[i + n], a[i])\n\ndef get_answera(a: list, n: int) -> int:\n    if check(a):\n        return 0\n    ans = 0\n    for i in range(2 * n):\n        if i & 1:\n            swapa(a, n)\n        else:\n            swapb(a, n)\n        ans += 1\n        if check(a):\n            return ans\n    return 2 * n + 1\n\ndef get_answerb(a: list, n: int) -> int:\n    if check(a):\n        return 0\n    ans = 0\n    for i in range(2 * n):\n        if i & 1:\n            swapb(a, n)\n        else:\n            swapa(a, n)\n        ans += 1\n        if check(a):\n            return ans\n    return 2 * n + 1\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    import copy\n    b = copy.deepcopy(a)\n    ans = min(get_answera(a, n), get_answerb(b, n))\n    if ans == 2 * n + 1:\n        ans = -1\n    print(ans)\nmain()", "n = int(input())\narr = map(int, input().split())\narr = list(arr)\narr2 = arr.copy()\ncount = 0\ncount2 = 0\nmax_steps = 0\nif n % 2 == 0:\n    max_steps = 4\nelse:\n    max_steps = 2 * n\nif arr != sorted(arr):\n    while arr != sorted(arr):\n        if count == max_steps:\n            count = -1\n            break\n        for i in range(0, 2 * n - 1, 2):\n            temp = arr[i]\n            arr[i] = arr[i + 1]\n            arr[i + 1] = temp\n        count += 1\n        if arr == sorted(arr):\n            break\n        for i in range(0, n):\n            temp = arr[i]\n            arr[i] = arr[i + n]\n            arr[i + n] = temp\n        count += 1\nif arr2 != sorted(arr):\n    while arr2 != sorted(arr2):\n        if count2 == max_steps:\n            count2 = -1\n            break\n        for i in range(0, n):\n            temp = arr2[i]\n            arr2[i] = arr2[i + n]\n            arr2[i + n] = temp\n        count2 += 1\n        if arr2 == sorted(arr):\n            break\n        for i in range(0, 2 * n - 1, 2):\n            temp = arr2[i]\n            arr2[i] = arr2[i + 1]\n            arr2[i + 1] = temp\n        count2 += 1\nif count <= count2:\n    print(count)\nelse:\n    print(count2)", "def op1(arr):\n    for i in range(0, 2 * n, 2):\n        aa = arr[i]\n        arr[i] = arr[i + 1]\n        arr[i + 1] = aa\n    k = ''.join(list(map(str, arr)))\n    if d.get(k) == None:\n        d[k] = 0\n        return True\n    else:\n        return False\n\ndef op2(arr):\n    for i in range(0, n):\n        aa = arr[i]\n        arr[i] = arr[i + n]\n        arr[i + n] = aa\n    k = ''.join(list(map(str, arr)))\n    if d.get(k) == None:\n        d[k] = 0\n        return True\n    else:\n        return False\nn = int(input())\narr = list(map(int, input().split()))\nar = [a for a in arr]\nbr = [a for a in arr]\na = 0\nd = {}\nar.sort()\nwhile ar != arr:\n    if op1(arr):\n        a += 1\n    else:\n        a = -1\n        break\n    if ar == arr:\n        break\n    if op2(arr):\n        a += 1\n    else:\n        a = -1\n        break\narr = [b for b in br]\nb = 0\nd = {}\nwhile ar != arr:\n    if op2(arr):\n        b += 1\n    else:\n        b = -1\n        break\n    if ar == arr:\n        break\n    if op1(arr):\n        b += 1\n    else:\n        b = -1\n        break\nif b == -1 and a == -1:\n    print(-1)\nelif b == -1 and a != -1:\n    print(a)\nelif a == -1 and b != -1:\n    print(b)\nelse:\n    print(min(a, b))"]