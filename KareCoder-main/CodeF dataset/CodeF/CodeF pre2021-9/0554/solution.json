["import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2 == 0:\n    s = 1\n    for x in a:\n        s |= s << x\n    if s & 1 << z // 2:\n        b = [x & -x for x in a]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2 == 0:\n    s = 1\n    for x in a:\n        s |= s << x\n    if s & 1 << z // 2:\n        b = [x & -x for x in a]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2 == 0:\n    s = 1\n    for x in a:\n        s |= s << x\n    if s & 1 << z // 2:\n        b = [x & -x for x in a]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2 == 0:\n    s = 1\n    for x in a:\n        s |= s << x\n    if s & 1 << z // 2:\n        b = [x & -x for x in a]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "I = input\nIN = lambda x: map(int, x.split())\nL = lambda x: list(IN(x))\nn = int(I())\na = L(I())\n\ndef find(a, n):\n    s = sum(a)\n    if s % 2 == 1:\n        print(0)\n        return\n    t = 1\n    for i in a:\n        t |= t << i\n    if t & 1 << s // 2:\n        pass\n    else:\n        print(0)\n        return\n    z = 0\n    p = 1024\n    for i in range(n):\n        t = a[i] & -a[i]\n        if t < p:\n            z = i\n            p = t\n            if p == 1:\n                break\n    print(1)\n    print(z + 1)\nfind(a, n)", "import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2 == 0:\n    s = 1\n    for x in a:\n        s |= s << x\n    if s & 1 << z // 2:\n        b = [x & -x for x in a]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "def highestPowerOf2(n):\n    return n & ~(n - 1)\n\ndef solve(a):\n    s = sum(a)\n    (q, r) = divmod(s, 2)\n    if r == 1:\n        return (0, 0)\n    else:\n        x = 1\n        for ai in a:\n            x |= x << ai\n        if not x >> q & 1:\n            return (0, 0)\n        else:\n            powers2 = [highestPowerOf2(ai) for ai in a]\n            return (1, powers2.index(min(powers2)))\nn = int(input())\na = list(map(int, input().split()))\nans = solve(a)\nprint(ans[0])\nif ans[0]:\n    print(ans[1] + 1)", "import sys\nn = int(input())\narray = [int(x) for x in input().split()]\nif sum(array) % 2 == 0:\n    s = 1\n    for i in array:\n        s |= s << i\n    if s & 1 << sum(array) // 2:\n        b = [x & -x for x in array]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "def bad(v):\n    global n\n    s = 0\n    for i in v:\n        s += i\n    if s % 2 != 0:\n        return 0\n    b = 2 ** 200005\n    for i in v:\n        b |= b >> i\n    r = b // 2 ** (200005 - s // 2) % 2\n    return r\npw = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\nn = int(input())\nm = [int(i) for i in input().split()]\nif bad(m):\n    mj = len(pw)\n    for i in range(len(m)):\n        if m[i] % 2 != 0:\n            t = i + 1\n            break\n        for j in range(mj):\n            if m[i] % pw[j] != 0:\n                if mj > j:\n                    mj = j\n                    t = i + 1\n    print(1, t, sep='\\n')\nelse:\n    print(0)", "import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2 == 0:\n    s = 1\n    for x in a:\n        s |= s << x\n    if s & 1 << z // 2:\n        b = [x & -x for x in a]\n        i = b.index(min(b))\n        print(f'1\\n{i + 1}')\n        sys.exit()\nprint(0)", "from functools import reduce\n\ndef canPartition(nums):\n    (target, r) = divmod(sum(nums), 2)\n    return r == 0 and reduce(lambda x, y: x << y | x, [1] + nums) >> target & 1\nn = int(input())\narr = [int(x) for x in input().split()]\nres = []\nwhile canPartition(arr):\n    tmp = []\n    tarr = arr\n    for i in range(n):\n        t = arr[:i] + arr[i + 1:]\n        if not canPartition(t):\n            tmp.append(i)\n    m = min(tmp)\n    arr = arr[:m] + arr[m + 1:]\n    res.append(m)\nif len(res) > 0:\n    print(len(res))\n    print(' '.join((str(x + 1) for x in res)))\nelse:\n    print('0')", "N = int(input())\naa = [int(x) for x in input().split()]\n\ndef get_max_pow2_factor(x):\n    result = 0\n    cur_a = x\n    while cur_a > 0 and cur_a % 2 == 0:\n        cur_a //= 2\n        result += 1\n    return result\nshared_pow2_factor = min([get_max_pow2_factor(x) for x in aa])\nif shared_pow2_factor > 0:\n    aa = [x // 2 ** shared_pow2_factor for x in aa]\nodd_a = None\nodd_a_index = None\nfor i in range(len(aa)):\n    if aa[i] % 2 != 0:\n        odd_a = aa[i]\n        odd_a_index = i\n        break\nif sum(aa) % 2 == 1:\n    print(0)\nelse:\n    sum_a = sum(aa)\n    target = sum_a // 2\n    aa = sorted(aa, key=lambda x: -x)\n    dp = set()\n    have_solution = False\n    for a in aa:\n        new_add = set()\n        for num in dp:\n            new_add.add(num + a)\n        new_add.add(a)\n        dp = dp | new_add\n        if target in dp:\n            have_solution = True\n            break\n    if have_solution:\n        print(1)\n        print(odd_a_index + 1)\n    else:\n        print(0)", "import sys\nn = int(input())\na = [int(x) for x in input().split()]\nz = sum(a)\nif z % 2:\n    print(0)\n    sys.exit()\ns = set([0])\nfor x in a:\n    s.update([t + x for t in s])\nif z // 2 not in s:\n    print(0)\n    sys.exit()\nb = [x & -x for x in a]\ni = b.index(min(b))\nprint(f'1\\n{i + 1}')", "def inp():\n    return [int(a) for a in input().split()]\n\ndef gcd(x, y):\n    if y:\n        return gcd(y, x % y)\n    else:\n        return x\n\ndef bad(array):\n    st = set()\n    st.add(0)\n    for i in array:\n        st1 = set()\n        for j in st:\n            st1.add(i + j)\n        st = st.union(st1)\n    if sum(array) // 2 in st:\n        return True\n    return False\nind = []\nn = int(input())\na = inp()\ng = a[0]\nfor i in range(1, n):\n    g = gcd(g, a[i])\nfor i in range(n):\n    a[i] //= g\nif sum(a) % 2 == 1:\n    print(0)\nelif bad(a):\n    for i in range(n):\n        if a[i] % 2:\n            print(1)\n            print(i + 1)\n            break\nelse:\n    print(0)", "import math\nn = int(input())\na = list(map(int, input().split()))\nd = math.gcd(a[0], a[1])\nfor i in range(2, len(a)):\n    d = math.gcd(d, a[i])\nfor i in range(len(a)):\n    a[i] //= d\ns = sum(a)\nif s % 2 == 1:\n    print(0)\nelse:\n    target = s // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for v in a:\n        for i in range(target, v - 1, -1):\n            dp[i] = dp[i] or dp[i - v]\n    if dp[target]:\n        j = 0\n        while a[j] % 2 == 0:\n            j += 1\n        print(1)\n        print(j + 1)\n    else:\n        print(0)", "def helper2(a, tar):\n    pool = [0] * 200005\n    pool[0] = 1\n    for i in range(len(a)):\n        child = []\n        for j in range(tar):\n            if pool[j] == 1:\n                child.append(j + a[i])\n        for c in child:\n            pool[c] = 1\n    return pool[tar] == 1\n\ndef helper(a):\n    if sum(a) % 2 == 1:\n        return -1\n    if helper2(a, sum(a) // 2):\n        while True:\n            for i in range(len(a)):\n                if a[i] % 2 == 1:\n                    return i\n                a[i] = a[i] // 2\n    else:\n        return -1\nn = int(input())\na = list(map(int, input().split(' ')))\nres = helper(a)\nif res == -1:\n    print(0)\n    print()\nelse:\n    print(1)\n    print(res + 1)", "import math\nn = int(input())\na = list(map(int, input().split()))\nd = math.gcd(a[0], a[1])\nfor i in range(2, len(a)):\n    d = math.gcd(d, a[i])\nfor i in range(len(a)):\n    a[i] //= d\ns = sum(a)\nif s % 2 == 1:\n    print(0)\nelse:\n    target = s // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for v in a:\n        for i in range(target, v - 1, -1):\n            dp[i] = dp[i] or dp[i - v]\n    if dp[target]:\n        j = 0\n        while a[j] % 2 == 0:\n            j += 1\n        print(1)\n        print(j + 1)\n    else:\n        print(0)", "def check(l):\n    for v in l:\n        if v % 2 == 1:\n            return False\n    else:\n        return True\n\ndef findTargetSumWays(nums):\n    sumAll = sum(nums)\n    if 0 > sumAll or (0 + sumAll) % 2:\n        return 0\n    target = (0 + sumAll) // 2\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] + dp[j - num]\n    return dp[-1]\n\ndef getResult(n, a_list):\n    while check(a_list):\n        a_list = [v // 2 for v in a_list]\n    if findTargetSumWays(a_list) == 0:\n        return (0, None)\n    for i in range(n):\n        if a_list[i] % 2 == 1:\n            return (1, i + 1)\nn = int(input())\na_list = [int(tt) for tt in input().split()]\n(r1, r2) = getResult(n, a_list)\nprint(r1)\nif r2:\n    print(r2)", "import math\nn = int(input())\na = list(map(int, input().split()))\nd = math.gcd(a[0], a[1])\nfor i in range(2, len(a)):\n    d = math.gcd(d, a[i])\nfor i in range(len(a)):\n    a[i] //= d\ns = sum(a)\nif s % 2 == 1:\n    print(0)\nelse:\n    target = s // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for v in a:\n        for i in range(target, v - 1, -1):\n            dp[i] = dp[i] or dp[i - v]\n    if dp[target]:\n        j = 0\n        while a[j] % 2 == 0:\n            j += 1\n        print(1)\n        print(j + 1)\n    else:\n        print(0)", "import math\nn = int(input())\na = list(map(int, input().split()))\nd = math.gcd(a[0], a[1])\nfor i in range(2, len(a)):\n    d = math.gcd(d, a[i])\nfor i in range(len(a)):\n    a[i] //= d\ns = sum(a)\nif s % 2 == 1:\n    print(0)\nelse:\n    target = s // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for v in a:\n        for i in range(target, v - 1, -1):\n            dp[i] = dp[i] or dp[i - v]\n    if dp[target]:\n        j = 0\n        while a[j] % 2 == 0:\n            j += 1\n        print(1)\n        print(j + 1)\n    else:\n        print(0)", "import math\nn = int(input())\na = list(map(int, input().split()))\nd = math.gcd(a[0], a[1])\nfor i in range(2, len(a)):\n    d = math.gcd(d, a[i])\nfor i in range(len(a)):\n    a[i] //= d\ns = sum(a)\nif s % 2 == 1:\n    print(0)\nelse:\n    target = s // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for v in a:\n        for i in range(target, v - 1, -1):\n            dp[i] = dp[i] or dp[i - v]\n    if dp[target]:\n        j = 0\n        while a[j] % 2 == 0:\n            j += 1\n        print(1)\n        print(j + 1)\n    else:\n        print(0)", "from functools import lru_cache\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n@lru_cache(None)\ndef subsetSum(curSum, totalSum, idx, array):\n    if idx >= len(array):\n        return False\n    if totalSum == 2 * curSum:\n        return True\n    if 2 * curSum > totalSum:\n        return False\n    withVal = subsetSum(curSum + array[idx], totalSum, idx + 1, array)\n    if withVal:\n        return True\n    withOutVal = subsetSum(curSum, totalSum, idx + 1, array)\n    return withOutVal\nn = int(input())\narray = tuple(map(int, input().split()))\ntotalSum = sum(array)\nif totalSum % 2 != 0 or not subsetSum(0, totalSum, 0, array):\n    print(0)\nelse:\n    for (idx, val) in enumerate(array):\n        if val % 2 != 0:\n            print(1)\n            print(idx + 1)\n            break\n    else:\n        ansIdx = 0\n        ansCount = float('inf')\n        for (idx, val) in enumerate(array):\n            count = 0\n            while val % 2 == 0:\n                count += 1\n                val = val / 2\n            if count < ansCount:\n                ansCount = count\n                ansIdx = idx\n        print(1)\n        print(ansIdx + 1)", "import math\nt = int(input())\na = list(map(int, input().split()))\nd = math.gcd(a[0], a[1])\nfor i in range(2, len(a)):\n    d = math.gcd(d, a[i])\nfor i in range(len(a)):\n    a[i] = a[i] // d\ntotal = sum(a)\nif total % 2 == 1:\n    print(0)\nelse:\n    target = total // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for v in a:\n        for i in range(target, v - 1, -1):\n            dp[i] = dp[i] or dp[i - v]\n    if dp[target]:\n        j = 0\n        while a[j] % 2 == 0:\n            j += 1\n        print(1)\n        print(j + 1)\n    else:\n        print(0)", "def findsubarr(s, n, e):\n    if n == 1:\n        return {0, e}\n    else:\n        p = list(findsubarr(s, n - 1, a[n - 2]))\n        q = set()\n        for x in range(len(p)):\n            sum1 = p[x] + 0\n            sum2 = p[x] + e\n            if sum1 <= s:\n                q.add(sum1)\n            if sum2 <= s:\n                q.add(sum2)\n        return q\nn = int(input())\na = list(map(int, input().split()))\nq = min(a)\ns = sum(a)\np = 1\nif s % 2 == 0:\n    if (s / 2 in findsubarr(int(s / 2), n, a[n - 1])) == False:\n        print(0)\n        exit()\nwhile True:\n    t = pow(2, p)\n    if s % t != 0:\n        print(0)\n        exit()\n    else:\n        for x in range(n):\n            if a[x] % t != 0:\n                print(1)\n                print(x + 1)\n                exit()\n        p = p + 1", "def check(arr):\n    n = sum(arr) // 2\n    dp = [0 for i in range(sum(arr) + 4)]\n    dp[0] = 1\n    for i in arr:\n        for j in range(len(dp) - 1, -1, -1):\n            if dp[j] == 1:\n                dp[i + j] = 1\n                if i + j == n:\n                    return True\n    if dp[n] == 1:\n        return True\n    return False\n\ndef answer(arr):\n    if sum(arr) % 2 != 0:\n        print(0)\n    else:\n        import math\n        n = sum(arr) // 2\n        dp = [0 for i in range(n + 1)]\n        if check(arr) == True:\n            d = math.gcd(arr[0], arr[1])\n            for i in range(2, len(arr)):\n                d = math.gcd(d, arr[i])\n            for i in range(len(arr)):\n                arr[i] //= d\n            j = 0\n            while j < len(arr):\n                if arr[j] % 2 != 0:\n                    break\n                j += 1\n            print(1)\n            if j < len(arr):\n                print(j + 1)\n            else:\n                print(j)\n        else:\n            print(0)\nn = int(input())\ninp = input().split()\narr = []\nfor i in inp:\n    arr.append(int(i))\nanswer(arr)", "import math\n\ndef calc(arr):\n    gc = arr[0]\n    for i in range(1, len(arr)):\n        gc = math.gcd(gc, arr[i])\n    return gc\n\ndef check(arr):\n    n = sum(arr) // 2\n    dp = [0 for i in range(sum(arr) + 4)]\n    dp[0] = 1\n    for i in arr:\n        for j in range(len(dp) - 1, -1, -1):\n            if dp[j] == 1:\n                dp[i + j] = 1\n                if i + j == n:\n                    return True\n    if dp[n] == 1:\n        return True\n    return False\nn = int(input())\narr = list(map(int, input().split()))\ngc = calc(arr)\nif sum(arr) % 2 == 0:\n    if check(arr) == False:\n        print(0)\n    else:\n        flag = 0\n        for i in range(n):\n            if arr[i] % 2 == 1:\n                print(1)\n                print(i + 1)\n                flag = 1\n                break\n        if flag == 0:\n            for i in range(n):\n                if arr[i] // gc % 2 == 1:\n                    print(1)\n                    print(i + 1)\n                    break\nelse:\n    print(0)", "def partition(arr):\n    n = len(arr)\n    k = sum(arr)\n    m = k // 2\n    p = [[False] * (n + 1) for i in range(m + 1)]\n    p[0] = [True] * (n + 1)\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            x = arr[j - 1]\n            if i - x >= 0:\n                p[i][j] = p[i][j - 1] or p[i - x][j - 1]\n            else:\n                p[i][j] = p[i][j - 1]\n    return p[m][n]\nn = int(input())\na = [int(x) for x in input().split()]\nwhile all((x % 2 == 0 for x in a)):\n    a = [x // 2 for x in a]\nk = sum(a)\nif k % 2 == 1:\n    result = 0\nelif not partition(a):\n    result = 0\nelse:\n    result = 1\n    for i in range(n):\n        if a[i] % 2 == 1:\n            break\nprint(result)\nif result == 1:\n    print(i + 1)"]