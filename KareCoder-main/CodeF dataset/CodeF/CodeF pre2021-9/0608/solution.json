["from collections import Counter, defaultdict, deque\nfrom heapq import heapify, heappush, heappop, heappushpop\nfrom sys import stdin\nimport sys\nsys.setrecursionlimit(2000000)\nimport threading\nthreading.stack_size(2 ** 26)\n\ndef main():\n    int_inp = lambda : int(stdin.readline().strip())\n    lst_inp = lambda : [int(i) for i in stdin.readline().strip().split(' ')]\n    str_inp = lambda : stdin.readline().strip()\n    n = int_inp()\n    a = lst_inp()\n    G = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = lst_inp()\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def dfs(u, G, a, vis, scores):\n        vis[u] = 1\n        scores[u] = 1 if a[u] == 1 else -1\n        for v in G[u]:\n            if not vis[v]:\n                dfs(v, G, a, vis, scores)\n                scores[u] += scores[v] if scores[v] > 0 else 0\n    vis = [0] * n\n    scores = [0] * n\n    dfs(0, G, a, vis, scores)\n    done = [0] * n\n    Q = deque([(v, 0) for v in G[0]])\n    done[0] = 1\n    while Q:\n        (v, u) = Q.popleft()\n        scores[v] += max(0, scores[u] - max(0, scores[v]))\n        done[v] = 1\n        for w in G[v]:\n            if not done[w]:\n                Q.append((w, v))\n    print(*scores)\nthreading.Thread(target=main).start()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 5 * 2)\nn = int(input())\nc = [int(item) for item in input().split()]\nedge = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    a -= 1\n    b -= 1\n    edge[a].append(b)\n    edge[b].append(a)\nmemo = [None] * n\n\ndef dfs(p, v):\n    st = []\n    st.append((p, v, 0))\n    while st:\n        (p, v, is_return) = st.pop()\n        if is_return:\n            val = 0\n            for nv in edge[v]:\n                if nv == p:\n                    continue\n                if memo[nv] > 0:\n                    val += memo[nv]\n            if c[v] == 0:\n                val = max(val - 1, -1)\n            else:\n                val = max(val + 1, 1)\n            memo[v] = val\n        else:\n            st.append((p, v, 1))\n            for nv in edge[v]:\n                if nv == p:\n                    continue\n                st.append((v, nv, 0))\n\ndef dfs_dp(p, v):\n    st = []\n    st.append((p, v))\n    while st:\n        (p, v) = st.pop()\n        val = memo[v]\n        if val < 0:\n            up = memo[p]\n        else:\n            up = memo[p] - memo[v]\n        if up > 0:\n            val += up\n        if p != -1:\n            memo[v] = val\n        for nv in edge[v]:\n            if nv == p:\n                continue\n            st.append((v, nv))\ndfs(-1, 0)\ndfs_dp(-1, 0)\nprint(*memo)", "import threading\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].append(b)\n        graph[b].append(a)\n    idea = {}\n\n    def dfs(node, par):\n        ans = 0\n        f = False\n        for nie in graph[node]:\n            if nie != par:\n                dfs(nie, node)\n                if idea[nie] >= 0:\n                    ans += idea[nie]\n                    f = True\n        ans -= 1 if arr[node] == 0 else -1\n        idea[node] = ans\n    dfs(0, -1)\n    ans = [0] * n\n\n    def dfs1(node, par):\n        if par == -1:\n            ans[node] = idea[node]\n        else:\n            ans[node] = idea[node] + max(0, idea[par] - (idea[node] if idea[node] >= 0 else 0))\n            idea[node] += max(0, idea[par] - (idea[node] if idea[node] >= 0 else 0))\n        for nie in graph[node]:\n            if nie != par:\n                dfs1(nie, node)\n    dfs1(0, -1)\n    print(*ans)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\nsys.setrecursionlimit(2000000)\nimport threading\nthreading.stack_size(2 ** 26)\n\ndef main():\n    n = int(input())\n    s = list(map(int, input().split()))\n    for (i, x) in enumerate(s):\n        if x == 0:\n            s[i] = -1\n    go = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        go[a].append(b)\n        go[b].append(a)\n    gone = [False] * n\n\n    def f(p):\n        gone[p] = True\n        SUM = 0\n        for x in go[p]:\n            if gone[x] == False:\n                SUM += max(0, f(x))\n        s[p] += SUM\n        return s[p]\n\n    def g(p):\n        gone[p] = True\n        for x in go[p]:\n            if gone[x] == False:\n                s[x] += max(0, s[p] - max(0, s[x]))\n                g(x)\n    f(0)\n    gone = [False] * n\n    g(0)\n    print(' '.join((str(x) for x in s)))\nthreading.Thread(target=main).start()", "from collections import defaultdict, Counter, deque\nimport threading\nimport sys\ninput = sys.stdin.readline\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = ri()\n    a = [0] + rl()\n    for i in range(n + 1):\n        if i != 0 and a[i] == 0:\n            a[i] = -1\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = rl()\n        g[u].append(v)\n        g[v].append(u)\n    par = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n\n    def d1(cn, p):\n        par[cn] = p\n        dp[cn] = a[cn]\n        for nn in g[cn]:\n            if nn != p:\n                dp[cn] += max(0, d1(nn, cn))\n        return dp[cn]\n    d1(1, 0)\n\n    def d2(cn, p):\n        if cn != 1:\n            if dp[cn] > 0:\n                res[cn] = max(res[par[cn]], dp[cn])\n            else:\n                res[cn] = max(res[par[cn]] + dp[cn], dp[cn])\n        for nn in g[cn]:\n            if nn != p:\n                d2(nn, cn)\n    res = [0] * (n + 1)\n    res[1] = dp[1]\n    d2(1, 0)\n    print(*res[1:])\n    pass\nthreading.Thread(target=main).start()", "from collections import defaultdict\nimport sys\nimport threading\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\nsize = list(map(int, input().split()))\nadj = defaultdict(list)\nsize = [0] + size\nfor i in range(1, n + 1):\n    size[i] = -1 if size[i] == 0 else 1\n\ndef dfs1(node, parent):\n    for child in adj[node]:\n        if child != parent:\n            dfs1(child, node)\n            size[node] += max(0, size[child])\n\ndef dfs2(node, parent):\n    size[node] = max(max(0, size[node]), size[parent]) + min(size[node], 0)\n    for child in adj[node]:\n        if child != parent:\n            dfs2(child, node)\n\ndef main():\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs1(1, -1)\n    for child in adj[1]:\n        dfs2(child, 1)\n    print(*size[1:])\nt = threading.Thread(target=main)\nt.start()\nt.join()", "import sys\ninput = sys.stdin.readline\nn = int(input())\nA = list(map(int, input().split()))\nA = [-1 if a == 0 else 1 for a in A]\ng = [[] for i in range(n)]\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    (u, v) = (u - 1, v - 1)\n    g[u].append(v)\n    g[v].append(u)\ns = []\ns.append(0)\nparent = [-1] * n\norder = []\nwhile s:\n    v = s.pop()\n    order.append(v)\n    for u in g[v]:\n        if parent[v] == u:\n            continue\n        parent[u] = v\n        s.append(u)\norder.reverse()\ndp = [0] * n\nfor v in order:\n    dp[v] += A[v]\n    u = parent[v]\n    if u == -1:\n        continue\n    dp[u] += max(0, dp[v])\nans = [0] * n\norder.reverse()\nfor v in order:\n    ans[v] = dp[v]\n    for u in g[v]:\n        if parent[v] == u:\n            continue\n        dp[u] += max(0, ans[v] - max(0, dp[u]))\nprint(*ans)", "from collections import defaultdict, Counter, deque\nimport threading\nimport sys\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = ri()\n    a = [0] + rl()\n    for i in range(n + 1):\n        if i != 0 and a[i] == 0:\n            a[i] = -1\n    g = defaultdict(list)\n    for _ in range(n - 1):\n        (u, v) = rl()\n        g[u].append(v)\n        g[v].append(u)\n    par = [-1] * (n + 1)\n    dp = [0] * (n + 1)\n\n    def d1(cn, p):\n        par[cn] = p\n        dp[cn] = a[cn]\n        for nn in g[cn]:\n            if nn != p:\n                dp[cn] += max(0, d1(nn, cn))\n        return dp[cn]\n    d1(1, 0)\n\n    def d2(cn, p):\n        if cn != 1:\n            if dp[cn] > 0:\n                res[cn] = max(res[par[cn]], dp[cn])\n            else:\n                res[cn] = max(res[par[cn]] + dp[cn], dp[cn])\n        for nn in g[cn]:\n            if nn != p:\n                d2(nn, cn)\n    res = [0] * (n + 1)\n    res[1] = dp[1]\n    d2(1, 0)\n    print(*res[1:])\n    pass\nthreading.Thread(target=main).start()", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    g = [list() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    st = [x * 2 - 1 for x in a] + [0]\n    p = [-1] * n\n    q = [0]\n    while q:\n        v = q.pop()\n        for x in g[v]:\n            if x == p[v]:\n                continue\n            p[x] = v\n            q.append(x)\n    seen = [0] * n\n    q = [0]\n    while q:\n        v = q[-1]\n        if seen[v]:\n            q.pop()\n            if st[v] > 0:\n                st[p[v]] += st[v]\n        else:\n            for x in g[v]:\n                if x == p[v]:\n                    continue\n                q.append(x)\n        seen[v] = 1\n    seen = [0] * n\n    q = [0]\n    while q:\n        v = q.pop()\n        for x in g[v]:\n            if x == p[v]:\n                continue\n            c = st[v]\n            if st[x] > 0:\n                c -= st[x]\n            if c > 0:\n                st[x] += c\n            q.append(x)\n    return st[:n]\nprint(*main())", "from collections import deque\nn = int(input())\nwt = list(map(int, input().split()))\ne = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    e[a - 1].append(b - 1)\n    e[b - 1].append(a - 1)\n(q, seq) = (deque([0]), [])\np = [-1] * n\np[0] = 0\nwhile q:\n    cur = q.popleft()\n    seq.append(cur)\n    for nex in e[cur]:\n        if nex == p[cur]:\n            continue\n        q.append(nex)\n        p[nex] = cur\ndp = [0] * n\nfor cur in reversed(seq):\n    for nex in e[cur]:\n        if nex == p[cur]:\n            continue\n        dp[cur] += max(0, dp[nex])\n    dp[cur] += 1 if wt[cur] else -1\ndp2 = [0] * n\nfor cur in seq:\n    if cur == p[cur]:\n        dp2[cur] = dp[cur]\n    else:\n        cost = 0\n        if dp[cur] < 0:\n            cost = dp2[p[cur]]\n        else:\n            cost = dp2[p[cur]] - dp[cur]\n        dp2[cur] = dp[cur] + max(0, cost)\nprint(*dp2)", "import sys, threading\nN = 2 * 10 ** 5 + 1\nl = [[] for x in range(N)]\ndp = [0 for i in range(N)]\n\ndef dfs1(v, color, par=-1):\n    dp[v] = color[v]\n    for i in l[v]:\n        if i == par:\n            continue\n        dfs1(i, color, v)\n        dp[v] += max(0, dp[i])\n\ndef dfs2(v, color, ans, par=-1):\n    ans[v] = dp[v]\n    for i in l[v]:\n        if i == par:\n            continue\n        dp[v] -= max(0, dp[i])\n        dp[i] += max(0, dp[v])\n        dfs2(i, color, ans, v)\n        dp[i] -= max(0, dp[v])\n        dp[v] += max(0, dp[i])\n\ndef main():\n    n = int(input())\n    color = [int(x) for x in input().split()]\n    for i in range(n):\n        if color[i] == 0:\n            color[i] = -1\n    for i in range(n - 1):\n        (a, b) = input().split()\n        a = int(a)\n        b = int(b)\n        a -= 1\n        b -= 1\n        l[a].append(b)\n        l[b].append(a)\n    ans = [0 for i in range(n)]\n    dfs1(0, color)\n    dfs2(0, color, ans)\n    print(*ans)\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import deque\nn = int(input())\nwt = list(map(int, input().split()))\ne = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    (a, b) = map(int, input().split())\n    e[a - 1].append(b - 1)\n    e[b - 1].append(a - 1)\n(q, seq) = (deque([0]), [])\np = [-1] * n\np[0] = 0\nwhile q:\n    cur = q.popleft()\n    seq.append(cur)\n    for nex in e[cur]:\n        if nex == p[cur]:\n            continue\n        q.append(nex)\n        p[nex] = cur\nseq.reverse()\ndp = [0] * n\nfor cur in seq:\n    for nex in e[cur]:\n        if nex == p[cur]:\n            continue\n        dp[cur] += max(0, dp[nex])\n    dp[cur] += 1 if wt[cur] else -1\nseq.reverse()\ndp2 = [0] * n\nfor cur in seq:\n    if cur == p[cur]:\n        dp2[cur] = dp[cur]\n    else:\n        cost = 0\n        if dp[cur] < 0:\n            cost = dp2[p[cur]]\n        else:\n            cost = dp2[p[cur]] - dp[cur]\n        dp2[cur] = dp[cur] + max(0, cost)\nprint(*dp2)", "n = int(input())\na = list(map(int, input().split()))\ng = [list() for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\nst = [x * 2 - 1 for x in a] + [0]\np = [-1] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        p[x] = v\n        q.append(x)\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q[-1]\n    if seen[v]:\n        q.pop()\n        if st[v] > 0:\n            st[p[v]] += st[v]\n    else:\n        for x in g[v]:\n            if x == p[v]:\n                continue\n            q.append(x)\n        seen[v] = 1\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        c = st[v]\n        if st[x] > 0:\n            c -= st[x]\n        if c > 0:\n            st[x] += c\n        q.append(x)\nprint(*st[:n])", "n = int(input())\na = list(map(int, input().split()))\ng = [list() for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\nst = [x * 2 - 1 for x in a] + [0]\np = [-1] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        p[x] = v\n        q.append(x)\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q[-1]\n    if seen[v]:\n        q.pop()\n        if st[v] > 0:\n            st[p[v]] += st[v]\n    else:\n        for x in g[v]:\n            if x == p[v]:\n                continue\n            q.append(x)\n        seen[v] = 1\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        c = st[v]\n        if st[x] > 0:\n            c -= st[x]\n        if c > 0:\n            st[x] += c\n        q.append(x)\nprint(*st[:n])", "n = int(input())\na = list(map(int, input().split()))\ng = [list() for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\nst = [x * 2 - 1 for x in a] + [0]\np = [-1] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        p[x] = v\n        q.append(x)\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q[-1]\n    if seen[v]:\n        q.pop()\n        if st[v] > 0:\n            st[p[v]] += st[v]\n    else:\n        for x in g[v]:\n            if x == p[v]:\n                continue\n            q.append(x)\n        seen[v] = 1\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        c = st[v]\n        if st[x] > 0:\n            c -= st[x]\n        if c > 0:\n            st[x] += c\n        q.append(x)\nprint(*st[:n])", "n = int(input())\na = list(map(int, input().split()))\ng = [list() for _ in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\nst = [x * 2 - 1 for x in a] + [0]\np = [-1] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        p[x] = v\n        q.append(x)\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q[-1]\n    if seen[v]:\n        q.pop()\n        if st[v] > 0:\n            st[p[v]] += st[v]\n    else:\n        for x in g[v]:\n            if x == p[v]:\n                continue\n            q.append(x)\n        seen[v] = 1\nseen = [0] * n\nq = [0]\nwhile q:\n    v = q.pop()\n    for x in g[v]:\n        if x == p[v]:\n            continue\n        c = st[v]\n        if st[x] > 0:\n            c -= st[x]\n        if c > 0:\n            st[x] += c\n        q.append(x)\nprint(*st[:n])"]