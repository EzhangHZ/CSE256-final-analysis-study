["from sys import stdin\nimport sys\nsys.setrecursionlimit(300000)\n\ndef dfs(v, pa):\n    good = 0\n    bad = 0\n    for nex in lis[v]:\n        if nex != pa:\n            (nans, ng, nb) = dfs(nex, v)\n            if not nans:\n                return (nans, 0, 0)\n            good += ng\n            bad += nb\n    num = good + bad + p[v]\n    if (num - h[v]) % 2 == 0:\n        newbad = (num - h[v]) // 2\n    else:\n        return (False, 0, 0)\n    newgood = num - newbad\n    if newbad - p[v] > bad or newgood < good or newbad < 0 or (newgood < 0):\n        return (False, 0, 0)\n    else:\n        return (True, newgood, newbad)\ntt = int(stdin.readline())\nfor loop in range(tt):\n    (n, m) = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    h = list(map(int, stdin.readline().split()))\n    lis = [[] for i in range(n)]\n    for i in range(n - 1):\n        (v, u) = map(int, stdin.readline().split())\n        v -= 1\n        u -= 1\n        lis[v].append(u)\n        lis[u].append(v)\n    (ans, good, bad) = dfs(0, 0)\n    if ans:\n        print('YES')\n    else:\n        print('NO')", "from collections import defaultdict\nfrom sys import setrecursionlimit, stdin\ninput = stdin.readline\nimport threading\nsetrecursionlimit(30000)\nflag = False\n\ndef dfs(node, parent, person, factor, happy, g):\n    th = 0\n    global flag\n    for i in g[node]:\n        if i != parent:\n            th += dfs(i, node, person, factor, happy, g)\n            person[node] += person[i]\n    if (person[node] + factor[node]) % 2 != 0:\n        flag = True\n    x = (person[node] + factor[node]) // 2 - th\n    if x < 0 or factor[node] > person[node]:\n        flag = True\n    else:\n        happy[node] = x + th\n    return x + th\n\ndef main():\n    global flag\n    for _ in range(int(input())):\n        (n, m) = map(int, input().strip().split())\n        g = defaultdict(list)\n        person = list(map(int, input().strip().split()))\n        factor = list(map(int, input().strip().split()))\n        for i in range(n - 1):\n            (x, y) = map(int, input().strip().split())\n            g[x - 1].append(y - 1)\n            g[y - 1].append(x - 1)\n        happy = [0] * n\n        flag = False\n        l = dfs(0, -1, person, factor, happy, g)\n        if flag:\n            print('NO')\n        else:\n            print('YES')\nthreading.stack_size(10 ** 8)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from sys import stdin\nimport sys\nsys.setrecursionlimit(300000)\n\ndef dfs(v, pa):\n    good = 0\n    bad = 0\n    for nex in lis[v]:\n        if nex != pa:\n            (nans, ng, nb) = dfs(nex, v)\n            if not nans:\n                return (nans, 0, 0)\n            good += ng\n            bad += nb\n    num = good + bad + p[v]\n    if (num - h[v]) % 2 == 0:\n        newbad = (num - h[v]) // 2\n    else:\n        return (False, 0, 0)\n    newgood = num - newbad\n    if newbad - p[v] > bad or newgood < good or newbad < 0 or (newgood < 0):\n        return (False, 0, 0)\n    else:\n        return (True, newgood, newbad)\ntt = int(stdin.readline())\nfor loop in range(tt):\n    (n, m) = map(int, stdin.readline().split())\n    p = list(map(int, stdin.readline().split()))\n    h = list(map(int, stdin.readline().split()))\n    lis = [[] for i in range(n)]\n    for i in range(n - 1):\n        (v, u) = map(int, stdin.readline().split())\n        v -= 1\n        u -= 1\n        lis[v].append(u)\n        lis[u].append(v)\n    (ans, good, bad) = dfs(0, 0)\n    if ans:\n        print('YES')\n    else:\n        print('NO')", "import sys\nfrom collections import deque\nsys.setrecursionlimit(300000)\ninput = sys.stdin.readline\n\ndef dfs(node, pre):\n    sub[node] = p[node]\n    s = 0\n    for n in graph[node]:\n        if n != pre:\n            dfs(n, node)\n            s += g[n]\n            sub[node] += sub[n]\n    if (sub[node] + h[node]) % 2 != 0:\n        poo[0] = False\n    g[node] = (sub[node] + h[node]) // 2\n    if not (g[node] >= 0 and g[node] <= sub[node]):\n        poo[0] = False\n    if not s <= g[node]:\n        poo[0] = False\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = [0] + list(map(int, input().split()))\n    h = [0] + list(map(int, input().split()))\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    sub = [0 for i in range(n + 1)]\n    g = [0 for i in range(n + 1)]\n    poo = [True]\n    dfs(1, -1)\n    print('YES' if poo[0] else 'NO')", "from sys import stdin\nimport sys, threading\nimport math\ninput = stdin.readline\n\ndef dfs(current, parent, children, h, p):\n    happypeople = 0\n    people = p[current - 1]\n    happiness = h[current - 1]\n    for c in children[current]:\n        if c != parent:\n            (peoplei, happypeoplei) = dfs(c, current, children, h, p)\n            if happypeoplei == -1:\n                return (-1, -1)\n            happypeople += happypeoplei\n            people += peoplei\n    if happiness > people or happiness < -people:\n        return (-1, -1)\n    z = (people - happiness) / 2\n    if z != int(z):\n        return (-1, -1)\n    if people - z < happypeople:\n        return (-1, -1)\n    return (people, people - z)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = list(map(int, input().rstrip().split(' ')))\n        p = list(map(int, input().rstrip().split(' ')))\n        h = list(map(int, input().rstrip().split(' ')))\n        children = [[] for i in range(n + 1)]\n        for _ in range(n - 1):\n            (x, y) = map(int, input().rstrip().split(' '))\n            children[x].append(y)\n            children[y].append(x)\n        (people, happypeople) = dfs(1, -1, children, h, p)\n        if happypeople == -1:\n            print('NO')\n        else:\n            print('YES')\nsys.setrecursionlimit(100001)\nthreading.stack_size(512000)\nthread = threading.Thread(target=main)\nthread.start()", "import sys\nsys.setrecursionlimit(int(100000.0) + 7)\nip = sys.stdin.readline\nfor _ in range(int(ip())):\n    (n, m) = map(int, ip().split())\n    p = list(map(int, ip().split()))\n    h = list(map(int, ip().split()))\n    graph = [[] for _ in range(n)]\n    a = [0] * n\n    g = [0] * n\n    for _ in range(n - 1):\n        (x, y) = map(int, ip().split())\n        x -= 1\n        y -= 1\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dfs(node, ancestor):\n        a[node] = p[node]\n        sg = 0\n        for destination in graph[node]:\n            if destination == ancestor:\n                continue\n            dfs(destination, node)\n            a[node] += a[destination]\n            sg += g[destination]\n        if (a[node] + h[node]) % 2:\n            flag[0] = False\n        g[node] = a[node] + h[node] >> 1\n        if not 0 <= g[node] <= a[node]:\n            flag[0] = False\n        if not sg <= g[node]:\n            flag[0] = False\n    flag = [True]\n    dfs(0, -1)\n    print('YES' if flag[0] else 'NO')", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\nsys.setrecursionlimit(300000)\n\ndef gift():\n\n    def dfs(v, pa):\n        good = 0\n        bad = 0\n        for nex in dic[v]:\n            if nex != pa:\n                (nans, ng, nb) = dfs(nex, v)\n                if not nans:\n                    return (nans, 0, 0)\n                good += ng\n                bad += nb\n        num = good + bad + p[v]\n        if (num - h[v]) % 2 == 0:\n            newbad = (num - h[v]) // 2\n        else:\n            return (False, 0, 0)\n        newgood = num - newbad\n        if newbad - p[v] > bad or newgood < good or newbad < 0 or (newgood < 0):\n            return (False, 0, 0)\n        else:\n            return (True, newgood, newbad)\n    for _ in range(t):\n        (city, people) = list(map(int, input().split()))\n        p = list(map(int, input().split()))\n        h = list(map(int, input().split()))\n        dic = [[] for i in range(city)]\n        for i in range(city - 1):\n            (s, e) = list(map(int, input().split()))\n            dic[s - 1].append(e - 1)\n            dic[e - 1].append(s - 1)\n        (ans, good, bad) = dfs(0, 0)\n        yield ('YES' if ans else 'NO')\nt = int(input())\nans = gift()\nprint(*ans, sep='\\n')", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    r = p[u]\n    for v in g[u]:\n        if v ^ x:\n            t = f(v, u)\n            r += t\n            s += t + h[v]\n    q = h[u] + r\n    p[0] &= ~q & (s <= q <= 2 * r)\n    return r\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = (0, *R())\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            s += f(v, u)\n            p[u] += p[v]\n    q = h[u] + p[u]\n    p[0] &= ~q & (s <= q <= 2 * p[u])\n    return q\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = (0, *R())\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    vis = set()\n\n    def dfs(root):\n        count = 0\n        h = 0\n        for i in g[root]:\n            if i not in vis:\n                vis.add(i)\n                (temp, htemp) = dfs(i)\n                count += temp\n                h += htemp\n        count += a[root - 1]\n        happy = count + b[root - 1]\n        if happy % 2:\n            ans[0] = 'NO'\n        happy //= 2\n        if happy < 0 or happy > count:\n            ans[0] = 'NO'\n        elif h > happy:\n            ans[0] = 'NO'\n        return (count, happy)\n    ans = ['YES']\n    vis.add(1)\n    dfs(1)\n    print(ans[0])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            s += f(v, u)\n            p[u] += p[v]\n    q = h[u] + p[u]\n    p[0] &= ~q & (s <= q <= 2 * p[u])\n    return q\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = (0, *R())\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    vis = set()\n\n    def dfs(root):\n        count = 0\n        h = 0\n        for i in g[root]:\n            if i not in vis:\n                vis.add(i)\n                (temp, htemp) = dfs(i)\n                count += temp\n                h += htemp\n        count += a[root - 1]\n        happy = count + b[root - 1]\n        if happy % 2:\n            ans[0] = 'NO'\n        happy //= 2\n        if happy < 0 or happy > count:\n            ans[0] = 'NO'\n        elif h > happy:\n            ans[0] = 'NO'\n        return (count, happy)\n    ans = ['YES']\n    vis.add(1)\n    dfs(1)\n    print(ans[0])", "__import__('sys').setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            f(v, u)\n            p[u] += p[v]\n            s += p[v] + h[v]\n    q = h[u] + p[u]\n    p[0] &= ~q & (s <= q <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = (0, *R())\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v != x:\n            f(v, u)\n            p[u] += p[v]\n            s += h[v]\n    h[u] += p[u]\n    r[0] &= ~h[u] & (s <= h[u] <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [0, *R()]\n    h = [0, *R()]\n    g = [[] for _ in p]\n    r = [1]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nimport sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            s += f(v, u)\n            p[u] += p[v]\n    q = h[u] + p[u]\n    p[0] &= ~q & (s <= q <= 2 * p[u])\n    return q\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = (0, *R())\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            f(v, u)\n            p[u] += p[v]\n            s += h[v]\n    h[u] += p[u]\n    p[0] &= ~h[u] & (s <= h[u] <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = [0, *R()]\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            f(v, u)\n            p[u] += p[v]\n            s += p[v] + h[v]\n    q = h[u] + p[u]\n    p[0] &= ~q & (s <= q <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = (0, *R())\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(k, z):\n    s = 0\n    for t in g[k]:\n        if t ^ z:\n            f(t, k)\n            p[k] += p[t]\n            s += h[t]\n    h[k] += p[k]\n    p[0] &= ~h[k] & (s <= h[k] <= 2 * p[k])\nB = lambda : map(int, input().split())\n(t,) = B()\nfor _ in [0] * t:\n    B()\n    p = [1, *B()]\n    h = [0, *B()]\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (z, y) = B()\n        g[z] += (y,)\n        g[y] += (z,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v != x:\n            f(v, u)\n            p[u] += p[v]\n            s += h[v]\n    h[u] += p[u]\n    r[0] &= ~h[u] & (s <= h[u] <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [0, *R()]\n    h = [0, *R()]\n    g = [[] for _ in p]\n    r = [1]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\n\ndef put():\n    return [int(i) for i in input().split()]\n\ndef dfs(tree, h, p, i, parent):\n    cgood = 0\n    flag = True\n    for j in tree[i]:\n        if j != parent:\n            (x, y, z) = dfs(tree, h, p, j, i)\n            p[i] += x\n            cgood += y\n            flag &= z\n    good = (p[i] + h[i]) // 2\n    bad = p[i] - good\n    if (p[i] + h[i]) % 2 == 1 or good < cgood or good < 0 or (bad < 0):\n        flag = False\n    return (p[i], good, flag)\n\ndef solve():\n    t = int(input())\n    while t > 0:\n        (n, m) = put()\n        (p, h) = (put(), put())\n        tree = [[] for i in range(n)]\n        for _ in range(n - 1):\n            (x, y) = put()\n            tree[x - 1].append(y - 1)\n            tree[y - 1].append(x - 1)\n        (a, _, c) = dfs(tree, h, p, 0, -1)\n        if a != m or not c:\n            print('NO')\n        else:\n            print('YES')\n        t -= 1\nrecur = 10 ** 5 * 2 + 1000\nsys.setrecursionlimit(recur)\nsolve()", "import sys\nsys.setrecursionlimit(100000)\nfor _ in range(int(input())):\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    g = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    vis = set()\n\n    def dfs(root):\n        count = 0\n        h = 0\n        for i in g[root]:\n            if i not in vis:\n                vis.add(i)\n                (temp, htemp) = dfs(i)\n                count += temp\n                h += htemp\n        count += a[root - 1]\n        happy = count + b[root - 1]\n        if happy % 2:\n            ans[0] = 'NO'\n        happy //= 2\n        if happy < 0 or happy > count:\n            ans[0] = 'NO'\n        elif h > happy:\n            ans[0] = 'NO'\n        return (count, happy)\n    ans = ['YES']\n    vis.add(1)\n    dfs(1)\n    print(ans[0])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(k, z):\n    s = 0\n    for v in g[k]:\n        if v ^ z:\n            f(v, k)\n            p[k] += p[v]\n            s += h[v]\n    h[k] += p[k]\n    p[0] &= ~h[k] & (s <= h[k] <= 2 * p[k])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [1, *R()]\n    h = [0, *R()]\n    g = [[] for _ in p]\n    for _ in p[2:]:\n        (z, y) = R()\n        g[z] += (y,)\n        g[y] += (z,)\n    f(1, 0)\n    print('NYOE S'[p[0]::2])", "from collections import defaultdict, Counter\nimport threading\nimport sys\n\ndef ri():\n    return int(input())\n\ndef rs():\n    return input()\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef rls():\n    return list(input().split())\nthreading.stack_size(10 ** 8)\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    for test in range(ri()):\n        (n, m) = rl()\n        p = [0] + rl()\n        h = [0] + rl()\n        g = defaultdict(list)\n        for edge in range(n - 1):\n            (u, v) = rl()\n            g[u].append(v)\n            g[v].append(u)\n        tot = [0] * (n + 1)\n        gg = [0] * (n + 1)\n        global pos\n        pos = True\n\n        def dfs(cn, par):\n            global pos\n            tot[cn] = p[cn]\n            sg = 0\n            for nn in g[cn]:\n                if nn != par:\n                    dfs(nn, cn)\n                    tot[cn] += tot[nn]\n                    sg += gg[nn]\n            if tot[cn] + h[cn] & 1:\n                pos = False\n            gg[cn] = (tot[cn] + h[cn]) // 2\n            if gg[cn] < 0 or gg[cn] > tot[cn] or sg > gg[cn]:\n                pos = False\n        dfs(1, -1)\n        print(['NO', 'YES'][pos])\n    pass\nthreading.Thread(target=main).start()", "from collections import deque as dq\nfrom collections import defaultdict as dd\nfrom collections import Counter as ct\nfrom functools import lru_cache as lc\nfrom heapq import heappush as hpush, heappop as hpop, heapify as hfy\nfrom bisect import bisect_left, bisect_right\nimport itertools as it\nimport math\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    P = list(map(int, input().split()))\n    H = list(map(int, input().split()))\n    edges = [[] for i in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        edges[u].append(v)\n        edges[v].append(u)\n\n    def dfs(cur, prev):\n        ret = True\n        happy = unhappy = 0\n        for nxt in edges[cur]:\n            if nxt == prev:\n                continue\n            (sub_ret, sub_happy, sub_unhappy) = dfs(nxt, cur)\n            ret &= sub_ret\n            happy += sub_happy\n            unhappy += sub_unhappy\n        unhappy += P[cur]\n        h = happy - unhappy\n        if H[cur] < h:\n            ret = False\n        if happy + unhappy < abs(H[cur]):\n            ret = False\n        if H[cur] % 2 != h % 2:\n            ret = False\n        happy += (H[cur] - h) // 2\n        unhappy -= (H[cur] - h) // 2\n        return (ret, happy, unhappy)\n    print('YES' if dfs(0, -1)[0] else 'NO')\nT = int(input())\nfor t in range(T):\n    solve()", "from collections import deque as dq\nfrom collections import defaultdict as dd\nfrom collections import Counter as ct\nfrom functools import lru_cache as lc\nfrom heapq import heappush as hpush, heappop as hpop, heapify as hfy\nfrom bisect import bisect_left, bisect_right\nimport itertools as it\nimport math\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    P = list(map(int, input().split()))\n    H = list(map(int, input().split()))\n    edges = [[] for i in range(n)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        (u, v) = (u - 1, v - 1)\n        edges[u].append(v)\n        edges[v].append(u)\n\n    def dfs(cur, prev):\n        ret = True\n        happy = unhappy = 0\n        for nxt in edges[cur]:\n            if nxt == prev:\n                continue\n            (sub_ret, sub_happy, sub_unhappy) = dfs(nxt, cur)\n            ret &= sub_ret\n            happy += sub_happy\n            unhappy += sub_unhappy\n        unhappy += P[cur]\n        h = happy - unhappy\n        if H[cur] < h:\n            ret = False\n        if happy + unhappy < abs(H[cur]):\n            ret = False\n        if H[cur] % 2 != h % 2:\n            ret = False\n        happy += (H[cur] - h) // 2\n        unhappy -= (H[cur] - h) // 2\n        return (ret, happy, unhappy)\n    print('YES' if dfs(0, -1)[0] else 'NO')\nT = int(input())\nfor t in range(T):\n    solve()", "import bisect\nimport collections\nimport copy\nimport enum\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List, Mapping\nsys.setrecursionlimit(999999)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ps = list(map(int, input().split()))\n    modes = list(map(int, input().split()))\n    g = collections.defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(cur, far):\n        b = True\n        kg = 0\n        cnt = 0\n        for nc in g[cur]:\n            if nc == far:\n                continue\n            (bn, gc, pc) = dfs(nc, cur)\n            if not bn:\n                return (False, 0, 0)\n            else:\n                kg += gc\n                cnt += pc\n        s = modes[cur]\n        cnt += ps[cur]\n        if s % 2 != cnt % 2:\n            return (False, 0, 0)\n        a = (s + cnt) // 2\n        b = (cnt - s) // 2\n        if a < 0 or b < 0:\n            return (False, 0, 0)\n        if a < kg:\n            return (False, 0, 0)\n        return (True, a, cnt)\n    (b, _, _) = dfs(0, -1)\n    if b:\n        print('YES')\n    else:\n        print('NO')", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\nimport threading\nthreading.stack_size(67108864)\n\ndef dfs1(v):\n    global u, used, h, p, ok, d\n    if not ok:\n        return\n    used[v] = True\n    hap = 0\n    for i in u[v]:\n        if not used[i]:\n            dfs1(i)\n            p[v] += p[i]\n            hap += d[i]\n    d[v] = (p[v] + h[v]) // 2\n    if (p[v] + h[v]) % 2 != 0 or not 0 <= d[v] <= p[v]:\n        ok = False\n        return\n    if d[v] < hap:\n        ok = False\n        return\n\ndef main():\n    global u, used, d, p, h, ok\n    ans = []\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        p = list(map(int, input().split()))\n        h = list(map(int, input().split()))\n        d = [0] * n\n        u = []\n        ok = True\n        for i in range(n):\n            u.append([])\n        for i in range(n - 1):\n            (a, b) = map(lambda z: int(z) - 1, input().split())\n            u[a].append(b)\n            u[b].append(a)\n        used = [0] * n\n        dfs1(0)\n        if not ok:\n            ans.append('NO')\n        else:\n            ans.append('YES')\n    print('\\n'.join(ans))\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    s = 0\n    for v in g[u]:\n        if v ^ x:\n            f(v, u)\n            p[u] += p[v]\n            s += h[v]\n    h[u] += p[u]\n    r[0] &= ~h[u] & (s <= h[u] <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [0, *R()]\n    h = [0, *R()]\n    g = [[] for _ in p]\n    r = [1]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] += (y,)\n        g[y] += (x,)\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import math\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 5 + 100)\n\ndef check(v, pr):\n    sumy = 0\n    pn = p[v]\n    for x in g[v]:\n        if x == pr:\n            continue\n        if check(x, v) == 0:\n            return 0\n        p[v] += p[x]\n        sumy += y[x]\n    pos = (p[v] + h[v]) // 2\n    neg = (p[v] - h[v]) // 2\n    y[v] = neg\n    if pos + neg != p[v] or pos - neg != h[v] or pos < 0 or (neg < 0) or (pos > p[v]) or (neg > p[v]):\n        return 0\n    if y[v] <= sumy + pn:\n        return 1\n    return 0\nt = int(input())\nwhile t > 0:\n    t -= 1\n    global g, y, h, p\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    y = [0] * n\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        g[a].append(b)\n        g[b].append(a)\n    if check(0, -1) == 1:\n        print('YES')\n    else:\n        print('NO')", "import math\nimport threading, sys\n\ndef main():\n    m = int(input())\n    for l in range(m):\n        (n, m) = map(int, input().split())\n        p = list(map(int, input().split()))\n        h = list(map(int, input().split()))\n        di = {}\n        for _ in range(n - 1):\n            (x, y) = map(int, input().split())\n            if x == y:\n                continue\n            if x - 1 in di:\n                di[x - 1].add(y - 1)\n            else:\n                di[x - 1] = {y - 1}\n            if y - 1 in di:\n                di[y - 1].add(x - 1)\n            else:\n                di[y - 1] = {x - 1}\n\n        def dfs(k, pa):\n            (good, bad) = (0, 0)\n            if k in di:\n                for i in di[k]:\n                    if i == pa:\n                        continue\n                    (g, b) = dfs(i, k)\n                    if g <= -1:\n                        return (-1, -1)\n                    good += g\n                    bad += b\n            g1 = good\n            g2 = bad\n            t = g1 + g2 + p[k]\n            good = int((h[k] + t) / 2)\n            bad = t - good\n            if bad > g2 + p[k] or abs(h[k]) > t or (h[k] + t) % 2 != 0:\n                return (-1, -1)\n            return (good, bad)\n        (gf, bf) = dfs(0, -1)\n        if gf == -1 or gf + bf > m:\n            print('NO')\n        else:\n            print('YES')\nsys.setrecursionlimit(1000000)\nthreading.stack_size(1024000)\nthread = threading.Thread(target=main)\nthread.start()", "import sys\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef dfs(x, pa):\n    g = 0\n    b = 0\n    for nex in e[x]:\n        if nex == pa:\n            continue\n        (ng, nb) = dfs(nex, x)\n        g += ng\n        b += nb\n    c = p[x]\n    num = h[x]\n    if num % 2 != (c % 2 + (g - b) % 2) % 2:\n        return (float('INF'), float('INF'))\n    if num > g + b + c or num < g - b - c:\n        return (float('INF'), float('INF'))\n    now = g - b\n    if num >= now:\n        g += num - now\n        g += (c - num + now) // 2\n        b += (c - num + now) // 2\n    else:\n        b += now - num\n        g += (c + num - now) // 2\n        b += (c + num - now) // 2\n    return (g, b)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    e = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        e[a].append(b)\n        e[b].append(a)\n    (g, b) = dfs(0, -1)\n    if g >= 10 ** 15:\n        print('NO')\n    else:\n        print('YES')", "from collections import defaultdict\nfrom sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(100000)\nt = int(stdin.readline())\nfor _ in range(t):\n    (n, m) = map(int, stdin.readline().split())\n    p = [0] + list(map(int, stdin.readline().split()))\n    h = [0] + list(map(int, stdin.readline().split()))\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    cities = [(0, 0)] * (n + 1)\n    visitors = [0] * (n + 1)\n    seen = {1}\n\n    def dfs(n):\n        total = p[n]\n        (ha, uh) = (0, 0)\n        for nei in adj[n]:\n            if nei not in seen:\n                seen.add(nei)\n                if not dfs(nei):\n                    return False\n                ha += cities[nei][0]\n                uh += cities[nei][1]\n                total += visitors[nei]\n        visitors[n] = total\n        if abs(h[n]) > total:\n            return False\n        if (total + h[n]) % 2 == 1:\n            return False\n        ex_ha = (total + h[n]) // 2\n        ex_uh = ex_ha - h[n]\n        cities[n] = (ex_ha, ex_uh)\n        if ex_ha < ha:\n            return False\n        return True\n    if dfs(1):\n        print('YES')\n    else:\n        print('NO')", "from sys import setrecursionlimit as srl\nsrl(3 * 10 ** 5)\n\ndef dfs(v, pa):\n    (good, bad) = (0, 0)\n    for nex in lis[v]:\n        if nex != pa:\n            (nans, ng, nb) = dfs(nex, v)\n            if not nans:\n                return (nans, 0, 0)\n            good += ng\n            bad += nb\n    num = good + bad + p[v]\n    if (num - h[v]) % 2 == 0:\n        newbad = (num - h[v]) // 2\n    else:\n        return (False, 0, 0)\n    newgood = num - newbad\n    if newbad - p[v] > bad or newgood < good or newbad < 0 or (newgood < 0):\n        return (False, 0, 0)\n    else:\n        return (True, newgood, newbad)\nfor loop in range(int(input())):\n    (n, m) = map(int, input().split())\n    (p, h) = (list(map(int, input().split())), list(map(int, input().split())))\n    lis = [[] for i in range(n)]\n    for i in range(n - 1):\n        (v, u) = map(int, input().split())\n        v -= 1\n        u -= 1\n        lis[v].append(u)\n        lis[u].append(v)\n    (ans, good, bad) = dfs(0, 0)\n    print('YES') if ans else print('NO')", "import math\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 5 + 100)\n\ndef dfs(v, pr):\n    sumy = 0\n    pn = p[v]\n    for x in adj[v]:\n        if x == pr:\n            continue\n        if dfs(x, v) == 0:\n            return 0\n        p[v] += p[x]\n        sumy += y[x]\n    pos = (p[v] + h[v]) // 2\n    neg = (p[v] - h[v]) // 2\n    y[v] = neg\n    if pos + neg != p[v] or pos - neg != h[v] or pos < 0 or (neg < 0) or (pos > p[v]) or (neg > p[v]):\n        return 0\n    if y[v] <= sumy + pn:\n        return 1\n    return 0\nfor _ in range(int(input())):\n    global adj, y, h, p\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    y = [0] * n\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n    if dfs(0, 0) == 1:\n        print('YES')\n    else:\n        print('NO')", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    an = 'YES'\n    c = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "num_inp = lambda : int(input())\narr_inp = lambda : list(map(int, input().split()))\nsp_inp = lambda : map(int, input().split())\nstr_inp = lambda : input()\nfrom sys import setrecursionlimit as srl\nsrl(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    an = 'YES'\n    c = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "import sys\nsys.setrecursionlimit(320000)\ninput = sys.stdin.readline\n\ndef dfs(x, pa):\n    g = 0\n    b = 0\n    for nex in e[x]:\n        if nex == pa:\n            continue\n        (ng, nb, check) = dfs(nex, x)\n        if check == False:\n            return (0, 0, False)\n        g += ng\n        b += nb\n    c = p[x]\n    num = h[x]\n    if num % 2 != (c % 2 + (g - b) % 2) % 2:\n        return (0, 0, False)\n    if num > g + b + c or num < g - b - c:\n        return (0, 0, False)\n    now = g - b\n    if num >= now:\n        g += num - now\n        g += (c - num + now) // 2\n        b += (c - num + now) // 2\n    else:\n        b += now - num\n        g += (c + num - now) // 2\n        b += (c + num - now) // 2\n    return (g, b, True)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    e = [[] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        e[a].append(b)\n        e[b].append(a)\n    (g, b, check) = dfs(0, -1)\n    if check:\n        print('YES')\n    else:\n        print('NO')", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    an = 'YES'\n    c = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "import sys\nsys.setrecursionlimit(4 ** 7)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nI = lambda : list(map(int, input().split()))\n(t,) = I()\nfor _ in range(t):\n    (n, m) = I()\n    p = I()\n    h = I()\n    g = [[] for i in range(n)]\n    an = 'YES'\n    for i in range(n - 1):\n        (u, v) = I()\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    c = [0] * n\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "import sys\nsys.setrecursionlimit(7 ** 5)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5100)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5300)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5060)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(6 ** 6)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5500)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5070)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= ~h[u] & (sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    R()\n    p = [0, *R()]\n    h = [0, *R()]\n    g = [set() for _ in p]\n    r = [1]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    an = 'YES'\n    c = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5057)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(3 ** 8)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "import sys\nsys.setrecursionlimit(6000)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= h[u] % 2 < 1 and sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u]\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in r * (n - 1):\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "from sys import setrecursionlimit as srl\nsrl(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    an = 'YES'\n    c = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    an = 'YES'\n    c = [0] * n\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(v, pa):\n        d = 0\n        for i in g[v]:\n            if i != pa:\n                d += dfs(i, v)\n        c[v] = d + p[v]\n        return c[v]\n    dfs(0, -1)\n\n    def df(v, pa):\n        d = h[v]\n        cr = c[v]\n        bd = (cr - h[v]) // 2\n        gd = cr - bd\n        pos = 1\n        aa = 0\n        bb = 0\n        for i in g[v]:\n            if i != pa:\n                kk = c[i]\n                bh = (c[i] - h[i]) // 2\n                gh = c[i] - bh\n                aa += gh\n                bb += bh\n                pos = min(pos, df(i, v))\n        if c[v] < abs(h[v]) or (cr - h[v]) % 2:\n            return 0\n        if aa <= gd and bb <= bd + (gd - aa):\n            return pos\n        return 0\n    po = df(0, -1)\n    if not po:\n        an = 'NO'\n    print(an)", "import sys\nsys.setrecursionlimit(5056)\n\ndef f(u, x):\n    g[u] -= {x}\n    for v in g[u]:\n        f(v, u)\n        p[u] += p[v]\n    h[u] += p[u]\n    r[0] &= ~h[u] & (sum((h[v] for v in g[u])) <= h[u] <= 2 * p[u])\nR = lambda : map(int, input().split())\n(t,) = R()\nfor _ in [0] * t:\n    (n, m) = R()\n    p = [0, *R()]\n    h = [0, *R()]\n    r = [1]\n    g = r + [set() for _ in r * n]\n    for _ in p[2:]:\n        (x, y) = R()\n        g[x] |= {y}\n        g[y] |= {x}\n    f(1, 0)\n    print('NYOE S'[r[0]::2])", "t = int(input())\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nwhile t:\n    (n, m) = [int(i) for i in input().split()]\n    p = [int(i) for i in input().split()]\n    h = [int(i) for i in input().split()]\n    adj = {i: [] for i in range(1, n + 1)}\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, par):\n        passers = 0\n        new_h = h[node - 1]\n        for c in adj[node]:\n            if c == par:\n                continue\n            (tot, b) = dfs(c, node)\n            new_h -= h[c - 1]\n            passers += tot\n            if not b:\n                return (0, False)\n        if (passers + p[node - 1] - h[node - 1]) % 2 == 0 and h[node - 1] <= passers + p[node - 1] and (h[node - 1] >= -1 * (passers + p[node - 1])):\n            if (p[node - 1] - new_h) % 2 == 0 and new_h >= -1 * p[node - 1]:\n                return (passers + p[node - 1], True)\n            else:\n                return (passers, False)\n        return (passers, False)\n    (_, ans) = dfs(1, -1)\n    if ans:\n        print('YES')\n    else:\n        print('NO')\n    t -= 1"]