["def candies(n, array):\n    i = 0\n    j = n - 1\n    turns = 0\n    prev = 0\n    p = 'a'\n    a_count = 0\n    b_count = 0\n    while i <= j:\n        if p == 'a':\n            c = 0\n            while i <= j and c <= prev:\n                c += array[i]\n                i += 1\n            prev = c\n            p = 'b'\n            a_count += c\n        else:\n            c = 0\n            while i <= j and c <= prev:\n                c += array[j]\n                j -= 1\n            prev = c\n            p = 'a'\n            b_count += c\n        turns += 1\n    return (turns, a_count, b_count)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    ans = candies(n, l)\n    print(ans[0], ans[1], ans[2])", "def solve():\n    n = int(input())\n    c = list(map(int, input().split()))\n    a = 0\n    b = 0\n    current = 0\n    prev = 0\n    turn = 0\n    aliceturn = True\n    while c:\n        if aliceturn:\n            current += c.pop(0)\n        else:\n            current += c.pop()\n        if current > prev:\n            turn += 1\n            if aliceturn:\n                a += current\n            else:\n                b += current\n            prev = current\n            current = 0\n            aliceturn = not aliceturn\n    if current:\n        turn += 1\n        if aliceturn:\n            a += current\n        else:\n            b += current\n    print(turn, a, b)\nfor _ in range(int(input())):\n    solve()", "from math import *\nfrom math import factorial as fact, comb as ncr\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom collections import Counter as ctr\nfrom collections import deque as dq\nfrom array import array\nfrom re import search\nli = lambda : list(map(int, input().split()))\narr = lambda a: array('i', a)\nbi = lambda n: bin(n).replace('0b', '')\nyn = lambda f: print('NYOE S'[f::2])\nsbstr = lambda a, s: search('.*'.join(a), s)\n\ndef solve():\n    for _ in range(int(input())):\n        n = int(input())\n        a = li()\n        c = 0\n        al = bob = 0\n        i = 0\n        j = n - 1\n        ta = 0\n        while j >= i:\n            c += 1\n            if c % 2:\n                al = 0\n                while bob >= al and i <= j:\n                    al += a[i]\n                    i += 1\n                ta += al\n            else:\n                bob = 0\n                while al >= bob and i <= j:\n                    bob += a[j]\n                    j -= 1\n        print(c, ta, sum(a) - ta)\nsolve()", "def candyGameResult(nCandies, candies):\n    (Alice_sCandiesSize, Bob_sCandiesSize) = (candies[0], 0)\n    (pastCandiesSize, currCandiesSize) = (Alice_sCandiesSize, 0)\n    nMoves = 1\n    (iAlice, iBob) = (0, nCandies)\n    while iAlice + 1 < iBob:\n        while pastCandiesSize >= currCandiesSize and iAlice + 1 < iBob:\n            iBob -= 1\n            currCandiesSize += candies[iBob]\n        if currCandiesSize:\n            nMoves += 1\n            Bob_sCandiesSize += currCandiesSize\n            (pastCandiesSize, currCandiesSize) = (currCandiesSize, 0)\n        while pastCandiesSize >= currCandiesSize and iAlice + 1 < iBob:\n            iAlice += 1\n            currCandiesSize += candies[iAlice]\n        if currCandiesSize:\n            nMoves += 1\n            Alice_sCandiesSize += currCandiesSize\n            (pastCandiesSize, currCandiesSize) = (currCandiesSize, 0)\n    return f'{nMoves} {Alice_sCandiesSize} {Bob_sCandiesSize}'\n\ndef testCase_1352d():\n    nCandies = int(input())\n    return (nCandies, list(map(int, input().split())))\nnTestCases = int(input())\ntestCases = tuple((testCase_1352d() for testCase in range(nTestCases)))\ntuple((print(candyGameResult(*testCase)) for testCase in testCases))", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nMOD = 10 ** 9 + 7\n\ndef solve():\n    _ = int(input())\n    A = list(map(int, input().split()))\n    que = deque(A)\n    Alice = Bob = 0\n    quota = 1\n    cnt = 0\n    flg = 0\n    while que:\n        if not flg:\n            tot = 0\n            while que and tot < quota:\n                a = que.popleft()\n                tot += a\n            Alice += tot\n            quota = tot + 1\n        else:\n            tot = 0\n            while que and tot < quota:\n                a = que.pop()\n                tot += a\n            Bob += tot\n            quota = tot + 1\n        flg ^= 1\n        cnt += 1\n    print(cnt, Alice, Bob)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import deque\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    n_moves = 0\n    moves = input().split()\n    moves = deque([int(move) for move in moves])\n    total_a = total_b = 0\n    curr_b = 0\n    alice_turn = True\n    while moves:\n        if alice_turn:\n            curr_a = moves.popleft()\n            while curr_a <= curr_b and moves:\n                curr_a += moves.popleft()\n            total_a += curr_a\n        else:\n            curr_b = moves.pop()\n            while curr_b <= curr_a and moves:\n                curr_b += moves.pop()\n            total_b += curr_b\n        alice_turn = not alice_turn\n        n_moves += 1\n    print(n_moves, total_a, total_b)", "def main():\n    x = int(input())\n    for _ in range(x):\n        z = int(input())\n        i = [int(i) for i in input().split()]\n        counter = 0\n        max_first = 0\n        max_second = 0\n        first = 0\n        second = 0\n        while len(i) > 0:\n            while first <= second and i != []:\n                first += i.pop(0)\n            max_first += first\n            counter += 1\n            second = 0\n            while second <= first and i != []:\n                second += i.pop()\n            max_second += second\n            if second != 0:\n                counter += 1\n            first = 0\n        print(counter, max_first, max_second)\nmain()", "def candyGameResult(nCandies, candies):\n    (Alice_sCandiesSize, Bob_sCandiesSize) = (candies[0], 0)\n    (pastCandiesSize, currCandiesSize) = (Alice_sCandiesSize, 0)\n    nMoves = 1\n    (iAlice, iBob) = (0, nCandies)\n    while iAlice + 1 < iBob:\n        nMoves += 1\n        if Alice_sCandiesSize > Bob_sCandiesSize:\n            while pastCandiesSize >= currCandiesSize and iAlice + 1 < iBob:\n                iBob -= 1\n                currCandiesSize += candies[iBob]\n            Bob_sCandiesSize += currCandiesSize\n        else:\n            while pastCandiesSize >= currCandiesSize and iAlice + 1 < iBob:\n                iAlice += 1\n                currCandiesSize += candies[iAlice]\n            Alice_sCandiesSize += currCandiesSize\n        (pastCandiesSize, currCandiesSize) = (currCandiesSize, 0)\n    return f'{nMoves} {Alice_sCandiesSize} {Bob_sCandiesSize}'\n\ndef testCase_1352d():\n    nCandies = int(input())\n    return (nCandies, list(map(int, input().split())))\nnTestCases = int(input())\ntestCases = tuple((testCase_1352d() for testCase in range(nTestCases)))\ntuple((print(candyGameResult(*testCase)) for testCase in testCases))", "list_ans = []\nfor _ in range(int(input())):\n    n = int(input())\n    (a, b, x) = (0, 0, 0)\n    (a1, b1) = (0, 0)\n    list1 = list(map(int, input().split()))\n    while list1:\n        while a <= b and list1:\n            a += list1.pop(0)\n        else:\n            if a > 0:\n                x += 1\n                a1 += a\n                b = 0\n        while b <= a and list1:\n            b += list1.pop(-1)\n        else:\n            if b > 0:\n                x += 1\n                b1 += b\n                a = 0\n    list_ans.append(str(x) + ' ' + str(a1) + ' ' + str(b1))\nfor item in list_ans:\n    print(item)", "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    a = nl()\n    l = 0\n    r = n - 1\n    al = bo = 0\n    cnt = 0\n    ra = rb = 0\n    while l <= r:\n        cnt += 1\n        ra = 0\n        while l <= r and ra <= rb:\n            al += a[l]\n            ra += a[l]\n            l += 1\n        if l <= r:\n            cnt += 1\n            rb = 0\n            while l <= r and rb <= ra:\n                bo += a[r]\n                rb += a[r]\n                r -= 1\n    print(cnt, al, bo)\n    return\nT = ni()\nfor _ in range(T):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        n = II()\n        cc = LI()\n        a = cc[0]\n        b = 0\n        i = 1\n        j = n - 1\n        ps = a\n        cnt = 1\n        while i <= j:\n            s = 0\n            while i <= j and s <= ps:\n                s += cc[j]\n                j -= 1\n            b += s\n            cnt += 1\n            ps = s\n            if j < i:\n                break\n            s = 0\n            while i <= j and s <= ps:\n                s += cc[i]\n                i += 1\n            a += s\n            cnt += 1\n            ps = s\n        print(cnt, a, b)\nmain()", "def candies(arr):\n    (totalAlice, totalBob) = (0, 0)\n    aliceTurn = True\n    currentAlice = 0\n    currentBob = arr[0] - 1\n    (i, j) = (0, len(arr) - 1)\n    moves = 0\n    while i <= j:\n        if aliceTurn:\n            currentAlice += arr[i]\n            if currentAlice > currentBob:\n                aliceTurn = False\n                currentBob = 0\n                moves += 1\n            totalAlice += arr[i]\n            i += 1\n        else:\n            currentBob += arr[j]\n            if currentBob > currentAlice:\n                aliceTurn = True\n                currentAlice = 0\n                moves += 1\n            totalBob += arr[j]\n            j -= 1\n    if aliceTurn and currentAlice <= currentBob and (currentAlice != 0):\n        moves += 1\n    if not aliceTurn and currentBob <= currentAlice and (currentBob != 0):\n        moves += 1\n    return (moves, totalAlice, totalBob)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(*candies(arr))", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return list(map(int, input().split()))\n\ndef solve(arr):\n    res = []\n    for a in arr:\n        q = deque(a)\n        count = 0\n        (a, b) = (0, 0)\n        (a_prev, b_prev) = (0, 0)\n        a_turn = True\n        while q:\n            if a_turn:\n                i = q.popleft()\n                a += i\n                a_prev += i\n                if a_prev > b_prev:\n                    a_turn = False\n                    b_prev = 0\n                    count += 1\n                elif not q:\n                    count += 1\n            else:\n                i = q.pop()\n                b += i\n                b_prev += i\n                if b_prev > a_prev:\n                    a_turn = True\n                    a_prev = 0\n                    count += 1\n                elif not q:\n                    count += 1\n        res.append([count, a, b])\n    return res\nn = inp()\narr = []\nfor i in range(n):\n    l = inp()\n    arr.append(inlt())\nres = solve(arr)\nfor r in res:\n    print(' '.join(map(str, r)))", "from sys import stdin\n\ndef solve(n, L):\n    sum_a = 0\n    sum_b = 0\n    size = 0\n    a = 0\n    b = n - 1\n    count = 0\n    val = 0\n    while a <= b:\n        size = 0\n        flag = 0\n        while size <= val and a <= b:\n            size += L[a]\n            flag = 1\n            a += 1\n        sum_a += size\n        if flag == 1:\n            count += 1\n        val = 0\n        flag = 0\n        while val <= size and a <= b:\n            val += L[b]\n            b -= 1\n            flag = 1\n        sum_b += val\n        if flag == 1:\n            count += 1\n    print(count, sum_a, sum_b)\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    L = list(map(int, stdin.readline().split()))\n    solve(n, L)", "from collections import deque\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        A = deque(map(int, input().split()))\n        num = 0\n        pre = 0\n        Flag = 0\n        a = 0\n        b = 0\n        while A:\n            eats = 0\n            while A and eats <= pre:\n                if Flag == 0:\n                    v = A.popleft()\n                else:\n                    v = A.pop()\n                eats += v\n            pre = eats\n            num += 1\n            if Flag == 0:\n                a += eats\n            else:\n                b += eats\n            Flag = 1 - Flag\n        ret = [num, a, b]\n        print(*ret)\nmain()", "t = int(input())\n\ndef to_sum(a):\n    res = []\n    for (i, n) in enumerate(a):\n        num = int(str(n) + '0' * (len(a) - i - 1))\n        if num != 0:\n            res.append(num)\n    return res\nfor _ in range(t):\n    n = input()\n    ai = list(map(int, input().split()))\n    bob_p = len(ai) - 1\n    alice_p = 0\n    alice_sweet = 0\n    bob_sweet = 0\n    alice_turn = True\n    alice_sum = 0\n    bob_sum = 0\n    turns = 1\n    while bob_p >= alice_p:\n        if alice_turn:\n            alice_sweet += ai[alice_p]\n            if alice_sweet > bob_sweet:\n                bob_sweet = 0\n                alice_turn = False\n                turns += 1\n            alice_sum += ai[alice_p]\n            alice_p += 1\n        else:\n            bob_sweet += ai[bob_p]\n            if bob_sweet > alice_sweet:\n                alice_sweet = 0\n                alice_turn = True\n                turns += 1\n            bob_sum += ai[bob_p]\n            bob_p -= 1\n    if alice_turn and alice_sweet == 0 or (not alice_turn and bob_sweet == 0):\n        turns -= 1\n    print(turns, alice_sum, bob_sum)", "def solve(n, candies):\n    a_prev = candies[0]\n    a_total = candies[0]\n    a_index = 0\n    b_index = n\n    b_total = 0\n    numMoves = 1\n    aTurn = False\n    while a_index + 1 != b_index:\n        if aTurn:\n            a_prev = 0\n            while a_index + 1 != b_index and a_prev < b_prev + 1:\n                a_prev += candies[a_index + 1]\n                a_index += 1\n            a_total += a_prev\n        else:\n            b_prev = 0\n            while b_index - 1 != a_index and b_prev < a_prev + 1:\n                b_prev += candies[b_index - 1]\n                b_index -= 1\n            b_total += b_prev\n        aTurn = not aTurn\n        numMoves += 1\n    print(numMoves, a_total, b_total)\nnumTests = int(input())\nfor test in range(numTests):\n    n = int(input())\n    candies = [int(candy) for candy in input().split()]\n    solve(n, candies)", "def f():\n    T = int(input())\n    for _ in range(T):\n        _ = input()\n        nums = [int(c) for c in input().split()]\n        solve(nums)\n\ndef solve(nums):\n    n = len(nums)\n    (i, j) = (-1, n)\n    (a, b) = (0, 0)\n    cur_max_size = 0\n    is_left = True\n    cnt = 0\n    while i + 1 < j:\n        if is_left:\n            size = 0\n            while i + 1 < j and size <= cur_max_size:\n                size += nums[i + 1]\n                i += 1\n            a += size\n            cur_max_size = size\n            is_left = False\n            cnt += 1\n        else:\n            size = 0\n            while i < j - 1 and size <= cur_max_size:\n                size += nums[j - 1]\n                j -= 1\n            b += size\n            cur_max_size = size\n            is_left = True\n            cnt += 1\n    print(cnt, a, b)\nf()", "import heapq\nfrom collections import *\nimport math\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    (a1, a2) = (a.pop(0), 0)\n    (t1, t2) = (a1, a2)\n    c = 1\n    while len(a) != 0:\n        k2 = 0\n        if k2 < t1 + 1:\n            while k2 < t1 + 1 and len(a) != 0:\n                l = a.pop()\n                a2 += l\n                k2 += l\n            if k2 != 0:\n                c += 1\n            t2 = k2\n        k1 = 0\n        if k1 < t2 + 1:\n            while k1 < t2 + 1 and len(a) != 0:\n                l = a.pop(0)\n                a1 += l\n                k1 += l\n            if k1 != 0:\n                c += 1\n            t1 = k1\n    print(c, a1, a2)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\n\ndef minp():\n    return sys.stdin.readline().strip()\n\ndef mint():\n    return int(minp())\n\ndef mints():\n    return map(int, minp().split())\n\ndef solve():\n    n = mint()\n    c = list(mints())\n    l = 1\n    r = n\n    a = c[0]\n    b = 0\n    la = c[0]\n    lb = 0\n    ans = 1\n    while l < r:\n        x = 0\n        ans += 1\n        while x <= la and l < r:\n            r -= 1\n            x += c[r]\n        lb = x\n        b += x\n        if l >= r:\n            break\n        ans += 1\n        x = 0\n        while x <= lb and l < r:\n            x += c[l]\n            l += 1\n        la = x\n        a += x\n    print(ans, a, b)\nfor i in range(mint()):\n    solve()", "def main():\n    n = int(input())\n    for i in range(n):\n        tamano = int(input())\n        dulces = list(map(int, input().split()))\n        if tamano == 1:\n            print('1 ' + str(dulces[0]) + ' 0')\n        else:\n            A = 1\n            B = tamano - 1\n            sumaA = dulces[0]\n            sumaB = 0\n            antA = dulces[0]\n            contador = 1\n            while A <= B:\n                antB = 0\n                entro = 0\n                while antB <= antA and A <= B:\n                    sumaB = sumaB + dulces[B]\n                    antB = antB + dulces[B]\n                    B -= 1\n                    entro = 1\n                if entro == 1:\n                    contador += 1\n                entro = 0\n                antA = 0\n                while antA <= antB and A <= B:\n                    sumaA = sumaA + dulces[A]\n                    antA = antA + dulces[A]\n                    A += 1\n                    entro = 1\n                if entro == 1:\n                    contador += 1\n            resultado = []\n            resultado.append(contador)\n            resultado.append(sumaA)\n            resultado.append(sumaB)\n            print(*resultado)\nmain()", "from math import *\nfrom collections import *\nfrom functools import *\nfrom bisect import *\nfrom itertools import *\nfrom heapq import *\nfrom statistics import *\ninf = float('inf')\nninf = -float('inf')\nip = input\nalphal = 'abcdefghijklmnopqrstuvwxyz'\nalphau = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef ipl():\n    return list(map(int, input().split()))\n\ndef ipn():\n    return int(input())\n\ndef ipf():\n    return float(input())\n\ndef solve():\n    (n, l) = (ipn(), ipl())\n    f = i = a = b = at = bt = m = 0\n    j = n - 1\n    while i <= j:\n        if not f:\n            a = 0\n            while i <= j:\n                at += l[i]\n                a += l[i]\n                i += 1\n                if a > b:\n                    break\n            f = 1\n        else:\n            b = 0\n            while i <= j:\n                b += l[j]\n                bt += l[j]\n                j -= 1\n                if b > a:\n                    break\n            f = 0\n        m += 1\n    print(m, at, bt)\nfor _ in range(ipn()):\n    solve()", "def main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        arr = list(map(int, input().split()))\n        i = 1\n        j = len(arr) - 1\n        prev = arr[0]\n        A = arr[0]\n        B = 0\n        turn = 0\n        move = 1\n        while i <= j:\n            if not turn:\n                s = 0\n                while s <= prev and i <= j:\n                    s += arr[j]\n                    j -= 1\n                prev = s\n                B += s\n                move += 1\n            else:\n                s = 0\n                while s <= prev and i <= j:\n                    s += arr[i]\n                    i += 1\n                prev = s\n                A += s\n                move += 1\n            turn = 1 - turn\n        print(move, A, B)\nmain()", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    left = 0\n    right = n - 1\n    s_alice = 0\n    s_bob = 0\n    alice = 0\n    bob = 0\n    steps = 0\n    while left <= right:\n        if steps % 2 == 0:\n            s_alice = 0\n            while s_bob >= s_alice and left <= right:\n                s_alice += a[left]\n                left += 1\n            alice += s_alice\n        else:\n            s_bob = 0\n            while s_alice >= s_bob and left <= right:\n                s_bob += a[right]\n                right -= 1\n            bob += s_bob\n        steps += 1\n    print(steps, alice, bob)\n\ndef main():\n    for _ in range(int(input())):\n        solve()\nmain()", "import sys\nI = sys.stdin.readline\npr = sys.stdout.write\n\ndef main():\n    for _ in range(int(I())):\n        n = int(I())\n        ar = list(map(int, I().split()[:n]))\n        i = 1\n        j = n - 1\n        a = at = ar[0]\n        b = bt = 0\n        c = 1\n        try:\n            while i < j:\n                while bt <= at and i <= j:\n                    bt += ar[j]\n                    ar[j] = -1\n                    j -= 1\n                c += 1\n                at = 0\n                b += bt\n                while at <= bt and i <= j:\n                    at += ar[i]\n                    ar[i] = -1\n                    i += 1\n                a += at\n                if at:\n                    c += 1\n                if at > bt:\n                    bt = 0\n            if i == j and ar[i] != -1:\n                if bt:\n                    a += ar[i]\n                else:\n                    b += ar[i]\n                    c += 1\n        except Exception as e:\n            pr(f'{e} => {n},{j}')\n            break\n        pr(f'{c} {a} {b}\\n')\nmain()", "def countScores(n, a):\n    l = 0\n    r = n - 1\n    suml = sumr = 0\n    cnt = ansl = ansr = 0\n    while l <= r:\n        if cnt % 2 == 0:\n            nsuml = 0\n            while l <= r and nsuml <= sumr:\n                nsuml += int(a[l])\n                l += 1\n            ansl += nsuml\n            suml = nsuml\n        else:\n            nsumr = 0\n            while l <= r and nsumr <= suml:\n                nsumr += int(a[r])\n                r -= 1\n            ansr += nsumr\n            sumr = nsumr\n        cnt += 1\n    return str(cnt) + ' ' + str(ansl) + ' ' + str(ansr)\nn = 0\ncandies = []\nresult = []\nfor _ in range(0, int(input())):\n    n = int(input())\n    candies = list(input().split())\n    result.append(countScores(n, candies))\nfor r in result:\n    print(r)", "def eat(candies):\n    (a_last, a_total) = (0, 0)\n    (b_last, b_total) = (0, 0)\n    (a_turn, b_turn) = (True, False)\n    moves = 0\n    while len(candies) > 0:\n        if a_turn:\n            candy = candies.pop(0)\n            a_last += candy\n            a_total += candy\n            if a_last > b_last or len(candies) == 0:\n                b_turn = True\n                a_turn = False\n                b_last = 0\n                moves += 1\n        else:\n            candy = candies.pop(-1)\n            b_last += candy\n            b_total += candy\n            if b_last > a_last or len(candies) == 0:\n                a_turn = True\n                b_turn = False\n                a_last = 0\n                moves += 1\n    return (moves, a_total, b_total)\nimport os\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    candies = list(map(int, input().split()))\n    (moves, a_total, b_total) = eat(candies)\n    print(moves, a_total, b_total)", "def func(A):\n    i = -1\n    j = len(A)\n    flag = 0\n    prev_flag = -1\n    summ1 = 0\n    summ2 = 0\n    summ11 = 0\n    summ22 = 0\n    count = 0\n    while i < j:\n        if flag != prev_flag:\n            count += 1\n        prev_flag = flag\n        if flag == 0:\n            i += 1\n            summ1 += A[i]\n            summ11 += A[i]\n            if summ11 > summ22:\n                flag = 1\n                summ22 = 0\n        else:\n            j -= 1\n            summ2 += A[j]\n            summ22 += A[j]\n            if summ22 > summ11:\n                flag = 0\n                summ11 = 0\n        if i + 1 == j:\n            break\n    return (count, summ1, summ2)\nx = int(input())\na = []\nfor _ in range(x):\n    l = input()\n    a.append(list(map(int, input().split())))\nfor i in a:\n    (a, b, c) = func(i)\n    print(' '.join(list(map(str, [a, b, c]))))", "n = int(input())\n\ndef get_answer(arr):\n    (r, a, b) = (0, 0, 0)\n    (i, j) = (0, len(arr) - 1)\n    s = 0\n    while i <= j:\n        t = 0\n        while t <= s and i <= j:\n            t += int(arr[i])\n            a += int(arr[i])\n            i += 1\n        r += 1\n        s = t\n        if i == j + 1:\n            print(r, a, b)\n            return\n        t = 0\n        while t <= s and i <= j:\n            t += int(arr[j])\n            b += int(arr[j])\n            j -= 1\n        r += 1\n        s = t\n        if i == j + 1:\n            print(r, a, b)\n            return\nfor _ in range(n):\n    v = input()\n    arr = input().split()\n    get_answer(arr)", "def solve(num, candies):\n    aliceIndex = -1\n    bobIndex = num\n    aliceEaten = 0\n    bobEaten = 0\n    aliceTurn = True\n    biggerThanThis = 0\n    move = 0\n    temp = 0\n    while aliceIndex < bobIndex:\n        temp = 0\n        if bobIndex - aliceIndex == 1:\n            break\n        if aliceTurn:\n            while temp <= biggerThanThis and aliceIndex + 1 < bobIndex:\n                aliceIndex += 1\n                temp += candies[aliceIndex]\n            biggerThanThis = temp\n            aliceEaten += temp\n            aliceTurn = False\n        else:\n            while temp <= biggerThanThis and bobIndex - 1 > aliceIndex:\n                bobIndex -= 1\n                temp += candies[bobIndex]\n            biggerThanThis = temp\n            bobEaten += temp\n            aliceTurn = True\n        move += 1\n    print(move, aliceEaten, bobEaten)\n    return\nfor x in range(int(input())):\n    n = int(input())\n    c = list(map(int, input().split()))\n    solve(n, c)", "import sys\ninput = sys.stdin.readline\nt = int(input())\n\ndef move(P, index, m, a, player, opindex):\n    C = 0\n    key = 0\n    while C <= P:\n        if index == opindex:\n            key = 1\n        C += a[index]\n        if player == 'A':\n            index += 1\n        else:\n            index -= 1\n        if key == 1:\n            break\n    m += 1\n    return (C, m, index)\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().strip().split()))\n    (A, B, m) = (a[0], 0, 1)\n    i = 1\n    j = n - 1\n    Ap = a[0]\n    while i <= j:\n        (Bp, m, j) = move(Ap, j, m, a, 'B', i)\n        B += Bp\n        if i <= j:\n            (Ap, m, i) = move(Bp, i, m, a, 'A', j)\n            A += Ap\n    print(m, A, B)", "from collections import deque\nt = int(input())\n\ndef solve(n, arr):\n    q = deque(arr)\n    alice = 0\n    bob = 0\n    now = 0\n    prev = 0\n    turn_alice = True\n    moves = 1\n    while q:\n        if turn_alice and now <= prev:\n            candy = q.popleft()\n            alice += candy\n            now += candy\n        elif not turn_alice and now <= prev:\n            candy = q.pop()\n            bob += candy\n            now += candy\n        else:\n            turn_alice = not turn_alice\n            prev = now\n            now = 0\n            moves += 1\n    print(f'{moves} {alice} {bob}')\nwhile t:\n    t -= 1\n    n = int(input())\n    k = list(map(int, input().split(' ')))\n    solve(n, k)", "def solve(n, arr):\n    prev = 0\n    steps = 0\n    a = b = 0\n    (l, r) = (0, n - 1)\n    while l <= r:\n        curr = 0\n        while l <= r and curr <= prev:\n            curr += arr[l]\n            l += 1\n        a += curr\n        prev = curr\n        steps += 1\n        if l <= r:\n            curr = 0\n            while l <= r and curr <= prev:\n                curr += arr[r]\n                r -= 1\n            b += curr\n            prev = curr\n            steps += 1\n    return (steps, a, b)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (m, a, b) = solve(n, arr)\n    print(m, a, b)", "def main():\n    n = int(input())\n    lst = list(map(int, input().split()))\n    left = 0\n    right = n\n    ltot = lst[0]\n    rtot = 0\n    lsum = lst[0]\n    rsum = 0\n    turns = 1\n    while left + 1 != right:\n        if rsum == 0:\n            turns += 1\n            while rsum <= lsum and left + 1 != right:\n                right -= 1\n                rsum += lst[right]\n            rtot += rsum\n            lsum = 0\n        else:\n            turns += 1\n            while rsum >= lsum and left + 1 != right:\n                left += 1\n                lsum += lst[left]\n            rsum = 0\n            ltot += lsum\n    print(turns, ltot, rtot)\nt = int(input())\nfor i in range(t):\n    main()", "def RA():\n    return list(map(int, input().split()))\n\ndef solve():\n    n = int(input())\n    arr = RA()\n    l = 0\n    r = n\n    aliceEat = arr[0]\n    a = arr[0]\n    b = 0\n    count = 1\n    while l != r - 1:\n        bobEat = 0\n        while l != r - 1 and bobEat <= aliceEat:\n            r -= 1\n            bobEat += arr[r]\n        b += bobEat\n        count += 1\n        if l == r - 1:\n            break\n        aliceEat = 0\n        while l != r - 1 and aliceEat <= bobEat:\n            l += 1\n            aliceEat += arr[l]\n        a += aliceEat\n        count += 1\n    print(count, a, b)\nt = int(input())\nfor i in range(t):\n    solve()", "from collections import deque\nt = int(input())\n\ndef solve(candies: deque):\n    alices_turn = True\n    alice_ate_total = 0\n    bob_ate_total = 0\n    alice_ate_last_turn = 0\n    bob_ate_last_turn = 0\n    turns_done = 0\n    while candies:\n        if alices_turn:\n            alice_ate_current_turn = 0\n            while alice_ate_current_turn <= bob_ate_last_turn and candies:\n                alice_ate_current_turn += candies.popleft()\n            alice_ate_last_turn = alice_ate_current_turn\n            alice_ate_total += alice_ate_current_turn\n            alices_turn = False\n        elif not alices_turn:\n            bob_ate_current_turn = 0\n            while bob_ate_current_turn <= alice_ate_last_turn and candies:\n                bob_ate_current_turn += candies.pop()\n            bob_ate_last_turn = bob_ate_current_turn\n            bob_ate_total += bob_ate_current_turn\n            alices_turn = True\n        turns_done += 1\n    print(turns_done, alice_ate_total, bob_ate_total, flush=False)\nfor _ in range(t):\n    n = int(input())\n    candies = deque((int(s) for s in input().split(' ')))\n    solve(candies)", "from sys import stdin\nfrom collections import deque\n\ndef main():\n    readline = stdin.readline\n    t = int(readline())\n    res = []\n    for i in range(t):\n        n = int(readline())\n        a = list(map(int, readline().split()))\n        d = deque(a)\n        alice = 0\n        bob = 0\n        t_alice = 0\n        t_bob = 0\n        t_move = 0\n        flag = False\n        now = 0\n        while len(d) > 0:\n            if now == 0:\n                if flag == False:\n                    t_move += 1\n                    flag = True\n                m = d.popleft()\n                alice += m\n                if alice > bob:\n                    now = 1\n                    t_alice += alice\n                    bob = 0\n                elif len(d) == 0:\n                    t_alice += alice\n            else:\n                if flag:\n                    t_move += 1\n                    flag = False\n                m = d.pop()\n                bob += m\n                if bob > alice:\n                    now = 0\n                    t_bob += bob\n                    alice = 0\n                elif len(d) == 0:\n                    t_bob += bob\n        res.append([t_move, t_alice, t_bob])\n    for i in range(t):\n        print(*res[i])\nmain()", "def read_int():\n    return int(input().strip())\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\ndef solve():\n    n = read_ints()\n    a = read_ints()\n    (i, j) = (0, len(a) - 1)\n    (alice, bob) = (0, 0)\n    (total_alice, total_bob) = (0, 0)\n    count = 0\n    while i <= j:\n        while i <= j and alice <= bob:\n            alice += a[i]\n            total_alice += a[i]\n            i += 1\n        count += 1\n        bob = 0\n        if i > j:\n            break\n        while i <= j and bob <= alice:\n            bob += a[j]\n            total_bob += a[j]\n            j -= 1\n        alice = 0\n        count += 1\n    print(count, total_alice, total_bob)\nT = read_int()\nfor _ in range(T):\n    solve()", "def solve():\n    N = int(input())\n    arr = [int(el) for el in input().split()]\n    (l, r) = (1, N - 1)\n    (A, B) = (arr[0], 0)\n    (A_cur, B_cur) = (arr[0], 0)\n    cnt = 0\n    for i in range(1, N):\n        if i % 2 == 1:\n            B_cur = 0\n            while B_cur <= A_cur and r >= l:\n                B_cur += arr[r]\n                r -= 1\n            if B_cur > 0:\n                cnt += 1\n                B += B_cur\n        else:\n            A_cur = 0\n            while A_cur <= B_cur and l <= r:\n                A_cur += arr[l]\n                l += 1\n            if A_cur > 0:\n                cnt += 1\n                A += A_cur\n    print(cnt + 1, A, B)\nfor t in range(1, int(input()) + 1):\n    solve()", "def candies(data):\n    i = 1\n    a = data.pop(0)\n    alice = a\n    b = 0\n    bob = 0\n    while data:\n        if i % 2 != 0:\n            while b <= a:\n                if data:\n                    b += data.pop()\n                else:\n                    break\n            bob += b\n            a = 0\n        else:\n            while a <= b:\n                if data:\n                    a += data.pop(0)\n                else:\n                    break\n            alice += a\n            b = 0\n        i += 1\n    print(i, alice, bob)\nn = int(input())\nfor i in range(n):\n    x = int(input())\n    candies(list(map(int, input().split())))", "def answer(n, A):\n    a = A[0]\n    b = 0\n    a_p = a\n    b_p = 0\n    count = 1\n    l = 0\n    r = n - 1\n    while r > l:\n        if count % 2 != 0:\n            while r > l and b_p <= a_p:\n                b_p += A[r]\n                r -= 1\n            a_p = 0\n            b += b_p\n            count += 1\n        else:\n            while r > l and a_p <= b_p:\n                l += 1\n                a_p += A[l]\n            a += a_p\n            b_p = 0\n            count += 1\n    return [count, a, b]\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(*answer(n, arr))", "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve(test):\n    n = int(input())\n    a = list(map(int, input().split()))\n    moves = 0\n    (i, j) = (0, n - 1)\n    last = 0\n    curr = 0\n    flag = 0\n    alice = 0\n    bob = 0\n    while i <= j:\n        if not flag:\n            curr += a[i]\n            alice += a[i]\n            if curr > last:\n                last = curr\n                curr = 0\n                moves += 1\n                flag = 1\n            i += 1\n        else:\n            curr += a[j]\n            bob += a[j]\n            if curr > last:\n                last = curr\n                curr = 0\n                moves += 1\n                flag = 0\n            j -= 1\n    if curr:\n        moves += 1\n    print('{} {} {}'.format(moves, alice, bob))\ntest_cases = int(input())\nfor t in range(1, test_cases + 1):\n    solve(t)", "def Hello(l):\n    (a, b) = (0, 0)\n    c = 0\n    (i, j) = (0, len(l) - 1)\n    k = 0\n    while i <= j:\n        p = 0\n        if c % 2 != 0:\n            while p <= k and i <= j:\n                p += l[j]\n                b += l[j]\n                j -= 1\n            k = p\n        else:\n            while p <= k and i <= j:\n                p += l[i]\n                a += l[i]\n                i += 1\n            k = p\n        c += 1\n    print(c, a, b)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    Hello(list(map(int, input().split())))", "def candy(a):\n    n = len(a)\n    (l, r) = (0, n - 1)\n    (totl, totr) = (0, 0)\n    (prevl, prevr) = (0, 0)\n    move = 0\n    while l <= r:\n        aggl = a[l]\n        while aggl <= prevr and l + 1 <= r:\n            l += 1\n            aggl += a[l]\n        if l == r:\n            totl += aggl\n            move += 1\n            return (move, totl, totr)\n        move += 1\n        l += 1\n        prevl = aggl\n        totl += aggl\n        aggr = a[r]\n        while aggr <= prevl and r - 1 >= l:\n            r -= 1\n            aggr += a[r]\n        if r == l:\n            totr += aggr\n            move += 1\n            return (move, totl, totr)\n        move += 1\n        r -= 1\n        prevr = aggr\n        totr += aggr\n    return (move, totl, totr)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [int(c) for c in input().split()]\n    print(*candy(a))", "def f(n, arr):\n    p1 = 0\n    p2 = n - 1\n    cur = arr[0]\n    al = 0\n    bl = 0\n    moves = 0\n    total_al = 0\n    total_bl = 0\n    while p1 <= p2:\n        while cur > al and p1 <= p2:\n            al += arr[p1]\n            p1 += 1\n        total_al += al\n        cur = al + 1\n        if al > 0:\n            moves += 1\n        while cur > bl and p1 <= p2:\n            bl += arr[p2]\n            p2 -= 1\n        total_bl += bl\n        cur = bl + 1\n        if bl > 0:\n            moves += 1\n        al = 0\n        bl = 0\n    return [moves, total_al, total_bl]\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*f(n, a))", "def main():\n    n = int(input())\n    candies = list(map(int, input().split()))\n    left = 0\n    right = n - 1\n    alice = 0\n    a = 0\n    b = 0\n    bob = 0\n    flag = 0\n    moves = 0\n    while left <= right:\n        if flag == 0:\n            while alice <= bob and left <= right:\n                alice += candies[left]\n                a += candies[left]\n                left += 1\n            flag = 1\n            bob = 0\n        else:\n            while bob <= alice and left <= right:\n                bob += candies[right]\n                b += candies[right]\n                right -= 1\n            flag = 0\n            alice = 0\n        moves += 1\n    print(moves, a, b)\nt = int(input())\nfor _ in range(t):\n    main()", "def checker(n, lst):\n    (l, r) = (0, n - 1)\n    (sl, sr) = (0, 0)\n    (count, ansl, ansr) = (0, 0, 0)\n    while l <= r:\n        if count % 2 == 0:\n            s1 = 0\n            while l <= r and s1 <= sr:\n                s1 += lst[l]\n                l += 1\n            ansl += s1\n            sl = s1\n        else:\n            s2 = 0\n            while l <= r and s2 <= sl:\n                s2 += lst[r]\n                r -= 1\n            ansr += s2\n            sr = s2\n        count += 1\n    return (count, ansl, ansr)\nfor _ in range(int(input())):\n    m = int(input())\n    a = [int(i) for i in input().split()]\n    print(*checker(m, a))", "def solve(n, a):\n    players = [[0], [0]]\n    current = 0\n    alice = 0\n    la = 0\n    bob = 0\n    lb = 0\n    alice_turn = True\n    ac = -1\n    bc = n\n    moves = 0\n    while ac + 1 < bc:\n        t = 0\n        if alice_turn:\n            while t <= lb and ac + 1 < bc:\n                ac += 1\n                t += a[ac]\n            la = t\n            moves += 1\n            alice += t\n        else:\n            while t <= la and ac < bc - 1:\n                bc -= 1\n                t += a[bc]\n            lb = t\n            moves += 1\n            bob += t\n        alice_turn = not alice_turn\n    print('{} {} {}'.format(moves, alice, bob))\nT = int(input())\nfor case in range(T):\n    solve(int(input()), [int(x) for x in input().split()])", "def task(n, a):\n    aa = 0\n    bb = 0\n    moves = 0\n    Alice = True\n    last = 0\n    candies = 0\n    while True:\n        if Alice:\n            candy = a.pop(0)\n            candies += candy\n            aa += candy\n        else:\n            candy = a.pop()\n            candies += candy\n            bb += candy\n        if len(a) == 0:\n            moves += 1\n            break\n        if candies > last:\n            last = candies\n            candies = 0\n            Alice = not Alice\n            moves += 1\n    print(moves, aa, bb)\nt = int(input())\nfor i in range(0, t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    task(n, a)", "def main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        candie = list(map(int, input().split()))\n        a = 0\n        b = 0\n        j = 0\n        cur_a = 0\n        cur_b = 0\n        flag = False\n        while True:\n            cur_a = 0\n            while cur_b >= cur_a:\n                try:\n                    cur_a += candie.pop(0)\n                except IndexError:\n                    a += cur_a\n                    j += 1\n                    flag = True\n                    break\n            if flag:\n                break\n            a += cur_a\n            if candie != []:\n                j += 1\n            cur_b = 0\n            while cur_a >= cur_b:\n                try:\n                    cur_b += candie.pop(-1)\n                except IndexError:\n                    b += cur_b\n                    j += 1\n                    flag = True\n                    break\n            if flag:\n                break\n            b += cur_b\n            if candie != []:\n                j += 1\n        print(j, a, b)\nmain()", "import sys\nfrom sys import maxsize\nfrom collections import Counter as cnt\nfrom collections import defaultdict as dic\nget_int = lambda : int(input())\nget_list = lambda : list(map(int, input().rstrip().split()))\nTEST_CASES = True\n\ndef main():\n    n = get_int()\n    arr = get_list()\n    (alice, bob, c, i) = [0] * 4\n    j = n - 1\n    curr = last = 0\n    while i <= j:\n        if c % 2 == 0:\n            while curr <= last and i <= j:\n                curr += arr[i]\n                i += 1\n            (last, curr) = (curr, 0)\n            alice += last\n            c += 1\n        else:\n            while curr <= last and i <= j:\n                curr += arr[j]\n                j -= 1\n            (last, curr) = (curr, 0)\n            bob += last\n            c += 1\n    print(c, alice, bob)\nif not TEST_CASES:\n    main()\nelse:\n    [main() for _ in range(int(input()))]", "from collections import deque\n\ndef tc():\n    n = int(input())\n    cs = deque(map(int, input().split()))\n    (a, b) = (0, 0)\n    (pa, pb) = (a, b)\n    turn = 1\n    moves = 0\n    while cs:\n        if turn == 1 and pa <= pb:\n            x = cs.popleft()\n            pa += x\n            a += x\n            if pa > pb or not cs:\n                pb = 0\n                moves += 1\n                turn *= -1\n        elif turn == -1 and pb <= pa:\n            x = cs.pop()\n            pb += x\n            b += x\n            if pb > pa or not cs:\n                pa = 0\n                moves += 1\n                turn *= -1\n    return (moves, a, b)\nt = int(input())\nfor _ in range(t):\n    (moves, a, b) = tc()\n    print(moves, a, b)", "import sys\nfrom math import sqrt, gcd, ceil, log\nfrom bisect import bisect\nfrom collections import defaultdict, Counter, deque\nfrom heapq import heapify, heappush, heappop\ninp = sys.stdin.readline\nread = lambda : list(map(int, inp().strip().split()))\n\ndef solve():\n    ans = ''\n    for _ in range(int(inp())):\n        n = int(inp())\n        arr = deque(read())\n        moves = 0\n        eats = [0, 0]\n        last_eat = 0\n        f = 0\n        while arr:\n            curr_eat = 0\n            while arr and last_eat >= curr_eat:\n                if f:\n                    curr_eat += arr.pop()\n                else:\n                    curr_eat += arr.popleft()\n            eats[f] += curr_eat\n            last_eat = curr_eat\n            f = [1, 0][f]\n            moves += 1\n        ans += ' '.join(map(str, [moves] + eats)) + '\\n'\n    print(ans)\nsolve()", "def main():\n    n = int(input())\n    for i in range(n):\n        tamano = int(input())\n        dulces = list(map(int, input().split()))\n        if tamano == 1:\n            print('1 ' + str(dulces[0]) + ' 0')\n        else:\n            A = 1\n            B = tamano - 1\n            sumaA = dulces[0]\n            sumaB = 0\n            antA = dulces[0]\n            contador = 1\n            while A <= B:\n                antB = 0\n                entro = 0\n                while antB <= antA and A <= B:\n                    sumaB = sumaB + dulces[B]\n                    antB = antB + dulces[B]\n                    B -= 1\n                    entro = 1\n                if entro == 1:\n                    contador += 1\n                entro = 0\n                antA = 0\n                while antA <= antB and A <= B:\n                    sumaA = sumaA + dulces[A]\n                    antA = antA + dulces[A]\n                    A += 1\n                    entro = 1\n                if entro == 1:\n                    contador += 1\n            resultado = []\n            resultado.append(contador)\n            resultado.append(sumaA)\n            resultado.append(sumaB)\n            print(*resultado)\nmain()", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    a1 = list(map(int, input().split()))\n    a = 0\n    b = 0\n    s = 0\n    c = 0\n    l = 0\n    m = n - 1\n    f = 0\n    while l <= m:\n        d = 0\n        if f == 0:\n            while s >= d:\n                d = d + a1[l]\n                l = l + 1\n                if l > m:\n                    break\n            s = d\n            a = a + d\n            c = c + 1\n            f = 1\n        else:\n            while s >= d:\n                d = d + a1[m]\n                m = m - 1\n                if l > m:\n                    break\n            s = d\n            b = b + d\n            c = c + 1\n            f = 0\n    print('{} {} {}'.format(c, a, b))", "o = []\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (l, r, sl, sr, c, al, ar) = (0, n - 1, 0, 0, 0, 0, 0)\n    while l <= r:\n        if c % 2 < 1:\n            nsl = 0\n            while l <= r and nsl <= sr:\n                nsl += a[l]\n                l += 1\n            al += nsl\n            sl = nsl\n        else:\n            nsr = 0\n            while l <= r and nsr <= sl:\n                nsr += a[r]\n                r -= 1\n            ar += nsr\n            sr = nsr\n        c += 1\n    o.append(str(c) + ' ' + str(al) + ' ' + str(ar))\nprint(*o, sep='\\n')", "t = int(input())\nfor _ in range(t):\n    number_of_candies = int(input())\n    candies = list(map(int, input().split()))\n    (l, r) = (0, len(candies) - 1)\n    (prev_alice, prev_bob) = (0, 0)\n    (cur_alice, cur_bob) = (0, 0)\n    (total_alice, total_bob) = (0, 0)\n    num_of_moves = 0\n    total_candies = sum(candies)\n    while total_alice + total_bob < total_candies:\n        (alice_ate, bob_ate) = (False, False)\n        (cur_alice, cur_bob) = (0, 0)\n        while cur_alice <= prev_bob and l <= r:\n            alice_ate = True\n            cur_alice += candies[l]\n            total_alice += candies[l]\n            l += 1\n            prev_alice = cur_alice\n        while cur_bob <= prev_alice and l <= r:\n            bob_ate = True\n            total_bob += candies[r]\n            cur_bob += candies[r]\n            r -= 1\n            prev_bob = cur_bob\n        if alice_ate and bob_ate:\n            num_of_moves += 2\n        else:\n            num_of_moves += 1\n    print(*[num_of_moves, total_alice, total_bob])", "for t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (a_i, b_i) = (1, n - 1)\n    (Alice, Bob) = (a[0], 0)\n    num_list = [a[0], 0]\n    k = 1\n    while a_i <= b_i:\n        if Bob < Alice:\n            while Bob <= Alice and b_i >= a_i:\n                Bob += a[b_i]\n                b_i -= 1\n            else:\n                Alice = 0\n                num_list[1] += Bob\n        else:\n            while Bob >= Alice and b_i >= a_i:\n                Alice += a[a_i]\n                a_i += 1\n            else:\n                Bob = 0\n                num_list[0] += Alice\n        k += 1\n    print(k, num_list[0], num_list[1])", "for t in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    (a_i, b_i) = (1, n - 1)\n    (Alice, Bob) = (a[0], 0)\n    num_list = [a[0], 0]\n    k = 1\n    while a_i <= b_i:\n        if Bob < Alice:\n            while Bob <= Alice and b_i >= a_i:\n                Bob += a[b_i]\n                b_i -= 1\n            else:\n                Alice = 0\n                num_list[1] += Bob\n        else:\n            while Bob >= Alice and b_i >= a_i:\n                Alice += a[a_i]\n                a_i += 1\n            else:\n                Bob = 0\n                num_list[0] += Alice\n        k += 1\n    print(k, num_list[0], num_list[1])", "from math import *\nmod = 10 ** 9 + 7\n\ndef _in():\n    return [int(x) for x in input().split(' ')]\n\ndef main():\n    n = int(input())\n    arr = _in()\n    (cnt, a, b, t) = (1, arr[0], 0, 1)\n    (preva, prevb) = (arr[0], 0)\n    (i, j) = (1, n - 1)\n    while i <= j:\n        s = 0\n        if t == 0:\n            while i <= j and prevb >= s:\n                s = s + arr[i]\n                i = i + 1\n            (preva, a) = (s, a + s)\n        else:\n            while j >= i and preva >= s:\n                s = s + arr[j]\n                j = j - 1\n            (prevb, b) = (s, b + s)\n        t = t ^ 1\n        cnt = cnt + 1\n    print(cnt, a, b)\nfor _ in range(int(input())):\n    main()", "import collections\nfrom sys import stdin\ninput = stdin.readline\n\ndef main():\n    test = int(input())\n    for t in range(test):\n        n = int(input())\n        l = [int(i) for i in input().split(' ')]\n        d = collections.deque(l)\n        a = 0\n        b = 0\n        preva = 0\n        prevb = 0\n        count = 0\n        while len(d) > 0:\n            curra = 0\n            flag = False\n            while curra <= prevb and len(d) > 0:\n                curra += d.popleft()\n                flag = True\n            if flag:\n                count += 1\n            a += curra\n            preva = curra\n            currb = 0\n            flag = False\n            while currb <= preva and len(d) > 0:\n                currb += d.pop()\n                flag = True\n            if flag:\n                count += 1\n            b += currb\n            prevb = currb\n        print(count, a, b)\nmain()", "def solve(arr):\n    i = -1\n    j = len(arr)\n    (a, b) = (0, 0)\n    (preva, prevb) = (0, 0)\n    move = 0\n    while i < j:\n        (suma, sumb) = (0, 0)\n        i += 1\n        while i < j:\n            if suma == 0:\n                move += 1\n            suma += arr[i]\n            if suma > prevb:\n                break\n            i += 1\n        a += suma\n        preva = suma\n        j -= 1\n        while i < j:\n            if sumb == 0:\n                move += 1\n            sumb += arr[j]\n            if sumb > preva:\n                break\n            j -= 1\n        b += sumb\n        prevb = sumb\n    print(move, a, b)\nT = int(input())\nfor ti in range(1, T + 1):\n    size = int(input())\n    arr = list(map(int, input().split(' ')))\n    solve(arr)", "def solution(x):\n    (idxL, idxR) = (0, len(x) - 1)\n    (ansA, ansB, last) = (0, 0, 0)\n    moves = 0\n    while idxL <= idxR:\n        tmp = 0\n        moves += 1\n        while tmp <= last and idxL <= idxR:\n            tmp += x[idxL]\n            idxL += 1\n        ansA += tmp\n        last = tmp\n        tmp = 0\n        if idxL <= idxR:\n            moves += 1\n        while tmp <= last and idxL <= idxR:\n            tmp += x[idxR]\n            idxR -= 1\n        ansB += tmp\n        last = tmp\n    return (moves, ansA, ansB)\nN = int(input())\nfor _ in range(N):\n    sz = int(input())\n    x = list(map(int, input().split()))\n    print(*solution(x))", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    cookies = input().split()\n    cookies = list(map(int, cookies))\n    alice_curr = 0\n    bob_curr = len(cookies) - 1\n    alice_count = 0\n    bob_count = 0\n    last_max = 0\n    turn_count = 0\n    while alice_curr <= bob_curr:\n        curr_eat = 0\n        while curr_eat <= last_max:\n            if turn_count % 2 == 0:\n                alice_count += cookies[alice_curr]\n                curr_eat += cookies[alice_curr]\n                alice_curr += 1\n                if alice_curr > bob_curr:\n                    break\n            else:\n                bob_count += cookies[bob_curr]\n                curr_eat += cookies[bob_curr]\n                bob_curr -= 1\n                if alice_curr > bob_curr:\n                    break\n        last_max = curr_eat\n        turn_count += 1\n    print(turn_count, alice_count, bob_count)", "def solve(arr):\n    a = arr.pop(0)\n    asum = a\n    b = bsum = 0\n    index = 'b'\n    counter = 1\n    while len(arr) > 0:\n        if len(arr) == 1:\n            counter += 1\n        if index == 'b':\n            x = arr.pop()\n            b += x\n            bsum += x\n            if b > a and len(arr) > 0:\n                index = 'a'\n                a = 0\n                counter += 1\n        elif index == 'a':\n            x = arr.pop(0)\n            a += x\n            asum += x\n            if a > b and len(arr) > 0:\n                index = 'b'\n                b = 0\n                counter += 1\n    print('{} {} {}'.format(counter, asum, bsum))\ni = int(input())\nfor k in range(i):\n    c = int(input())\n    j = input().split(' ')\n    arr = list(map(int, j))\n    solve(arr)", "for _ in [0] * int(input()):\n    n = int(input())\n    a = (*map(int, input().split()),)\n    i = l = 0\n    j = n - 1\n    x = y = z = 0\n    while i <= j:\n        c = 0\n        while i <= j and c <= l:\n            c += a[i]\n            i += 1\n        z += 1\n        x += c\n        l = c\n        if i > j:\n            break\n        c = 0\n        while i <= j and c <= l:\n            c += a[j]\n            j -= 1\n        z += 1\n        y += c\n        l = c\n    print(z, x, y)", "T = int(input())\nn = [0] * T\nns = [0] * T\nfor t in range(T):\n    n[t] = int(input())\n    ns[t] = [int(i) for i in input().split(' ')]\n\ndef ans(n, ns):\n    a = ns.pop(0)\n    atot = a\n    btot = 0\n    m = 1\n    while len(ns) > 0:\n        b = 0\n        while b <= a and len(ns) > 0:\n            b += ns.pop(-1)\n        m += 1\n        btot += b\n        a = 0\n        if len(ns) > 0:\n            m += 1\n        while a <= b and len(ns) > 0:\n            a += ns.pop(0)\n        atot += a\n    return str(str(m) + ' ' + str(atot) + ' ' + str(btot))\nfor t in range(T):\n    print(ans(n[t], ns[t]))", "def eat_candies(candy: list) -> None:\n    new_li = candy\n    alice = 0\n    bob = 0\n    turn = True\n    previous = 0\n    turns = 0\n    length = len(new_li)\n    while length > 0:\n        if turn:\n            current = 0\n            while current <= previous:\n                if len(new_li) == 0:\n                    break\n                temp = new_li.pop(0)\n                current += temp\n            previous = current\n            alice += current\n            turn = False\n            turns += 1\n        else:\n            current = 0\n            while current <= previous:\n                if len(new_li) == 0:\n                    break\n                temp = new_li.pop(-1)\n                current += temp\n            previous = current\n            bob += current\n            turn = True\n            turns += 1\n        length = len(new_li)\n    print(turns, alice, bob)\n\ndef main():\n    cases = int(input())\n    for _ in range(cases):\n        input()\n        li = [int(x) for x in input().split(' ')]\n        eat_candies(li)\nmain()", "import collections, heapq, itertools, math\ngroupby = itertools.groupby\nrs = lambda : input()\nri = lambda : int(input())\nrm = lambda : map(int, input().split())\nrai = lambda : [int(x) for x in input().split()]\n\ndef solve(n, a):\n    move = 0\n    sum_a = 0\n    sum_b = 0\n    prev_a = 0\n    prev_b = 0\n    turn = 0\n    l = 0\n    r = n - 1\n    while l <= r:\n        if turn == 0:\n            while prev_a <= prev_b and turn == 0 and (l <= r):\n                sum_a += a[l]\n                prev_a += a[l]\n                l += 1\n            prev_b = 0\n            turn = 1\n        else:\n            while prev_b <= prev_a and turn == 1 and (l <= r):\n                sum_b += a[r]\n                prev_b += a[r]\n                r -= 1\n            prev_a = 0\n            turn = 0\n        move += 1\n    return (move, sum_a, sum_b)\nfor t in range(ri()):\n    n = ri()\n    a = rai()\n    print('{} {} {}'.format(*solve(n, a)))", "def numCandies(n, a):\n    alice = 0\n    bob = 0\n    current = 0\n    i = 0\n    j = len(a) - 1\n    moves = 0\n    newSum = 0\n    while i <= j:\n        while current >= newSum:\n            if moves % 2 == 0 and i <= j:\n                newSum += a[i]\n                alice += a[i]\n                i += 1\n            elif moves % 2 != 0 and i <= j:\n                bob += a[j]\n                newSum += a[j]\n                j -= 1\n            else:\n                break\n        current = newSum\n        newSum = 0\n        moves += 1\n    print('{} {} {}'.format(moves, alice, bob))\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    numCandies(n, a)", "def solve(size, array):\n    alice = 1\n    bob = size - 1\n    alice_candies = array[0]\n    bob_candies = 0\n    moves = 1\n    bob_total = bob_candies\n    alice_total = alice_candies\n    visited = [False] * size\n    visited[0] = True\n    while alice <= bob:\n        bob_candies = 0\n        while not visited[bob] and bob_candies <= alice_candies:\n            flag_bob = 1\n            flag_alice = 0\n            bob_candies += array[bob]\n            visited[bob] = True\n            bob -= 1\n        bob_total += bob_candies\n        if flag_bob == 1:\n            moves += 1\n        alice_candies = 0\n        while not visited[alice] and alice_candies <= bob_candies:\n            flag_alice = 1\n            flag_bob = 0\n            alice_candies += array[alice]\n            visited[alice] = True\n            alice += 1\n        alice_total += alice_candies\n        if flag_alice == 1:\n            moves += 1\n    print(moves, alice_total, bob_total)\ntestCases = int(input())\nwhile testCases:\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    solve(n, A)\n    testCases -= 1", "from sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\n\ndef main():\n    for t in range(I()):\n        n = I()\n        arr = L()\n        (sa, sb) = (0, 0)\n        a = 0\n        b = 0\n        t = 1\n        l = 0\n        r = n - 1\n        x = 0\n        while r >= l:\n            x += 1\n            if t == 1:\n                a = 0\n                while a <= b and l <= r:\n                    a += arr[l]\n                    sa += arr[l]\n                    l += 1\n            else:\n                b = 0\n                while b <= a and r >= l:\n                    b += arr[r]\n                    sb += arr[r]\n                    r -= 1\n            t *= -1\n        print(x, sa, sb)\nmain()", "def min_terms(n, arr):\n    a = 0\n    b = 0\n    moves = 1\n    turn = 1\n    ta = 0\n    tb = 0\n    while arr:\n        if turn == 1:\n            num = arr.pop(0)\n            a += num\n            ta += num\n            if ta > tb:\n                tb = 0\n                moves += 1\n                turn = 2\n        elif turn == 2:\n            num = arr.pop()\n            b += num\n            tb += num\n            if tb > ta:\n                ta = 0\n                moves += 1\n                turn = 1\n        if (ta == 0 or tb == 0) and len(arr) == 0:\n            moves -= 1\n    print(moves, a, b)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    min_terms(n, arr)", "for _ in range(int(input())):\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    i = 0\n    x = z = 0\n    a = b = 0\n    while True:\n        if i % 2 == 0:\n            if l != []:\n                y = l.pop(0)\n            else:\n                break\n            while y <= x:\n                if l != []:\n                    y += l.pop(0)\n                else:\n                    break\n            x = y\n            a += x\n        else:\n            if l != []:\n                y = l.pop()\n            else:\n                break\n            while y <= x:\n                if l != []:\n                    y += l.pop()\n                else:\n                    break\n            x = y\n            b += x\n        i += 1\n    print(i, a, b)", "def solution(n, arr):\n    (boolA, boolB) = (True, False)\n    i = 0\n    (currA, currB) = ([0], [0])\n    (a, b) = (0, n - 1)\n    while a <= b:\n        if boolA:\n            chA = 0\n            while chA <= currB[-1] and a <= b:\n                chA += arr[a]\n                a += 1\n            currA.append(chA)\n            boolA = False\n        else:\n            chB = 0\n            while chB <= currA[-1] and a <= b:\n                chB += arr[b]\n                b -= 1\n            currB.append(chB)\n            boolA = True\n    return (len(currA) + len(currB) - 2, sum(currA), sum(currB))\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*solution(n, a))", "def notd(n, a):\n    i = 1\n    j = n - 1\n    s = 1\n    p1s = a[0]\n    p1ts = a[0]\n    p2s = 0\n    p2ts = 0\n    while i <= j:\n        while i <= j and p2s <= p1s:\n            p2s += a[j]\n            p2ts += a[j]\n            j -= 1\n        s += 1\n        if i > j:\n            break\n        p1s = 0\n        while i <= j and p1s <= p2s:\n            p1s += a[i]\n            p1ts += a[i]\n            i += 1\n        s += 1\n        p2s = 0\n    print(s, p1ts, p2ts)\nfor q in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    notd(n, a)", "import sys, threading\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef dfs(index, d, visited, p, dep, ans):\n    visited[index] = True\n    dep[index] = d\n    for i in range(len(ans[index])):\n        if visited[ans[index][i]] == False:\n            dfs(ans[index][i], d + 1, visited, p, dep, ans)\n            p[index] += p[ans[index][i]]\n\ndef solve():\n    n = list(map(int, input().split()))\n    n = int(n[0])\n    arr = list(map(int, input().split()))\n    alice = 0\n    bob = 0\n    t_alice = 0\n    t_bob = 0\n    i = 0\n    j = n - 1\n    flag = 0\n    count = 0\n    while i <= j:\n        count += 1\n        if flag == 0:\n            alice = 0\n            flag = 1\n            while i < n and i <= j:\n                alice += arr[i]\n                i += 1\n                if alice > bob:\n                    break\n            t_alice += alice\n        else:\n            bob = 0\n            flag = 0\n            while j >= 0 and i <= j:\n                bob += arr[j]\n                j -= 1\n                if bob > alice:\n                    break\n            t_bob += bob\n    print(count, t_alice, t_bob)\n\ndef main():\n    t = input().split()\n    t = int(t[0])\n    for _ in range(t):\n        solve()\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "t = int(input())\nimport math\n\ndef solve(arr):\n    a = -1\n    b = len(arr)\n    at = 0\n    att = 0\n    btt = 0\n    bt = 0\n    turns = 0\n    avail = len(arr)\n    turn = 1\n    while avail > 0:\n        turns += 1\n        if turn:\n            turn = 0\n            while at <= bt:\n                if a + 1 != b:\n                    a += 1\n                    at += arr[a]\n                    att += arr[a]\n                    avail -= 1\n                else:\n                    break\n            bt = 0\n        else:\n            turn = 1\n            while bt <= at:\n                if b - 1 != a:\n                    b -= 1\n                    bt += arr[b]\n                    btt += arr[b]\n                    avail -= 1\n                else:\n                    break\n            at = 0\n    return ' '.join((str(turns), str(att), str(btt)))\nfor _ in range(t):\n    n = int(input())\n    print(solve([int(x) for x in input().strip().split()]))", "import bisect\nimport heapq\n\ndef main():\n    k = int(input())\n    for i in range(k):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        (l, r) = (0, n)\n        (tmp_r, tmp_l) = (0, 0)\n        (a, b) = (0, 0)\n        counter = 0\n        while l < r:\n            if l == 0:\n                counter += 1\n                a = arr[0]\n                tmp_l = arr[0]\n                l += 1\n            else:\n                if l < r:\n                    counter += 1\n                while tmp_l <= tmp_r and l < r:\n                    tmp_l += arr[l]\n                    a += arr[l]\n                    l += 1\n                tmp_r = 0\n            if l < r:\n                counter += 1\n            while tmp_r <= tmp_l and l < r:\n                tmp_r += arr[r - 1]\n                b += arr[r - 1]\n                r -= 1\n            tmp_l = 0\n        print(counter, a, b)\nmain()", "import sys, heapq\nfrom collections import *\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split(' ')))\n        (a, b, cur, i, j, flag, cnt) = (0, 0, 0, 0, n - 1, -1, 0)\n        while i <= j:\n            delta = 0\n            if flag == -1:\n                while i <= j and delta <= cur:\n                    delta += arr[i]\n                    i += 1\n                a += delta\n            else:\n                while i <= j and delta <= cur:\n                    delta += arr[j]\n                    j -= 1\n                b += delta\n            flag *= -1\n            cur = delta\n            cnt += 1\n        print(cnt, a, b)\nmain()", "def candies(a, n):\n    if n == 1:\n        print('1', a[0], '0')\n        return\n    e = 0\n    m1 = 0\n    m2 = 0\n    m = 0\n    p = n - 1\n    i = 0\n    while i <= p and p >= 0:\n        d = 0\n        while i <= p:\n            if a[i] + d > e or i == p:\n                m1 = m1 + d + a[i]\n                m = m + 1\n                e = a[i] + d\n                break\n            d = d + a[i]\n            i = i + 1\n        d = 0\n        i = i + 1\n        while p >= i:\n            if a[p] + d > e or p == i:\n                m2 = m2 + a[p] + d\n                m = m + 1\n                e = a[p] + d\n                break\n            d = d + a[p]\n            p = p - 1\n        p = p - 1\n    print(m, m1, m2)\n    return\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    T = input()\n    l = list(map(int, T.split()))\n    candies(l, n)", "def candies(n, l):\n    st = 0\n    end = n - 1\n    bob = 0\n    alice = 0\n    move = 0\n    b = 0\n    while st <= end:\n        a = 0\n        while st <= end and a <= b:\n            alice += l[st]\n            a += l[st]\n            st += 1\n        move += 1\n        if st > end:\n            break\n        b = 0\n        while end >= st and b <= a:\n            bob += l[end]\n            b += l[end]\n            end -= 1\n        move += 1\n        if st > end:\n            break\n    print(move, alice, bob)\n    return\nT = int(input())\nfor i in range(T):\n    n = int(input())\n    a = [int(j) for j in input().split()]\n    candies(n, a)", "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (alice, bob) = (0, n - 1)\n    (aliceeat, bobeat) = (0, 0)\n    (a, b) = (0, 0)\n    cnt = 0\n    while alice <= bob:\n        a = 0\n        while a <= b:\n            a += arr[alice]\n            aliceeat += arr[alice]\n            alice += 1\n            if alice > bob:\n                break\n        cnt += 1\n        if alice > bob:\n            break\n        b = 0\n        while b <= a:\n            b += arr[bob]\n            bobeat += arr[bob]\n            bob -= 1\n            if alice > bob:\n                break\n        cnt += 1\n    print(cnt, aliceeat, bobeat)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    solve()", "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    (alice, bob) = (0, n - 1)\n    (aliceeat, bobeat) = (0, 0)\n    (a, b) = (0, 0)\n    cnt = 0\n    while alice <= bob:\n        a = 0\n        while a <= b:\n            a += arr[alice]\n            aliceeat += arr[alice]\n            alice += 1\n            if alice > bob:\n                break\n        cnt += 1\n        if alice > bob:\n            break\n        b = 0\n        while b <= a:\n            b += arr[bob]\n            bobeat += arr[bob]\n            bob -= 1\n            if alice > bob:\n                break\n        cnt += 1\n    print(cnt, aliceeat, bobeat)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    solve()", "def main():\n    n = int(input())\n    for i in range(n):\n        tamano = int(input())\n        dulces = list(map(int, input().split()))\n        if tamano == 1:\n            print('1 ' + str(dulces[0]) + ' 0')\n        else:\n            A = 1\n            B = tamano - 1\n            sumaA = dulces[0]\n            sumaB = 0\n            antA = dulces[0]\n            contador = 1\n            while A <= B:\n                antB = 0\n                entro = 0\n                while antB <= antA and A <= B:\n                    sumaB = sumaB + dulces[B]\n                    antB = antB + dulces[B]\n                    B -= 1\n                    entro = 1\n                if entro == 1:\n                    contador += 1\n                entro = 0\n                antA = 0\n                while antA <= antB and A <= B:\n                    sumaA = sumaA + dulces[A]\n                    antA = antA + dulces[A]\n                    A += 1\n                    entro = 1\n                if entro == 1:\n                    contador += 1\n            resultado = []\n            resultado.append(contador)\n            resultado.append(sumaA)\n            resultado.append(sumaB)\n            print(*resultado)\nmain()", "def candies(n, a):\n    ca = 0\n    cb = 0\n    moves = 0\n    s = 0\n    l = 0\n    last = 0\n    current = 0\n    while l != n:\n        s += a[current]\n        if current == 0:\n            ca += a[current]\n            l += 1\n            if s > last:\n                moves += 1\n                last = s\n                s = 0\n                current = -1\n                del a[0]\n            else:\n                del a[0]\n                if l == n:\n                    moves += 1\n        elif current == -1:\n            cb += a[current]\n            l += 1\n            if s > last:\n                moves += 1\n                current = 0\n                last = s\n                s = 0\n                a.pop()\n            else:\n                a.pop()\n                if l == n:\n                    moves += 1\n    print(moves, ca, cb)\n    return\nt = int(input())\na = []\nfor i in range(t):\n    b = int(input())\n    c = list(map(int, input().split(' ')))\n    a.append([b, c])\nfor x in a:\n    candies(*x)", "def solve():\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    start = 0\n    end = n - 1\n    ans = 0\n    pr = 0\n    a = 0\n    b = 0\n    nwa = 0\n    nwb = 0\n    nw = 1\n    while start <= end:\n        if nw == 1:\n            if nwa > pr:\n                a += nwa\n                pr = nwa\n                nwa = 0\n                nw = 2\n                ans += 1\n            else:\n                nwa += arr[start]\n                start += 1\n        elif nwb > pr:\n            b += nwb\n            pr = nwb\n            nwb = 0\n            nw = 1\n            ans += 1\n        else:\n            nwb += arr[end]\n            end -= 1\n    a += nwa\n    b += nwb\n    if nwa or nwb:\n        ans += 1\n    print(ans, a, b)\nt = int(input())\nfor i in range(t):\n    solve()", "def main():\n    for _ in range(int(input())):\n        _ = input()\n        entrada = list(map(int, input().split()))\n        A = 0\n        B = 0\n        SumA = 0\n        SumB = 0\n        turnos = 1\n        A = entrada[0]\n        SumA = A\n        entrada.pop(0)\n        while len(entrada) != 0:\n            turnos += 1\n            if turnos % 2 == False:\n                B = 0\n                while B <= A:\n                    if len(entrada) == 0:\n                        break\n                    B += entrada[-1]\n                    entrada.pop(-1)\n                SumB += B\n            else:\n                A = 0\n                while A <= B:\n                    if len(entrada) == 0:\n                        break\n                    A += entrada[0]\n                    entrada.pop(0)\n                SumA += A\n        print(turnos, SumA, SumB)\nmain()", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = [int(i) for i in input().split()]\n    d = deque(arr)\n    last_sum = 0\n    a = 0\n    b = 0\n    cnt = 0\n    while d:\n        flag = False\n        work = 0\n        while work <= last_sum and d:\n            work += d.popleft()\n            flag = True\n        last_sum = work\n        a += last_sum\n        if flag:\n            cnt += 1\n        flag = False\n        work = 0\n        while work <= last_sum and d:\n            work += d.pop()\n            flag = True\n        last_sum = work\n        b += last_sum\n        if flag:\n            cnt += 1\n    print(cnt, a, b)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    a = 0\n    b = n - 1\n    s_1 = 0\n    s_2 = 0\n    s1 = 0\n    s2 = 0\n    c = 0\n    x = False\n    y = False\n    while a <= b:\n        while s1 <= s2 and a <= b:\n            s1 += l[a]\n            s_1 += l[a]\n            a += 1\n            x = True\n        s2 = 0\n        while s2 <= s1 and a <= b:\n            s2 += l[b]\n            s_2 += l[b]\n            b -= 1\n            y = True\n        s1 = 0\n        if x:\n            c += 1\n        if y:\n            c += 1\n        x = False\n        y = False\n    print(c, s_1, s_2)", "def solve():\n    n = int(input())\n    li = list(map(int, input().split()))\n    l = li.copy()\n    a = 0\n    b = 0\n    c = 0\n    prev_a = 0\n    prev_b = 0\n    f = 0\n    d = 0\n    i = 0\n    j = n - 1\n    while len(li):\n        if f == 0:\n            temp = 0\n            while len(li) and temp <= prev_b:\n                temp += l[i]\n                li.pop(0)\n                i += 1\n            a += temp\n            prev_a = temp\n            f = 1\n            d = 0\n        elif d == 0:\n            temp = 0\n            while len(li) and temp <= prev_a:\n                temp += l[j]\n                li.pop(-1)\n                j -= 1\n            b += temp\n            prev_b = temp\n            f = 0\n            d = 1\n        c += 1\n    print(c, a, b)\nt = int(input())\nfor _ in range(t):\n    solve()", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    candy = deque(map(int, input().split()))\n    moves = 1\n    a = candy.popleft()\n    b = 0\n    current = a\n    while candy:\n        temp = 0\n        while candy and temp <= current:\n            last = candy.pop()\n            temp += last\n            b += last\n        if temp > 0:\n            moves += 1\n        current = temp\n        temp = 0\n        while candy and temp <= current:\n            first = candy.popleft()\n            temp += first\n            a += first\n        if temp > 0:\n            moves += 1\n        current = temp\n    print(moves, a, b)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    i = 1\n    j = n - 1\n    x = a[0]\n    y = 0\n    p = a[0]\n    q = 0\n    count = 1\n    fg = 0\n    while i <= j:\n        if fg == 0:\n            q = a[j]\n            while q <= p and j > i:\n                j = j - 1\n                q += a[j]\n            j = j - 1\n            y += q\n            fg = 1\n            count += 1\n        elif fg == 1:\n            p = a[i]\n            while p <= q and i < j:\n                i += 1\n                p += a[i]\n            i += 1\n            x += p\n            fg = 0\n            count += 1\n    print(count, x, y)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    N = int(input())\n    A = list(map(int, input().split()))\n    X = A[0]\n    a = A[0]\n    Y = 0\n    (i, j, move) = (0, N, 1)\n    while i < j - 1:\n        j -= 1\n        cnt = A[j]\n        while cnt <= a and i < j - 1:\n            j -= 1\n            cnt += A[j]\n        move += 1\n        if i < j - 1:\n            move += 1\n        b = cnt\n        Y += cnt\n        cnt = 0\n        while cnt <= b and i < j - 1:\n            i += 1\n            cnt += A[i]\n        X += cnt\n        a = cnt\n    print(move, X, Y)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    candies = list(map(int, input().split()))\n    alice_pointer = 0\n    bob_pointer = n - 1\n    alice_current = 0\n    bob_current = 0\n    alice = 0\n    bob = 0\n    toggle = False\n    number_of_moves = 0\n    while alice_pointer <= bob_pointer:\n        if toggle == False:\n            alice_current += candies[alice_pointer]\n            if alice_current > bob_current:\n                alice += alice_current\n                bob_current = 0\n                toggle = True\n                number_of_moves += 1\n            alice_pointer += 1\n        else:\n            bob_current += candies[bob_pointer]\n            if bob_current > alice_current:\n                bob += bob_current\n                alice_current = 0\n                toggle = False\n                number_of_moves += 1\n            bob_pointer -= 1\n    if toggle:\n        bob += bob_current\n    else:\n        alice += alice_current\n    if alice_current != 0 and bob_current != 0:\n        number_of_moves += 1\n    print(number_of_moves, alice, bob)", "import sys\nfrom os import path\nif path.exists('C:/Users/prana/Desktop/sublime/input.txt'):\n    sys.stdin = open('C:/Users/prana/Desktop/sublime/input.txt', 'r')\n    sys.stdout = open('C:/Users/prana/Desktop/sublime/output.txt', 'w')\n\ndef solve():\n    n = input()\n    n = int(n)\n    a = list(map(int, input().split()))\n    i = 0\n    j = n\n    temp = a[0]\n    flag = 0\n    count = 1\n    y = a[0]\n    b = 0\n    p = 0\n    if n == 1:\n        count = 1\n        y = a[0]\n        b = 0\n    else:\n        while j > i:\n            if flag == 0:\n                j -= 1\n                p = a[j]\n                if j > i:\n                    b += p\n                x2 = b\n                while p <= temp and j > i:\n                    j -= 1\n                    if j > i:\n                        p += a[j]\n                        b += a[j]\n                if abs(j - i) == 1 and p > temp:\n                    count += 1\n                    break\n                flag = 1\n                temp = p\n            else:\n                i += 1\n                p = a[i]\n                if j > i:\n                    y += p\n                x1 = y\n                while p <= temp and j > i:\n                    i += 1\n                    if j > i:\n                        p += a[i]\n                        y += a[i]\n                if abs(j - i) == 1 and p > temp:\n                    count += 1\n                    break\n                flag = 0\n                temp = p\n            count += 1\n    print(count, y, b)\nT = 1\nT = int(input())\nfor _ in range(1, T + 1):\n    print('Case #', _, file=sys.stderr)\n    solve()", "for _ in [0] * int(input()):\n    n = int(input())\n    a = (*map(int, input().split()),)\n    i = l = 0\n    j = n - 1\n    x = y = z = 0\n    while i <= j:\n        c = 0\n        while i <= j and c <= l:\n            c += a[i]\n            i += 1\n        z += 1\n        x += c\n        l = c\n        if i > j:\n            break\n        c = 0\n        while i <= j and c <= l:\n            c += a[j]\n            j -= 1\n        z += 1\n        y += c\n        l = c\n    print(z, x, y)", "t = int(input())\nfor tt in range(0, t):\n    n = int(input())\n    l = []\n    l = list(map(int, input().split()))\n    left = 0\n    right = n - 1\n    i = 0\n    alicesum = 0\n    palicesum = 0\n    bobsum = 0\n    pbobsum = 0\n    flag = 0\n    while left <= right:\n        if i % 2 == 0:\n            alicesum += l[left]\n            if alicesum <= bobsum:\n                flag = 0\n            else:\n                palicesum += alicesum\n                bobsum = 0\n                i += 1\n                flag = 1\n            left += 1\n        else:\n            bobsum += l[right]\n            if alicesum >= bobsum:\n                flag = 2\n            else:\n                pbobsum += bobsum\n                alicesum = 0\n                i += 1\n                flag = 1\n            right -= 1\n    if flag == 0:\n        palicesum += alicesum\n        i += 1\n    if flag == 2:\n        pbobsum += bobsum\n        i += 1\n    print(i, end=' ')\n    print(palicesum, end=' ')\n    print(pbobsum)"]