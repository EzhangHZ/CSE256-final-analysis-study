["t = int(input())\n\ndef euclidean(a, b):\n    (a, b) = (max(a, b), min(a, b))\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef main():\n    n = int(input())\n    l = [int(s) for s in input().split()]\n    l_next = list(range(1, n)) + [0]\n    l_forw = list(range(1, n)) + [0]\n    prev = n - 1\n    i = 0\n    res = []\n    while True:\n        if l_forw[i] == i:\n            if l[i] == 1:\n                res.append(i + 1)\n            break\n        if euclidean(l[i], l[l_forw[i]]) == 1:\n            if l_forw[i] == l_next[i]:\n                l_next[i] = l_next[l_next[i]]\n            res.append(l_forw[i] + 1)\n            l_forw[i] = l_forw[l_forw[i]]\n            prev = i\n        else:\n            if prev == i:\n                break\n            l_next[prev] = l_next[i]\n        i = l_next[prev]\n    res = [len(res)] + res\n    print(' '.join([str(r) for r in res]))\nfor _ in range(t):\n    main()", "from math import gcd\nfrom collections import deque\nfor i in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = deque()\n    next = [None] * n\n    for i in range(n):\n        next[i] = (i + 1) % n\n        q.append(i)\n    temp = 0\n    ans = []\n    while q:\n        i = q.popleft()\n        j = next[i]\n        if i == j:\n            if a[i] == 1:\n                ans.append(i + 1)\n            continue\n        if len(q) and next[q[-1]] == j:\n            pass\n        elif gcd(a[i], a[j]) == 1:\n            ans.append(j + 1)\n            next[i] = next[j]\n            q.append(i)\n    print(len(ans), *ans)", "from math import gcd\nfor _ in [*open(0)][2::2]:\n    a = (*map(int, _.split()),)\n    n = len(a)\n    s = []\n    f = [*range(1, n)] + [0]\n    q = [(i, f[i]) for i in range(n) if gcd(a[i], a[f[i]]) < 2]\n    while len(q) != 0:\n        (x, y) = q[0]\n        q.pop(0)\n        if f[x] == y:\n            s.append(y + 1)\n            f[x] = f[y]\n            f[y] = -1\n            if f[x] < 0 or x < 0:\n                continue\n            if gcd(a[x], a[f[x]]) < 2:\n                q.append((x, f[x]))\n    print(len(s), *s)", "from math import gcd\nfor _ in [*open(0)][2::2]:\n    a = (*map(int, _.split()),)\n    n = len(a)\n    s = []\n    f = [*range(1, n)] + [0]\n    q = [(i, f[i]) for i in range(n) if gcd(a[i], a[f[i]]) < 2]\n    while len(q) != 0:\n        (x, y) = q[0]\n        q.pop(0)\n        if f[x] == y:\n            s.append(y + 1)\n            f[x] = f[y]\n            f[y] = -1\n            if f[x] < 0 or x < 0:\n                continue\n            if gcd(a[x], a[f[x]]) < 2:\n                q.append((x, f[x]))\n    print(len(s), *s)", "from math import gcd\nfor _ in [*open(0)][2::2]:\n    a = (*map(int, _.split()),)\n    n = len(a)\n    s = []\n    f = [*range(1, n)] + [0]\n    q = [(i, f[i]) for i in range(n) if gcd(a[i], a[f[i]]) < 2]\n    while len(q) != 0:\n        (x, y) = q[0]\n        q.pop(0)\n        if f[x] == y:\n            s.append(y + 1)\n            f[x] = f[y]\n            f[y] = -1\n            if f[x] < 0 or x < 0:\n                continue\n            if gcd(a[x], a[f[x]]) < 2:\n                q.append((x, f[x]))\n    print(len(s), *s)", "import queue\nimport math\nimport sys\nglobal pre, suf\nsuf = [0 for i in range(int(1000000.0 + 10))]\ncases = int(input())\nwhile cases:\n    cases -= 1\n    n = int(input())\n    a = list(map(int, input().split()))\n    que = []\n    for i in range(n):\n        suf[i] = (i + 1) % n\n        if math.gcd(a[i], a[suf[i]]) == 1:\n            que.append((i, suf[i]))\n    ans = []\n    while len(que) != 0:\n        tp = que[0]\n        que.pop(0)\n        (x, y) = (tp[0], tp[1])\n        if suf[x] == y:\n            ans.append(y)\n            suf[x] = suf[y]\n            suf[y] = -1\n            if suf[x] == -1 or x == -1:\n                continue\n            if math.gcd(a[x], a[suf[x]]) == 1:\n                que.append((x, suf[x]))\n    print(len(ans), end=' ')\n    for i in ans:\n        print(i + 1, end=' ')\n    print()"]