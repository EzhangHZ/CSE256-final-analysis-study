["import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nE = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    (x, y) = map(int, input().split())\n    E[x].append(y)\n    E[y].append(x)\nC = [-1] * (n + 1)\nQ = [1]\nC[1] = 0\nwhile Q:\n    x = Q.pop()\n    for to in E[x]:\n        if C[to] == -1:\n            C[to] = 1 - C[x]\n            Q.append(to)\nB = C.count(0)\nW = C.count(1)\nprint(min(B, W) - 1)", "import sys\n\ndef minp():\n    return sys.stdin.readline().strip()\n\ndef mint():\n    return int(minp())\n\ndef mints():\n    return map(int, minp().split())\n\ndef solve():\n    n = mint()\n    e = [[] for i in range(n)]\n    for _ in range(n - 1):\n        (u, v) = mints()\n        e[u - 1].append(v - 1)\n        e[v - 1].append(u - 1)\n    q = [None] * n\n    d = [None] * n\n    c = [0, 0]\n    q[0] = 0\n    d[0] = 0\n    ql = 0\n    qr = 1\n    while ql < qr:\n        x = q[ql]\n        ql += 1\n        dd = d[x]\n        c[dd] += 1\n        dd ^= 1\n        for v in e[x]:\n            if d[v] is None:\n                d[v] = dd\n                q[qr] = v\n                qr += 1\n    print(min(c) - 1)\nsolve()", "import sys\ninput = sys.stdin.readline\nn = int(input())\nadj = [[] for i in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\ndepth = [-1] * n\ndepth[0] = 0\nodd = 0\neven = 1\nq = [0]\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\nprint(min(odd, even) - 1)", "n = int(input())\nadj = [[] for i in range(n)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\ndepth = [-1] * n\ndepth[0] = 0\nodd = 0\neven = 1\nq = [0]\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\nprint(min(odd, even) - 1)", "n = int(input())\nadj = [[] for i in range(n)]\ndepth = [-1] * n\ndepth[0] = 0\n(odd, even, q) = (0, 1, [0])\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\nprint(min(odd, even) - 1)", "from collections import defaultdict\nn = int(input())\ngraph = defaultdict(list)\nfor i in range(n - 1):\n    l = list(map(int, input().split()))\n    graph[l[0]].append(l[1])\n    graph[l[1]].append(l[0])\ncolor_v = [-1] * (n + 1)\ncolor_v[1] = 0\nq = [1]\nwhile q:\n    x = q.pop()\n    for i in graph[x]:\n        if color_v[i] == -1:\n            color_v[i] = 1 - color_v[x]\n            q.append(i)\nprint(min(color_v.count(1), color_v.count(0)) - 1)", "from collections import defaultdict, deque\nNONE = -1\nWHITE = 0\nBLACK = 1\nnw = 0\n\ndef colorize(G, color, v, c):\n    global nw\n    nw += c == WHITE\n    color[v] = c\n    for u in G[v]:\n        if color[u] == NONE:\n            colorize(G, color, u, 1 - c)\n\ndef colorize_v2(G, stack, color):\n    nw = 0\n    while stack:\n        (v, c) = stack.pop()\n        color[v] = c\n        nw += c == WHITE\n        for u in G[v]:\n            if color[u] == NONE:\n                stack.append((u, 1 - c))\n    return nw\nn = int(input())\nG = defaultdict(list)\nfor _ in range(n - 1):\n    (u, v) = (int(x) for x in input().strip().split())\n    G[u].append(v)\n    G[v].append(u)\ncolor = [NONE] * (n + 1)\nstack = deque()\nstack.append((1, WHITE))\nnw = colorize_v2(G, stack, color)\nprint(min(nw, n - nw) - 1)", "n = int(input())\nadj = [[] for i in range(n)]\ndepth = [-1] * n\ndepth[0] = 0\n(odd, even, q) = (0, 1, [0])\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\nwhile q:\n    nex = q.pop()\n    for v in adj[nex]:\n        if depth[v] == -1:\n            depth[v] = depth[nex] + 1\n            if depth[v] & 1:\n                odd += 1\n            else:\n                even += 1\n            q.append(v)\nprint(min(odd, even) - 1)", "import collections as cc\nimport sys\nI = lambda : list(map(int, input().split()))\n(n,) = I()\ng = cc.defaultdict(list)\nfor i in range(n - 1):\n    (x, y) = I()\n    g[x].append(y)\n    g[y].append(x)\ncol = [-1] * (n + 1)\nb = 0\nw = 0\nvisi = [0] * (n + 1)\nst = cc.deque()\nst.append(1)\ncol[1] = 1\nw += 1\nwhile st:\n    x = st.pop()\n    visi[x] = 1\n    for y in g[x]:\n        if not visi[y]:\n            col[y] = col[x] ^ 1\n            st.append(y)\nb = col.count(1)\nw = col.count(0)\nprint(min(b, w) - 1)", "n = int(input())\nallNodes = []\nfor i in range(n):\n    allNodes.append([i])\nfor i in range(n - 1):\n    (u, v) = map(int, input().split())\n    allNodes[u - 1].append(v - 1)\n    allNodes[v - 1].append(u - 1)\nblack = 0\nwhite = 0\nfrom collections import deque\nq = deque([])\nq.append(0)\nvisited = [-1] * n\nvisited[0] = 1\nwhile len(q) != 0:\n    e = q.pop()\n    for i in allNodes[e][1:]:\n        if visited[i] == -1:\n            q.append(i)\n            visited[i] = 1 - visited[e]\nm = min(visited.count(1), visited.count(0))\nprint(m - 1)", "a = int(input())\nc = list()\nfor i in range(a + 1):\n    c.append(list())\nfor i in range(a - 1):\n    (g, h) = map(int, input().split())\n    c[g].append(h)\n    c[h].append(g)\nq = list()\np = 0\nk = 1\nq.append(1)\nodw = list()\nwyn = 0\nfor i in range(a + 1):\n    odw.append(0)\nwhile k > p:\n    x = q[p]\n    chk = 0\n    if x < 0:\n        x = -x\n        wyn += 1\n        chk = 1\n    p += 1\n    odw[x] = 1\n    for s in c[x]:\n        if odw[s] == 0:\n            q.append(s if chk > 0 else -s)\n            k += 1\n            odw[s] = 1\nwyn = wyn - 1\nif wyn > a - (wyn + 1) - 1:\n    wyn = a - wyn - 2\nprint(wyn)"]