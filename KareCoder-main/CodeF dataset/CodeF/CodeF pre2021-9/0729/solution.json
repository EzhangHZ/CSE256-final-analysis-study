["def I1():\n    n = int(input())\n    h = [int(j) for j in input().split()]\n    x = [0] * n\n    y = [0]\n    z = [0]\n    for i in range(1, n):\n        x[i] = x[i - 1] + 1\n        while len(y) and h[i] >= h[y[-1]]:\n            a = y[-1]\n            y.pop()\n            if h[i] > h[a] and len(y):\n                x[i] = min(x[i], x[y[-1]] + 1)\n        while len(z) and h[i] <= h[z[-1]]:\n            a = z[-1]\n            z.pop()\n            if h[i] < h[a] and len(z):\n                x[i] = min(x[i], x[z[-1]] + 1)\n        y.append(i)\n        z.append(i)\n    print(x[-1])\nI1()", "from collections import deque\nfrom itertools import chain\n\ndef construct_links(h_and_idx):\n    lt_stack = []\n    gt_stack = []\n    g = [[] for _ in h_and_idx]\n    for (h, idx) in reversed(h_and_idx):\n        prev_h = None\n        while lt_stack and lt_stack[-1][0] >= h:\n            (prev_h, prev_idx) = lt_stack.pop()\n            g[idx].append(prev_idx)\n        if lt_stack and prev_h != h:\n            g[idx].append(lt_stack[-1][1])\n        lt_stack.append((h, idx))\n        prev_h = None\n        while gt_stack and gt_stack[-1][0] <= h:\n            (prev_h, prev_idx) = gt_stack.pop()\n            g[idx].append(prev_idx)\n        if gt_stack and prev_h != h:\n            g[idx].append(gt_stack[-1][1])\n        gt_stack.append((h, idx))\n    return g\n\ndef main():\n    n = int(input())\n    h_and_idx = tuple(((h, i) for (i, h) in enumerate(map(int, input().split()))))\n    g = construct_links(h_and_idx)\n    dist = [0] + [-1] * (n - 1)\n    q = deque([0], n)\n    while q:\n        v = q.popleft()\n        for x in g[v]:\n            if dist[x] == -1:\n                dist[x] = dist[v] + 1\n                q.append(x)\n    print(dist[-1])\nmain()", "import operator as ops\nfrom collections import deque\nfrom itertools import chain\n\ndef construct_links(h_and_idx):\n    lt_stack = []\n    gt_stack = []\n    g = [[] for _ in h_and_idx]\n    for (h, idx) in reversed(h_and_idx):\n        for (stack, cmp_op) in [(lt_stack, ops.le), (gt_stack, ops.ge)]:\n            prev_h = None\n            while stack and cmp_op(h, stack[-1][0]):\n                (prev_h, prev_idx) = stack.pop()\n                g[idx].append(prev_idx)\n            if stack and prev_h != h:\n                g[idx].append(stack[-1][1])\n            stack.append((h, idx))\n    return g\n\ndef main():\n    n = int(input())\n    h_and_idx = tuple(((h, i) for (i, h) in enumerate(map(int, input().split()))))\n    g = construct_links(h_and_idx)\n    dist = [0] + [-1] * (n - 1)\n    q = deque([0], n)\n    while q:\n        v = q.popleft()\n        for x in g[v]:\n            if dist[x] == -1:\n                dist[x] = dist[v] + 1\n                q.append(x)\n    print(dist[-1])\nmain()", "ans = []\nn = int(input())\nh = [int(x) for x in input().split(' ')]\njumps = [0] * n\nbuild_ctr_short = [0]\nbuild_ctr_tall = [0]\nfor i in range(1, n):\n    jumps[i] = jumps[i - 1] + 1\n    while len(build_ctr_short) and h[i] >= h[build_ctr_short[-1]]:\n        build_num = build_ctr_short[-1]\n        build_ctr_short.pop()\n        if h[i] > h[build_num] and len(build_ctr_short):\n            jumps[i] = min(jumps[i], jumps[build_ctr_short[-1]] + 1)\n    while len(build_ctr_tall) and h[i] <= h[build_ctr_tall[-1]]:\n        build_num = build_ctr_tall[-1]\n        build_ctr_tall.pop()\n        if h[i] < h[build_num] and len(build_ctr_tall):\n            jumps[i] = min(jumps[i], jumps[build_ctr_tall[-1]] + 1)\n    build_ctr_short.append(i)\n    build_ctr_tall.append(i)\nans.append(jumps[-1])\nfor i in ans:\n    print(i)", "n = int(input())\nh = list(map(int, input().split()))\na = [0] * n\na1 = [0]\na2 = [0]\nfor i in range(1, n):\n    a[i] = a[i - 1] + 1\n    while len(a1) and h[i] >= h[a1[-1]]:\n        x = a1[-1]\n        a1.pop()\n        if h[i] > h[x] and len(a1):\n            a[i] = min(a[i], a[a1[-1]] + 1)\n    while len(a2) and h[i] <= h[a2[-1]]:\n        x = a2[-1]\n        a2.pop()\n        if h[i] < h[x] and len(a2):\n            a[i] = min(a[i], a[a2[-1]] + 1)\n    a1.append(i)\n    a2.append(i)\nprint(a[-1])", "try:\n    n = int(input())\n    a = [int(i) for i in input().split(' ')]\n    dp = [n] * n\n    dp[0] = 0\n    (s1, s2) = ([], [])\n    s1.append(0)\n    s2.append(0)\n    i = 1\n    while i < n:\n        dp[i] = dp[i - 1] + 1\n        while s1 and a[i] <= a[s1[len(s1) - 1]]:\n            item = a[s1[len(s1) - 1]]\n            s1.pop()\n            if a[i] < item and s1:\n                dp[i] = min(dp[i], dp[s1[len(s1) - 1]] + 1)\n        while s2 and a[i] >= a[s2[len(s2) - 1]]:\n            item = a[s2[len(s2) - 1]]\n            s2.pop()\n            if a[i] > item and s2:\n                dp[i] = min(dp[i], dp[s2[len(s2) - 1]] + 1)\n        s1.append(i)\n        s2.append(i)\n        i += 1\n    print(dp[n - 1])\nexcept:\n    pass", "n = int(input())\ninp = input().split(' ')\nh = []\nfor i in inp:\n    h.append(int(i))\narr = []\nfor i in range(n):\n    arr.append(i)\narr[0] = 0\nhigh = []\nlow = []\nfor i in range(n):\n    flag = True\n    while high and h[high[-1]] >= h[i]:\n        val = high.pop()\n        arr[i] = min(arr[i], arr[val] + 1)\n        if h[i] == h[val]:\n            flag = False\n        else:\n            flag = True\n    if high and flag:\n        arr[i] = min(arr[high[-1]] + 1, arr[i])\n    while low and h[low[-1]] <= h[i]:\n        val = low.pop()\n        arr[i] = min(arr[i], arr[val] + 1)\n        if h[i] == h[val]:\n            flag = False\n        else:\n            flag = True\n    if low and flag:\n        arr[i] = min(arr[low[-1]] + 1, arr[i])\n    high.append(i)\n    low.append(i)\nprint(arr[-1])", "try:\n    n = int(input())\n    a = [int(i) for i in input().split(' ')]\n    dp = [n] * n\n    dp[0] = 0\n    (s1, s2) = ([], [])\n    s1.append(0)\n    s2.append(0)\n    i = 1\n    while i < n:\n        dp[i] = dp[i - 1] + 1\n        while s1 and a[i] <= a[s1[len(s1) - 1]]:\n            item = a[s1[len(s1) - 1]]\n            s1.pop()\n            if a[i] < item and s1:\n                dp[i] = min(dp[i], dp[s1[len(s1) - 1]] + 1)\n        while s2 and a[i] >= a[s2[len(s2) - 1]]:\n            item = a[s2[len(s2) - 1]]\n            s2.pop()\n            if a[i] > item and s2:\n                dp[i] = min(dp[i], dp[s2[len(s2) - 1]] + 1)\n        s1.append(i)\n        s2.append(i)\n        i += 1\n    print(dp[n - 1])\nexcept:\n    pass", "N = int(input())\na = list(map(int, input().split()))\ninf = N + 1\ndp = [inf] * N\ndp[0] = 0\nups = []\ndws = []\nfor i in range(N):\n    x = a[i]\n    f = 1\n    while len(ups) > 0 and a[ups[-1]] >= x:\n        j = ups.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(ups) > 0:\n        dp[i] = min(dp[i], dp[ups[-1]] + 1)\n    f = 1\n    while len(dws) > 0 and a[dws[-1]] <= x:\n        j = dws.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(dws) > 0:\n        dp[i] = min(dp[i], dp[dws[-1]] + 1)\n    ups.append(i)\n    dws.append(i)\nprint(dp[-1])", "import sys\ninput = sys.stdin.readline\nN = int(input())\na = list(map(int, input().split()))\ninf = N + 1\ndp = [inf] * N\ndp[0] = 0\nups = []\ndws = []\nfor i in range(N):\n    x = a[i]\n    f = 1\n    while len(ups) > 0 and a[ups[-1]] >= x:\n        j = ups.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(ups) > 0:\n        dp[i] = min(dp[i], dp[ups[-1]] + 1)\n    f = 1\n    while len(dws) > 0 and a[dws[-1]] <= x:\n        j = dws.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(dws) > 0:\n        dp[i] = min(dp[i], dp[dws[-1]] + 1)\n    ups.append(i)\n    dws.append(i)\nprint(dp[-1])", "import collections\nl = int(input())\ns = list(map(int, input().split()))\ndp = [float('inf') for i in range(l + 1)]\ndp = [float('inf') for i in range(l + 1)]\ndp[1] = 0\nst1 = collections.deque()\nst2 = collections.deque()\nfor (i, n) in enumerate(s):\n    if len(st1) == 1 or (len(st1) > 0 and s[st1[1]] < n):\n        dp[i + 1] = min(dp[st1[0] + 1] + 1, dp[i + 1])\n    c = 1\n    while st1 and s[st1[-1]] <= n:\n        if s[st1[-1]] == n:\n            c = 0\n        dp[i + 1] = min(dp[i + 1], dp[st1.pop() + 1] + 1)\n    if st1 and c:\n        dp[i + 1] = min(dp[i + 1], dp[st1[-1] + 1] + 1)\n    st1.append(i)\n    if len(st2) == 1 or (len(st2) > 0 and s[st2[1]] > n):\n        dp[i + 1] = min(dp[st2[0] + 1] + 1, dp[i + 1])\n    c = 1\n    while st2 and s[st2[-1]] >= n:\n        if s[st2[-1]] == n:\n            c = 0\n        dp[i + 1] = min(dp[i + 1], dp[st2.pop() + 1] + 1)\n    if st2 and c == 1:\n        dp[i + 1] = min(dp[i + 1], dp[st2[-1] + 1] + 1)\n    st2.append(i)\nprint(dp[-1])", "import sys\ninput = sys.stdin.readline\nN = int(input())\na = list(map(int, input().split()))\ninf = N + 1\ndp = [inf] * N\ndp[0] = 0\nups = []\ndws = []\nfor i in range(N):\n    x = a[i]\n    f = 1\n    while len(ups) > 0 and a[ups[-1]] >= x:\n        j = ups.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(ups) > 0:\n        dp[i] = min(dp[i], dp[ups[-1]] + 1)\n    f = 1\n    while len(dws) > 0 and a[dws[-1]] <= x:\n        j = dws.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(dws) > 0:\n        dp[i] = min(dp[i], dp[dws[-1]] + 1)\n    ups.append(i)\n    dws.append(i)\nprint(dp[-1])", "import sys\ninput = sys.stdin.readline\nN = int(input())\na = list(map(int, input().split()))\ninf = N + 1\ndp = [inf] * N\ndp[0] = 0\nups = []\ndws = []\nfor i in range(N):\n    x = a[i]\n    f = 1\n    while len(ups) > 0 and a[ups[-1]] >= x:\n        j = ups.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(ups) > 0:\n        dp[i] = min(dp[i], dp[ups[-1]] + 1)\n    f = 1\n    while len(dws) > 0 and a[dws[-1]] <= x:\n        j = dws.pop()\n        dp[i] = min(dp[i], dp[j] + 1)\n        f = a[j] != x\n    if f and len(dws) > 0:\n        dp[i] = min(dp[i], dp[dws[-1]] + 1)\n    ups.append(i)\n    dws.append(i)\nprint(dp[-1])", "import collections\nl = int(input())\ns = list(map(int, input().split()))\ndp = [float('inf') for i in range(l + 1)]\ndp = [float('inf') for i in range(l + 1)]\ndp[0] = -1\nst1 = collections.deque()\nst2 = collections.deque()\nfor (i, n) in enumerate(s):\n    dp[i + 1] = min(dp[i + 1], dp[i] + 1)\n    if len(st1) == 1 or (len(st1) > 0 and s[st1[1]] < n):\n        dp[i + 1] = min(dp[st1[0] + 1] + 1, dp[i + 1])\n    c = 1\n    while st1 and s[st1[-1]] <= n:\n        if s[st1[-1]] == n:\n            c = 0\n        dp[i + 1] = min(dp[i + 1], dp[st1.pop() + 1] + 1)\n    if st1 and c:\n        dp[i + 1] = min(dp[i + 1], dp[st1[-1] + 1] + 1)\n    st1.append(i)\n    if len(st2) == 1 or (len(st2) > 0 and s[st2[1]] > n):\n        dp[i + 1] = min(dp[st2[0] + 1] + 1, dp[i + 1])\n    c = 1\n    while st2 and s[st2[-1]] >= n:\n        if s[st2[-1]] == n:\n            c = 0\n        dp[i + 1] = min(dp[i + 1], dp[st2.pop() + 1] + 1)\n    if st2 and c == 1:\n        dp[i + 1] = min(dp[i + 1], dp[st2[-1] + 1] + 1)\n    st2.append(i)\nprint(dp[-1])"]