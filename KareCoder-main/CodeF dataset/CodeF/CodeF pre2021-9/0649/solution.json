["n = int(input())\ns = input()\ns1 = s[-1::-1]\nd = [[] for _ in range(26)]\nfor i in range(n):\n    d[ord(s1[i]) - 97].append(i)\ndp = []\nmp = [0] * 26\nfor i in range(n):\n    tp = ord(s[i]) - 97\n    dp.append(d[tp][mp[tp]])\n    mp[tp] += 1\nLEN = n + 1\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n    while v <= LEN:\n        BIT[v] += w\n        v += v & -v\n\ndef getvalue(v):\n    ANS = 0\n    while v != 0:\n        ANS += BIT[v]\n        v -= v & -v\n    return ANS\nans = 0\nfor i in range(n - 1, -1, -1):\n    ans += getvalue(dp[i] + 1)\n    update(dp[i] + 1, 1)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nS = input().strip()\nLIST = [[] for i in range(26)]\nfor i in range(n):\n    LIST[ord(S[i]) - 97].append(i)\nLEN = n + 1\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n    while v <= LEN:\n        BIT[v] += w\n        v += v & -v\n\ndef getvalue(v):\n    ANS = 0\n    while v != 0:\n        ANS += BIT[v]\n        v -= v & -v\n    return ANS\nANS = 0\nmoji = [0] * 26\nfor i in range(n - 1, -1, -1):\n    s = ord(S[i]) - 97\n    x = LIST[s][moji[s]]\n    ANS += x - getvalue(x + 1)\n    moji[s] += 1\n    update(x + 1, 1)\nprint(ANS)", "n = int(input())\nS = input().strip()\nLIST = [[] for i in range(26)]\nfor i in range(n):\n    LIST[ord(S[i]) - 97].append(i)\nLEN = n + 1\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n    while v <= LEN:\n        BIT[v] += w\n        v += v & -v\n\ndef getvalue(v):\n    ANS = 0\n    while v != 0:\n        ANS += BIT[v]\n        v -= v & -v\n    return ANS\nANS = 0\nmoji = [0] * 26\nfor i in range(n - 1, -1, -1):\n    s = ord(S[i]) - 97\n    x = LIST[s][moji[s]]\n    ANS += x - getvalue(x + 1)\n    moji[s] += 1\n    update(x + 1, 1)\nprint(ANS)", "n = int(input())\nS = input().strip()\nLIST = [[] for i in range(26)]\nfor i in range(n):\n    LIST[ord(S[i]) - 97].append(i)\nLEN = n + 1\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n    while v <= LEN:\n        BIT[v] += w\n        v += v & -v\n\ndef getvalue(v):\n    ANS = 0\n    while v != 0:\n        ANS += BIT[v]\n        v -= v & -v\n    return ANS\nANS = 0\nmoji = [0] * 26\nfor i in range(n - 1, -1, -1):\n    s = ord(S[i]) - 97\n    x = LIST[s][moji[s]]\n    ANS += x - getvalue(x + 1)\n    moji[s] += 1\n    update(x + 1, 1)\nprint(ANS)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nS = input().strip()\nLIST = [[] for i in range(26)]\nfor i in range(n):\n    LIST[ord(S[i]) - 97].append(i)\nLEN = n + 1\nBIT = [0] * (LEN + 1)\n\ndef update(v, w):\n    while v <= LEN:\n        BIT[v] += w\n        v += v & -v\n\ndef getvalue(v):\n    ANS = 0\n    while v != 0:\n        ANS += BIT[v]\n        v -= v & -v\n    return ANS\nANS = 0\nmoji = [0] * 26\nfor i in range(n - 1, -1, -1):\n    s = ord(S[i]) - 97\n    x = LIST[s][moji[s]]\n    ANS += x - getvalue(x + 1)\n    moji[s] += 1\n    update(x + 1, 1)\nprint(ANS)", "import heapq\nimport collections\nfrom math import log2\nimport itertools\nfrom functools import lru_cache\nfrom sys import setrecursionlimit as srl\nsrl(2 * 10 ** 6)\nN = 200001\n\nclass fenwick:\n\n    def __init__(self, n):\n        self.n = n\n        self.arr = [0] * (n + 1)\n\n    def update(self, ind, x):\n        if ind <= 0:\n            return\n        while ind <= self.n:\n            self.arr[ind] += x\n            ind += ind & -ind\n\n    def query(self, ind):\n        s = 0\n        while ind > 0:\n            s += self.arr[ind]\n            ind -= ind & -ind\n        return s\n\ndef solve(n, s):\n    fen = fenwick(n + 1)\n    t = s[::-1]\n    chars = collections.defaultdict(collections.deque)\n    for i in range(n):\n        chars[ord(s[i]) - ord('a')].append(i)\n    inv = 0\n    for i in range(n):\n        v = chars[ord(t[i]) - ord('a')].popleft()\n        fen.update(v + 1, 1)\n        v += i + 1 - fen.query(v + 1)\n        inv += v - i\n    return inv\nn = int(input())\ns = input()\nprint(solve(n, s))", "import heapq\nimport collections\nfrom math import log2\nimport itertools\nfrom functools import lru_cache\nfrom sys import setrecursionlimit as srl\nsrl(2 * 10 ** 6)\nN = 200001\n\nclass fenwick:\n\n    def __init__(self, n):\n        self.n = n\n        self.arr = [0] * (n + 1)\n\n    def update(self, ind, x):\n        if ind <= 0:\n            return\n        while ind <= self.n:\n            self.arr[ind] += x\n            ind += ind & -ind\n\n    def query(self, ind):\n        s = 0\n        while ind > 0:\n            s += self.arr[ind]\n            ind -= ind & -ind\n        return s\n\ndef solve(n, s):\n    fen = fenwick(n + 1)\n    inv = 0\n    t = s[::-1]\n    chars = collections.defaultdict(collections.deque)\n    for i in range(n):\n        chars[ord(s[i]) - ord('a')].append(i)\n    for i in range(n):\n        v = chars[ord(t[i]) - ord('a')].popleft()\n        fen.update(v + 1, 1)\n        v += i + 1 - fen.query(v + 1)\n        inv += v - i\n    return inv\nn = int(input())\ns = input()\nprint(solve(n, s))", "from sys import stdin\ninput = stdin.readline\nglobal T, N\n\ndef get_index(char):\n    return ord(char) - 97\n\ndef read(index):\n    global T, N\n    s = 0\n    while index > 0:\n        s += T[index]\n        index -= index & -index\n    return s\n\ndef update(index, val):\n    global T, N\n    while index <= N:\n        T[index] += val\n        index += index & -index\nN = int(input())\nS = input()[:N]\nA = [[] for _ in range(26)]\nfor i in range(N):\n    ind = get_index(S[i])\n    A[ind].append(i + 1)\ninds = [-1 for _ in range(26)]\nT = [0 for _ in range(N + 1)]\nans = 0\nfor i in range(N - 1, -1, -1):\n    idx = get_index(S[N - i - 1])\n    x = A[idx][inds[idx]]\n    inds[idx] -= 1\n    ans += i + 1 - x - read(x)\n    update(x + 1, -1)\nprint(ans)", "from collections import deque\nn = int(input())\nk = input()\ns = []\nfor i in k:\n    if i != '\\x00':\n        s.append(i)\nd = {}\nfor i in range(n - 1, -1, -1):\n    if s[i] in d:\n        d[s[i]].append(n - i - 1)\n    else:\n        d[s[i]] = deque([n - i - 1])\nlis = [-1] * n\nfor i in range(n):\n    lis[i] = d[s[i]].popleft()\n\ndef merge(a, b):\n    (i, j, ans) = (0, 0, 0)\n    (n, m) = (len(a), len(b))\n    c = []\n    while i < n and j < m:\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n            ans += n - i\n    while i < n:\n        c.append(a[i])\n        i += 1\n    while j < m:\n        c.append(b[j])\n        j += 1\n    return (c, ans)\n\ndef mergesort(lis):\n    p = len(lis)\n    if p in (0, 1):\n        return (lis, 0)\n    mid = p // 2\n    (a, v1) = mergesort(lis[:mid])\n    (b, v2) = mergesort(lis[mid:])\n    (c, v3) = merge(a, b)\n    return (c, v1 + v2 + v3)\n(_, ans) = mergesort(lis)\nprint(ans)", "n = int(input())\ns = input().strip()\ncharacter_indexes = [[] for indx in range(26)]\nfor indx in range(n):\n    char_to_append = ord(s[indx]) - 97\n    character_indexes[char_to_append].append(indx)\narr = [0 for i in range(n + 2)]\nresult = 0\nfreqs = [0 for i in range(26)]\nfor i in range(n - 1, -1, -1):\n    char_to_append = ord(s[i]) - 97\n    tmp = character_indexes[char_to_append][freqs[char_to_append]]\n    res = 0\n    first_tmp = tmp + 1\n    while first_tmp != 0:\n        res += arr[first_tmp]\n        first_tmp -= first_tmp & -first_tmp\n    result += tmp - res\n    freqs[char_to_append] += 1\n    second_tmp = tmp + 1\n    while second_tmp <= n:\n        arr[second_tmp] += 1\n        second_tmp += second_tmp & -second_tmp\nprint(result)"]