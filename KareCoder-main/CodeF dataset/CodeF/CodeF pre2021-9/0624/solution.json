["import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    rg = []\n    comm = [list(map(int, input().split())) for _ in range(n)]\n    q = []\n    curr = t = cnt = 0\n    for i in range(n):\n        (ti, xi) = comm[i]\n        if t <= ti:\n            rg.append((curr, xi, ti, ti + abs(xi - curr)))\n            (t, curr) = (rg[-1][3], xi)\n            if i == n - 1:\n                cnt += 1\n            else:\n                (tj, xj) = comm[i + 1]\n                if t <= tj or rg[-1][0] == curr:\n                    cnt += 1\n        else:\n            (prev, curr, t1, t2) = rg[-1]\n            (tx, x) = comm[i]\n            if i < n - 1:\n                tu = comm[i + 1][0]\n            else:\n                tu = t2\n            if prev <= curr:\n                (f, b) = (curr - (t2 - tx), curr - max(t2 - tu, 0))\n                if f <= x <= b:\n                    cnt += 1\n            else:\n                (f, b) = (curr + max(t2 - tu, 0), curr + t2 - tx)\n                if f <= x <= b:\n                    cnt += 1\n    return cnt\nfor _ in range(int(input())):\n    print(solve())", "innum = lambda : int(input())\ninmul = lambda : map(int, input().split())\ninstr = lambda : str(input())\ninarr = lambda : list(map(int, input().split()))\n\ndef solve():\n    n = innum()\n    a = []\n    for i in range(n):\n        (j, k) = inmul()\n        a.append([j, k])\n    a.append([float('inf')] * 2)\n    cp = 0\n    dest = 0\n    ans = 0\n    for i in range(n):\n        if cp == dest:\n            dest = a[i][1]\n        if dest > cp:\n            add = min(a[i + 1][0] - a[i][0], dest - cp)\n            if a[i][1] >= cp and a[i][1] <= cp + add:\n                ans += 1\n            cp += add\n        else:\n            add = min(a[i + 1][0] - a[i][0], cp - dest)\n            if a[i][1] <= cp and a[i][1] >= cp - add:\n                ans += 1\n            cp -= add\n    print(ans)\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "test = int(input())\nfor sdfas in range(test):\n    n = int(input())\n    (tp, xp) = map(int, input().split())\n    pos = 0\n    target = xp\n    ans = 0\n    for i in range(n - 1):\n        (tc, xc) = map(int, input().split())\n        if tc - tp >= abs(target - pos):\n            if target <= xp <= pos or target >= xp >= pos:\n                ans += 1\n            pos = target\n            (tp, xp) = (tc, xc)\n            target = xp\n        else:\n            newpos = pos + (tc - tp) * (1 if target > pos else -1)\n            if newpos <= xp <= pos or newpos >= xp >= pos:\n                ans += 1\n            pos = newpos\n            (tp, xp) = (tc, xc)\n    if pos <= xp <= target or pos >= xp >= target:\n        ans += 1\n    print(ans)", "import math\n\ndef func(commands):\n    ans = 0\n    n = len(commands)\n    t_nxt = 0\n    for i in range(n):\n        (t, x) = commands[i]\n        if t >= t_nxt:\n            if i == 0:\n                pos = 0\n                t_nxt = t + abs(x - pos)\n            else:\n                pos = commands[state][1]\n                t_nxt = t + abs(x - pos)\n            state = i\n            if state == n - 1 or t_nxt <= commands[state + 1][0]:\n                ans += 1\n        else:\n            (ts, xs) = commands[state]\n            if (x - pos) * (xs - pos) > 0:\n                if abs(x - pos) <= abs(xs - pos) and abs(x - pos) >= t - ts and (i == n - 1 or abs(x - pos) <= commands[i + 1][0] - ts):\n                    ans += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    commands = []\n    for itr in range(n):\n        item = list(map(int, input().split()))\n        commands.append(item)\n    ans = func(commands)\n    print(ans)", "def in_range(a, b, x):\n    if a > b:\n        (a, b) = (b, a)\n    if a <= x <= b:\n        return True\n    else:\n        return False\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = 0\n    moving = False\n    ti = 0\n    xi = 0\n    signi = 1\n    dest = 0\n    pos = 0\n    for _ in range(n):\n        (t, x) = map(int, input().split())\n        diff = t - ti\n        if moving and dest != pos:\n            sign = (dest - pos) / abs(dest - pos)\n        if abs(dest - pos) <= diff:\n            current = dest\n            moving = False\n        else:\n            current = pos + sign * diff\n        if in_range(current, pos, xi):\n            ans += 1\n        if not moving:\n            moving = True\n            dest = x\n        pos = current\n        ti = t\n        xi = x\n    if in_range(dest, pos, xi):\n        ans += 1\n    print(ans - 1)", "def between(begin, end, pos):\n    return begin <= pos <= end or begin >= pos >= end\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    (pre_t, pre_x, pre_pos, pos, dest, valid_num) = (0, 0, 0, 0, 0, 0)\n    for i in range(n):\n        (cur_t, cur_x) = map(int, input().split())\n        pre_pos = pos\n        if cur_t - pre_t >= abs(dest - pos):\n            pos = dest\n            dest = cur_x\n        else:\n            direction = 1 if dest > pos else -1\n            pos += (cur_t - pre_t) * direction\n        if i > 0 and between(pos, pre_pos, pre_x):\n            valid_num += 1\n        (pre_t, pre_x) = (cur_t, cur_x)\n    if between(dest, pos, pre_x):\n        valid_num += 1\n    print(valid_num)", "for tt in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    i = 0\n    ppos = 0\n    cpos = l[0][1]\n    time = l[0][0] + abs(cpos)\n    ptime = l[0][0]\n    cnt = 0\n    for i in range(n - 1):\n        if l[i][0] < time:\n            if cpos < ppos:\n                if cpos <= l[i][1] <= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos) <= l[i + 1][0]:\n                    cnt += 1\n            elif cpos >= l[i][1] >= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos) <= l[i + 1][0]:\n                cnt += 1\n        else:\n            ppos = cpos\n            cpos = l[i][1]\n            time = l[i][0] + abs(cpos - ppos)\n            ptime = l[i][0]\n            if time <= l[i + 1][0]:\n                cnt += 1\n    i = n - 1\n    if l[i][0] < time:\n        if cpos < ppos:\n            if cpos <= l[i][1] <= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos):\n                cnt += 1\n        elif cpos >= l[i][1] >= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos):\n            cnt += 1\n    else:\n        cnt += 1\n    print(cnt)", "for tt in range(int(input())):\n    n = int(input())\n    l = [list(map(int, input().split())) for ii in range(n)]\n    i = 0\n    ppos = 0\n    cpos = l[0][1]\n    time = l[0][0] + abs(cpos)\n    ptime = l[0][0]\n    cnt = 0\n    for i in range(n - 1):\n        if l[i][0] < time:\n            if cpos < ppos:\n                if cpos <= l[i][1] <= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos) <= l[i + 1][0]:\n                    cnt += 1\n            elif cpos >= l[i][1] >= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos) <= l[i + 1][0]:\n                cnt += 1\n        else:\n            ppos = cpos\n            cpos = l[i][1]\n            time = l[i][0] + abs(cpos - ppos)\n            ptime = l[i][0]\n            if time <= l[i + 1][0]:\n                cnt += 1\n    i = n - 1\n    if l[i][0] < time:\n        if cpos < ppos:\n            if cpos <= l[i][1] <= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos):\n                cnt += 1\n        elif cpos >= l[i][1] >= ppos and l[i][0] <= ptime + abs(l[i][1] - ppos):\n            cnt += 1\n    else:\n        cnt += 1\n    print(cnt)", "T = int(input())\nfor _ in range(T):\n    n = int(input())\n    (res, cp) = (0, 0)\n    (t, x) = map(int, input().split())\n    (des, ct, X) = (x, t, x)\n    for i in range(n - 1):\n        (t, x) = map(int, input().split())\n        (et, rd) = (t - ct, abs(des - cp))\n        if rd <= et:\n            if min(des, cp) <= X <= max(des, cp):\n                res += 1\n            (cp, des) = (des, x)\n        else:\n            if des < cp and cp - et <= X <= cp:\n                res += 1\n            elif des > cp and cp <= X <= cp + et:\n                res += 1\n            cp = cp - et if des < cp else cp + et\n        (ct, X) = (t, x)\n    res += min(cp, des) <= X <= max(cp, des)\n    print(res)", "for z in range(int(input())):\n    n = int(input())\n    e = [None] * n\n    for i in range(n):\n        e[i] = tuple(map(int, input().split()))\n    i = 0\n    p = 0\n    res = 0\n    while i < n:\n        (st, tx) = e[i]\n        et = st + abs(tx - p)\n        if tx > p:\n            dir = 1\n        elif tx < p:\n            dir = -1\n        else:\n            res += 1\n            i += 1\n            continue\n        j = i + 1\n        have = 1\n        while j < n and e[j][0] < et:\n            have = 0\n            xx = e[j][1]\n            xt = (xx - p) * dir + st\n            if xt >= e[j][0] and xt <= et and (j + 1 >= n or xt <= e[j + 1][0]):\n                res += 1\n            j += 1\n        i = j\n        p = tx\n        res += have\n    print(res)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    timer = -1\n    xx = 0\n    cnt = 0\n    f = 0\n    a = []\n    for i in range(n):\n        (tt, x) = map(int, input().split())\n        a.append([tt, x])\n    timer = a[0][0]\n    lt = 0\n    a.append([10 ** 13, 0])\n    for i in range(n):\n        if a[i][0] >= timer:\n            time = abs(xx - a[i][1])\n            timer = a[i][0]\n            if timer + time <= a[i + 1][0]:\n                cnt += 1\n            lt = timer\n            lx = xx\n            timer += time\n            xx = a[i][1]\n        elif xx >= lx:\n            x1 = lx + a[i][0] - lt\n            te = a[i][0] + a[i][1] - x1\n            if x1 <= a[i][1] and a[i][1] <= xx and (te <= a[i + 1][0]):\n                cnt += 1\n        else:\n            x1 = lx - (a[i][0] - lt)\n            te = a[i][0] + abs(a[i][1] - x1)\n            if x1 >= a[i][1] and a[i][1] >= xx and (te <= a[i + 1][0]):\n                cnt += 1\n    print(cnt)", "def direction(position, destination):\n    diff = destination - position\n    if diff == 0:\n        return 0\n    return int(diff / abs(diff))\n\ndef hits(pos, dir_, t_range, x):\n    moved_pos = pos + t_range * dir_\n    if dir_ > 0:\n        if x >= pos and x <= moved_pos:\n            return True\n    elif x >= moved_pos and x <= pos:\n        return True\n    return False\n\ndef main():\n    t = int(input())\n    total = []\n    for _ in range(t):\n        n = int(input())\n        cmds = []\n        for _ in range(n):\n            cmds.append(list(map(int, input().split())))\n        cmds.append([float('inf'), 0])\n        pos = 0\n        t_left = 0\n        dir_ = 0\n        res = 0\n        for i in range(n):\n            (t_i, x_i) = cmds[i]\n            t_j = cmds[i + 1][0]\n            if t_left == 0:\n                t_left = abs(x_i - pos)\n                dir_ = direction(pos, x_i)\n            t_range = min(t_left, t_j - t_i)\n            if hits(pos, dir_, t_range, x_i):\n                res += 1\n            t_left -= t_range\n            pos += dir_ * t_range\n        total.append(res)\n    for item in total:\n        print(item)\nmain()", "for z in range(int(input())):\n    n = int(input())\n    e = [None] * n\n    for i in range(n):\n        e[i] = tuple(map(int, input().split()))\n    i = 0\n    p = 0\n    res = 0\n    while i < n:\n        (st, tx) = e[i]\n        et = st + abs(tx - p)\n        if tx > p:\n            dir = 1\n        elif tx < p:\n            dir = -1\n        else:\n            res += 1\n            i += 1\n            continue\n        j = i + 1\n        have = 1\n        while j < n and e[j][0] < et:\n            have = 0\n            xx = e[j][1]\n            xt = (xx - p) * dir + st\n            if xt >= e[j][0] and xt <= et and (j + 1 >= n or xt <= e[j + 1][0]):\n                res += 1\n            j += 1\n        i = j\n        p = tx\n        res += have\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    (busy_until, pos) = (0, 0)\n    direction = True\n    ans = 0\n    cmds = [[int(x) for x in input().split()] for i in range(n)]\n    (t, x) = ([x[0] for x in cmds], [x[1] for x in cmds])\n    t.append(3 * 10 ** 9 + 7)\n    for i in range(n):\n        if t[i] >= busy_until:\n            busy_until = t[i] + abs(pos - x[i])\n            direction = pos < x[i]\n        new_pos = pos + (min(busy_until, t[i + 1]) - t[i]) * (1 if direction else -1)\n        ans += direction and x[i] >= pos and (x[i] <= new_pos)\n        ans += not direction and x[i] <= pos and (x[i] >= new_pos)\n        pos = new_pos\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [0] * (n + 1)\n    ans = 0\n    for i in range(n):\n        a[i] = list(map(int, input().split()))\n    a[n] = [10 ** 10]\n    t = a[0][0]\n    p = 0\n    for i in range(n):\n        if a[i][0] >= t:\n            t_pre = a[i][0]\n            t = a[i][0] + abs(a[i][1] - p)\n            if t <= a[i + 1][0]:\n                ans += 1\n            if a[i][1] >= p:\n                c = 1\n            else:\n                c = -1\n            p_pre = p\n            p = a[i][1]\n        else:\n            tt = t_pre + abs(a[i][1] - p_pre)\n            pp = p_pre + c * (a[i][0] - t_pre)\n            if c == 1:\n                if p >= a[i][1] and a[i][1] >= pp and (tt <= a[i + 1][0]):\n                    ans += 1\n            elif p <= a[i][1] and a[i][1] <= pp and (tt <= a[i + 1][0]):\n                ans += 1\n    print(ans)", "def hugou(n):\n    if n >= 0:\n        return 1\n    else:\n        return -1\nT = int(input())\nINF = 10 ** 16\nans = []\nfor t in range(T):\n    n = int(input())\n    tx = [list(map(int, input().split())) for i in range(n)] + [[INF, INF]]\n    place = [0] * (n + 1)\n    (goal, time) = (0, -1)\n    for i in range(n + 1):\n        (t, x) = tx[i]\n        if time > t:\n            place[i] = place[i - 1] + (t - tx[i - 1][0]) * hugou(goal - place[i - 1])\n        else:\n            place[i] = goal\n            goal = x\n            time = t + abs(x - place[i])\n    score = 0\n    for i in range(n):\n        (l, r) = (place[i], place[i + 1])\n        if l > r:\n            (r, l) = (l, r)\n        if l <= tx[i][1] and tx[i][1] <= r:\n            score += 1\n    ans.append(score)\nfor t in range(T):\n    print(ans[t])", "for _ in range(int(input())):\n    n = int(input())\n    array = []\n    for i in range(n):\n        array.append(list(map(int, input().split())))\n    array.append([10 ** 20, array[-1][1]])\n    curr = 0\n    moveTo = 0\n    ans = 0\n    for i in range(n):\n        if curr == moveTo:\n            moveTo = array[i][1]\n        if curr < moveTo:\n            pos = min(moveTo, curr + array[i + 1][0] - array[i][0])\n            if array[i][1] <= pos and array[i][1] >= curr:\n                ans += 1\n        else:\n            pos = max(moveTo, curr - (array[i + 1][0] - array[i][0]))\n            if array[i][1] >= pos and array[i][1] <= curr:\n                ans += 1\n        curr = pos\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    x = 0\n    xi = [0] * n\n    ti = [0] * n\n    for j in range(n):\n        (ti[j], xi[j]) = map(int, input().split(' '))\n    ti.append(10000000000)\n    successful = 0\n    j = 0\n    flag = True\n    while j < n:\n        xj = xi[j]\n        tj = ti[j]\n        x_travel = abs(x - xj)\n        j += 1\n        if x_travel <= ti[j] - tj:\n            successful += 1\n        else:\n            x0 = x\n            while j < n and ti[j] < tj + x_travel:\n                if x0 < xj:\n                    x = x0 + (ti[j] - tj)\n                elif x0 > xj:\n                    x = x0 - (ti[j] - tj)\n                if x <= xi[j] and xi[j] <= min(xj, x + (ti[j + 1] - ti[j])):\n                    successful += 1\n                elif x >= xi[j] and xi[j] >= max(xj, x - (ti[j + 1] - ti[j])):\n                    successful += 1\n                j += 1\n        x = xj\n    print(successful)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    tx = []\n    for i in range(n):\n        tx.append(list(map(int, input().split())))\n    att = []\n    stop = 0\n    dstop = 0\n    dir = 0\n    curr = 0\n    for i in range(n):\n        if tx[i][0] >= stop:\n            stop = tx[i][0] + abs(dstop - tx[i][1])\n            curr = dstop\n            if tx[i][1] > dstop:\n                dir = 1\n            elif tx[i][1] < dstop:\n                dir = -1\n            else:\n                dir = 0\n            dstop = tx[i][1]\n        else:\n            curr += dir * (tx[i][0] - tx[i - 1][0])\n        att.append(curr)\n    att.append(dstop)\n    ans = 0\n    for i in range(n):\n        if att[i] <= tx[i][1] <= att[i + 1] or att[i] >= tx[i][1] >= att[i + 1]:\n            ans += 1\n    print(ans)", "test = int(input())\nwhile test:\n    test -= 1\n    n = int(input())\n    arr = []\n    cnt = 0\n    for i in range(n):\n        arr.append(list(map(int, input().split())))\n    (i, t, c) = (0, 0, 0)\n    while i < n:\n        if t < arr[i][0]:\n            t = arr[i][0]\n        if t == arr[i][0]:\n            x = arr[i][1]\n            val = 1 if c < x else -1\n            t += abs(c - x)\n            c = x\n            if i + 1 >= n or arr[i + 1][0] >= t:\n                cnt += 1\n        else:\n            x = arr[i][1]\n            t1 = arr[i][0]\n            if i + 1 >= n or t < arr[i + 1][0]:\n                t2 = t\n            else:\n                t2 = arr[i + 1][0]\n            if val == 1:\n                f = c - (t - t1)\n                l = c - (t - t2)\n            else:\n                f = c + (t - t1)\n                l = c + (t - t2)\n            if x >= f and x <= l or (x <= f and x >= l):\n                cnt += 1\n        i += 1\n    print(cnt)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = []\n    for i in range(n):\n        (t, x) = map(int, input().split())\n        arr.append([t, x])\n    start = 0\n    end = arr[0][1]\n    stime = arr[0][0]\n    etime = stime + abs(end - start)\n    ans = 0\n    for i in range(1, n):\n        if end > start:\n            curr = min(arr[i][0] - stime + start, end)\n            last = min(arr[i - 1][0] - stime + start, end)\n            if arr[i - 1][1] >= last and arr[i - 1][1] <= curr:\n                ans += 1\n        else:\n            curr = max(start - arr[i][0] + stime, end)\n            last = max(start - arr[i - 1][0] + stime, end)\n            if arr[i - 1][1] <= last and arr[i - 1][1] >= curr:\n                ans += 1\n        if etime <= arr[i][0]:\n            start = end\n            end = arr[i][1]\n            stime = arr[i][0]\n            etime = stime + abs(end - start)\n    if end > start:\n        curr = end\n        last = min(arr[n - 1][0] - stime + start, end)\n        if arr[n - 1][1] >= last and arr[n - 1][1] <= curr:\n            ans += 1\n    else:\n        curr = end\n        last = max(start - arr[n - 1][0] + stime, end)\n        if arr[n - 1][1] <= last and arr[n - 1][1] >= curr:\n            ans += 1\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "from sys import stdin\nT = int(stdin.readline().strip())\nfor caso in range(T):\n    n = int(stdin.readline().strip())\n    s = [list(map(int, stdin.readline().strip().split())) for i in range(n)]\n    s.append([10 ** 10, 10 ** 10])\n    x = 0\n    t = 0\n    ind = 0\n    ans = 0\n    while ind < n:\n        t = s[ind][0]\n        t1 = t\n        x1 = x\n        y = abs(x - s[ind][1])\n        t = t + y\n        x = s[ind][1]\n        lim = [x1, x]\n        lim.sort()\n        ind1 = ind\n        while ind < n and s[ind][0] < t:\n            t2 = t1 + abs(x1 - s[ind][1])\n            if t2 >= s[ind][0] and t2 <= s[ind + 1][0] and (s[ind][1] >= lim[0]) and (s[ind][1] <= lim[1]):\n                ans += 1\n            ind += 1\n        if ind1 == ind:\n            t2 = t1 + abs(x1 - s[ind][1])\n            if t2 >= s[ind][0] and t2 <= s[ind + 1][0] and (s[ind][1] >= lim[0]) and (s[ind][1] <= lim[1]):\n                ans += 1\n            ind += 1\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(a, b, x):\n    return min(a, b) <= x <= max(a, b)\n\ndef sgx(x):\n    if x < 0:\n        return -1\n    else:\n        return int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sgx(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "import sys\nimport math, bisect, operator\n(inf, m) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 5)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\n\ndef inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "def inside(l, r, x):\n    return min(l, r) <= x <= max(l, r)\n\ndef sg(x):\n    return -1 if x < 0 else int(x > 0)\nfor _ in range(int(input())):\n    n = int(input())\n    qs = []\n    for i in range(n):\n        qs.append(list(map(int, input().split())))\n    qs.append([4 * 10 ** 9, 0])\n    ans = 0\n    (pos, dr, lft) = (0, 0, 0)\n    for i in range(n):\n        (t, x) = qs[i]\n        tn = qs[i + 1][0]\n        if lft == 0:\n            lft = abs(pos - x)\n            dr = sg(x - pos)\n        tmp = min(lft, tn - t)\n        if inside(pos, pos + dr * tmp, x):\n            ans += 1\n        pos += dr * tmp\n        lft -= tmp\n    print(ans)", "import sys\nimport bisect\n\ndef load_sys():\n    return sys.stdin.readlines()\n\ndef load_local():\n    with open('input.txt', 'r') as f:\n        input = f.readlines()\n    return input\n\ndef busy_robot(commands):\n    idx_end = cur_pos = target = 0\n    events = [x[0] for x in commands]\n    positions = [0] + [None] * len(commands)\n    ans = 0\n    for i in range(len(commands)):\n        if i >= idx_end:\n            positions[i] = cur_pos = target\n            target = commands[i][1]\n            idx_end = bisect.bisect_left(events, commands[i][0] + abs(cur_pos - target))\n            continue\n        if cur_pos > target:\n            cur_pos += events[i - 1] - events[i]\n        elif cur_pos < target:\n            cur_pos += events[i] - events[i - 1]\n        positions[i] = cur_pos\n    positions[-1] = target\n    for i in range(len(commands)):\n        mn = min(positions[i], positions[i + 1])\n        mx = max(positions[i], positions[i + 1])\n        if mn <= commands[i][1] <= mx:\n            ans += 1\n    return ans\ninput = load_sys()\nTEST_CASES = []\ncase = []\ni = 0\nwhile i <= len(input):\n    if i == len(input):\n        TEST_CASES.append(case)\n        break\n    input[i] = input[i].split()\n    if len(input[i]) == 1 and case:\n        TEST_CASES.append(case)\n        case = []\n    elif len(input[i]) == 2:\n        case.append([int(x) for x in input[i]])\n    i += 1\nfor commands in TEST_CASES:\n    print(busy_robot(commands))", "import sys\nimport bisect\n\ndef load_sys():\n    return sys.stdin.readlines()\n\ndef load_local():\n    with open('input.txt', 'r') as f:\n        input = f.readlines()\n    return input\n\ndef busy_robot(commands):\n    idx_end = cur_pos = target = 0\n    events = [x[0] for x in commands]\n    positions = [0] + [None] * len(commands)\n    ans = 0\n    for i in range(len(commands)):\n        if i >= idx_end:\n            positions[i] = cur_pos = target\n            target = commands[i][1]\n            idx_end = bisect.bisect_left(events, commands[i][0] + abs(cur_pos - target))\n            continue\n        if cur_pos > target:\n            cur_pos += events[i - 1] - events[i]\n        elif cur_pos < target:\n            cur_pos += events[i] - events[i - 1]\n        positions[i] = cur_pos\n    positions[-1] = target\n    for i in range(len(commands)):\n        mn = min(positions[i], positions[i + 1])\n        mx = max(positions[i], positions[i + 1])\n        if mn <= commands[i][1] <= mx:\n            ans += 1\n    return ans\ninput = load_sys()\nTEST_CASES = []\ncase = []\ni = 0\nwhile i <= len(input):\n    if i == len(input):\n        print(busy_robot(case))\n        break\n    input[i] = input[i].split()\n    if len(input[i]) == 1 and case:\n        print(busy_robot(case))\n        case = []\n    elif len(input[i]) == 2:\n        case.append([int(x) for x in input[i]])\n    i += 1", "for _ in range(int(input())):\n    n = int(input())\n    queue = []\n    for i in range(n):\n        queue.append(tuple(map(int, input().split())))\n    queue.append((9999999999, 0))\n    (success, position, direction, target_x) = (0, 0, 0, 0)\n    for i in range(n):\n        (t, x) = queue[i]\n        next_t = queue[i + 1][0]\n        if position == target_x:\n            target_x = x\n            displacement = x - position\n            direction = 0 if displacement == 0 else displacement // abs(displacement)\n        time_pass = min(next_t - t, abs(target_x - position))\n        success += int(min(position, position + direction * time_pass) <= x <= max(position, position + direction * time_pass))\n        position += direction * time_pass\n    print(success)"]