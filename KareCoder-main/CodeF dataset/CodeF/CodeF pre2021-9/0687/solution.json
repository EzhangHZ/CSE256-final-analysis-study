["from sys import stdin, stdout\nimport collections, heapq, bisect, math\ninput = stdin.readline\n\ndef rint():\n    return int(input())\n\ndef rstr():\n    return input().strip()\n\ndef rlstr():\n    return list(input().strip().split())\n\ndef rlint():\n    return list(map(int, input().split()))\n\ndef main():\n    (n, p) = rlint()\n    a = rlint()\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in range(1, n):\n        if a[i] % c == 0:\n            b[i - 1] = min(b[i - 1], c)\n        else:\n            c = a[i]\n    c = a[-1]\n    for i in range(n - 2, -1, -1):\n        if a[i] % c == 0:\n            b[i] = min(b[i], c)\n        else:\n            c = a[i]\n    print(sum(b))\nfor _ in range(rint()):\n    main()", "for t in range(int(input())):\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    res = [p] * (n - 1)\n    c = a[0]\n    for i in range(1, n):\n        if a[i] % c == 0:\n            res[i - 1] = min(c, res[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if a[i] % c == 0:\n            res[i] = min(c, res[i])\n        else:\n            c = a[i]\n    print(sum(res))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "for t in range(int(input())):\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    res = [p] * (n - 1)\n    c = a[0]\n    for i in range(1, n):\n        if a[i] % c == 0:\n            res[i - 1] = min(c, res[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if a[i] % c == 0:\n            res[i] = min(c, res[i])\n        else:\n            c = a[i]\n    print(sum(res))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "from sys import stdin, stdout\nimport collections, heapq, bisect, math\ninput = stdin.readline\n\ndef rint():\n    return int(input())\n\ndef rstr():\n    return input().strip()\n\ndef rlstr():\n    return list(input().strip().split())\n\ndef rlint():\n    return list(map(int, input().split()))\n\ndef main():\n    (n, p) = rlint()\n    a = rlint()\n    d = []\n    connected = [False] * n\n    for i in range(n):\n        d.append((a[i], i))\n    d.sort()\n    res = 0\n    for (cur, t) in d:\n        if cur >= p:\n            break\n        i = t\n        while i > 0:\n            if connected[i - 1]:\n                break\n            if a[i - 1] % cur == 0:\n                connected[i - 1] = True\n                res += cur\n                i -= 1\n            else:\n                break\n        i = t\n        while i < n - 1:\n            if connected[i]:\n                break\n            if a[i + 1] % cur == 0:\n                connected[i] = True\n                res += cur\n                i += 1\n            else:\n                break\n    for i in range(n - 1):\n        if not connected[i]:\n            res += p\n    print(res)\nfor _ in range(rint()):\n    main()", "I = lambda : map(int, input().split())\n(t,) = I()\nfor test in range(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in range(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "I = lambda : map(int, input().split())\n(t,) = I()\nr = range\nfor _ in r(t):\n    (n, p) = I()\n    a = (*I(),)\n    b = [p] * (n - 1)\n    c = a[0]\n    for i in r(1, n):\n        if a[i] % c < 1:\n            b[i - 1] = min(c, b[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in r(n - 2, -1, -1):\n        if a[i] % c < 1:\n            b[i] = min(c, b[i])\n        else:\n            c = a[i]\n    print(sum(b))", "for t in range(int(input())):\n    (n, p) = map(int, input().split())\n    a = list(map(int, input().split()))\n    output = [p] * (n - 1)\n    c = a[0]\n    for i in range(1, n):\n        if a[i] % c == 0:\n            output[i - 1] = min(c, output[i - 1])\n        else:\n            c = a[i]\n    c = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if a[i] % c == 0:\n            output[i] = min(c, output[i])\n        else:\n            c = a[i]\n    print(sum(output))", "class UnionFind:\n\n    def __init__(self, n):\n        self.Id = list(range(n + 1))\n        self.sz = [1] * (n + 1)\n\n    def find(self, node):\n        root = node\n        while root != self.Id[root]:\n            root = self.Id[root]\n        while node != root:\n            nxt = self.Id[node]\n            self.Id[node] = root\n            node = nxt\n        return root\n\n    def union(self, u, v):\n        (pu, pv) = (self.find(u), self.find(v))\n        if pu == pv:\n            return False\n        if self.sz[pu] <= self.sz[pv]:\n            self.Id[pu] = pv\n            self.sz[pv] += self.sz[pu]\n        else:\n            self.Id[pv] = pu\n            self.sz[pu] += self.sz[pv]\n        return True\n\ndef solve(A, n, p):\n    edg = [(p, i, i + 1) for i in range(1, n)]\n    (pel, pind) = (10 ** 9 + 10, 1)\n    for (i, it) in enumerate(A):\n        if it % pel == 0:\n            edg.append((pel, pind, i + 1))\n        else:\n            (pel, pind) = (it, i + 1)\n    (pel, pind) = (10 ** 9 + 10, n)\n    i = n\n    for it in A[-1::-1]:\n        if it % pel == 0:\n            edg.append((pel, i, pind))\n        else:\n            (pel, pind) = (it, i)\n        i -= 1\n    edg.sort()\n    dsu = UnionFind(n)\n    ans = 0\n    for (w, u, v) in edg:\n        if dsu.union(u, v):\n            ans += w\n    return ans\nfor case in range(int(input())):\n    (n, p) = map(int, input().split())\n    print(solve(list(map(int, input().split())), n, p))"]