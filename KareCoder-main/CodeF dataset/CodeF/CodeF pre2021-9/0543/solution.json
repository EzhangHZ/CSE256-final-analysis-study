["def ss(n, m, l):\n    a = []\n    b = []\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == 'B':\n                a.append([i, j])\n            elif l[i][j] == 'G':\n                b.append([i, j])\n    if len(b) == 0:\n        return 'Yes'\n    t = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    for (x, y) in a:\n        for (dx, dy) in t:\n            nx = x + dx\n            ny = y + dy\n            if nx < n and ny < m and (nx >= 0) and (ny >= 0):\n                if l[nx][ny] == 'G':\n                    return 'No'\n                if l[nx][ny] == '.':\n                    l[nx][ny] = '#'\n    if l[n - 1][m - 1] == '#':\n        if len(b) == 0:\n            return 'Yes'\n        return 'No'\n    q = [[n - 1, m - 1]]\n    while q:\n        q1 = []\n        for (x, y) in q:\n            for (dx, dy) in t:\n                nx = x + dx\n                ny = y + dy\n                if nx < n and ny < m and (nx >= 0) and (ny >= 0) and (l[nx][ny] != '#'):\n                    l[nx][ny] = '#'\n                    q1.append([nx, ny])\n        q = q1\n    for i in range(n):\n        for j in range(m):\n            if l[i][j] == 'G':\n                return 'No'\n    return 'Yes'\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        l.append(list(str(input())))\n    print(ss(n, m, l))", "import sys\nsys.setrecursionlimit(10 ** 5)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                if i > 0 and grid[i - 1][j] == '.':\n                    grid[i - 1][j] = '#'\n                if i < n - 1 and grid[i + 1][j] == '.':\n                    grid[i + 1][j] = '#'\n                if j > 0 and grid[i][j - 1] == '.':\n                    grid[i][j - 1] = '#'\n                if j < m - 1 and grid[i][j + 1] == '.':\n                    grid[i][j + 1] = '#'\n    access = [[False] * m for _ in range(n)]\n\n    def dfs(i, j):\n        if 0 <= i < n and 0 <= j < m and (grid[i][j] != '#'):\n            if access[i][j]:\n                return\n            access[i][j] = True\n            dfs(i - 1, j)\n            dfs(i, j - 1)\n            dfs(i + 1, j)\n            dfs(i, j + 1)\n    dfs(n - 1, m - 1)\n    ans = 'Yes'\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'G':\n                if not access[i][j]:\n                    ans = 'No'\n            if grid[i][j] == 'B':\n                if access[i][j]:\n                    ans = 'No'\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 5)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = [list(input()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 'B':\n                if i > 0 and a[i - 1][j] == '.':\n                    a[i - 1][j] = '#'\n                if i < n - 1 and a[i + 1][j] == '.':\n                    a[i + 1][j] = '#'\n                if j > 0 and a[i][j - 1] == '.':\n                    a[i][j - 1] = '#'\n                if j < m - 1 and a[i][j + 1] == '.':\n                    a[i][j + 1] = '#'\n    vis = [[False] * m for _ in range(n)]\n\n    def dfs(i, j):\n        if 0 <= i < n and 0 <= j < m and (a[i][j] != '#'):\n            if vis[i][j]:\n                return\n            vis[i][j] = True\n            dfs(i - 1, j)\n            dfs(i, j - 1)\n            dfs(i + 1, j)\n            dfs(i, j + 1)\n    dfs(n - 1, m - 1)\n    ans = 'Yes'\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 'G':\n                if not vis[i][j]:\n                    ans = 'No'\n            if a[i][j] == 'B':\n                if vis[i][j]:\n                    ans = 'No'\n    print(ans)", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nWALL = '#'\nGOOD_PERSON = 'G'\nBAD_PERSON = 'B'\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    used[i][j] = 1\n    for (di, dj) in DIR:\n        if not used[i + di][j + dj] and a[i + di][j + dj] != WALL:\n            dfs(i + di, j + dj)\ntests = int(input())\nfor t in range(tests):\n    (n, m) = list(map(int, input().split()))\n    a = [['#'] * (m + 2)] + [list(WALL + input() + WALL) for i in range(n)] + [[WALL] * (m + 2)]\n    (used, ok) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == BAD_PERSON:\n                for (di, dj) in DIR:\n                    if a[i + di][j + dj] == GOOD_PERSON:\n                        ok = False\n                    elif a[i + di][j + dj] != BAD_PERSON:\n                        a[i + di][j + dj] = WALL\n    if a[n][m] != WALL:\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == GOOD_PERSON and (not used[i][j]):\n                ok = False\n    print('Yes' if ok else 'No')", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    used[i][j] = 1\n    for (di, dj) in DIR:\n        if not used[i + di][j + dj] and a[i + di][j + dj] != '#':\n            dfs(i + di, j + dj)\ntests = int(input())\nfor t in range(tests):\n    (n, m) = list(map(int, input().split()))\n    a = [['#'] * (m + 2)] + [list('#' + input() + '#') for i in range(n)] + [['#'] * (m + 2)]\n    (used, ok) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'B':\n                for (di, dj) in DIR:\n                    if a[i + di][j + dj] == 'G':\n                        ok = False\n                    elif a[i + di][j + dj] != 'B':\n                        a[i + di][j + dj] = '#'\n    if a[n][m] != '#':\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'G' and (not used[i][j]):\n                ok = False\n    print('Yes' if ok else 'No')", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nWALL = '#'\nGOOD_PERSON = 'G'\nBAD_PERSON = 'B'\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    been[i][j] = 1\n    for (di, dj) in DIR:\n        if not been[i + di][j + dj] and a[i + di][j + dj] != WALL:\n            dfs(i + di, j + dj)\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = [[WALL] * (m + 2)] + [list(WALL + input() + WALL) for i in range(n)] + [[WALL] * (m + 2)]\n    (been, isValid) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for j in range(1, n + 1):\n        for k in range(1, m + 1):\n            if a[j][k] == BAD_PERSON:\n                for (di, dj) in DIR:\n                    if a[j + di][k + dj] == GOOD_PERSON:\n                        isValid = False\n                    elif a[j + di][k + dj] != BAD_PERSON:\n                        a[j + di][k + dj] = WALL\n    if a[n][m] != WALL:\n        dfs(n, m)\n    for j in range(1, n + 1):\n        for k in range(1, m + 1):\n            if a[j][k] == GOOD_PERSON and (not been[j][k]):\n                isValid = False\n    print('Yes' if isValid else 'No')", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nWALL = '#'\nGOOD_PERSON = 'G'\nBAD_PERSON = 'B'\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    been[i][j] = 1\n    for (d_i, d_j) in DIR:\n        if not been[i + d_i][j + d_j] and a[i + d_i][j + d_j] != WALL:\n            dfs(i + d_i, j + d_j)\nt = int(input())\nfor i in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = [[WALL] * (m + 2)] + [list(WALL + input() + WALL) for i in range(n)] + [[WALL] * (m + 2)]\n    (been, isValid) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for j in range(1, n + 1):\n        for k in range(1, m + 1):\n            if a[j][k] == BAD_PERSON:\n                for (d_i, d_j) in DIR:\n                    if a[j + d_i][k + d_j] == GOOD_PERSON:\n                        isValid = False\n                    elif a[j + d_i][k + d_j] != BAD_PERSON:\n                        a[j + d_i][k + d_j] = WALL\n    if a[n][m] != WALL:\n        dfs(n, m)\n    for j in range(1, n + 1):\n        for k in range(1, m + 1):\n            if a[j][k] == GOOD_PERSON and (not been[j][k]):\n                isValid = False\n    print('Yes' if isValid else 'No')", "directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\ndef solve(matrix, n, m):\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'B':\n                for (di, dj) in directions:\n                    ni = i + di\n                    nj = j + dj\n                    if 0 <= ni < n and 0 <= nj < m:\n                        if matrix[ni][nj] == 'G':\n                            return False\n                        if matrix[ni][nj] != 'B':\n                            matrix[ni][nj] = '#'\n    q = []\n    visited = set()\n    if matrix[-1][-1] != '#':\n        q.append((n - 1, m - 1))\n        visited.add((n - 1, m - 1))\n    while q:\n        (i, j) = q.pop()\n        for (di, dj) in directions:\n            ni = i + di\n            nj = j + dj\n            if (ni, nj) not in visited and 0 <= ni < n and (0 <= nj < m) and (matrix[ni][nj] != '#'):\n                q.append((ni, nj))\n                visited.add((ni, nj))\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'G' and (i, j) not in visited:\n                return False\n    return True\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    matrix = []\n    for i in range(n):\n        matrix.append([x for x in input()])\n    if solve(matrix, n, m):\n        print('Yes')\n    else:\n        print('No')", "import sys\nsys.setrecursionlimit(10 ** 5)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                if i > 0 and grid[i - 1][j] == '.':\n                    grid[i - 1][j] = '#'\n                if i < n - 1 and grid[i + 1][j] == '.':\n                    grid[i + 1][j] = '#'\n                if j > 0 and grid[i][j - 1] == '.':\n                    grid[i][j - 1] = '#'\n                if j < m - 1 and grid[i][j + 1] == '.':\n                    grid[i][j + 1] = '#'\n    access = [[False] * m for _ in range(n)]\n\n    def dfs(i, j):\n        if 0 <= i < n and 0 <= j < m and (grid[i][j] != '#'):\n            if access[i][j]:\n                return\n            access[i][j] = True\n            dfs(i - 1, j)\n            dfs(i, j - 1)\n            dfs(i + 1, j)\n            dfs(i, j + 1)\n    dfs(n - 1, m - 1)\n    ans = 'Yes'\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'G':\n                if not access[i][j]:\n                    ans = 'No'\n            if grid[i][j] == 'B':\n                if access[i][j]:\n                    ans = 'No'\n    print(ans)", "from collections import deque\n\ndef solve():\n    (n, m) = map(int, input().split(' '))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    n_good = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'G':\n                n_good += 1\n            elif matrix[i][j] == 'B':\n                for (di, dj) in directions:\n                    if di + i < 0 or di + i >= n or dj + j < 0 or (dj + j >= m) or (matrix[di + i][dj + j] == 'B'):\n                        continue\n                    elif matrix[di + i][dj + j] == 'G':\n                        return 'No'\n                    matrix[di + i][dj + j] = '#'\n    if n_good == 0:\n        return 'Yes'\n    if matrix[n - 1][m - 1] == '#':\n        return 'No'\n    q = deque()\n    q.append((n - 1, m - 1))\n    matrix[n - 1][m - 1] = '#'\n    while q:\n        (i, j) = q.popleft()\n        for (di, dj) in directions:\n            if di + i < 0 or di + i >= n or dj + j < 0 or (dj + j >= m) or (matrix[di + i][dj + j] == '#'):\n                continue\n            if matrix[di + i][dj + j] == 'G':\n                n_good -= 1\n            matrix[di + i][dj + j] = '#'\n            q.append((di + i, dj + j))\n    return 'Yes' if n_good == 0 else 'No'\nT = int(input())\nfor _ in range(T):\n    print(solve())", "from collections import deque\n\ndef solve():\n    (n, m) = map(int, input().split(' '))\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    n_good = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'G':\n                n_good += 1\n            elif matrix[i][j] == 'B':\n                for (di, dj) in directions:\n                    if di + i < 0 or di + i >= n or dj + j < 0 or (dj + j >= m) or (matrix[di + i][dj + j] == 'B'):\n                        continue\n                    elif matrix[di + i][dj + j] == 'G':\n                        return 'No'\n                    matrix[di + i][dj + j] = '#'\n    if n_good == 0:\n        return 'Yes'\n    if n_good != 0 and matrix[n - 1][m - 1] == '#':\n        return 'No'\n    q = deque()\n    q.append((n - 1, m - 1))\n    matrix[n - 1][m - 1] = '#'\n    while q:\n        (i, j) = q.popleft()\n        for (di, dj) in directions:\n            if di + i < 0 or di + i >= n or dj + j < 0 or (dj + j >= m) or (matrix[di + i][dj + j] == '#'):\n                continue\n            if matrix[di + i][dj + j] == 'G':\n                n_good -= 1\n            matrix[di + i][dj + j] = '#'\n            q.append((di + i, dj + j))\n    return 'Yes' if n_good == 0 else 'No'\nT = int(input())\nfor _ in range(T):\n    print(solve())", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    used[i][j] = 1\n    for (di, dj) in DIR:\n        if not used[i + di][j + dj] and a[i + di][j + dj] != '#':\n            dfs(i + di, j + dj)\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = [['#'] * (m + 2)] + [list('#' + input() + '#') for i in range(n)] + [['#'] * (m + 2)]\n    (used, ok) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'B':\n                for (di, dj) in DIR:\n                    if a[i + di][j + dj] == 'G':\n                        ok = False\n                    elif a[i + di][j + dj] != 'B':\n                        a[i + di][j + dj] = '#'\n    if a[n][m] != '#':\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'G' and (not used[i][j]):\n                ok = False\n    print('Yes' if ok else 'No')", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    used[i][j] = 1\n    for (di, dj) in DIR:\n        if not used[i + di][j + dj] and a[i + di][j + dj] != '#':\n            dfs(i + di, j + dj)\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = [['#'] * (m + 2)] + [list('#' + input() + '#') for i in range(n)] + [['#'] * (m + 2)]\n    (used, ok) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'B':\n                for (di, dj) in DIR:\n                    if a[i + di][j + dj] == 'G':\n                        ok = False\n                    elif a[i + di][j + dj] != 'B':\n                        a[i + di][j + dj] = '#'\n    if a[n][m] != '#':\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'G' and (not used[i][j]):\n                ok = False\n    print('Yes' if ok else 'No')", "import sys\nsys.setrecursionlimit(100000)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    used[i][j] = 1\n    for (di, dj) in DIR:\n        if not used[i + di][j + dj] and a[i + di][j + dj] != '#':\n            dfs(i + di, j + dj)\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = [['#'] * (m + 2)] + [list('#' + input() + '#') for i in range(n)] + [['#'] * (m + 2)]\n    used = [[0] * (m + 2) for i in range(n + 2)]\n    ok = True\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'B':\n                for (di, dj) in DIR:\n                    if a[i + di][j + dj] == 'G':\n                        ok = False\n                    elif a[i + di][j + dj] != 'B':\n                        a[i + di][j + dj] = '#'\n    if a[n][m] != '#':\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'G' and (not used[i][j]):\n                ok = False\n    print('Yes' if ok else 'No')", "from sys import setrecursionlimit as srl\nsrl(10 ** 5)\nDIR = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    used[i][j] = 1\n    for (di, dj) in DIR:\n        if not used[i + di][j + dj] and a[i + di][j + dj] != '#':\n            dfs(i + di, j + dj)\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    a = [['#'] * (m + 2)] + [list('#' + input() + '#') for i in range(n)] + [['#'] * (m + 2)]\n    (used, ok) = ([[0] * (m + 2) for i in range(n + 2)], True)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'B':\n                for (di, dj) in DIR:\n                    if a[i + di][j + dj] == 'G':\n                        ok = False\n                    elif a[i + di][j + dj] != 'B':\n                        a[i + di][j + dj] = '#'\n    if a[n][m] != '#':\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i][j] == 'G' and (not used[i][j]):\n                ok = False\n    print('Yes' if ok else 'No')", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\n\ndef solve():\n    (h, w) = nm()\n    g = [list(ns()) for _ in range(h)]\n    d = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    for i in range(h):\n        for j in range(w):\n            if g[i][j] == 'B':\n                for (di, dj) in d:\n                    ni = i + di\n                    nj = j + dj\n                    if 0 <= ni < h and 0 <= nj < w and (g[ni][nj] == '.'):\n                        g[ni][nj] = '#'\n    q = deque()\n    f = [[-1] * w for _ in range(h)]\n    if g[-1][-1] == '.':\n        f[-1][-1] = 0\n        q.append((h - 1, w - 1))\n    while q:\n        (i, j) = q.popleft()\n        for (di, dj) in d:\n            ni = i + di\n            nj = j + dj\n            if 0 <= ni < h and 0 <= nj < w and (g[ni][nj] != '#') and (f[ni][nj] < 0):\n                f[ni][nj] = f[i][j] + 1\n                q.append((ni, nj))\n    for i in range(h):\n        for j in range(w):\n            if g[i][j] == 'G' and f[i][j] < 0 or (g[i][j] == 'B' and f[i][j] >= 0):\n                print('No')\n                return\n    print('Yes')\n    return\nT = int(input())\nfor _ in range(T):\n    solve()", "import sys\nsys.setrecursionlimit(100000)\nDirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef dfs(i, j):\n    if i > n or i == 0 or j > m or (j == 0):\n        return\n    visited[i][j] = 1\n    for (di, dj) in Directions:\n        if not visited[i + di][j + dj] and maze[i + di][j + dj] != '#':\n            dfs(i + di, j + dj)\nfor t in range(int(input())):\n    (n, m) = list(map(int, input().split()))\n    maze = [['#'] * (m + 2)] + [list('#' + input() + '#') for i in range(n)] + [['#'] * (m + 2)]\n    visited = [[0] * (m + 2) for i in range(n + 2)]\n    canDoIt = True\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if maze[i][j] == 'B':\n                for (di, dj) in Directions:\n                    if maze[i + di][j + dj] == 'G':\n                        canDoIt = False\n                    elif maze[i + di][j + dj] != 'B':\n                        maze[i + di][j + dj] = '#'\n    if maze[n][m] != '#':\n        dfs(n, m)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if maze[i][j] == 'G' and (not visited[i][j]):\n                canDoIt = False\n    print('Yes' if canDoIt else 'No')", "def valid(x, y):\n    return 0 <= x < n and 0 <= y < m\ndirc = [(1, 0), (0, 1), (0, -1), (-1, 0)]\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        temp = [el for el in input()]\n        arr.append(temp)\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 'B':\n                for (dx, dy) in dirc:\n                    (nx, ny) = (dx + i, dy + j)\n                    if valid(nx, ny) and arr[nx][ny] == '.':\n                        arr[nx][ny] = '#'\n    q = []\n    seen = set()\n    if arr[-1][-1] == '.':\n        q.append((n - 1, m - 1))\n        seen.add((n - 1, m - 1))\n    while q:\n        (x, y) = q.pop()\n        for (dx, dy) in dirc:\n            (nx, ny) = (dx + x, dy + y)\n            if valid(nx, ny) and (nx, ny) not in seen and (arr[nx][ny] != '#'):\n                q.append((nx, ny))\n                seen.add((nx, ny))\n    good = True\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 'G' and (i, j) not in seen or (arr[i][j] == 'B' and (i, j) in seen):\n                good = False\n    if good:\n        print('Yes')\n    else:\n        print('No')"]