["import sys\nfrom collections import deque, defaultdict, Counter\nfrom bisect import bisect_left\n\ndef debug(*args):\n    print(*args, file=sys.stderr)\n\ndef read_str():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef read_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef read_str_split():\n    return list(sys.stdin.readline().strip())\n\ndef read_int_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef solve(a: list, b: list):\n    position = set(b)\n    tmp = len(set(a) & position)\n    que = deque()\n    (res, ptr) = (tmp, 0)\n    for x in b:\n        que.append(x)\n        while a and a[-1] <= x:\n            y = a.pop()\n            if y in position:\n                tmp -= 1\n            ptr += 1\n        while que and que[0] <= x - ptr:\n            que.popleft()\n        res = max(res, tmp + len(que))\n    return res\n\ndef Main():\n    t = read_int()\n    for _ in range(t):\n        (n, m) = read_ints()\n        a = read_int_list()\n        b = read_int_list()\n        a_i = bisect_left(a, 0)\n        b_i = bisect_left(b, 0)\n        (a_plus, b_plus) = (a[a_i:], b[b_i:])\n        (a_minus, b_minus) = ([-x for x in a[:a_i]], [-x for x in b[:b_i]])\n        a_plus.sort(reverse=True)\n        a_minus.sort(reverse=True)\n        b_plus.sort()\n        b_minus.sort()\n        print(solve(a_plus, b_plus) + solve(a_minus, b_minus))\nMain()", "import sys\nimport bisect\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    boxes = list(map(int, input().split()))\n    marks = list(map(int, input().split()))\n    bidx = bisect.bisect(boxes, 0)\n    midx = bisect.bisect(marks, 0)\n\n    def countbox(boxes, marks):\n        (res, already) = (0, 0)\n        (i, j) = (len(boxes) - 1, len(marks) - 1)\n        while i >= 0 and j >= 0:\n            if boxes[i] > marks[j]:\n                i -= 1\n                continue\n            box_num = i + 1\n            mark_num = j - bisect.bisect_left(marks, marks[j] - box_num + 1) + 1\n            res = max(res, mark_num + already)\n            if boxes[i] == marks[j]:\n                already += 1\n            j -= 1\n        return res\n    print(countbox(boxes[bidx:], marks[midx:]) + countbox([-i for i in boxes[:bidx][::-1]], [-i for i in marks[:midx][::-1]]))", "from bisect import bisect_left\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ai = bisect_left(a, 0)\n    bi = bisect_left(b, 0)\n\n    def solve(a, b):\n        n = len(a)\n        m = len(b)\n        pp = [0 for _ in range(len(a) + 1)]\n        latest = len(b) - 1\n        for i in reversed(range(len(a))):\n            prev = pp[i + 1]\n            while latest >= 0 and a[i] < b[latest]:\n                latest -= 1\n            if latest >= 0 and a[i] == b[latest]:\n                prev += 1\n                latest -= 1\n            pp[i] = prev\n        size = 0\n        (l1, r1) = (0, 0)\n        latest = 0\n        res = 0\n        for i in range(m):\n            while size < n and b[i] + size > a[size]:\n                size += 1\n            while latest < m and b[latest] < b[i] + size:\n                latest += 1\n            res = max(res, latest - i + pp[size])\n        return res\n    print(solve(a[ai:], b[bi:]) + solve([-x for x in a[:ai]][::-1], [-x for x in b[:bi]][::-1]))", "from bisect import bisect_left\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    ai = bisect_left(a, 0)\n    bi = bisect_left(b, 0)\n\n    def solve(a, b):\n        n = len(a)\n        m = len(b)\n        pp = [0 for _ in range(len(a) + 1)]\n        latest = len(b) - 1\n        for i in reversed(range(len(a))):\n            prev = pp[i + 1]\n            while latest >= 0 and a[i] < b[latest]:\n                latest -= 1\n            if latest >= 0 and a[i] == b[latest]:\n                prev += 1\n                latest -= 1\n            pp[i] = prev\n        size = 0\n        (l1, r1) = (0, 0)\n        latest = 0\n        res = 0\n        for i in range(m):\n            while size < n and b[i] + size > a[size]:\n                size += 1\n            while latest < m and b[latest] < b[i] + size:\n                latest += 1\n            res = max(res, latest - i + pp[size])\n        return res\n    print(solve(a[ai:], b[bi:]) + solve([-x for x in a[:ai]][::-1], [-x for x in b[:bi]][::-1]))", "import bisect\nimport collections\nimport copy\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(99999)\n\ndef f(ta, tb):\n    if not ta or not tb:\n        return 0\n    sa = set(ta)\n    sb = set(tb)\n    m1 = 0\n    d = [0] * (len(tb) + 5)\n    d[len(tb) - 1] += tb[-1] in sa\n    for i in range(len(tb) - 2, -1, -1):\n        d[i] = d[i + 1] + (tb[i] in sa)\n    j = 0\n    j2 = 0\n    for (i, c) in enumerate(tb):\n        while j < len(ta) and ta[j] <= c:\n            j += 1\n        lo = c - j + 1\n        while j2 < len(tb) and tb[j2] < lo:\n            j2 += 1\n        m1 = max(m1, i - j2 + 1 + d[i + 1])\n    return m1\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a1 = []\n    a2 = []\n    b1 = []\n    b2 = []\n    for c in map(int, input().split()):\n        if c < 0:\n            a1.append(-c)\n        else:\n            a2.append(c)\n    for c in map(int, input().split()):\n        if c < 0:\n            b1.append(-c)\n        else:\n            b2.append(c)\n    m1 = f(a2, b2)\n    m2 = f(a1[::-1], b1[::-1])\n    print(m1 + m2)\nfor _ in range(int(input())):\n    solve()", "def read_list_of_input():\n    return [x for x in input().split()]\n\ndef read_list_of_int():\n    return [int(x) for x in read_list_of_input()]\n\ndef optimal_num(boxes, postions):\n    ans = 0\n    (n, m) = (len(boxes), len(postions))\n    after_nth_box_best = [0 for _ in range(n + 1)]\n    b = m - 1\n    for x in range(n - 1, -1, -1):\n        after_nth_box_best[x] = after_nth_box_best[x + 1]\n        while b >= 0 and boxes[x] < postions[b]:\n            b -= 1\n        if b >= 0 and boxes[x] == postions[b]:\n            after_nth_box_best[x] += 1\n    j = 0\n    r = 0\n    for x in range(m):\n        while j < n and postions[x] + j >= boxes[j]:\n            j += 1\n        while r < m and postions[r] < j + postions[x]:\n            r += 1\n        ans = max(ans, after_nth_box_best[j] + r - x)\n    return ans\n\ndef solve():\n    (n, m) = read_list_of_int()\n    box_pos = read_list_of_int()\n    special_pos = read_list_of_int()\n    box_left = [-1 * x for x in box_pos if x < 0]\n    box_left.reverse()\n    box_right = [x for x in box_pos if x >= 0]\n    special_left = [-1 * x for x in special_pos if x < 0]\n    special_left.reverse()\n    special_right = [x for x in special_pos if x >= 0]\n    print(optimal_num(box_left, special_left) + optimal_num(box_right, special_right))\ntest = int(input())\nfor x in range(test):\n    solve()", "from bisect import bisect_left\n\ndef ggwp(pos, neg):\n    if len(pos) == 0 or len(neg) == 0:\n        return 0\n    a = len(pos) - 1\n    b = len(neg) - 1\n    ans = 0\n    already_in_position = 0\n    while a >= 0 and b >= 0:\n        if pos[a] > neg[b]:\n            a -= 1\n            continue\n        tot_boxes_behind = a + 1\n        index_of_boxes_available = bisect_left(neg, neg[b] - tot_boxes_behind + 1)\n        boxes_finally_filled = b - index_of_boxes_available + 1\n        ans = max(ans, already_in_position + boxes_finally_filled)\n        if pos[a] == neg[b]:\n            already_in_position += 1\n        b -= 1\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    apos = [i for i in a if i > 0]\n    aneg = [-i for i in a if i < 0]\n    aneg.reverse()\n    bpos = [i for i in b if i > 0]\n    bneg = [-i for i in b if i < 0]\n    bneg.reverse()\n    ans = 0\n    ans += ggwp(apos, bpos)\n    ans += ggwp(aneg, bneg)\n    print(ans)", "from bisect import *\nl = bisect_left\nr = range\n\ndef s(a):\n    (A, B) = a\n    S = set(A)\n    b = len(B)\n    C = [0] * (b + 1)\n    for i in r(b - 1, -1, -1):\n        if B[i] in S:\n            C[i] += 1\n        C[i] += C[i + 1]\n    a = C[0]\n    X = 0\n    for i in r(b):\n        while X < len(A) and A[X] <= B[i]:\n            X += 1\n        if X > 0:\n            a = max(a, l(B, B[i]) - l(B, B[i] - X + 1) + 1 + C[i + 1])\n    return a\n\ndef g():\n    A = []\n    B = []\n    for v in p():\n        if v < 0:\n            A += (-v,)\n        else:\n            B += (v,)\n    return (A[::-1], B)\np = lambda : map(int, input().split())\nfor t in r(*p()):\n    p()\n    print(sum(map(s, zip(g(), g()))))", "import sys\ninput = sys.stdin.readline\n\ndef solve(x, y):\n    (n, m, ans) = (len(x), len(y), 0)\n    (already, i, j) = ([0 for _ in range(n + 1)], 0, m - 1)\n    for i in range(n - 1, -1, -1):\n        already[i] = already[i + 1]\n        while j >= 0 and y[j] > x[i]:\n            j -= 1\n        if j >= 0 and y[j] == x[i]:\n            already[i] += 1\n    j = 0\n    for k in range(m):\n        while j < n and x[j] <= y[k] + j:\n            j += 1\n        while i < m and y[i] - y[k] < j:\n            i += 1\n        ans = max(ans, i - k + already[j])\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    (initial, special) = ([int(i) for i in input().split()], [int(i) for i in input().split()])\n    (initial_left, initial_right) = ([-initial[i] for i in range(n) if initial[i] < 0][::-1], [initial[i] for i in range(n) if initial[i] > 0])\n    (special_left, special_right) = ([-special[i] for i in range(m) if special[i] < 0][::-1], [special[i] for i in range(m) if special[i] > 0])\n    print(solve(initial_left, special_left) + solve(initial_right, special_right))", "from bisect import *\nl = bisect_left\nr = range\n\ndef s(A, B):\n    S = set(A)\n    b = len(B)\n    C = [0] * (b + 1)\n    for i in r(b - 1, -1, -1):\n        if B[i] in S:\n            C[i] += 1\n        C[i] += C[i + 1]\n    a = C[0]\n    X = 0\n    for i in r(b):\n        while X < len(A) and A[X] <= B[i]:\n            X += 1\n        if X > 0:\n            a = max(a, l(B, B[i]) - l(B, B[i] - X + 1) + 1 + C[i + 1])\n    return a\np = lambda : map(int, input().split())\nfor t in r(*p()):\n    p()\n    A = []\n    X = []\n    B = []\n    Y = []\n    for v in p():\n        if v < 0:\n            A += (-v,)\n        else:\n            B += (v,)\n    for w in p():\n        if w < 0:\n            X += (-w,)\n        else:\n            Y += (w,)\n    print(s(A[::-1], X[::-1]) + s(B, Y))", "import sys\ninput = sys.stdin.readline\n\ndef solve(x, y):\n    (n, m, ans) = (len(x), len(y), 0)\n    (already, i, j) = ([0 for _ in range(n + 1)], 0, m - 1)\n    for i in range(n - 1, -1, -1):\n        already[i] = already[i + 1]\n        while j >= 0 and y[j] > x[i]:\n            j -= 1\n        if j >= 0 and y[j] == x[i]:\n            already[i] += 1\n    j = 0\n    for k in range(m):\n        while j < n and x[j] <= y[k] + j:\n            j += 1\n        while i < m and y[i] - y[k] < j:\n            i += 1\n        ans = max(ans, i - k + already[j])\n    return ans\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    (initial, special) = ([int(i) for i in input().split()], [int(i) for i in input().split()])\n    (initial_left, initial_right) = ([-initial[i] for i in range(n) if initial[i] < 0][::-1], [initial[i] for i in range(n) if initial[i] > 0])\n    (special_left, special_right) = ([-special[i] for i in range(m) if special[i] < 0][::-1], [special[i] for i in range(m) if special[i] > 0])\n    print(solve(initial_left, special_left) + solve(initial_right, special_right))", "from bisect import *\nl = bisect_left\nr = range\n\ndef s(a):\n    (A, B) = a\n    S = set(A)\n    b = len(B)\n    C = [0] * (b + 1)\n    for i in r(b - 1, -1, -1):\n        if B[i] in S:\n            C[i] += 1\n        C[i] += C[i + 1]\n    a = C[0]\n    X = 0\n    for i in r(b):\n        while X < len(A) and A[X] <= B[i]:\n            X += 1\n        if X > 0:\n            a = max(a, l(B, B[i]) - l(B, B[i] - X + 1) + 1 + C[i + 1])\n    return a\n\ndef g():\n    A = []\n    B = []\n    for v in p():\n        if v < 0:\n            A += (-v,)\n        else:\n            B += (v,)\n    return (A[::-1], B)\np = lambda : map(int, input().split())\nfor t in r(*p()):\n    p()\n    print(sum(map(s, zip(g(), g()))))", "from bisect import *\nl = bisect_left\nr = range\n\ndef s(A, B):\n    S = set(A)\n    b = len(B)\n    C = [0] * (b + 1)\n    for i in r(b - 1, -1, -1):\n        if B[i] in S:\n            C[i] += 1\n        C[i] += C[i + 1]\n    a = C[0]\n    X = 0\n    for i in r(b):\n        while X < len(A) and A[X] <= B[i]:\n            X += 1\n        if X > 0:\n            a = max(a, l(B, B[i]) - l(B, B[i] - X + 1) + 1 + C[i + 1])\n    return a\np = lambda : map(int, input().split())\n(T,) = p()\nwhile T:\n    T -= 1\n    p()\n    A = []\n    X = []\n    B = []\n    Y = []\n    for v in p():\n        if v < 0:\n            A += (-v,)\n        else:\n            B += (v,)\n    for w in p():\n        if w < 0:\n            X += (-w,)\n        else:\n            Y += (w,)\n    print(s(A[::-1], X[::-1]) + s(B, Y))"]