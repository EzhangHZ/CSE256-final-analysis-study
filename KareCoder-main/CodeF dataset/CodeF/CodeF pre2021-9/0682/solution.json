["inf = 10 ** 16\nn = int(input())\naa = list(map(int, input().split()))\nans = inf\nif n > 70:\n    print(1)\n    exit()\nfor i in range(1, n - 1):\n    ll = []\n    mx = -inf\n    x = 0\n    for j in range(i - 1, -1, -1):\n        x ^= aa[j]\n        if x > mx:\n            mx = x\n            ll.append((x, i - 1 - j))\n    rr = []\n    mn = inf\n    x = 0\n    for j in range(i, n):\n        x ^= aa[j]\n        if x < mn:\n            mn = x\n            rr.append((x, j - i))\n    j = 0\n    for (x, c) in ll[::-1]:\n        while j < len(rr) and rr[j][0] >= x:\n            j += 1\n        if j == len(rr):\n            break\n        cur = c + rr[j][1]\n        ans = min(ans, cur)\nprint(-1) if ans == inf else print(ans)", "n = int(input())\na = list(map(int, input().split()))\nres = -1\nxor_a = [0]\nfor i in range(n):\n    xor_a.append(a[i] ^ xor_a[-1])\n(step, i) = (1, 0)\nwhile step < n - 1:\n    i = 0\n    while i < n:\n        for x in range(step + 1):\n            if step + 1 + i - x + 1 <= n and i - x >= 0:\n                if xor_a[i - x] ^ xor_a[i + 1] > xor_a[1 + i] ^ xor_a[1 + i + step - x + 1]:\n                    res = step\n                    i = n\n                    step = n\n        i += 1\n    step += 1\nprint(res)", "import sys\nimport math, bisect, operator\n(inf, m) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\n\ndef solve(case):\n    n = I()\n    a = Neo()\n    pre = [0] * (n + 1)\n    for i in range(n):\n        pre[i] = pre[i - 1] ^ a[i]\n    if n > 60:\n        print(1)\n        return\n    ans = inf\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            for k in range(i, j):\n                left = pre[k] ^ pre[i - 1]\n                right = pre[j] ^ pre[k]\n                if right < left:\n                    ans = min(ans, j - i - 1)\n    print(ans if ans != inf else -1)\nsolve(1)", "import sys\n\ndef left(n):\n    i = -1\n    while n > 0:\n        i += 1\n        n //= 2\n    return i\nn = int(input())\narr = list(map(int, input().split()))\ni1 = 0\nwhile i1 + 2 < n:\n    i2 = i1 + 1\n    i3 = i1 + 2\n    if left(arr[i1]) == left(arr[i2]) and left(arr[i1]) == left(arr[i3]):\n        print(1)\n        sys.exit()\n    i1 += 1\n\ndef tong(l, r):\n    res = 0\n    for i in range(l, r + 1):\n        res ^= arr[i]\n    return res\nkq = 10 ** 12\nfor a in range(n):\n    for b in range(a, n):\n        c = b + 1\n        for d in range(c, n):\n            t1 = tong(a, b)\n            t2 = tong(c, d)\n            if t1 > t2:\n                kq = min(kq, b - a + 1 - 1 + (d - c + 1) - 1)\nprint(-1 if kq == 10 ** 12 else kq)", "from sys import stdin\nfrom collections import deque\nimport math\n\ndef mxb(n):\n    k = int(math.log(n, 2))\n    return 2 ** k\nn = int(stdin.readline().strip())\ns = list(map(int, stdin.readline().strip().split()))\nmx = [mxb(i) for i in s]\nfor i in range(2, n):\n    if mx[i] == mx[i - 1] and mx[i - 1] == mx[i - 2]:\n        print(1)\n        exit(0)\nlast = -100\nans = 100000000000\nfor i in range(n):\n    if i > 0:\n        last = s[i - 1]\n    xor = s[i]\n    for j in range(i + 1, n):\n        xor = xor ^ s[j]\n        if xor < last:\n            ans = min(ans, j - i)\n        if j != n - 1 and xor > s[j + 1]:\n            ans = min(ans, j - i)\n        if j == n - 1:\n            continue\n        c = 1\n        xor1 = s[j + 1]\n        for k in range(j + 2, n):\n            xor1 = xor1 ^ s[k]\n            if xor > xor1:\n                ans = min(ans, j - i + c)\n            c += 1\nif ans != 100000000000:\n    print(ans)\nelse:\n    print(-1)", "input()\nv = list(map(lambda x: int(x), input().split()))\n\ndef ok(x):\n    print(x)\n    raise SystemExit\nif len(v) == 2:\n    ok(-1)\n\ndef absolute(x):\n    q = 0\n    while x != 0:\n        x >>= 1\n        q += 1\n    return q\n\ndef xor(v, y, x):\n    q = 0\n    y = max(0, y)\n    for i in range(y, x + 1):\n        q ^= v[i]\n    return q\nfor i in range(2, len(v)):\n    if absolute(v[i - 2]) == absolute(v[i - 1]) == absolute(v[i]):\n        ok(1)\nq = 10000000000.0\nfor a in range(0, len(v) - 1):\n    for b in range(a, len(v)):\n        c = b + 1\n        for d in range(c, len(v)):\n            if xor(v, a, b) > xor(v, c, d):\n                if q > b - a + (d - c):\n                    q = b - a + (d - c)\nif q != 10000000000.0:\n    ok(q)\nelse:\n    ok(-1)"]