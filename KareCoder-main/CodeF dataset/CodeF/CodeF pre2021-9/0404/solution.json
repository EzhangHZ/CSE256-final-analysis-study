["def task():\n    (n, m, x) = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    d = sorted(range(n), key=lambda t: s[t])\n    ans = [0] * n\n    print('YES')\n    a = 0\n    for i in d:\n        ans[i] = a + 1\n        a = (a + 1) % m\n    print(' '.join([str(x) for x in ans]))\nfor _ in range(int(input())):\n    task()", "def read():\n    number = eval(input())\n    return number\n\ndef gets():\n    s = input()\n    return s\n\ndef cout(x):\n    print(x)\n\ndef main():\n    T = eval(input())\n    while T:\n        T = T - 1\n        (n, m, x) = map(int, input().split())\n        k = list(map(int, input().split()))\n        dj = sorted(range(n), key=lambda i: k[i])\n        ans = [0] * n\n        cnt = 0\n        for i in dj:\n            ans[i] = cnt + 1\n            cnt = (cnt + 1) % m\n        cout('YES')\n        print(*ans)\nmain()", "for _ in range(int(input())):\n    (n, m, x) = [int(x) for x in input().split()]\n    h = [int(x) for x in input().split()]\n    idx = sorted(range(n), key=lambda i: h[i])\n    ans = [0] * n\n    count = 0\n    for i in idx:\n        ans[i] = count + 1\n        count = (count + 1) % m\n    print('YES')\n    print(*ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    ans = [0] * n\n    lst = sorted(range(n), key=lst.__getitem__)\n    count = 1\n    for i in range(n):\n        if count > m:\n            count = 1\n        ans[lst[i]] = count\n        count += 1\n    print('YES')\n    print(*ans)", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    order = sorted(range(n), key=lambda i: -a[i])\n    ans = [0] * n\n    cur = 0\n    for i in order:\n        ans[i] = cur + 1\n        cur = (cur + 1) % m\n    print('YES')\n    print(*ans)", "from math import gcd\nfrom collections import defaultdict as dd\nimport heapq\nMOD = 10 ** 9 + 7\n\ndef R(type=int):\n    line = input().rstrip()\n    try:\n        return type(line)\n    except:\n        pass\n    return line\nRL = lambda type=int: list(map(type, input().rstrip().split()))\nRLL = lambda N, type=int: [RL(type) for _ in range(N)]\nRLS = lambda N, type=int: [R(type) for _ in range(N)]\n\ndef solve():\n    (N, M, X) = RL()\n    H = RL()\n    towers = [(0, i) for i in range(1, M + 1)]\n    res = []\n    for h in H:\n        (height, index) = heapq.heappop(towers)\n        res += [index]\n        heapq.heappush(towers, (height + h, index))\n    print('YES')\n    print(' '.join(map(str, res)))\nT = R()\nfor t in range(T):\n    solve()", "import heapq\n\ndef solve(n, m, x, lst):\n    heap = [(0, i + 1) for i in range(m)]\n    res = [-1] * n\n    for (i, ele) in enumerate(lst):\n        (tower_height, tower_index) = heapq.heappop(heap)\n        tower_height += ele\n        heapq.heappush(heap, (tower_height, tower_index))\n        res[i] = tower_index\n    print('YES')\n    return ' '.join(map(str, res))\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    print(solve(n, m, x, lst))", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = [*map(int, input().split())]\n    s = sorted(range(n), key=lambda i: a[i])\n    ans = [0] * n\n    c = 0\n    for i in s:\n        ans[i] = c + 1\n        c = (c + 1) % m\n    print('YES')\n    print(*ans)", "import sys\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_list_string():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_print_int(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef get_print(x):\n    sys.stdout.write(x + '\\n')\n\ndef get_print_int_same(x):\n    sys.stdout.write(str(x) + ' ')\n\ndef get_print_same(x):\n    sys.stdout.write(x + ' ')\nfrom sys import maxsize\n\ndef solve():\n    for _ in range(get_int()):\n        (n, m, x) = get_ints()\n        h = get_list()\n        data = []\n        for i in range(n):\n            data.append([h[i], i])\n        data.sort()\n        ans = [0] * n\n        for i in range(n):\n            ans[data[i][1]] = i % m + 1\n        get_print('YES')\n        get_print(' '.join(map(str, ans)))\nsolve()", "from heapq import heappop, heappush, heapify\nt = int(input())\nfor tt in range(t):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    h = [[a[r], r + 1] for r in range(m)]\n    print('YES')\n    print(' '.join([str(i + 1) for i in range(m)]), end=' ')\n    heapify(h)\n    for j in range(m, n):\n        o = heappop(h)\n        o[0] += a[j]\n        print(o[1], end=' ')\n        heappush(h, o)\n    print()", "import math\nimport heapq as hq\n\ndef main():\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    tower_set = [(0, i) for i in range(m)]\n    hq.heapify(tower_set)\n    order = [0] * n\n    for i in range(n):\n        tower = hq.heappop(tower_set)\n        h = a[i] + tower[0]\n        order[i] = tower[1] + 1\n        hq.heappush(tower_set, (h, tower[1]))\n    print('YES')\n    print(' '.join(map(str, order)))\nt = int(input())\nfor i in range(t):\n    main()", "for iii in range(int(input())):\n\n    def solution(n, m, x, s):\n        e = sorted([(s[i], i) for i in range(n)])\n        d = [0 for i in range(n)]\n        j = f = 1\n        for i in range(n - 1, -1, -1):\n            if j > m and f:\n                j = 1\n                f = 0\n            elif j > m:\n                j = 1\n                f = 1\n            if f:\n                d[e[i][1]] = j\n            else:\n                d[e[i][1]] = m - j + 1\n            j += 1\n        return d\n    (n, m, x) = map(int, input().split())\n    s = list(map(int, input().split()))\n    print('YES')\n    print(*solution(n, m, x, s))", "import heapq\nT = int(input())\nfor _ in range(T):\n    (n, m, x) = [int(x) for x in input().split()]\n    h = [int(x) for x in input().split()]\n    result = []\n    q = []\n    for i in range(1, m + 1):\n        heapq.heappush(q, (0, i))\n    for el in h:\n        t = heapq.heappop(q)\n        result += [str(t[1])]\n        heapq.heappush(q, (t[0] + el, t[1]))\n    print('YES')\n    print(' '.join(result))", "t = int(input())\nfor i in range(t):\n    (n, m, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ans = [0 for j in range(n)]\n    ind = []\n    for i in range(n):\n        ind.append([i, arr[i]])\n    ind.sort(key=lambda x: x[1])\n    print('YES')\n    for i in range(n):\n        if (i + 1) % m == 0:\n            ans[ind[i][0]] = m\n        else:\n            ans[ind[i][0]] = (i + 1) % m\n    print(*ans)", "from bisect import insort\nfrom array import array\nfor _ in range(int(input())):\n    (N, M, X) = map(int, input().split())\n    blocks_heights = map(int, input().split())\n    if N < M:\n        print('NO')\n        continue\n    print('YES')\n    towers = {}\n    smallest_height = 0\n    heights = array('i')\n    smallest_towers = towers[0] = list(range(1, M + 1))\n    blocks_positions = []\n    for block_height in blocks_heights:\n        smallest_tower_index = smallest_towers.pop()\n        blocks_positions.append(smallest_tower_index)\n        new_tower_height = smallest_height + block_height\n        if new_tower_height not in towers:\n            insort(heights, -new_tower_height)\n            towers[new_tower_height] = [smallest_tower_index]\n        else:\n            towers[new_tower_height].append(smallest_tower_index)\n        if not smallest_towers:\n            del towers[smallest_height]\n            smallest_height = -heights.pop()\n            smallest_towers = towers[smallest_height]\n    print(*blocks_positions)", "from bisect import insort\nfrom array import array\nfor _ in range(int(input())):\n    (N, M, X) = map(int, input().split())\n    blocks_heights = map(int, input().split())\n    if N < M:\n        print('NO')\n        continue\n    print('YES')\n    towers = {}\n    smallest_height = 0\n    heights = array('i')\n    smallest_towers = towers[0] = array('i', range(1, M + 1))\n    blocks_positions = []\n    for block_height in blocks_heights:\n        smallest_tower_index = smallest_towers.pop()\n        blocks_positions.append(smallest_tower_index)\n        new_tower_height = smallest_height + block_height\n        if new_tower_height not in towers:\n            insort(heights, -new_tower_height)\n            towers[new_tower_height] = array('i', [smallest_tower_index])\n        else:\n            towers[new_tower_height].append(smallest_tower_index)\n        if not smallest_towers:\n            del towers[smallest_height]\n            smallest_height = -heights.pop()\n            smallest_towers = towers[smallest_height]\n    print(*blocks_positions)", "for i in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    res = sorted([(a[i], i) for i in range(n)])\n    ans = [0] * n\n    for i in range(n):\n        ans[res[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "import heapq\n\ndef solve():\n    (n, m, x) = map(int, input().split())\n    heights = list(map(int, input().split()))\n    heap = [(0, i + 1) for i in range(m)]\n    res = [-1] * n\n    for (i, h) in enumerate(heights):\n        (tower_height, idx) = heapq.heappop(heap)\n        tower_height += h\n        heapq.heappush(heap, (tower_height, idx))\n        res[i] = idx\n    print('YES')\n    print(*res)\nt = int(input())\nfor _ in range(t):\n    solve()", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nlim = mod * mod\nsys.setrecursionlimit(depth)\nfrom math import inf, ceil, sqrt\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    if n < m:\n        print('NO')\n        continue\n    print('YES')\n    d = [[a[i], i + 1] for i in range(n)]\n    d.sort(key=lambda x: x[0], reverse=True)\n    ans = [-1 for _ in range(n)]\n    for i in range(n):\n        ans[d[i][1] - 1] = i % m + 1\n    print(*ans)", "from math import ceil\nimport sys\nfrom collections import defaultdict\n\ndef solve():\n    for i in range(n):\n        arr[i] = (arr[i], i)\n    arr.sort()\n    ans = [0 for i in range(m)]\n    res = [0 for i in range(n)]\n    for i in range(n):\n        ans[i % m] += arr[i][0]\n        res[arr[i][1]] = i % m + 1\n    for i in range(1, m):\n        if abs(ans[i] - ans[i - 1]) > x:\n            print('NO', flush=True)\n            return None\n    print('YES')\n    print(' '.join(map(str, res)))\n    return None\nT = int(input())\nfor t in range(1, T + 1):\n    (n, m, x) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    solve()", "n = int(input())\nfor i in range(n):\n    (n, m, x) = map(int, input().split())\n    s = list(map(int, input().split()))\n    li = []\n    for i in range(len(s)):\n        li.append([s[i], i])\n    li.sort()\n    sort_index = []\n    for x in li:\n        sort_index.append(x[1])\n    Ans = [0] * n\n    cnt = -1\n    for j in sort_index:\n        cnt += 1\n        Ans[j] = cnt % m + 1\n    print('YES')\n    print(' '.join((str(i) for i in Ans)))", "for i in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    res = []\n    ans = [0] * n\n    for i in range(n):\n        res.append((a[i], i))\n    res.sort()\n    for i in range(n):\n        ans[res[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = sorted(zip(map(int, input().split()), [i for i in range(n)]))\n    loc = [0] * n\n    for i in range(n):\n        loc[a[i][1]] = i % m + 1\n    print('YES')\n    print(*loc)", "from sys import stdin\nfrom heapq import *\ninput = stdin.readline\n\ndef solve():\n    (n, m, x) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    arr = [[0, i] for i in range(1, m + 1)]\n    ans = [0] * n\n    if m == 1:\n        print('YES')\n        return [1] * n\n    for (ind, el) in enumerate(lst):\n        temp = heappop(arr)\n        temp[0] += el\n        ans[ind] = temp[1]\n        heappush(arr, temp)\n    print('YES')\n    return ans\nfor test in range(int(input())):\n    print(*solve())", "import heapq\n\ndef solve():\n    (n, m, x) = map(int, input().split())\n    heights = list(map(int, input().split()))\n    heap = [(0, i + 1) for i in range(m)]\n    res = [-1] * n\n    for (i, h) in enumerate(heights):\n        (tower_height, idx) = heapq.heappop(heap)\n        tower_height += h\n        heapq.heappush(heap, (tower_height, idx))\n        res[i] = idx\n    print('YES')\n    print(*res)\nt = int(input())\nfor _ in range(t):\n    solve()", "import heapq\n\ndef solve():\n    (n, m, x) = map(int, input().split())\n    heights = list(map(int, input().split()))\n    heap = [(0, i + 1) for i in range(m)]\n    res = [-1] * n\n    for (i, h) in enumerate(heights):\n        (tower_height, idx) = heapq.heappop(heap)\n        tower_height += h\n        heapq.heappush(heap, (tower_height, idx))\n        res[i] = idx\n    print('YES')\n    print(*res)\nt = int(input())\nfor _ in range(t):\n    solve()", "R = lambda : list(map(int, input().split()))\n(t,) = R()\nfor _ in range(t):\n    (n, m, x) = R()\n    h = R()\n    h = [(h[i], i) for i in range(n)]\n    h.sort()\n    ans = [0] * n\n    for i in range(n):\n        ans[h[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = defaultdict(list)\n    for i in range(n):\n        d[a[i]].append(i)\n    ans = [0] * m\n    fans = [0] * n\n    a.sort()\n    r = 0\n    for i in sorted(d.keys()):\n        for j in range(len(d[i])):\n            if r == m:\n                r = 0\n            ans[r] += i\n            fans[d[i][j]] = r + 1\n            r += 1\n    if max(ans) - min(ans) > k:\n        print('NO')\n    else:\n        print('YES')\n        print(*fans)", "def mapit():\n    temp = list(map(int, input().split()))\n    return temp\nimport heapq\n\ndef solution():\n    (n, m, x) = mapit()\n    arr = mapit()\n    res = [0] * n\n    heap = [(0, i + 1) for i in range(m)]\n    for i in range(n):\n        (tow, idx) = heapq.heappop(heap)\n        tow += arr[i]\n        res[i] = idx\n        heapq.heappush(heap, (tow, idx))\n    print('YES')\n    print(*res)\n    return\nt = int(input())\nwhile t:\n    t -= 1\n    solution()", "from sys import stdin\nfrom heapq import *\ninput = stdin.readline\n\ndef solve():\n    (n, m, x) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    arr = [[0, i] for i in range(1, m + 1)]\n    ans = [0] * n\n    print('YES')\n    if m == 1:\n        return [1] * n\n    for (ind, el) in enumerate(lst):\n        temp = heappop(arr)\n        temp[0] += el\n        ans[ind] = temp[1]\n        heappush(arr, temp)\n    return ans\nfor test in range(int(input())):\n    print(*solve())", "import heapq\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    zoop = list(map(int, input().split()))\n    kk = [(0, i) for i in range(m)]\n    ans = [0] * n\n    j = n - 1\n    while zoop:\n        el = zoop.pop()\n        (a, ind) = heapq.heappop(kk)\n        heapq.heappush(kk, (a + el, ind))\n        ans[j] = ind + 1\n        j -= 1\n    print('YES')\n    print(*ans)", "from collections import defaultdict\nfrom bisect import insort\nfor _ in range(int(input())):\n    (N, M, X) = map(int, input().split())\n    blocks_heights = map(int, input().split())\n    if N < M:\n        print('NO')\n        continue\n    print('YES')\n    towers = defaultdict(list)\n    smallest_height = 0\n    heights = []\n    smallest_towers = towers[0] = list(range(1, M + 1))\n    blocks_positions = []\n    for block_height in blocks_heights:\n        smallest_tower_index = smallest_towers.pop()\n        blocks_positions.append(smallest_tower_index)\n        new_tower_height = smallest_height + block_height\n        if new_tower_height not in towers:\n            insort(heights, -new_tower_height)\n        towers[new_tower_height] = towers_indices = towers[new_tower_height]\n        towers_indices.append(smallest_tower_index)\n        if not smallest_towers:\n            smallest_height = -heights.pop()\n            smallest_towers = towers[smallest_height]\n    print(*blocks_positions)", "from math import ceil, floor, log\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split(' '))\n    arr = [int(w) for w in input().split(' ')]\n    p = []\n    for i in range(n):\n        p.append([i, arr[i]])\n    p.sort(key=lambda x: x[1])\n    curr = 0\n    res = [0] * n\n    for item in p:\n        res[item[0]] = curr % m + 1\n        curr = curr + 1\n    print('YES')\n    for item in res:\n        print(item, end=' ')\n    print('')", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    l = []\n    j = 1\n    for i in h:\n        l.append([j, i])\n        j += 1\n    l.sort(key=lambda x: x[1])\n    j = 0\n    for k in l:\n        k[1] = j % m + 1\n        j += 1\n    l.sort(key=lambda x: x[0])\n    print('YES')\n    print(*(i[1] for i in l))", "from collections import Counter\nimport collections\nimport heapq\n\ndef process(case, n, m, x, arr):\n    h = [(0, i) for i in range(1, m + 1)]\n    heapq.heapify(h)\n    res = []\n    for v in arr:\n        (height, idx) = heapq.heappop(h)\n        height += v\n        res.append(idx)\n        heapq.heappush(h, (height, idx))\n    print('YES')\n    print(*res)\ntcs = int(input())\nfor tc in range(tcs):\n    (n, m, x) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    process(tc + 1, n, m, x, arr)", "for _ in range(int(input())):\n    (n, m, x) = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    print('YES')\n    (a, an, p) = ([], [0] * n, 0)\n    for i in range(n):\n        a.append([l[i], i])\n    a.sort()\n    for i in range(n):\n        an[a[i][1]] = p + 1\n        p = (p + 1) % m\n    print(*an)", "import heapq\nT = int(input())\nfor testcase in range(1, T + 1):\n    (n, m, x) = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    heap = []\n    for i in range(m):\n        heapq.heappush(heap, (0, i + 1))\n    res = []\n    for height in h:\n        min = heapq.heappop(heap)\n        res.append(min[1])\n        heapq.heappush(heap, (min[0] + height, min[1]))\n    min = heapq.heappop(heap)\n    if min[0] > 0:\n        print('YES')\n        print(*res)\n    else:\n        print('NO')", "import heapq\n\ndef solve(H, n, m, x):\n    result = [0] * n\n    pq = [(0, i + 1) for i in range(m)]\n    heapq.heapify(pq)\n    for i in range(n):\n        (th, ti) = heapq.heappop(pq)\n        th += H[i]\n        result[i] = ti\n        heapq.heappush(pq, (th, ti))\n    return (True, result)\nt = int(input())\nfor tc in range(t):\n    (n, m, x) = map(int, input().split())\n    H = list(map(int, input().split()))\n    result = solve(H, n, m, x)\n    if result is not False:\n        print('YES')\n        print(*result[1])\n    else:\n        print('NO')", "import heapq\nfor i in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    heap = []\n    for j in range(m):\n        heap.append((0, j))\n    for j in range(n):\n        c = heapq.heappop(heap)\n        heapq.heappush(heap, (c[0] + a[j], c[1]))\n        a[j] = c[1] + 1\n    print('YES')\n    print(*a)", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    l = []\n    j = 0\n    for i in h:\n        l.append([j, i])\n        j += 1\n    l.sort(key=lambda x: x[1])\n    j = 0\n    for k in l:\n        k[1] = j % m + 1\n        j += 1\n    l.sort(key=lambda x: x[0])\n    print('YES')\n    print(*(i[1] for i in l))", "import heapq\nfor _ in range(int(input())):\n    (n, m, x) = [int(i) for i in input().split()]\n    h = [int(i) for i in input().split()]\n    res = []\n    towers = [(0, i) for i in range(1, m + 1)]\n    heapq.heapify(towers)\n    for (index, height) in enumerate(h):\n        (h, i) = heapq.heappop(towers)\n        res.append(i)\n        heapq.heappush(towers, (height + h, i))\n    print('YES')\n    print(*res)", "import sys\nimport math\nfrom bisect import bisect_left\nfrom collections import Counter, defaultdict\nL = lambda : list(map(int, input().split()))\nI = lambda : int(input())\nS = lambda : input()\nmod = 10 ** 9 + 7\n\ndef solve():\n    (n, m, z) = L()\n    a = L()\n    a = [(a[i], i) for i in range(n)]\n    h = [0] * m\n    ans = [0] * n\n    a.sort()\n    j = n - 1\n    c = 0\n    t = 1\n    while n > c:\n        if t == 0:\n            for x in range(m - 1, -1, -1):\n                h[x] += a[j][0]\n                ans[a[j][1]] = x + 1\n                j -= 1\n                c += 1\n                if c == n:\n                    break\n            t = 1\n        elif t == 1:\n            for x in range(m):\n                h[x] += a[j][0]\n                ans[a[j][1]] = x + 1\n                j -= 1\n                c += 1\n                if c == n:\n                    break\n            t = 0\n    if abs(max(h) - min(h)) > z:\n        print('NO')\n        return\n    print('YES')\n    print(*ans)\nfor _ in range(I()):\n    solve()", "def solve(A, n, m, x):\n    li = [(it, i) for (i, it) in enumerate(A)]\n    li.sort()\n    ans = [-1] * n\n    oc = 0\n    while li:\n        t = []\n        if oc % 2:\n            t = li[:m]\n            li = li[m:]\n        else:\n            for i in range(min(m, len(li))):\n                t.append(li.pop())\n        for (i, (v, ind)) in enumerate(t):\n            ans[ind] = i + 1\n    print('YES')\n    print(*ans)\nfor case in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    A = list(map(int, input().split()))\n    solve(A, n, m, x)", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    A = list(map(int, input().split()))\n    ans = [0] * m\n    s = []\n    for i in range(n):\n        s.append((A[i], i))\n    s.sort(key=lambda x: (x[0], x[1]))\n    j = 0\n    for i in range(n):\n        ans[j] += s[i][0]\n        j = (j + 1) % m\n    if max(ans) - min(ans) > x:\n        print('NO')\n    else:\n        print('YES')\n        out = [0] * n\n        j = 1\n        for i in range(n):\n            if j == m + 1:\n                j = 1\n            out[s[i][1]] = j\n            j += 1\n        print(*out)", "import heapq\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    tower = [[0, i] for i in range(m)]\n    heapq.heapify(tower)\n    res = [0] * n\n    for j in range(n):\n        (height, idx) = heapq.heappop(tower)\n        height += h[j]\n        res[j] = idx + 1\n        heapq.heappush(tower, [height, idx])\n    if abs(tower[0][0] - tower[-1][0]) <= x:\n        print('YES')\n        print(*res)\n    else:\n        print('NO')", "def solve():\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    i = 0\n    b = [0] * m\n    ind = [-1] * n\n    hai = [(h[i], i) for i in range(n)]\n    hai.sort(key=lambda z: z[0])\n    i = 0\n    j = 0\n    while j < n:\n        while b[i] <= b[(i + 1) % m]:\n            b[i] += hai[j][0]\n            ind[hai[j][1]] = i + 1\n            j += 1\n            if j >= n:\n                break\n        i += 1\n        i %= m\n    for i in range(1, m):\n        if b[i] - b[i - 1] > x:\n            print('NO')\n            return\n    print('YES')\n    for i in range(n):\n        print(ind[i], end=' ')\n    print()\n\ndef main():\n    for _ in range(int(input())):\n        solve()\nmain()", "for u in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = [int(w) for w in input().split()]\n    ans = [0] * n\n    y = [[h[i], i] for i in range(n)]\n    y = sorted(y)\n    print('YES')\n    for i in range(n):\n        ans[y[i][1]] = i % m + 1\n    print(*ans)", "for t in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    lis = list(map(int, input().split()))\n    mls = [(0, i) for i in range(m)]\n    import heapq\n    print('YES')\n    for i in range(n):\n        pop = heapq.heappop(mls)\n        (mn, ind) = pop\n        print(ind + 1, end=' ')\n        mn += lis[i]\n        heapq.heappush(mls, (mn, ind))\n    print()", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [[a[i], i] for i in range(n)]\n    b.sort()\n    b.reverse()\n    res = [0] * n\n    c = 0\n    for i in range(n):\n        k = b[i][1]\n        res[k] = c % m + 1\n        c += 1\n    print('YES')\n    print(*res)", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    new = []\n    for i in range(n):\n        new.append([arr[i], i])\n    new.sort(reverse=True)\n    res = [0] * n\n    for i in range(0, n, 2 * m):\n        c = 0\n        while i + c < n and c < m:\n            res[new[i + c][1]] = c + 1\n            c += 1\n    for i in range(m, n, 2 * m):\n        c = 0\n        while i + c < n and c < m:\n            res[new[i + c][1]] = m - c\n            c += 1\n    print('YES')\n    print(*res)", "import sys, os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    temp = []\n    ans = []\n    for i in range(n):\n        temp.append([h[i], i])\n        ans.append(0)\n    temp.sort()\n    for i in range(n):\n        k = i % m + 1\n        ans[temp[i][1]] = k\n    print('YES')\n    print(*ans)", "from collections import defaultdict\nimport heapq\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = [int(i) for i in input().split()]\n    heap = []\n    for order_num in range(1, m + 1):\n        heapq.heappush(heap, [0, order_num])\n    towers = []\n    for (ind, h_i) in enumerate(h):\n        pair = heapq.heappop(heap)\n        towers.append(pair[1])\n        pair[0] += h_i\n        heapq.heappush(heap, pair)\n    print('YES')\n    print(*towers)", "t = int(input())\nfor i in range(t):\n    a = [int(x) for x in input().split()]\n    n = a[0]\n    m = a[1]\n    x = a[2]\n    a = [int(x) for x in input().split()]\n    bl = []\n    for ind in range(len(a)):\n        bl.append((a[ind], ind))\n    bl.sort()\n    to = []\n    for ind in range(len(bl)):\n        eff = ind % m\n        if len(to) - 1 < eff:\n            to.append([bl[ind]])\n        else:\n            to[eff].append(bl[ind])\n    su = []\n    res = [-1 for x in range(n)]\n    ind = 1\n    for el in to:\n        summ = 0\n        for k in el:\n            summ += k[0]\n            res[k[1]] = str(ind)\n        su.append(summ)\n        ind += 1\n    minn = min(su)\n    maxx = max(su)\n    if maxx - minn > x:\n        print('NO')\n    else:\n        print('YES')\n        print(' '.join(res))", "from sys import stdin, stdout\nimport math\nimport heapq\n\ndef ii():\n    return int(stdin.readline())\n\ndef mi():\n    return map(int, stdin.readline().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return stdin.readline()\nfor _ in range(ii()):\n    (n, m, x) = mi()\n    l1 = li()\n    ans = [0] * n\n    heapp = [[0, x] for x in range(1, m + 1)]\n    heapq.heapify(heapp)\n    for i in range(n):\n        node = heapq.heappop(heapp)\n        ans[i] = node[1]\n        node[0] += l1[i]\n        heapq.heappush(heapp, node)\n    print('YES')\n    print(*ans)", "import heapq\ncases = int(input())\nwhile cases:\n    cases -= 1\n    (n, m, x) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    ans = []\n    towers = [(0, i) for i in range(1, m + 1)]\n    heapq.heapify(towers)\n    for (ind, num) in enumerate(arr):\n        (h, i) = heapq.heappop(towers)\n        ans.append(i)\n        heapq.heappush(towers, (num + h, i))\n    print('YES')\n    print(*ans)", "t = int(input())\nfor i in range(t):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    h = []\n    for i in range(n):\n        h.append([a[i], i])\n    h.sort()\n    ans = [0] * n\n    for i in range(n):\n        ans[h[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "import sys\nimport math\nmod = 10 ** 9 + 7\nLI = lambda : [int(k) for k in input().split()]\ninput = lambda : sys.stdin.readline().rstrip()\nIN = lambda : int(input())\nS = lambda : input()\nfor t in range(IN()):\n    (n, m, x) = LI()\n    h = LI()\n    hh = []\n    for i in range(n):\n        hh.append([h[i], i])\n    hh.sort()\n    ans = [0] * n\n    for i in range(n):\n        ans[hh[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "import heapq\n\ndef question3():\n    (N, M, X) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    print('YES')\n    k1 = []\n    for i in range(1, M + 1):\n        k1.append([0, i])\n    heapq.heapify(k1)\n    for i in range(N):\n        read = heapq.heappop(k1)\n        read[0] += arr[i]\n        print(read[1], end=' ')\n        heapq.heappush(k1, read)\nremained_test_cases = int(input())\nwhile remained_test_cases > 0:\n    question3()\n    print()\n    remained_test_cases -= 1", "from heapq import *\n\ndef f(a, m, x):\n    l = [(0, i) for i in range(m)]\n    heapify(l)\n    ans = [None] * len(a)\n    for i in range(len(a)):\n        t = list(heappop(l))\n        t[0] += a[i]\n        ans[i] = t[1] + 1\n        heappush(l, tuple(t))\n    mn = min(l, key=lambda s: s[0])[0]\n    mx = max(l, key=lambda s: s[0])[0]\n    if mx - mn <= x:\n        print('YES')\n        print(*ans)\n        return\n    print('NO')\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().strip().split())\n    l = list(map(int, input().strip().split()))\n    f(l, m, x)", "from heapq import *\n\ndef f(a, m, x):\n    l = [(0, i) for i in range(m)]\n    heapify(l)\n    ans = [None] * len(a)\n    for i in range(len(a)):\n        t = list(heappop(l))\n        t[0] += a[i]\n        ans[i] = t[1] + 1\n        heappush(l, tuple(t))\n    mn = min(l, key=lambda s: s[0])[0]\n    mx = max(l, key=lambda s: s[0])[0]\n    if mx - mn <= x:\n        print('YES')\n        print(*ans)\n        return\n    print('NO')\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().strip().split())\n    l = list(map(int, input().strip().split()))\n    f(l, m, x)", "t = int(input())\nfor _ in range(t):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = [0] * n\n    arr = []\n    for i in range(n):\n        arr.append([a[i], i])\n    arr.sort()\n    for i in range(n):\n        ans[arr[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "import heapq\n\ndef main():\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    h = list(zip(h, range(n)))\n    h.sort(reverse=True)\n    ans = [0] * n\n    q = []\n    max_sum = 0\n    for i in range(m):\n        heapq.heappush(q, (h[i][0], i + 1))\n        ans[h[i][1]] = i + 1\n        max_sum = max(max_sum, h[i][0])\n    for i in range(m, n):\n        (sumh, mi) = heapq.heappop(q)\n        heapq.heappush(q, (sumh + h[i][0], mi))\n        ans[h[i][1]] = mi\n        max_sum = max(max_sum, sumh + h[i][0])\n    if max_sum - q[0][0] > x:\n        print('NO')\n    else:\n        print('YES')\n        print(*ans)\n    return\nt = int(input())\nfor _ in range(t):\n    main()", "import heapq\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    l = [int(x) for x in input().split()]\n    print('YES')\n    heap = []\n    for i in range(m):\n        heap.append([0, i])\n    heapq.heapify(heap)\n    for i in range(n):\n        result = heapq.heappop(heap)\n        print(result[1] + 1, end=' ')\n        result[0] += l[i]\n        heapq.heappush(heap, result)\n    print()", "for _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    ans = [-1] * n\n    h = []\n    tower = [0] * n\n    for i in range(n):\n        h.append((a[i], i))\n    h.sort()\n    for i in range(n):\n        tower[i % m] += h[i][0]\n        ans[h[i][1]] = i % m + 1\n    tower.sort()\n    idx = -1\n    for i in range(n):\n        if tower[i] != 0:\n            idx = i\n            break\n    if tower[i] - tower[idx] > x:\n        print('NO')\n    else:\n        print('YES')\n        for i in ans:\n            print(i, end=' ')\n        print('')", "t = int(input())\nfor i in range(t):\n    (n, m, x) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    lst1 = []\n    for j in range(n):\n        lst1.append((lst[j], j))\n    lst1.sort(key=lambda y: y[0])\n    dic = {}\n    for j in lst1:\n        dic[j] = -1\n    q = n // m\n    ind = 0\n    c = 1\n    for h in range(q * m):\n        dic[lst1[ind]] = c\n        ind += 1\n        c += 1\n        if c > m:\n            c = 1\n    rem = n % m\n    c = 1\n    for h in range(rem):\n        dic[lst1[ind]] = c\n        ind += 1\n        c += 1\n    dic1 = {}\n    for g in range(1, m + 1):\n        dic1[g] = 0\n    for h in dic.keys():\n        dic1[dic[h]] += h[0]\n    ma = -1000000000.0\n    mi = 1000000000.0\n    for h in dic1.values():\n        if h > ma:\n            ma = h\n        if h < mi:\n            mi = h\n    if abs(ma - mi) > x:\n        print('NO')\n    else:\n        print('YES')\n        lst2 = []\n        for h in range(n):\n            lst2.append(0)\n        for k in dic.keys():\n            lst2[k[1]] = dic[k]\n        print(*lst2)", "import heapq\nt = int(input())\nfor case in range(1, t + 1):\n    (n, m, x) = [int(x) for x in input().split(' ')]\n    heights = [int(x) for x in input().split(' ')]\n    sorted_h = sorted(enumerate(heights), key=lambda x: x[1], reverse=True)\n    heap = [(0, i) for i in range(m)]\n    ans = [0] * n\n    for (i, h) in sorted_h:\n        (hh, mm) = heapq.heappop(heap)\n        tow = (hh + h, mm)\n        heapq.heappush(heap, tow)\n        ans[i] = mm + 1\n    if max(heap)[0] - min(heap)[0] > x:\n        print('NO')\n    else:\n        print('YES')\n        print(*ans)", "import heapq\n\ndef solve(amount, diff, arr):\n    blocks = sorted(enumerate(arr), reverse=True, key=lambda x: x[1])\n    towers = [[0, i + 1] for i in range(amount)]\n    res = [0] * len(arr)\n    for (idx, block) in blocks:\n        tower = heapq.heappop(towers)\n        tower[0] += block\n        res[idx] = tower[1]\n        heapq.heappush(towers, tower)\n    return res\nfor _ in '_' * int(input()):\n    (_, amount, diff) = map(int, input().split())\n    result = solve(amount, diff, [*map(int, input().split())])\n    print(['NO', 'YES'][bool(result)])\n    if result != None:\n        print(*result)", "from collections import defaultdict, deque, Counter\nfrom functools import lru_cache, reduce\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_right, bisect_left\nfrom random import randint\nfrom fractions import Fraction as frac\nimport math\nimport operator\nimport sys\nhpop = heappop\nhpush = heappush\nMOD = 10 ** 9 + 7\n\ndef solution():\n    (n, m, x) = map(int, input().split())\n    arr = map(int, input().split())\n    arr = [(val, i) for (i, val) in enumerate(arr)]\n    arr.sort()\n    min_heap = []\n    for tower in range(m):\n        heappush(min_heap, (0, tower))\n    res = [-1] * n\n    for (val, i) in arr:\n        (tower_height, tower) = heappop(min_heap)\n        res[i] = tower + 1\n        heappush(min_heap, (tower_height + val, tower))\n    min_heap.sort(key=lambda x: x[1])\n    for i in range(1, len(min_heap)):\n        if min_heap[i][0] - min_heap[i - 1][0] > x:\n            return print('NO')\n    print('YES')\n    print(*res)\n\ndef main():\n    t = 1\n    t = int(input())\n    for _ in range(t):\n        solution()\nmain()", "import heapq\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    h = []\n    for i in range(n):\n        h.append((a[i], i))\n        a[i] = 0\n    heapq.heapify(h)\n    while h:\n        for i in range(1, m + 1):\n            if h:\n                (ele, idx) = heapq.heappop(h)\n                a[idx] = i\n            else:\n                break\n    print('YES')\n    print(*a)", "for i in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    l = list(map(int, input().split()))\n    pair = [[l[i], i] for i in range(n)]\n    final = [-1] * n\n    pair.sort()\n    towers = [0] * m\n    m1 = 0\n    for j in range(n):\n        if m1 == m:\n            m1 = 0\n        towers[m1] += pair[j][0]\n        final[pair[j][1]] = m1\n        m1 += 1\n    if max(towers) - min(towers) <= x:\n        print('YES')\n        for k in final:\n            print(k + 1, end=' ')\n        print()\n    else:\n        print('NO')", "T = int(input())\nfor t in range(T):\n    (n, m, x) = map(int, input().split())\n    hs = list(map(int, input().split()))\n    hs = [(hs[i], i) for i in range(n)]\n    ord = [0] * n\n    hs.sort()\n    (i, j) = (0, 0)\n    arr = [0] * m\n    while i < n:\n        arr[j] += hs[i][0]\n        if abs(arr[j] - arr[j - 1]) > x:\n            break\n        ord[hs[i][1]] = j + 1\n        j = (j + 1) % m\n        i += 1\n    if i == n:\n        print('YES')\n        for i in ord:\n            print(i, end=' ')\n        print()\n    else:\n        print('NO')", "from heapq import heapify, heappush, heappop\nfrom sys import stdin\n\ndef read_int():\n    return int(stdin.readline())\n\ndef read_ints():\n    return map(int, stdin.readline().split(' '))\nt = read_int()\nfor case_num in range(t):\n    (n, m, x) = read_ints()\n    h = list(read_ints())\n    ans = [0] * n\n    towers = [(0, i) for i in range(1, m + 1)]\n    blocks = [(-h[i], i) for i in range(n)]\n    heapify(blocks)\n    while blocks:\n        (block_height_neg, block_index) = heappop(blocks)\n        block_height = -block_height_neg\n        (tower_height, tower_index) = heappop(towers)\n        ans[block_index] = tower_index\n        heappush(towers, (tower_height + block_height, tower_index))\n    if max(towers)[0] - min(towers)[0] <= x:\n        print('YES')\n        print(' '.join(map(str, ans)))\n    else:\n        print('NO')", "for u in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    h = list(map(int, input().split()))\n    ans = [0] * n\n    y = [[h[i], i] for i in range(n)]\n    y = sorted(y)\n    print('YES')\n    for i in range(n):\n        ans[y[i][1]] = i % m + 1\n    print(*ans)", "def ii():\n    return int(input())\n\ndef li():\n    return [int(i) for i in input().split()]\nfor t in range(ii()):\n    (n, m, x) = li()\n    a = li()\n    h = []\n    for i in range(n):\n        h.append([a[i], i])\n    h.sort()\n    ans = [0 for i in range(n)]\n    for i in range(n):\n        ans[h[i][1]] = i % m + 1\n    print('YES')\n    print(*ans)", "import heapq\nt = int(input())\nfor _ in range(t):\n    (n, m, x) = map(int, input().split())\n    hs = [int(i) for i in input().split()]\n    hs = [(num, i) for (i, num) in enumerate(hs)]\n    q = []\n    heapq.heapify(q)\n    for i in range(m):\n        q.append((0, i + 1))\n    hs.sort()\n    res = [0] * n\n    while hs:\n        (height, tower) = heapq.heappop(q)\n        (h, i) = hs.pop()\n        height += h\n        res[i] = tower\n        heapq.heappush(q, (height, tower))\n    mn = min(q)\n    mx = max(q)\n    if mx[0] - mn[0] > x:\n        ans = 'NO'\n    else:\n        ans = 'YES'\n    print(ans)\n    if ans == 'YES':\n        print(*res)", "import bisect\nimport collections\nimport functools\nimport itertools\nimport math\nimport heapq\nimport random\nimport string\n\ndef repeat(_func=None, *, times=1):\n\n    def decorator(func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                func(*args, **kwargs)\n        return wrapper\n    if _func is None:\n        return decorator\n    else:\n        return decorator(_func)\n\ndef unpack(func=int):\n    return map(func, input().split())\n\ndef l_unpack(func=int):\n    return list(map(func, input().split()))\n\ndef getint():\n    return int(input())\n\ndef getmatrix(rows):\n    return [list(map(int, input().split())) for _ in range(rows)]\n\ndef display_matrix(mat):\n    for i in range(len(mat)):\n        print(mat[i])\n    print('-' * 20)\nMOD = 1000000007\n\n@repeat(times=int(input()))\ndef main():\n    (n, m, x) = unpack()\n    arr = [(ht, i) for (i, ht) in enumerate(unpack())]\n    arr.sort(reverse=True)\n    tower = [(0, i + 1) for i in range(m)]\n    out = [0] * n\n    for (ht, i) in arr:\n        (currht, idx) = tower[0]\n        currht += ht\n        out[i] = idx\n        heapq.heapreplace(tower, (currht, idx))\n    Max = max(tower, key=lambda x: x[0])[0]\n    Min = min(tower, key=lambda x: x[0])[0]\n    if Max - Min > x:\n        print('NO')\n        return\n    print('YES')\n    print(*out)\nmain()", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    (n, m, x) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(n):\n        a[i] = [a[i], i]\n    a.sort()\n    ans = defaultdict(list)\n    for i in range(n):\n        ans[a[i][1]] = i % m\n    print('YES')\n    v = [0] * n\n    for i in range(n):\n        v[i] = ans[i] + 1\n    print(*v)", "from typing import List\nfrom heapq import heappop, heappush\n\ndef solve(n: int, m: int, x: int, h: List[int]) -> None:\n    h = sorted(([h[i], i] for i in range(n)))\n    h.sort()\n    ans = [0] * n\n    heap = []\n    for i in range(1, m + 1):\n        heappush(heap, [0, i])\n    for i in range(n - 1, -1, -1):\n        (val, ind) = h[i]\n        node = heappop(heap)\n        node[0] += val\n        ans[ind] = node[1]\n        heappush(heap, node)\n    if max(heap)[0] - min(heap)[0] > x:\n        print('NO')\n        return\n    ans_str = ''\n    for x in ans:\n        ans_str += str(x) + ' '\n    print('YES')\n    print(ans_str)\n    return\ntest_cases = int(input())\nfor _ in range(test_cases):\n    (n, m, x) = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    solve(n, m, x, h)", "import heapq\nfor _ in range(int(input())):\n    (n, m, x) = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    k = []\n    for i in range(n):\n        k.append([l[i], i])\n    k.sort()\n    h = [[0, i] for i in range(m)]\n    a = [0] * n\n    for i in range(n):\n        (c, d) = heapq.heappop(h)\n        c += k[i][0]\n        a[k[i][1]] = d + 1\n        heapq.heappush(h, [c, d])\n    j = min(h, key=lambda s: s[0])[0]\n    o = max(h, key=lambda s: s[0])[0]\n    if o - j <= c:\n        print('YES')\n        print(' '.join(map(str, a)))\n    else:\n        print('NO')", "import heapq\n\nclass PQNode:\n\n    def __init__(self, key, value) -> None:\n        self.key = key\n        self.value = value\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __str__(self) -> str:\n        return f'{self.key} : {self.value}'\n\ndef solve(n, m, x, lst):\n    heap = [PQNode(i + 1, 0) for i in range(m)]\n    res = [-1] * n\n    for (i, ele) in enumerate(lst):\n        min_tower = heapq.heappop(heap)\n        min_tower.value += ele\n        heapq.heappush(heap, min_tower)\n        res[i] = min_tower.key\n    print('YES')\n    return ' '.join(map(str, res))\nfor _ in range(int(input())):\n    (n, m, x) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    print(solve(n, m, x, lst))", "from math import *\nsInt = lambda : int(input())\nmInt = lambda : map(int, input().split())\nlInt = lambda : list(map(int, input().split()))\n\ndef takeSecond(elem):\n    return elem[1]\nt = sInt()\nfor _ in range(t):\n    (n, m, x) = mInt()\n    a = lInt()\n    b = []\n    for i in range(n):\n        b.append([a[i], i])\n    b.sort(reverse=True)\n    d = 1\n    flag = 1\n    ms = [0 for i in range(m)]\n    for i in range(n):\n        ms[d - 1] += b[i][0]\n        b[i][0] = d\n        if flag == 1:\n            d += 1\n        else:\n            d -= 1\n        if d == m + 1:\n            d = m\n            flag = 0\n        elif d == 0:\n            d = 1\n            flag = 1\n    b.sort(key=takeSecond)\n    ms.sort()\n    if ms[-1] - ms[0] > x:\n        print('NO')\n    else:\n        print('YES')\n        for i in range(n):\n            print(b[i][0], end=' ')\n        print()"]