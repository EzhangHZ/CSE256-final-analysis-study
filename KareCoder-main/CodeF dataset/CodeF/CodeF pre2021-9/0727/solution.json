["import sys\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\n\ndef solve(i, j, x):\n    if i > j:\n        return 0\n    idx = a.index(min(a[i:j + 1]), i, j + 1)\n    mn = a[idx]\n    case = mn - x + solve(i, idx - 1, mn) + solve(idx + 1, j, mn)\n    return min(case, j - i + 1)\nprint(solve(0, n - 1, 0))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef rec(l, r, sub):\n    if l >= r:\n        return 0\n    m = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[m] - sub + rec(l, m, a[m]) + rec(m + 1, r, a[m]))\nn = int(input())\na = list(map(int, input().split()))\nprint(rec(0, n, 0))", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\n\ndef calc(l, r, h):\n    if l >= r:\n        return 0\n    m = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[m] - h + calc(l, m, a[m]) + calc(m + 1, r, a[m]))\nprint(calc(0, n, 0))", "import sys\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\n\ndef f(l, r, h):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[x] - h + f(l, x, a[x]) + f(x + 1, r, a[x]))\nprint(f(0, n, 0))", "import sys\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\n\ndef f(l, r, h):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[x] - h + f(l, x, a[x]) + f(x + 1, r, a[x]))\nprint(f(0, n, 0))", "import sys\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef cal(l, r, h=0):\n    if l >= r:\n        return 0\n    mn = min(aa[l:r])\n    mni = aa.index(mn, l, r)\n    return min(cal(l, mni, mn) + cal(mni + 1, r, mn) + mn - h, r - l)\nn = II()\naa = LI()\nprint(cal(0, n))", "import sys\nimport threading\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(16 * 2048 * 2048)\nn = int(input())\na = [int(i) for i in input().split() if i != '\\n']\na.insert(0, 0)\na.append(0)\n\ndef solve(l, r):\n    if l > r:\n        return 0\n    outside = max(a[l - 1], a[r + 1])\n    mina = min(a[l:r + 1])\n    min_index = a.index(mina, l, r + 1)\n    return min(r - l + 1, solve(l, min_index - 1) + solve(min_index + 1, r) + mina - outside)\nans = solve(1, n)\nsys.stdout.write(str(ans) + '\\n')", "import sys\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\n\ndef f(l, r, h):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[x] - h + f(l, x, a[x]) + f(x + 1, r, a[x]))\nprint(f(0, n, 0))", "import sys\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\n\ndef f(l, r, h):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[x] - h + f(l, x, a[x]) + f(x + 1, r, a[x]))\nprint(f(0, n, 0))", "import sys\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\n\ndef f(l, r, h):\n    if l > r:\n        return 0\n    x = a.index(min(a[l:r + 1]), l, r + 1)\n    return min(r - l + 1, a[x] - h + f(l, x - 1, a[x]) + f(x + 1, r, a[x]))\nprint(f(0, n - 1, 0))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef rec(l, r, sub):\n    if l >= r:\n        return 0\n    m = a.index(min(a[l:r]), l, r)\n    return min(r - l, a[m] - sub + rec(l, m, a[m]) + rec(m + 1, r, a[m]))\nn = int(input())\na = list(map(int, input().split()))\nprint(rec(0, n, 0))", "import sys\n\ndef solve(l, r):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    mn = min(a[l:r])\n    (i, j) = (0, 0)\n    if l - 1 >= 0:\n        i = a[l - 1]\n    if r < n:\n        j = a[r]\n    out = max(i, j)\n    return min(r - l, mn + solve(l, x) + solve(x + 1, r) - out)\n\ndef main():\n    print(solve(0, n))\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\nmain()", "import sys\nfrom math import sqrt\nfrom collections import defaultdict\ninpt = sys.stdin.readline\n\ndef inp():\n    return int(inpt())\n\ndef inlist():\n    return list(map(int, inpt().split()))\n\ndef solve(l, r):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    mn = min(a[l:r])\n    (i, j) = (0, 0)\n    if l - 1 >= 0:\n        i = a[l - 1]\n    if r < n:\n        j = a[r]\n    out = max(i, j)\n    return min(r - l, mn + solve(l, x) + solve(x + 1, r) - out)\n\ndef main():\n    ans = solve(0, n)\n    print(ans)\nsys.setrecursionlimit(10000)\nn = inp()\na = inlist()\nmain()", "import sys\n\ndef solve(l, r):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    mn = min(a[l:r])\n    (i, j) = (0, 0)\n    if l - 1 >= 0:\n        i = a[l - 1]\n    if r < n:\n        j = a[r]\n    out = max(i, j)\n    return min(r - l, mn + solve(l, x) + solve(x + 1, r) - out)\nsys.setrecursionlimit(10000)\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(0, n))", "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(l, r):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    mn = min(a[l:r])\n    (i, j) = (0, 0)\n    if l - 1 >= 0:\n        i = a[l - 1]\n    if r < n:\n        j = a[r]\n    out = max(i, j)\n    return min(r - l, mn + solve(l, x) + solve(x + 1, r) - out)\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(0, n))", "import sys\nfrom math import sqrt\nfrom collections import defaultdict\ninpt = sys.stdin.readline\n\ndef inp():\n    return int(inpt())\n\ndef inlist():\n    return list(map(int, inpt().split()))\n\ndef solve(l, r):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    mn = min(a[l:r])\n    (i, j) = (0, 0)\n    if l - 1 >= 0:\n        i = a[l - 1]\n    if r < n:\n        j = a[r]\n    out = max(i, j)\n    return min(r - l, mn + solve(l, x) + solve(x + 1, r) - out)\n\ndef main():\n    ans = solve(0, n)\n    print(ans)\nsys.setrecursionlimit(10000)\nn = inp()\na = inlist()\nmain()", "import sys\nfrom math import sqrt\nfrom collections import defaultdict\ninpt = sys.stdin.readline\n\ndef inp():\n    return int(inpt())\n\ndef inlist():\n    return list(map(int, inpt().split()))\n\ndef instr():\n    s = inpt()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, inpt().split())\n\nclass Graph:\n\n    def __init__(self, n):\n        self.n = n\n        self.graph = defaultdict(list)\n        self.marked = defaultdict(int)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def dfs(self, u):\n        self.marked[u] = 1\n        for i in self.graph[u]:\n            if self.marked[i] == 0:\n                self.dfs(i)\n\ndef solve(a, l, r):\n    if l >= r:\n        return 0\n    x = a.index(min(a[l:r]), l, r)\n    mn = min(a[l:r])\n    (i, j) = (0, 0)\n    if l - 1 >= 0:\n        i = a[l - 1]\n    if r < n:\n        j = a[r]\n    out = max(i, j)\n    return min(r - l, mn + solve(a, l, x) + solve(a, x + 1, r) - out)\n\ndef main():\n    a = inlist()\n    ans = solve(a, 0, n)\n    print(ans)\nsys.setrecursionlimit(10000)\nn = inp()\nmain()", "n = int(input())\na = list(map(int, input().split()))\nimport sys\nsys.setrecursionlimit(10 ** 5)\n\ndef calc(l, r, base):\n    if l > r:\n        return 0\n    mn = min(a[l:r + 1])\n    ans = mn - base\n    L = l\n    for i in range(l, r + 1):\n        if a[i] == mn:\n            ans += calc(L, i - 1, mn)\n            L = i + 1\n    ans += calc(L, r, mn)\n    return min(ans, r - l + 1)\nprint(calc(0, n - 1, 0))", "import math, sys, bisect, heapq\nfrom collections import defaultdict, Counter, deque\nfrom itertools import groupby, accumulate\nsys.setrecursionlimit(200000000)\nilele = lambda : map(int, input().split())\nalele = lambda : list(map(int, input().split()))\n\ndef list2d(a, b, c):\n    return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d):\n    return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef Y(c):\n    print(['NO', 'YES'][c])\n\ndef y(c):\n    print(['no', 'yes'][c])\n\ndef Yy(c):\n    print(['No', 'Yes'][c])\nn = int(input())\nA = alele()\ndp = {}\n\ndef fun(l, r, h):\n    if l > r:\n        return 0\n    if dp.get((l, r, h), -1) != -1:\n        return dp[l, r, h]\n    m = min(A[l:r + 1])\n    pos = None\n    for i in range(l, r + 1):\n        if A[i] == m:\n            pos = i\n            break\n    dp[l, r, h] = min(r - l + 1, A[pos] - h + fun(l, pos - 1, A[pos]) + fun(pos + 1, r, A[pos]))\n    return dp[l, r, h]\nprint(fun(0, n - 1, 0))", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef cal(l, r, h=0):\n    if l >= r:\n        return 0\n    mn = mni = inf\n    for i in range(l, r):\n        if aa[i] < mn:\n            mn = aa[i]\n            mni = i\n    return min(cal(l, mni, mn) + cal(mni + 1, r, mn) + mn - h, r - l)\ninf = 10 ** 16\nn = II()\naa = LI()\nprint(cal(0, n))"]