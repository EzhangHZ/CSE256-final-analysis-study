["from math import comb\nfrom sys import stdin\ninput = stdin.readline\nMOD = 10 ** 9 + 7\n\ndef solve():\n    (n, k) = [int(x) for x in input().split()]\n    a = [0] + [int(x) for x in input().split()]\n    a.sort()\n    N = a.count(a[-k])\n    M = a[-k:].count(a[-k])\n    print(comb(N, M) % MOD)\nfor _ in range(int(input())):\n    solve()", "from math import comb\n\ndef swapp(n, k, a):\n    a.sort(reverse=True)\n    kk = 0\n    su = 0\n    p = 0\n    dd = 0\n    if n == k:\n        return 1\n    for i in range(k - 1, n - 1):\n        if a[i] != a[i + 1]:\n            break\n        if a[i] == a[i + 1]:\n            p = a[i]\n    if p == 0:\n        return 1\n    if p > 0:\n        for i in range(k - 1):\n            if a[k - i - 1] == a[k - i - 2]:\n                dd += 1\n            else:\n                break\n        ss = a.count(p)\n        return comb(ss, min(1 + dd, k)) % 1000000007\nt = int(input())\nfor i in range(t):\n    NM = input().split()\n    n = int(NM[0])\n    k = int(NM[1])\n    a = list(map(int, input().rstrip().split()))\n    ans = swapp(n, k, a)\n    print(ans)", "from math import comb, prod\n\ndef advert(arr, k):\n    arr = sorted(arr, reverse=True)\n    temp = arr[:k]\n    ans = 1\n    pp = []\n    for i in set(arr[:k]):\n        pp.append(comb(arr.count(i), temp.count(i)))\n    return prod(pp) % (10 ** 9 + 7)\nfor i in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    lst = list(map(int, input().strip().split()))\n    print(advert(lst, b))", "from math import *\na = int(input())\nfor x in range(a):\n    (d, e) = map(int, input().split())\n    b = list(map(int, input().split()))\n    b.sort(reverse=True)\n    h = 0\n    p = set([])\n    ss = {}\n    for y in range(e):\n        p.add(b[y])\n        if ss.get(b[y]) == None:\n            ss[b[y]] = 1\n        else:\n            ss[b[y]] += 1\n    t = {}\n    for y in range(d):\n        if b[y] in p:\n            if t.get(b[y]) == None:\n                t[b[y]] = 1\n            else:\n                t[b[y]] += 1\n    l = 1\n    for y in t:\n        l *= comb(t[y], ss[y])\n    print(l % (10 ** 9 + 7))", "def c2n(num, k):\n    k = min(k, num - k)\n    res = 1\n    nm = 1\n    dem = 1\n    while k > 0:\n        nm *= num\n        dem *= k\n        num -= 1\n        k -= 1\n    return nm // dem\nt = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    lt = [int(x) for x in input().split()]\n    dt = {}\n    st = list(set(lt))\n    st = sorted(st, reverse=True)\n    for x in lt:\n        dt[x] = dt.get(x, 0) + 1\n    i = 0\n    ans = 1\n    while m > 0:\n        if dt[st[i]] <= m:\n            m -= dt[st[i]]\n        else:\n            ans = c2n(dt[st[i]], m)\n            m = 0\n        i += 1\n    print(ans % 1000000007)", "from itertools import combinations\nfrom math import comb\ntestcase = int(input())\n\ndef enter():\n    rseq = input()\n    rseq = rseq.split(' ')\n    rseq = list(map(int, rseq))\n    return rseq\nwhile testcase:\n    c = 0\n    e = 0\n    f = 0\n    hire = enter()\n    follower = enter()\n    follower.sort(reverse=True)\n    for i in follower:\n        if i >= follower[hire[1] - 1]:\n            f += 1\n        if i > follower[hire[1] - 1]:\n            e += 1\n    left = hire[1] - e\n    j = f - e\n    c = 1\n    if left > 0:\n        c = comb(j, left)\n    c = c % 1000000007\n    print(c)\n    testcase -= 1", "def factorial(number):\n    if number <= 1:\n        return 1\n    fact = 1\n    for i in range(1, number + 1):\n        fact *= i\n    return fact\n\ndef solution(array, k, n):\n    N = 0\n    R = 0\n    array.sort()\n    element = array[n - k]\n    for i in range(n - k, n):\n        if array[i] == element:\n            R += 1\n    for i in range(n):\n        if array[i] == element:\n            N += 1\n    answer = factorial(N) // (factorial(R) * factorial(N - R))\n    return answer % (1000000000 + 7)\nT = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    array = list(map(int, input().split()))\n    ans = solution(array, k, n)\n    print(ans)", "try:\n    from math import comb\n    t = int(input())\n    for _ in range(t):\n        (n, k) = map(int, input().split())\n        l = [int(x) for x in input().split()]\n        l.sort(reverse=True)\n        n = l.count(l[k - 1])\n        r = l[:k].count(l[k - 1])\n        print(comb(n, r) % 1000000007)\nexcept EOFError:\n    pass", "rn = lambda : int(input())\nrns = lambda : map(int, input().split())\nrl = lambda : list(map(int, input().split()))\nrs = lambda : input()\nyn = lambda x: print('Yes') if x else print('No')\nYN = lambda x: print('YES') if x else print('NO')\npl = lambda l: print(' '.join(list(map(str, l))))\n\ndef d(a):\n    d = {}\n    for i in a:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    return d\nfrom math import comb\nfor _ in range(rn()):\n    (n, k) = rns()\n    a = rl()\n    a.sort()\n    num = a[n - k]\n    count = 1\n    while n - k + count < n and a[n - k + count] == num:\n        count += 1\n    ans = comb(a.count(num), count)\n    print(ans % (10 ** 9 + 7))", "in_length = int(input())\nfinal_ouput = []\nfor i in range(in_length):\n    [num_bloggers, av_contracts] = [int(el) for el in input().split()]\n    followers_p_b = [int(el) for el in input().split()]\n    followers_p_b = sorted(followers_p_b)\n    followers_p_b.reverse()\n    selected_bloggers = followers_p_b[:av_contracts]\n    lowest = selected_bloggers[-1]\n    n = followers_p_b.count(lowest)\n    r = selected_bloggers.count(lowest)\n    nr = n - r\n    m = 10 ** 9 + 7\n    for j in range(1, n):\n        n = n * j\n    for k in range(1, r):\n        r = r * k\n    for l in range(1, nr):\n        nr = nr * l\n    if n == 0:\n        n = 1\n    if r == 0:\n        r = 1\n    if nr == 0:\n        nr = 1\n    ans = n // r // nr % m\n    final_ouput.append(ans)\nfor out in final_ouput:\n    print(out)", "from math import factorial\nfor _ in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    g = sorted(a, reverse=True)[:k]\n    n1 = a.count(g[-1])\n    r1 = g.count(g[-1])\n    print(factorial(n1) // (factorial(n1 - r1) * factorial(r1)) % (10 ** 9 + 7))", "def combination(n, m):\n    (a, b) = (1, 1)\n    for i in range(m + 1, n + 1):\n        a *= i\n        if b <= n - m and a % b == 0:\n            a //= b\n            b += 1\n    return a % (1000000000 + 7)\n\ndef agency():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    mp = {i: 0 for i in a}\n    b = a[n - m]\n    for i in a:\n        mp[i] += 1\n    k = 0\n    for i in range(n - m, n):\n        if a[i] != b:\n            break\n        k += 1\n    return combination(mp[b], k)\nfor i in range(int(input())):\n    print(agency())", "import math\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nmod1 = 1000000007\nmod2 = 998244353\nfrom collections import defaultdict, Counter\nfact = [1] * 1001\nfor i in range(1, 1001):\n    fact[i] = fact[i - 1] * i % mod1\nfor _ in range(I()):\n    (n, k) = M()\n    a = sorted(L(), reverse=True)\n    req = defaultdict(lambda : 0)\n    for i in a:\n        if k == 0:\n            break\n        req[i] += 1\n        k -= 1\n    count = Counter(a)\n    ans = 1\n    for i in req:\n        x = count[i]\n        y = req[i]\n        num1 = fact[x]\n        den1 = fact[y]\n        den2 = fact[x - y]\n        ans = ans * num1 % mod1 * pow(den1, -1, mod1) * pow(den2, -1, mod1) % mod1\n    print(ans)", "import math\nfor j in range(int(input())):\n    (m, n) = map(int, input().split())\n    l = [int(x) for x in input().split()]\n    l.sort(reverse=True)\n    a = l[n - 1]\n    b = l.count(a)\n    for p in range(n):\n        if l[p] == a:\n            break\n    e = n - p\n    ans = math.comb(b, e)\n    print(ans % 1000000007)", "m = 10 ** 9 + 7\nfrom math import comb\n\ndef solve(l, n, k):\n    l.sort(reverse=True)\n    c = l.count(l[k - 1])\n    a = l.index(l[k - 1])\n    r = k - a\n    ans = comb(c, r)\n    print(ans % m)\nt = int(input())\nwhile t:\n    l = [int(i) for i in input().split(' ')]\n    (n, k) = (l[0], l[1])\n    l = [int(i) for i in input().split(' ')]\n    solve(l, n, k)\n    t -= 1", "from math import comb\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=1)\n    n = a.count(a[k - 1])\n    r = a[:k].count(a[k - 1])\n    print(comb(n, r) % (10 ** 9 + 7))", "import math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    t = a.count(a[k - 1])\n    s = 0\n    j = k - 1\n    while a[j] == a[k - 1] and j >= 0:\n        s += 1\n        j -= 1\n    if len(set(a)) == 1:\n        s = k\n        t = n\n    ans = math.factorial(t) // (math.factorial(t - s) * math.factorial(s))\n    print(ans % 1000000007)", "from collections import defaultdict as dd, deque as dq, Counter as ctr\nimport sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\ninp = lambda : int(input())\nmi = lambda x=int: map(x, input().split())\nli = lambda x=int: list(mi(x))\nlb = lambda x=int: list(map(x, input()))\nls = lambda : list(input())\nbi = lambda n: bin(n).replace('0b', '')\n\ndef sbsq(a, s):\n    i = 0\n    for x in s:\n        if i >= len(a):\n            break\n        if x == a[i]:\n            i += 1\n    return i == len(a)\nyn = ['No', 'Yes']\nYN = ['NO', 'YES']\nYY = 'YES'\nNN = 'NO'\nyy = 'Yes'\nnn = 'No'\nalp = 'abcdefghijklmnopqrstuvwxyz'\ninf = sys.maxsize\nmod = 1000000007\nfrom math import ceil, sqrt, gcd, log, comb\nimport heapq as hq\n\ndef main(kase):\n    (n, k) = mi()\n    a = li()\n    a.sort()\n    x = a[-k]\n    print(comb(a.count(x), br(a, x) - (n - k)) % mod)\n    pass\ntest_Cases = 1\ntest_Cases = inp()\nfor i in range(test_Cases):\n    main(i)", "from math import comb\nfrom collections import Counter\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    if n == k:\n        print(1)\n        continue\n    a.sort(reverse=True)\n    cnt = Counter(a)\n    c = 0\n    for i in cnt:\n        if c + cnt[i] > k:\n            print(comb(cnt[i], k - c) % 1000000007)\n            break\n        else:\n            c += cnt[i]", "from math import comb\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    L = [int(x) for x in input().split()]\n    count = [0] * (max(L) + 1)\n    for x in L:\n        count[x] += 1\n    for x in reversed(count):\n        if k - x > 0:\n            k -= x\n        else:\n            print(comb(x, k) % 1000000007)\n            break", "from math import comb\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(x) for x in input().split()]\n    L = [int(x) for x in input().split()]\n    count = [0] * (max(L) + 1)\n    for x in L:\n        count[x] += 1\n    for x in reversed(count):\n        if k - x > 0:\n            k -= x\n        else:\n            print(comb(x, k) % 1000000007)\n            break", "import sys\nfrom typing import List, Literal\nMOD: Literal[1000000007] = 1000000007\nresults: List[str] = []\n_factorial_cache: List[int] = [1]\n\ndef factorial(n: int) -> int:\n    try:\n        return _factorial_cache[n]\n    except IndexError:\n        _factorial_cache.append(n * factorial(n - 1))\n        return _factorial_cache[n]\n\ndef C(k: int, n: int) -> int:\n    result = factorial(n) // (factorial(k) * factorial(n - k))\n    return result % MOD\n\ndef solve() -> int:\n    (n, k) = [int(i) for i in input().split()]\n    followers = [int(f) for f in input().split()]\n    followers.sort(reverse=True)\n    start = -1\n    for i in range(n):\n        if followers[i] == followers[k - 1]:\n            end = i\n            if start == -1:\n                start = i\n    total = end - start + 1\n    pick = k - 1 - start + 1\n    return C(pick, total)\nsys.setrecursionlimit(10000)\nfor _ in range(int(input())):\n    results.append(str(solve()))\nprint('\\n'.join(results))", "from math import comb\nmod = int(pow(10, 9)) + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    arr = list(map(int, input().split(' ')))\n    arr = sorted(arr, reverse=True)\n    (l, r) = (k - 1, k - 1)\n    while r < n and arr[r] == arr[k - 1]:\n        r += 1\n    while l >= 0 and arr[l] == arr[k - 1]:\n        l -= 1\n    r -= 1\n    l += 1\n    print(comb(r - l + 1, k - l) % mod)", "from math import comb\nfor i in range(int(input())):\n    (a, k) = map(int, input().split())\n    arr = [int(arr) for arr in input().split()]\n    arr.sort()\n    goal = arr[-k:]\n    s = 1\n    for i in range(len(goal)):\n        if i > 0 and goal[i] == goal[i - 1]:\n            continue\n        s = s * comb(arr.count(goal[i]), goal.count(goal[i]))\n    print(s % (10 ** 9 + 7))", "import math\nfor i1 in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    lis = sorted([int(x) for x in input().split()])\n    value = lis[-k]\n    index = n - k\n    last_index = n - lis[::-1].index(value) - 1\n    first_index = lis.index(value)\n    print(math.comb(last_index - first_index + 1, last_index - index + 1) % (10 ** 9 + 7))", "import math\nT = int(input())\nfor testcase in range(1, T + 1):\n    (n, k) = [int(s) for s in input().split(' ')]\n    a = [0 for x in range(n)]\n    l = input().split()\n    for (y, name) in enumerate(l):\n        a[y] = int(l[y])\n    a.sort(reverse=True)\n    lastVal = a[0]\n    count = 1\n    myList = []\n    for i in range(1, n):\n        if a[i] == lastVal:\n            count += 1\n        else:\n            myList.append([lastVal, count])\n            lastVal = a[i]\n            count = 1\n    myList.append([lastVal, count])\n    i = 0\n    while k > 0:\n        k -= myList[i][1]\n        i += 1\n    if k == 0:\n        print(1)\n    else:\n        x = myList[i - 1][1]\n        y = -k\n        z = math.factorial(x) // math.factorial(y) // math.factorial(x - y) % (10 ** 9 + 7)\n        print(z)", "from math import comb, prod\n\ndef advert(arr, k):\n    arr = sorted(arr, reverse=True)\n    temp = arr[:k]\n    ans = 1\n    pp = []\n    for i in set(arr[:k]):\n        pp.append(comb(arr.count(i), temp.count(i)))\n    return prod(pp) % (10 ** 9 + 7)\nfor i in range(int(input())):\n    (a, b) = map(int, input().strip().split())\n    lst = list(map(int, input().strip().split()))\n    print(advert(lst, b))", "from sys import stdin\nt = int(stdin.readline())\nfact = [1]\nfor x in range(1, 1001):\n    fact.append(x * fact[-1])\n\ndef C(a, b):\n    return fact[b] // (fact[a] * fact[b - a]) % (10 ** 9 + 7)\nfor _ in range(t):\n    (n, k) = map(int, stdin.readline().split())\n    arr = sorted(list(map(int, stdin.readline().split())), reverse=True)\n    dct = {}\n    minn = arr[k - 1]\n    position1 = 0\n    jump = n - 1\n    while jump > 0:\n        if position1 + jump >= n:\n            jump = jump // 2\n        elif arr[position1 + jump] <= minn:\n            jump = jump // 2\n        else:\n            position1 += jump\n    if arr[position1] > minn:\n        position1 += 1\n    position2 = 0\n    jump = n - 1\n    while jump > 0:\n        if position2 + jump >= n:\n            jump = jump // 2\n        elif arr[position2 + jump] < minn:\n            jump = jump // 2\n        else:\n            position2 += jump\n    print(C(k - 1 - position1 + 1, position2 - position1 + 1))", "fact = [1]\nfor i in range(1, 1002):\n    fact.append(fact[i - 1] * i)\n\ndef comb(n, k):\n    return fact[n] // (fact[n - k] * fact[k])\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    store = {}\n    for i in a:\n        if i in store:\n            store[i] += 1\n        else:\n            store[i] = 1\n    a = sorted(list(set(a)))\n    count = 0\n    for i in a[::-1]:\n        if count + store[i] >= k:\n            ans = comb(store[i], k - count)\n            break\n        count += store[i]\n    print(ans % (10 ** 9 + 7))", "def dell(lst, m):\n    dic = {}\n    for i in lst:\n        try:\n            dic[i] += 1\n        except:\n            dic[i] = 1\n    bok = list(dic.keys())\n    bok.sort(reverse=True)\n    sum = num = 0\n    for i in bok:\n        num = dic[i]\n        if sum + num >= m:\n            break\n        else:\n            sum += num\n    need = m - sum\n    b = a = 1\n    for i in range(num, num - need, -1):\n        b *= i\n    for i in range(1, need + 1):\n        a *= i\n    print(b // a % (10 ** 9 + 7))\nt = int(input())\nfor u in range(t):\n    l = input().split()\n    lst = list(map(int, input().split()))\n    dell(lst, int(l[1]))", "import math\nI = lambda : [*map(int, input().split())]\n(t,) = I()\nfor _ in ' ' * t:\n    (n, k) = I()\n    l = sorted(I())\n    a = l[-k]\n    print(math.comb(l.count(a), l[-k:].count(a)) % (10 ** 9 + 7))", "import sys\nimport math\n\ndef fn(n, k, a):\n    h = []\n    a.sort(reverse=True)\n    for i in range(k):\n        h.append(a[i])\n    h1 = h.count(min(h))\n    h2 = a.count(min(h))\n    p = 1\n    for i in range(h1):\n        p = p * (h2 - i)\n    for i in range(h1):\n        p = p // (h1 - i)\n    return p % 1000000007\ninput = sys.stdin.read()\ndata = list(map(int, input.split()))\nt = data[0]\nl = 0\nfor i in range(t):\n    n = data[l + 1]\n    k = data[l + 2]\n    a = data[l + 3:l + 3 + n]\n    l = l + n + 2\n    print(fn(n, k, a))", "from collections import defaultdict, deque\nfrom sys import stdin\nfrom math import comb\ninput = lambda : stdin.readline().strip()\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    lst = [int(i) for i in input().split()]\n    lst.sort(reverse=True)\n    nd = 0\n    lst2 = deque()\n    while nd < k:\n        lst2.append(lst[nd])\n        nd += 1\n    a = lst2[-1]\n    nk = 0\n    nm = 0\n    while nd < n:\n        if lst[nd] == a:\n            nk += 1\n        else:\n            break\n        nd += 1\n    lst2 = list(lst2)[::-1]\n    for i in lst2:\n        if i == a:\n            nm += 1\n        else:\n            break\n    print(comb(nm + nk, nm) % 1000000007)", "import math\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    a.reverse()\n    n = a.count(a[k - 1])\n    r = a[:k].count(a[k - 1])\n    print(math.comb(n, r) % (10 ** 9 + 7))", "import sys\nimport math\nrl = lambda : list(map(int, sys.stdin.readline().split()))\nfor _ in range(int(input())):\n    (n, k) = rl()\n    A = rl()\n    dic = {}\n    for a in A:\n        if a in dic:\n            dic[a] += 1\n        else:\n            dic[a] = 1\n    num = 0\n    cnt = []\n    for a in sorted(dic, reverse=True):\n        if num >= k:\n            break\n        num += dic[a]\n        cnt.append(dic[a])\n    for b in cnt[:-1]:\n        k -= b\n    print(math.factorial(cnt[-1]) // (math.factorial(k) * math.factorial(cnt[-1] - k)) % (10 ** 9 + 7))", "from math import comb\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = [*map(int, input().split())]\n    l.sort(reverse=True)\n    d = {item: l.count(item) for item in l}\n    move = l[k - 1]\n    moc = 0\n    for i in range(k - 1, -1, -1):\n        if move == l[i]:\n            moc += 1\n        else:\n            break\n    ans = comb(d[move], moc)\n    print(ans % 1000000007)", "from collections import defaultdict\nfrom math import comb\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dic = defaultdict(lambda : 0)\n    a.sort()\n    arr = a[-k:]\n    temp = arr.count(arr[0])\n    ans = comb(a.count(arr[0]), temp)\n    print(ans % (10 ** 9 + 7))", "from math import comb\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    followers = list(map(int, input().split()))\n    lista = sorted(followers, reverse=True)\n    c = lista.count(lista[k - 1])\n    r = lista[:k].count(lista[k - 1])\n    print(comb(c, r) % (10 ** 9 + 7))", "import math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    t = a.count(a[k - 1])\n    s = 0\n    j = k - 1\n    while a[j] == a[k - 1] and j >= 0:\n        s += 1\n        j -= 1\n    if len(set(a)) == 1:\n        s = k\n        t = n\n    ans = math.factorial(t) // (math.factorial(t - s) * math.factorial(s))\n    print(ans % 1000000007)", "import math\nt = int(input())\nfor q in range(t):\n    arrc = [0] * 1001\n    end = 1\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    x = max(a)\n    for i in a:\n        arrc[i] += 1\n    for i in range(x, 0, -1):\n        if k >= arrc[i]:\n            k -= arrc[i]\n        else:\n            end = math.factorial(arrc[i]) // (math.factorial(k) * math.factorial(arrc[i] - k))\n            break\n    print(end % (10 ** 9 + 7))", "def fact(x):\n    if x == 0:\n        return 1\n    if x == 1:\n        return 1\n    else:\n        return x * fact(x - 1)\nimport math\nT = int(input())\nfor t in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort(reverse=True)\n    p = K - 1\n    c = 1\n    pnt = p\n    for i in range(p + 1, N, 1):\n        if A[p] != A[i]:\n            break\n        else:\n            c += 1\n    for i in range(p - 1, -1, -1):\n        if A[p] != A[i]:\n            break\n        else:\n            c += 1\n            pnt -= 1\n    done = pnt\n    req = K - done\n    ans = math.comb(c, req)\n    ans = ans % 1000000007\n    print(ans)", "import math\nfor _ in range(int(input())):\n    (n, k) = [*map(int, input().split())]\n    l = [*map(int, input().split())]\n    l.sort(reverse=True)\n    x = l.count(l[k - 1])\n    y = 0\n    for i in range(k, n):\n        if l[i] != l[k - 1]:\n            break\n        y += 1\n    MOD = 10 ** 9 + 7\n    print(math.comb(x, y) % MOD)", "import math\nfrom itertools import combinations\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    ls.sort(reverse=True)\n    sum = 0\n    if ls[k - 1] not in ls[k:]:\n        print(1)\n    else:\n        s = ls.count(ls[k - 1])\n        m = ls[0:k].count(ls[k - 1])\n        print(math.comb(s, m) % (10 ** 9 + 7))", "from math import comb\nm = 10 ** 9 + 7\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    l1 = [0] * (n + 1)\n    for i in l:\n        l1[i] += 1\n    a = l.index(l[k - 1])\n    a = k - a\n    print(comb(l1[l[k - 1]], a) % m)", "f = [1] * 1001\nfi = [1] * 1001\na = 1\nm = 10 ** 9 + 7\nfor i in range(1, 1001):\n    a *= i\n    a %= m\n    f[i] = a\nb = pow(f[1000], m - 2, m)\nfi[1000] = b\nfor i in range(999, 0, -1):\n    fi[i] = b * (i + 1) % m\n    b = fi[i]\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    l1 = [0] * (n + 1)\n    for i in l:\n        l1[i] += 1\n    a = l.index(l[k - 1])\n    a = k - a\n    print(f[l1[l[k - 1]]] * fi[l1[l[k - 1]] - a] * fi[a] % m)", "import math\nI = lambda : [*map(int, input().split())]\nfor _ in [0] * I()[0]:\n    (n, k) = I()\n    l = sorted(I())\n    print(math.comb(l.count(l[-k]), l[-k:].count(l[-k])) % (10 ** 9 + 7))", "import math\nfor j in range(int(input())):\n    (m, n) = map(int, input().split())\n    l = [int(x) for x in input().split()]\n    l.sort(reverse=True)\n    a = l[n - 1]\n    b = l.count(a)\n    for p in range(n):\n        if l[p] == a:\n            break\n    e = n - p\n    ans = math.comb(b, e)\n    print(ans % 1000000007)", "mod = int(1000000000.0 + 7)\n\ndef fact(x):\n    ans = 1\n    for i in range(2, x + 1):\n        ans = ans * i % mod\n    return ans\n\ndef C(x, k):\n    return fact(x) * (pow(fact(k), mod - 2, mod) % mod) * (pow(fact(x - k), mod - 2, mod) % mod)\n\ndef solve():\n    (n, m) = input().split()\n    n = int(n)\n    m = int(m)\n    arr = [0] * (n + 1)\n    for i in input().split():\n        x = int(i)\n        arr[x] += 1\n    for i in range(n, -1, -1):\n        if arr[i] >= m:\n            return int(C(arr[i], m) % mod)\n        else:\n            m -= arr[i]\n    return 1\nno_tests = int(input())\nresults = []\nfor i in range(no_tests):\n    results.append(solve())\nfor result in results:\n    print(result)", "from math import comb\ntc = int(input())\nfor _ in range(tc):\n    (n, k) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    val = arr[k - 1]\n    objects = 0\n    sample = 0\n    for i in range(n):\n        if arr[i] == val:\n            if i < k:\n                objects += 1\n                sample += 1\n            else:\n                objects += 1\n    ret = comb(objects, sample)\n    print(ret % 1000000007)", "from math import factorial as f\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    a = l.count(l[k - 1])\n    b = k - l.index(l[k - 1])\n    print(f(a) // (f(b) * f(a - b)) % (10 ** 9 + 7))", "def factorial(number):\n    if number <= 1:\n        return 1\n    fact = 1\n    for i in range(1, number + 1):\n        fact *= i\n    return fact\n\ndef solve(array, k, n):\n    N = 0\n    R = 0\n    array.sort()\n    element = array[n - k]\n    for i in range(n - k, n):\n        if array[i] == element:\n            R += 1\n    for i in range(n):\n        if array[i] == element:\n            N += 1\n    answer = factorial(N) // (factorial(R) * factorial(N - R))\n    print(answer % (1000000000 + 7))\n    return\nfor test in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    ans = solve(l, k, n)", "import math as m\n\ndef ncr(n, r):\n    return m.factorial(n) // (m.factorial(r) * m.factorial(n - r))\nt = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = {}\n    for i in range(n):\n        if a[i] not in b.keys():\n            b[a[i]] = 0\n        b[a[i]] += 1\n    c = []\n    for i in b:\n        c.append([i, b[i]])\n    c.sort(reverse=True)\n    f = 0\n    for i in range(len(c)):\n        if k - c[i][1] < 0:\n            f = 1\n            print(ncr(c[i][1], k) % (10 ** 9 + 7))\n            break\n        else:\n            k = k - c[i][1]\n    if f == 0:\n        print(1)", "from itertools import groupby\nfrom math import factorial\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(v) for v in input().split()]\n    w = [int(v) for v in input().split()]\n    c = groupby(sorted(w))\n    c = [[j[0], len(list(j[1]))] for j in c]\n    while k and k >= c[-1][1]:\n        k -= c.pop()[1]\n    if k:\n        z = c.pop()[1]\n        print(factorial(z) // (factorial(k) * factorial(z - k)) % (10 ** 9 + 7))\n    else:\n        print(1)", "def getn(a, b):\n    ans = 1\n    div = 1\n    for i in range(0, b):\n        ans *= a - i\n    for i in range(1, b + 1):\n        div *= i\n    ans //= div\n    return ans % 1000000007\ntot = int(input())\nfor i in range(0, tot):\n    mp = list(input().split())\n    n = int(mp[0])\n    k = int(mp[1])\n    mp = list(input().split())\n    lst = list()\n    dct = dict()\n    for i in mp:\n        t = int(i)\n        if dct.get(t, 0) > 0:\n            dct[t] += 1\n        else:\n            dct[t] = 1\n            lst.append(t)\n    lst.sort()\n    i = 0\n    ans = 1\n    while i < k:\n        t = lst.pop()\n        dt = dct[t]\n        gets = min(dt, k - i)\n        ans *= getn(dt, gets)\n        ans %= 1000000007\n        i += gets\n    print(ans)", "from collections import defaultdict\nimport math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    a.sort()\n    last = a[-k]\n    c = a.count(last)\n    start = n - k\n    cnt = 0\n    while start < n and a[start] == last:\n        start += 1\n        cnt += 1\n    ans = math.factorial(c)\n    ans //= math.factorial(cnt)\n    ans //= math.factorial(c - cnt)\n    ans = ans % mod\n    print(ans)", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    if k == n or a[k - 1] != a[k]:\n        print(1)\n    else:\n        z = a[k - 1]\n        for j in range(k - 2, -1, -1):\n            if a[j] != z:\n                break\n        else:\n            j = -1\n        for i in range(k, n):\n            if a[i] != z:\n                break\n        else:\n            i = n\n        MOD = int(1000000000.0) + 7\n        cnt = i - j\n        ans = 1\n        dd = 1\n        for z in range(1, k - j):\n            cnt -= 1\n            ans = ans * cnt % MOD\n            dd = dd * z % MOD\n        print(ans * pow(dd, MOD - 2, MOD) % MOD)\nfor i in range(int(input())):\n    solve()", "import math\n\ndef nCr(n, r):\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    (n, k) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    a.sort(reverse=True)\n    _count = 0\n    prev = a[0]\n    prev_count = 0\n    for num in a:\n        _count += 1\n        if num == prev:\n            prev_count += 1\n        else:\n            prev = num\n            prev_count = 1\n        if _count >= k:\n            break\n    total = a.count(prev)\n    print(nCr(total, prev_count) % (10 ** 9 + 7))", "from bisect import bisect_left as bsl\nfrom bisect import bisect_right as bsr\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    a = A[-k]\n    bl = bsl(A, a)\n    br = bsr(A, a)\n    x = br - bl\n    y = n - k - bl\n    ans = 1\n    if x < 2 * y:\n        y = x - y\n    for i in range(y):\n        ans *= x - i\n        ans *= pow(i + 1, -1, mod)\n        ans %= mod\n    print(ans)", "t = int(input())\n\ndef nCr(n, r):\n    return fact(n) // (fact(r) * fact(n - r))\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i\n    return res\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    p = list(map(int, input().split()))\n    p = sorted(p, reverse=True)\n    d = {}\n    for i in p:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    x = p[:k]\n    x.reverse()\n    t = x[0]\n    i = 0\n    while i < len(x) and x[i] == t:\n        i += 1\n    print(int(nCr(d[t], i)) % 1000000007)", "from math import comb\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    ch = dict()\n    l = list()\n    for i in input().split():\n        if int(i) not in ch:\n            l.append(int(i))\n            ch[int(i)] = 1\n        else:\n            ch[int(i)] += 1\n    l.sort(reverse=True)\n    cur = 0\n    ind = 0\n    prev = None\n    flag = False\n    while ind < len(l):\n        prev = cur\n        cur += ch[l[ind]]\n        if cur == k:\n            flag = True\n            print(1)\n            break\n        elif cur > k:\n            break\n        ind += 1\n    if flag:\n        continue\n    print(comb(ch[l[ind]], cur - k) % (10 ** 9 + 7))", "from math import comb\nmod = int(1000000000.0 + 7)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    ji = [0] * 1005\n    li = list(map(int, input().split()))\n    for i in li:\n        ji[i] += 1\n    li.sort()\n    dic = dict()\n    st = set()\n    for i in range(n - 1, n - k - 1, -1):\n        st.add(li[i])\n        dic[li[i]] = dic.setdefault(li[i], 0) + 1\n    ans = 1\n    for x in st:\n        ans *= comb(ji[x], dic[x])\n    ans %= mod\n    print(ans)", "import sys, math\ninputs = sys.stdin.read().splitlines()\ntc = int(inputs[0])\nout = []\nfor i in range(tc):\n    line = [int(i) for i in inputs[i * 2 + 1].split()]\n    n = line[0]\n    k = line[1]\n    followers = [0 for i in range(n)]\n    line = [int(i) for i in inputs[i * 2 + 2].split()]\n    for val in line:\n        followers[n - val] += 1\n    for i in range(n):\n        if followers[i] >= k:\n            out.append(str(math.comb(followers[i], k) % 1000000007))\n            break\n        k -= followers[i]\nsys.stdout.writelines('\\n'.join(out))", "from math import gcd\nmod = int(1000000000.0) + 7\n\ndef ip(mode):\n    if mode == 0:\n        return int(input())\n    if mode == 1:\n        return list(map(int, input().split()))\n    if mode == 2:\n        return input()\n    if mode == 3:\n        return list(map(str, input().split()))\n    if mode == 4:\n        return map(int, input().split())\n    if mode == 5:\n        return map(str, input().split())\n\ndef printNcR(n, r):\n    p = 1\n    k = 1\n    if n - r < r:\n        r = n - r\n    if r != 0:\n        while r:\n            p *= n\n            k *= r\n            m = gcd(p, k)\n            p //= m\n            k //= m\n            n -= 1\n            r -= 1\n    else:\n        p = 1\n    return p\nfor _ in range(int(input())):\n    (n, k) = ip(4)\n    l = ip(1)\n    l.sort(reverse=True)\n    lo = k - 1\n    hi = k - 1\n    for i in range(k - 1, -1, -1):\n        if l[i] == l[k - 1]:\n            lo = i\n        else:\n            break\n    for i in range(k, n):\n        if l[i] == l[k - 1]:\n            hi = i\n        else:\n            break\n    r = k - lo\n    num = hi - lo + 1\n    ans = printNcR(num, r) % mod\n    if ans < 0:\n        ans += mod\n    print(ans)", "from math import comb\nMOD = int(1000000000.0 + 7)\nt = int(input())\nwhile t:\n    line = input().split(' ')\n    n = int(line[0])\n    k = int(line[1])\n    numbers = [int(x) for x in input().split(' ')]\n    numbers = tuple(sorted(numbers))\n    strt = n - k\n    el = numbers[strt]\n    cnt = 1\n    for x in numbers[strt + 1:]:\n        if x != el:\n            break\n        cnt = cnt + 1\n    tot = cnt\n    for x in numbers[:strt]:\n        if x == el:\n            tot += 1\n    print(comb(tot, cnt) % MOD)\n    t = t - 1", "mod = 1000000007\nt = int(input())\nfor i in range(t):\n    [n, k] = [int(k) for k in input().split()]\n    a = [int(k) for k in input().split()]\n    a.sort(reverse=True)\n    tot = 0\n    no = 0\n    for j in range(n):\n        if a[j] == a[k - 1]:\n            tot = tot + 1\n            if j < k:\n                no = no + 1\n    ans = 1\n    p = 1\n    for j in range(tot, tot - no, -1):\n        ans = ans * j\n        ans = ans // p\n        p = p + 1\n    print(ans % mod)", "from math import comb\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=1)\n    c = a.count(a[k - 1])\n    r = a[:k].count(a[k - 1])\n    print(comb(c, r) % (10 ** 9 + 7))", "mod = 10 ** 9 + 7\nfrom math import comb\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = sorted(map(int, input().split()), reverse=True)\n    count = 1\n    before = a[0]\n    i = 0\n    for i in range(1, k):\n        if not before == a[i]:\n            count = 1\n            before = a[i]\n        else:\n            count += 1\n    countb = count\n    i += 1\n    if i < n:\n        while a[i] == before:\n            i += 1\n            countb += 1\n            if i >= n:\n                break\n    print(comb(countb, count) % mod)", "mod = 10 ** 9 + 7\nfrom math import comb\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = sorted(map(int, input().split()), reverse=True)\n    count = 1\n    before = a[0]\n    i = 0\n    for i in range(1, k):\n        if not before == a[i]:\n            count = 1\n            before = a[i]\n        else:\n            count += 1\n    countb = count\n    i += 1\n    if i < n:\n        while a[i] == before:\n            i += 1\n            countb += 1\n            if i >= n:\n                break\n    print(comb(countb, count) % mod)", "import math\nY = lambda : map(int, input().split())\nfor _ in range(next(Y())):\n    (n, k) = Y()\n    a = sorted(Y())\n    v = a[-k]\n    print(math.comb(a.count(v), a[-k:].count(v)) % (10 ** 9 + 7))", "from math import comb\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=1)\n    c = a.count(a[k - 1])\n    r = a[:k].count(a[k - 1])\n    print(comb(c, r) % (10 ** 9 + 7))", "import math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = sorted(list(map(int, input().split())), reverse=True)\n    x = a[k - 1]\n    i = 0\n    while a[i] != x:\n        i += 1\n        k -= 1\n    n = a.count(x)\n    r = k\n    y = math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n    print(y % 1000000007)", "def aCb(a, b):\n    prod = 1\n    for f in range(a - b + 1, a + 1):\n        prod = prod * f\n    pro = 1\n    for j in range(1, b + 1):\n        pro = pro * j\n    return prod // pro\nt = int(input())\nfor z in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr.sort(reverse=True)\n    mf = []\n    for i in range(k):\n        mf.append(arr[i])\n    q = list(set(mf))\n    cou = 1\n    for num in q:\n        a = arr.count(num)\n        b = mf.count(num)\n        cou = cou * aCb(a, b)\n        cou = cou % 1000000007\n    print(cou)", "from collections import Counter\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(op.mul, range(n, n - r, -1), 1)\n    denom = reduce(op.mul, range(1, r + 1), 1)\n    return numer // denom\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    d = l[n - k:]\n    s = sum(l)\n    c = Counter(l)\n    dd = Counter(d)\n    ans = 1\n    for i in dd:\n        ans *= ncr(c[i], dd[i])\n    print(ans % (10 ** 9 + 7))", "import math\nfrom collections import Counter as c\nfor _ in ' ' * int(input()):\n    (n, k) = map(int, input().split())\n    a = sorted(map(int, input().split()))\n    (t, b, s) = (c(a), c(a[-k:]), 1)\n    for i in b:\n        s *= math.comb(t[i], b[i]) % 1000000007\n    print(s)", "import math\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    a = l[-k:]\n    count = 1\n    for i in set(a):\n        a1 = a.count(i)\n        a2 = l.count(i)\n        a3 = math.factorial(a2) // math.factorial(a1) // math.factorial(a2 - a1)\n        count *= a3\n    print(count % 1000000007)", "from math import comb\nt = int(input())\nfor i in range(t):\n    (n, k) = tuple(map(int, input().split()))\n    list1 = list(map(int, input().split()))\n    list1.sort()\n    d1 = {}\n    for element in list1[::-1]:\n        if element in d1:\n            d1[element] += 1\n        else:\n            d1[element] = 1\n    for key in d1:\n        if d1[key] >= k:\n            print(comb(d1[key], k) % 1000000007)\n            break\n        else:\n            k -= d1[key]", "from math import comb\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=1)\n    n = a.count(a[k - 1])\n    r = a[:k].count(a[k - 1])\n    print(comb(n, r) % (10 ** 9 + 7))", "def binomial(n, k):\n    if not 0 <= k <= n:\n        return 0\n    b = 1\n    for t in range(min(k, n - k)):\n        b *= n\n        b //= t + 1\n        n -= 1\n    return b\nfor t in range(0, int(input())):\n    (n, k) = tuple(map(int, input().split()))\n    a = list(map(int, input().split()))\n    if k == 0:\n        print(0)\n    elif n == 1:\n        print(1)\n    else:\n        a = sorted(a, reverse=True)\n        i = 0\n        count = 0\n        nums = []\n        while count < k:\n            nums.append(a[i])\n            i += 1\n            count += 1\n        mn = min(nums)\n        x = nums.count(mn)\n        y = a.count(mn)\n        ans = binomial(y, x)\n        print(ans % (10 ** 9 + 7))", "from math import factorial\nR = lambda : list(map(int, input().split()))\n\ndef ncr(n, r):\n    return factorial(n) // (factorial(r) * factorial(n - r))\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k) = R()\n    a = R()\n    counter = {}\n    for i in a:\n        counter[i] = counter.get(i, 0) + 1\n    keys = sorted(counter)[::-1]\n    h = 0\n    way = 0\n    for f in keys:\n        if h + counter[f] < k:\n            h += counter[f]\n        else:\n            way += ncr(counter[f], k - h)\n            break\n    print(way % mod)", "from math import factorial\n\ndef nCk(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    worst = a[k - 1]\n    count = a.count(worst)\n    picked = 0\n    for i in a:\n        if i == worst:\n            break\n        picked += 1\n    topick = k - picked\n    ans = nCk(count, topick)\n    print(ans % 1000000007)", "import sys\nMOD = 1000000007\nimport math\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return int(sys.stdin.readline())\n\ndef get_line():\n    return sys.stdin.readline().strip()\n\ndef write_line(out):\n    return sys.stdout.write(str(out) + '\\n')\n\ndef solve():\n    (n, k) = get_ints()\n    followers = list(get_ints())\n    followers.sort(reverse=True)\n    count = followers.count(followers[k - 1])\n    i = k - 1\n    r = 0\n    while i >= 0 and followers[i] == followers[k - 1]:\n        r += 1\n        i -= 1\n    return math.comb(count, r) % MOD\nt = get_int()\nwhile t:\n    write_line(solve())\n    t -= 1", "mod = 1000000007\nfact = list()\nfact.append(1)\nfor i in range(1, 1001):\n    fact.append(fact[len(fact) - 1] * i)\n\ndef C(n, k):\n    return fact[n] // fact[k] // fact[n - k]\n\ndef solve():\n    s = input().split()\n    n = int(s[0])\n    k = int(s[1]) - 1\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    i = k\n    j = k\n    while i > -1 and a[i] == a[k]:\n        i -= 1\n    while j < n and a[j] == a[k]:\n        j += 1\n    res = C(j - i - 1, k - i) % mod\n    print(res)\nt = int(input())\nwhile t:\n    solve()\n    t -= 1", "mod = int(1000000000.0 + 7)\n\ndef fact(n):\n    ans = 1\n    for i in range(2, n + 1):\n        ans = ans * i\n    return ans\n\ndef comb(n, k):\n    ans = fact(n)\n    ans //= fact(k) * fact(n - k)\n    return ans % mod\nfor insjdfsdf in range(int(input())):\n    (n, k) = map(int, input().split())\n    L = list(map(int, input().split()))\n    us = [0 for i in range(n + 1)]\n    for i in range(n):\n        us[L[i]] += 1\n    L.sort(reverse=True)\n    ans = 1\n    least = L[k - 1]\n    for i in range(k):\n        x = L[i]\n        if x == least:\n            T = comb(us[x], k - i)\n            ans = ans * T\n            break\n    print(ans)", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nimport sys\nstdin = list(list(sys.stdin))\nt = int(stdin[0].strip())\nfor i in range(t):\n    inp = stdin[2 * i + 1].rstrip().split(' ')\n    n = int(inp[0])\n    k = int(inp[1])\n    a = [int(i) for i in stdin[2 * i + 2].rstrip().split(' ')]\n    a.sort(reverse=True)\n    x = a[k - 1]\n    start = a.index(x)\n    print(ncr(a.count(x), k - start, 10 ** 9 + 7))", "def ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    result = 1\n    if n > k:\n        d = {}\n        s = set()\n        for i in a:\n            if i not in d:\n                d[i] = 1\n                s.add(i)\n            else:\n                d[i] += 1\n        s = sorted(list(s))\n        s.reverse()\n        for i in s:\n            if k <= 0:\n                break\n            if d[i] <= k:\n                k -= d[i]\n            else:\n                n = d[i]\n                if 2 * k > n:\n                    k = n - k\n                result = ncr(n, k, 10 ** 9 + 7)\n                break\n    print(result)", "from math import comb\nMOD = 10 ** 9 + 7\n\ndef solve():\n    [n, k] = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    a.sort(reverse=True)\n    lo = 0\n    hi = n - 1\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if a[mid] > a[k - 1]:\n            lo = mid + 1\n        else:\n            hi = mid\n    l = lo\n    hi = n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if a[mid] < a[k - 1]:\n            hi = mid\n        else:\n            lo = mid + 1\n    r = lo\n    print(comb(r - l, k - l) % MOD)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from math import comb\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = {}\n    for i in l:\n        d[i] = d.get(i, 0) + 1\n    l.sort()\n    l.reverse()\n    temp1 = l[:k]\n    temp = set(temp1)\n    ans = 1\n    for i in temp:\n        ans *= comb(d[i], temp1.count(i))\n    print(ans % (10 ** 9 + 7))", "from math import comb\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    t = l[:k]\n    T = set(t)\n    d = dict()\n    for i in l:\n        d[i] = d.get(i, 0) + 1\n    ans = 1\n    for i in T:\n        ans *= comb(d[i], t.count(i))\n    print(ans % (10 ** 9 + 7))", "import sys\ninput = sys.stdin.readline\ngetint = lambda : int(input())\ngetints = lambda : [int(a) for a in input().split()]\n\ndef solve():\n    (n, k) = getints()\n    a = getints()\n    mod = 1000000007\n    counts = [0 for i in range(n + 1)]\n    for v in a:\n        counts[v] += 1\n    res = 1\n    pool = 0\n    for count in reversed(counts):\n        if k > count:\n            k -= count\n        else:\n            pool = count\n            break\n    if k >= pool // 2:\n        k = pool - k\n    for i in range(k):\n        res = res * (pool - i) // (1 + i)\n    print(res % mod)\nt = getint()\nfor i in range(t):\n    solve()", "from math import comb\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    s = k\n    l = list(map(int, input().split()))\n    tot = 1\n    for i in range(n):\n        d = max(l)\n        f = l.count(d)\n        for a in range(f):\n            l.remove(d)\n        k = k - f\n        if k == 0:\n            print(1)\n            break\n        elif k < 0:\n            k = k + f\n            print(comb(f, k) % (1000000000 + 7))\n            break", "from math import factorial\nn = int(input())\nfor k in range(n):\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b.sort()\n    temp = b[a[0] - a[1]:]\n    not_chosen = b[:a[0] - a[1]]\n    if not_chosen.count(b[a[0] - a[1]]) > 0:\n        possible = temp.count(b[a[0] - a[1]]) + not_chosen.count(b[a[0] - a[1]])\n        need = temp.count(b[a[0] - a[1]])\n        x = factorial(possible) // factorial(possible - need)\n        y = factorial(need)\n        z = x // y\n        print(z % 1000000007)\n    else:\n        print(1)", "from math import comb\n\ndef choose():\n    for i in range(int(input())):\n        (n, k) = list(map(int, input().split()))\n        li = sorted(list(map(int, input().split())), reverse=True)\n        y = li.count(li[k - 1])\n        x = li[:k].count(li[k - 1])\n        print(comb(y, x) % (10 ** 9 + 7))\nchoose()", "import math\nfrom itertools import combinations\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    ls = list(map(int, input().split()))\n    ls.sort(reverse=True)\n    sum = 0\n    if ls[k - 1] not in ls[k:]:\n        print(1)\n    else:\n        s = ls.count(ls[k - 1])\n        m = ls[0:k].count(ls[k - 1])\n        print(math.comb(s, m) % (10 ** 9 + 7))", "from collections import Counter\nfrom math import comb\n\ndef advertising_agency(lst, k):\n    s = set(lst)\n    s = list(s)\n    s.sort()\n    s = s[::-1]\n    d = Counter(lst)\n    result = 1\n    i = 0\n    while k > 0:\n        n = d[s[i]]\n        if k >= n:\n            k -= n\n        else:\n            result *= comb(n, k)\n            k = 0\n        i += 1\n    return result % (10 ** 9 + 7)\nn = int(input())\nfor i in range(n):\n    input1 = [int(x) for x in input().split()]\n    input2 = [int(x) for x in input().split()]\n    print(advertising_agency(input2, input1[1]))", "t = int(input())\nfrom math import comb\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    match = 0\n    val = -1\n    for j in range(k):\n        if A[n - 1 - j] == val:\n            match += 1\n        else:\n            match = 1\n            val = A[-1 - j]\n    math_2 = 0\n    for j in range(n - k - 1, -1, -1):\n        if A[j] == val:\n            math_2 += 1\n        else:\n            break\n    print(comb(match + math_2, match) % (10 ** 9 + 7))", "from math import comb\n\ndef main(n, k, s):\n    s.sort()\n    t = max(s)\n    prod = 1\n    arr = [0 for i in range(t + 1)]\n    for i in range(n):\n        arr[s[i]] += 1\n    for i in range(t, 0, -1):\n        if k == 0 or k < 0:\n            break\n        m = arr[i]\n        if m == 0:\n            continue\n        if k >= m:\n            k = k - m\n            continue\n        else:\n            p = comb(m, k)\n            prod = prod * p\n            k = k - m\n    return prod % 1000000007\nm = int(input())\nfor _ in range(m):\n    (n, k) = map(int, input().split())\n    s = list(map(int, input().strip().split()))\n    print(main(n, k, s))", "import math\nimport sys\nfrom collections import *\nfrom time import sleep\ninput = sys.stdin.readline\nMOD = int(10 ** 9 + 7)\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\nt = inp()\nret = []\nfor i in range(t):\n    (n, k) = inlt()\n    l = inlt()\n    ls = Counter(l)\n    keys = sorted(ls.keys(), reverse=True)\n    for key in keys:\n        k -= ls[key]\n        if k <= 0:\n            ret.append(math.comb(ls[key], k + ls[key]) % MOD)\n            break\nfor r in ret:\n    print(r)", "mod = 10 ** 9 + 7\nfrom math import comb\nfor _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n    n = a.count(a[k - 1])\n    r = a[:k].count(a[k - 1])\n    print(comb(n, r) % mod)"]