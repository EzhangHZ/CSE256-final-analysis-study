["import sys\ninput = sys.stdin.readline\nfrom collections import deque, Counter\n\ndef main():\n    N = int(input())\n    (A, B, C, cb, cc) = ([], [], [], [0, 0], [0, 0])\n    E = [[] for _ in range(N)]\n    for _ in range(N):\n        (a, b, c) = map(int, input().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n        cb[b] += 1\n        cc[c] += 1\n    for _ in range(N - 1):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        E[u].append(v)\n        E[v].append(u)\n    if cb[0] != cc[0]:\n        print(-1)\n        return\n    R = [-1] * N\n    V = [-1] * N\n    V[0] = A[0]\n    d = deque(E[0])\n    for v in E[0]:\n        R[v] = 0\n    T = [0]\n    while d:\n        v = d.popleft()\n        T.append(v)\n        V[v] = min(V[R[v]], A[v])\n        for w in E[v]:\n            if V[w] == -1:\n                d.append(w)\n                R[w] = v\n    RT = T[::-1]\n    Hzero = [0] * N\n    Hone = [0] * N\n    ans = 0\n    for v in RT:\n        if B[v] != C[v]:\n            if B[v] == 0:\n                Hzero[v] += 1\n            else:\n                Hone[v] += 1\n        if Hzero[v] > 0 and Hone[v] > 0:\n            m = min(Hone[v], Hzero[v])\n            ans += m * V[v] * 2\n            Hzero[v] -= m\n            Hone[v] -= m\n        if v != 0:\n            Hzero[R[v]] += Hzero[v]\n            Hone[R[v]] += Hone[v]\n    print(ans)\nmain()", "import sys\nimport threading\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    a = [0] * n\n    b = [0] * n\n    c = [0] * n\n    for i in range(n):\n        (a[i], b[i], c[i]) = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (x, y) = map(int, input().split())\n        g[x - 1].append(y - 1)\n        g[y - 1].append(x - 1)\n    _01 = [0] * n\n    _10 = [0] * n\n\n    def dfs(u, p=-1):\n        res = 0\n        for v in g[u]:\n            if v != p:\n                a[v] = min(a[v], a[u])\n                res += dfs(v, u)\n                _01[u] += _01[v]\n                _10[u] += _10[v]\n        if b[u] != c[u]:\n            if b[u] == 0:\n                _01[u] += 1\n            else:\n                _10[u] += 1\n        m = min(_01[u], _10[u])\n        res += 2 * m * a[u]\n        _01[u] -= m\n        _10[u] -= m\n        return res\n    ans = dfs(0)\n    print('-1') if _01[0] > 0 or _10[0] > 0 else print(ans)\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "import sys\ninput = sys.stdin.readline\nfrom collections import deque as dq\n\ndef main():\n    N = int(input())\n    (A, B, C, cb, cc) = ([], [], [], [0, 0], [0, 0])\n    E = [[] for _ in range(N)]\n    for _ in range(N):\n        (a, b, c) = map(int, input().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n        cb[b] += 1\n        cc[c] += 1\n    for _ in range(N - 1):\n        (u, v) = map(lambda x: int(x) - 1, input().split())\n        E[u].append(v)\n        E[v].append(u)\n    if cb[0] != cc[0]:\n        print(-1)\n        return\n    (R, V) = ([-1] * N, [-1] * N)\n    (V[0], d) = (A[0], dq(E[0]))\n    T = [0]\n    for v in E[0]:\n        R[v] = 0\n    while d:\n        v = d.popleft()\n        T.append(v)\n        V[v] = min(V[R[v]], A[v])\n        for w in E[v]:\n            if V[w] == -1:\n                d.append(w)\n                R[w] = v\n    RT = T[::-1]\n    (Hzero, Hone, ans) = ([0] * N, [0] * N, 0)\n    for v in RT:\n        if B[v] != C[v]:\n            if B[v] == 0:\n                Hzero[v] += 1\n            else:\n                Hone[v] += 1\n        if Hzero[v] > 0 and Hone[v] > 0:\n            m = min(Hone[v], Hzero[v])\n            ans += m * V[v] * 2\n            Hzero[v] -= m\n            Hone[v] -= m\n        if v != 0:\n            Hzero[R[v]] += Hzero[v]\n            Hone[R[v]] += Hone[v]\n    print(ans)\nmain()", "import sys\nreadline = sys.stdin.readline\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\n\ndef solve():\n    n = ni()\n    data = [tuple(nm()) for _ in range(n)]\n    sb = sum((x[1] for x in data))\n    sc = sum((x[2] for x in data))\n    if sb != sc:\n        print(-1)\n        return\n    G = [list() for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = nm()\n        u -= 1\n        v -= 1\n        G[u].append(v)\n        G[v].append(u)\n    q = [0]\n    cost = [x[0] for x in data]\n    dp = [None] * n\n    ans = 0\n    while q:\n        v = q[-1]\n        if dp[v] is None:\n            dp[v] = [-1, -1]\n            for x in G[v]:\n                if dp[x] is None:\n                    if cost[x] > cost[v]:\n                        cost[x] = cost[v]\n                    q.append(x)\n        else:\n            q.pop()\n            dp[v] = [0, 0]\n            if data[v][1] != data[v][2]:\n                dp[v][data[v][1]] += 1\n            for x in G[v]:\n                (a, b) = dp[x]\n                if a >= 0:\n                    dp[v][0] += a\n                    dp[v][1] += b\n            c = min(dp[v])\n            ans += c * cost[v] * 2\n            dp[v][0] -= c\n            dp[v][1] -= c\n    print(ans)\n    return\nsolve()", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    inf = 10 ** 16\n    n = II()\n    abc = LLI(n)\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v) = MI1()\n        to[u].append(v)\n        to[v].append(u)\n    dp = [-1] * n\n    cnt = [[0] * 2 for _ in range(n + 1)]\n    stack = [(0, n, inf)]\n    while stack:\n        (u, pu, mn) = stack.pop()\n        if dp[u] == -1:\n            (a, b, c) = abc[u]\n            mn = min(mn, a)\n            if b + c == 1:\n                cnt[u][b] += 1\n            dp[u] = 0\n            stack.append((u, pu, mn))\n            for v in to[u]:\n                if v == pu:\n                    continue\n                stack.append((v, u, mn))\n        else:\n            k = min(cnt[u])\n            dp[u] = mn * k * 2\n            cnt[pu][0] += cnt[u][0] - k\n            cnt[pu][1] += cnt[u][1] - k\n    if sum(cnt[n]):\n        print(-1)\n    else:\n        print(sum(dp))\nmain()", "n = int(input())\naa = [None]\nmm0 = [None]\nmm1 = [None]\nfor _ in range(n):\n    (a, b, c) = map(int, input().split())\n    aa.append(a)\n    m0 = m1 = 0\n    if b != c:\n        if b == 0:\n            m0 = 1\n        else:\n            m1 = 1\n    mm0.append(m0)\n    mm1.append(m1)\ng = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    (u, v) = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\nq = [1]\npar = [-1] * (n + 1)\npar[1] = 1\ndepths = [0] * (n + 1)\nroot_to_leaves = [1]\nwhile q:\n    u = q.pop()\n    for v in g[u]:\n        if par[v] != -1:\n            continue\n        par[v] = u\n        depths[v] = depths[u] + 1\n        aa[v] = min(aa[v], aa[u])\n        q.append(v)\n        root_to_leaves.append(v)\nans = 0\nfor u in reversed(root_to_leaves):\n    m = min(mm0[u], mm1[u])\n    ans += aa[u] * m\n    mm0[u] -= m\n    mm1[u] -= m\n    mm0[par[u]] += mm0[u]\n    mm1[par[u]] += mm1[u]\nprint(ans * 2 if mm0[1] == mm1[1] == 0 else -1)"]