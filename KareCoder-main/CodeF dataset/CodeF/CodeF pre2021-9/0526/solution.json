["(n, k) = map(int, input().split())\ns = input()\nres = 1\nfor i in range(n):\n    if s[i] < s[i % res]:\n        res = i + 1\n    elif s[i] > s[i % res]:\n        break\nprint((s[:res] * (k // res + 1))[:k])", "(n, k) = map(int, input().split())\ns = input()\nans = 1\nfor i in range(n):\n    if s[i] < s[i % ans]:\n        ans = i + 1\n    elif s[i] > s[i % ans]:\n        break\nprint((s[:ans] * (k // ans + 1))[:k])", "(n, k) = map(int, input().split())\ns = input()\nans = s[0] * k\nfor i in range(1, n):\n    c = i + 1\n    pr = s[0:i + 1]\n    while c < k:\n        pr *= 2\n        c = len(pr)\n    ans = min(ans, pr)\nprint(ans[0:k])", "(n, p) = map(int, input().split())\ns = list(input())\nj = n\ni = 1\nwhile i < n:\n    if s[i] > s[0]:\n        j = i\n        break\n    elif s[i] == s[0]:\n        k = i\n        l = 0\n        while k < n and s[k] == s[l]:\n            k += 1\n            l += 1\n        if k >= n or s[k] > s[l]:\n            j = i\n            break\n        else:\n            i = k\n    else:\n        i += 1\nprint((''.join(s[:j]) * p)[:p])", "import math\n(n, k) = map(int, input().split())\ns = input()\nj = k\nlst = list()\nfor i in range(len(s)):\n    s2 = s[:i + 1] * j\n    j = math.ceil(k / (i + 1))\n    lst.append(s2[:k])\nprint(min(lst))", "(n, k) = map(int, input().split())\ns = input()\nx = ''\nfor i in range(n):\n    if i == 0:\n        x += s[i]\n        r = k // n + 1\n        q = (s * r)[:k]\n    else:\n        r = k // len(x) + 1\n        p = (x * r)[:k]\n        if p < q:\n            break\n        x += s[i]\nr = k // len(x) + 1\nprint((x * r)[:k])", "import sys\nimport os\nif 'CP_LOCAL' in os.environ:\n    sys.stdin = open('codeforces/input.txt', 'r')\n    sys.stdout = open('codeforces/output.txt', 'w')\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n(n, k) = inlt()\nalp = insr()\nmc = 0\nct = 1\n(l, r) = (0, len(alp) - 1)\nfor i in range(1, len(alp)):\n    if alp[i] > alp[mc]:\n        break\n    ct += 1\n    if alp[i] == alp[mc]:\n        mc += 1\n    else:\n        mc = 0\nwhile mc:\n    ct -= 1\n    mc -= 1\nsub = ''.join(alp[:ct])\nres = sub[:k]\nwhile len(res) < k:\n    res += res\nprint(res[:k])", "def sol(A, k):\n    ans = 'z' * k\n    for i in range(1, len(A) + 1):\n        a = A[:i]\n        ans = min(ans, a * (k // i) + a[:k % i])\n    return ans\nA = list(map(int, input().split()))\nB = input()\nprint(sol(B, A[1]))", "(n, k) = map(int, input().split())\ns = input()\nf = s[0]\nidx = n\nfor i in range(1, n):\n    if ord(s[i]) > ord(f):\n        idx = i\n        break\n    elif s[i] == f:\n        temp = s + s\n        q = 2 * n // i\n        temp1 = (q + 1) * s[:i]\n        if temp1 < temp:\n            idx = i\n            break\nsn = s[0:idx]\nn = len(sn)\nq = k // n\nans = ''\nans += (q + 1) * sn\nans = ans[0:k]\nprint(ans)", "(n, k) = map(int, input().split())\ns = input()\nans = n\nm = s[0]\nfor i in range(1, n):\n    if s[i] > m:\n        ans = i\n        break\n    elif s[i] == m:\n        a = s[i:]\n        b = s[:len(a)]\n        if a >= b:\n            ans = i\n            break\nns = s[:ans]\nwhile len(ns) < k:\n    ns = ns + ns\nprint(ns[:k])", "(n, k) = map(int, input().split())\ns = input()\nunit = s[0]\nwhile True:\n    i = 0\n    test = s + unit\n    while i < len(s) and unit == test[i:i + len(unit)]:\n        i += len(unit)\n    while i < len(s) and unit > test[i:i + len(unit)]:\n        i += 1\n    if i == len(unit):\n        break\n    unit = test[:i]\nprint(unit * (k // len(unit)) + unit[:k % len(unit)])", "def cpy_tll(s, k):\n    s = s * (k // len(s) + 1)\n    s = s[:k]\n    return s\n(n, k) = map(int, input().split())\ns = input()\npref = s[0]\nans = s[0] * k\nfor i in s[1:]:\n    if i <= s[0]:\n        pref += i\n    else:\n        break\n    ans = min(ans, cpy_tll(pref, k))\nprint(ans)", "(n, k) = map(int, input().split())\ns = input()\np = ''\np += s[0]\nj = 1\nfor i in range(1, len(s)):\n    if s[i] > s[i % j]:\n        break\n    if s[i] < s[i % j]:\n        j = i + 1\nans = ''\nfor i in range(0, k):\n    ans += s[i % j]\nprint(ans)", "(n, k) = map(int, input().split())\n\ndef get_pref(pref, k):\n    while len(pref) < k:\n        pref += pref\n    return pref[:k]\nstring = input()\nmn = get_pref(string[0], k)\nfor i in range(1, len(string)):\n    if string[0] < string[i]:\n        break\n    mn = min(mn, get_pref(string[:i + 1], k))\nprint(mn)", "from math import ceil\n(n, k) = map(int, input().split())\ns = input()\nif n != 1:\n    if n < k:\n        s = s * ceil(k / n)\n    i = 1\n    while i < n and s[i] < s[0]:\n        i += 1\n    min_str = s[:i]\n    while i < n and s[i:i * 2] <= min_str:\n        min_str += s[i]\n        i += 1\n    if i < k:\n        min_str = min_str * ceil(k / i)\n    min_str = min_str[:k]\nelse:\n    min_str = s * k\nprint(min_str)", "(n, k) = map(int, input().split())\ns = input()\nl = ''\nl = l + s[0]\nj = 0\nfor i in range(1, n):\n    if s[i] > l[j]:\n        break\n    elif s[i] < l[j]:\n        l = l + s[i]\n        j = 0\n    elif s[i] == l[j]:\n        l = l + s[i]\n        j = j + 1\np = len(l)\nr = l[:p - j]\nm = len(r)\ns = r * (k // m)\nfor i in range(k % m):\n    s = s + r[i]\nprint(s)", "from heapq import heapify, heappush, heappop, heappushpop\nfrom collections import defaultdict as dd, deque as dq, Counter as C\nfrom math import factorial as f, ceil, gcd, sqrt, log\nfrom bisect import bisect_left as bl, bisect_right as br\nfrom itertools import combinations as c, permutations as p\nfrom math import factorial as f, ceil, gcd, sqrt, log\nfrom sys import stdin\ninput = stdin.readline\nmp = lambda : map(int, input().split())\nit = lambda : int(input())\nls = lambda : list(input().strip())\nmt = lambda r: [ls() for _ in range(r)]\nlcm = lambda a, b: a * b // gcd(a, b)\n\ndef fibo_n(n):\n    return ((1 + sqrt(5)) / 2) ** n / sqrt(5)\n(a, b) = mp()\ns = input().strip()\nstart = 0\nend = 1\nfinalend = 1\nwhile end != a:\n    if s[start] > s[end]:\n        finalend = end + 1\n        start = 0\n        end += 1\n    elif s[start] == s[end]:\n        start += 1\n        end += 1\n    else:\n        break\nst = s[:finalend]\nprint((st * ceil(b / len(st)))[:b])", "(n, k) = map(int, input().split())\ns = input()\np = -1\ni = 0\nwhile i < n:\n    if s[i] > s[0]:\n        p = i\n        break\n    elif s[i] == s[0]:\n        j = i + 1\n        z = 1\n        while j < n and z < i and (s[j] == s[z]):\n            j += 1\n            z += 1\n        if j < n and z < i and (s[j] > s[z]):\n            p = i\n            break\n        i = j - 1\n    i += 1\nif p != -1:\n    s = s[:p]\ni = len(s) - 1\nwhile i > 0 and s[i] == s[0]:\n    i -= 1\ns = s[:i + 1]\nprint(s * (k // len(s)) + s[:k % len(s)])", "(n, k) = [int(d) for d in input().split()]\ns = input()\nif len(s) == 1:\n    print(s * k)\nelse:\n    x = s[0]\n    done = True\n    i = 1\n    get = False\n    idx = 0\n    curr = 0\n    while i < len(s) and done == True:\n        if s[i] < s[curr]:\n            x = x + s[i]\n            if curr != 0:\n                curr = 0\n                get = False\n            i = i + 1\n        elif s[i] == s[curr]:\n            x = x + s[i]\n            curr = curr + 1\n            if get == False:\n                idx = i\n                get = True\n            i = i + 1\n        else:\n            break\n    if get == True:\n        x = x[:idx]\n    full = k // len(x)\n    rem = k - full * len(x)\n    res = x * full + x[:rem]\n    print(res)", "(n, k) = map(int, input().split())\ns = input()\nans = 1\nfor i in range(n):\n    if s[i] < s[i % ans]:\n        ans = i + 1\n    elif s[i] > s[i % ans]:\n        break\nprint((s[:ans] * (k // ans + 1))[:k])", "import math, bisect\n(n, k) = map(int, input().split())\na = input()\nind1 = 0\nx = 0\nind2 = 1\nz = 1\nans = a\nwhile ind2 != n:\n    if a[ind1] == a[ind2]:\n        if x == 0:\n            z = ind2\n            x = 1\n        ind1 += 1\n    elif a[ind1] > a[ind2]:\n        x = 0\n        z = ind2 + 1\n        ind1 = 0\n    else:\n        break\n    ind2 += 1\nans = a[:z]\nb = ''\nl = len(ans)\nfor i in range(k):\n    b += ans[i % l]\nprint(b)", "(n, k) = map(int, input().split())\ns = input()\nans = n\nfor i in range(1, n):\n    if ord(s[i]) < ord(s[0]):\n        continue\n    j = 0\n    x = i\n    while i < n:\n        if s[i] == s[j]:\n            i += 1\n            j += 1\n        else:\n            break\n    if i == n:\n        ans = x\n        break\n    if ord(s[j]) < ord(s[i]):\n        ans = x\n        break\nans = s[:ans]\nm = len(ans)\nwhile m < k:\n    m += m\n    ans += ans\nprint(ans[:k])", "(n, m) = map(int, input().split())\ns = input()\nnow = len(s)\nfor _ in range(1, n):\n    if s < s[_:] or s.startswith(s[_:]):\n        now = _\n        break\ni = 0\nwhile m != 0:\n    print(s[i], end='')\n    i = i + 1\n    m = m - 1\n    if i == now:\n        i = 0", "import sys\n(n, k) = map(int, sys.stdin.readline().split())\ndata = sys.stdin.readline().rstrip()\n(left, right) = (0, 0)\nfor i in range(1, len(data)):\n    if data[left] > data[i]:\n        left = 0\n        right = i\n    elif data[left] == data[i]:\n        left += 1\n    else:\n        break\nans = data[:right + 1]\nwhile len(ans) < k:\n    ans += ans\nprint(ans[:k])", "from math import ceil\n\ndef cin():\n    return map(int, input().split())\n\ndef process(pivot, k):\n    while len(pivot) < k:\n        pivot *= 2\n    return pivot[:k]\n(n, k) = cin()\nstring = input()\npivot = string * ceil(k / n)\nfor i in range(n - 1, -1, -1):\n    pivot = min(pivot, process(string[:i + 1], k))\nprint(pivot)", "import math\nimport random\nfrom collections import Counter, deque\nfrom sys import stdout\nimport time\nfrom math import factorial, log, gcd\nimport sys\nfrom decimal import Decimal\nimport heapq\n\ndef S():\n    return sys.stdin.readline().split()\n\ndef I():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef IS():\n    return sys.stdin.readline().replace('\\n', '')\n\ndef main():\n    (n, k) = I()\n    s = IS()\n    o = s[0]\n    if n == 1:\n        print(o * k)\n        return\n    mn = min(n, k)\n    idx = 1\n    ans_string = o\n    while idx < mn:\n        el = s[idx]\n        if el < o:\n            ans_string += el\n            idx += 1\n        elif el > o:\n            break\n        else:\n            new_idx_1 = 0\n            new_idx_2 = idx\n            flag = False\n            while new_idx_2 < mn - 1:\n                new_idx_2 += 1\n                new_idx_1 += 1\n                if s[new_idx_2] < s[new_idx_1]:\n                    flag = True\n                    ans_string += s[idx:new_idx_2]\n                    idx = new_idx_2\n                    break\n                elif s[new_idx_2] > s[new_idx_1]:\n                    break\n            if not flag:\n                break\n    _len = idx\n    print((ans_string * (k // _len + 1))[:k])\nmain()", "(n, k) = map(int, input().split())\ns = input()\nl = 0\npos = 0\nn = len(s)\nwhile l < n:\n    temp = s[:pos + 1] * ((l + 1) // (pos + 1) + 1)\n    if s[:l + 1] < temp[:l + 1]:\n        pos = l\n    l += 1\nres = s[:pos + 1] * (k // (pos + 1) + 1)\nprint(res[:k])", "(n, k) = [int(i) for i in input().split(' ')]\ns = input()\nnew = []\nfor i in range(1, n + 1):\n    a = s[:i]\n    while len(a) < k:\n        a += a\n    new.append(a[:k])\nnew.sort()\nprint(new[0])", "def readline():\n    return map(int, input().split())\n\ndef main():\n    (n, k) = readline()\n    s = list(map(ord, input()))\n    if len(s) > k:\n        s = s[:k]\n    prefix = 0\n    i = 0\n    for i in range(1, len(s)):\n        if s[i] > s[prefix]:\n            s = s[:i]\n            break\n        elif s[i] == s[prefix]:\n            prefix += 1\n        else:\n            prefix = 0\n    if prefix:\n        s = s[:-prefix]\n    s *= (k - 1) // len(s) + 1\n    print(''.join(map(chr, s[:k])))\nmain()", "(n, k) = list(map(int, input().split()))\ns = input()\nans = s[0] * k\nfor i in range(1, n):\n    x = s[:i + 1] * (k // (i + 1)) + s[:k % (i + 1)]\n    ans = min(x, ans)\nprint(ans)", "from math import ceil\n(n, k) = map(int, input().split())\ns = input()\nans = 'z' * 10 ** 6\nfor i in range(1, n + 1):\n    temp = s[:i] * ceil(k / i)\n    temp = temp[:k]\n    if temp < ans:\n        ans = temp\nprint(ans)", "(n, k) = map(int, input().split(' '))\ns = input()\nss = 2 * s\npos = n\nfor i in range(1, n):\n    if ss[:i] < ss[i:2 * i]:\n        pos = i\n        break\nans = s[:pos] * (1 + k // pos)\nprint(ans[:k])", "(n, k) = map(int, input().split())\ns = input()\nans = n\nm = s[0]\nfor i in range(1, n):\n    if s[i] > m:\n        ans = i\n        break\n    elif s[i] == m:\n        a = s[i:]\n        b = s[:len(a)]\n        if a >= b:\n            ans = i\n            break\n    m = max(s[i], m)\nns = s[:ans]\nwhile len(ns) < k:\n    ns = ns + ns\nprint(ns[:k])", "import sys\n(n, q) = map(int, sys.stdin.readline().split())\nstring = sys.stdin.readline().rstrip()\np = 0\ni = 1\nwhile i < len(string):\n    if string[i] < string[p]:\n        i += 1\n        p = 0\n    elif string[i] == string[p]:\n        i += 1\n        p += 1\n    else:\n        break\nst = string[:i - p]\nl = len(st)\nanswer = st * (q // l)\nanswer += st[:q % l]\nprint(answer)", "(n, k) = map(int, input().split())\ns = input()\nans = ''\nfor i in range(n):\n    st = s[:i + 1]\n    while len(st) <= k:\n        st += st\n    if ans == '':\n        ans = st[:k]\n    else:\n        ans = min(ans, st[:k])\nprint(ans)", "from math import ceil\nfrom sys import stdin\ninput = stdin.readline\n\ndef f(s, k):\n    ind = len(s)\n    mn = s[0] * k\n    for i in range(1, len(s)):\n        if s[i] > s[0]:\n            ind = i\n            break\n        l = s[:i + 1] * (k // (i + 1) + 1)\n        mn = min(mn, l[:k])\n    return mn\n(a, b) = map(int, input().strip().split())\nprint(f(input().strip(), b))", "(n, k) = map(int, input().split())\ns = input()\nans = 'z' * (k + 1)\nfor i in range(n):\n    ref = str()\n    ref = s[:i + 1]\n    while len(ref) < k:\n        ref = ref + ref\n    ref = ref[:k]\n    ans = min(ans, ref)\nprint()\nprint(ans)", "def findAns(s, k):\n    res = 'z' * k\n    for i in range(1, len(s) + 1):\n        u = s[:i]\n        while len(u) < k:\n            u = u + u\n        res = min(res, u[:k])\n    return res\n(n, k) = [int(x) for x in input().split(' ')]\ns = str(input())\nprint(findAns(s, k))", "(n, k) = map(int, input().split())\ns = input()\nprint(min([(s[:i + 1] * (k // (i + 1) + 1))[:k] for i in range(n)]))", "(n, k) = map(int, input().split())\n\ndef get_pref(pref, k):\n    while len(pref) < k:\n        pref += pref\n    return pref[:k]\nstring = input()\nmn = get_pref(string[0], k)\nfor i in range(1, len(string)):\n    if string[0] < string[i]:\n        break\n    mn = min(mn, get_pref(string[:i + 1], k))\nprint(mn)", "(n, k) = map(int, input().split())\ns = input()\nprint(min([(s[:i + 1] * (k // (i + 1) + 1))[:k] for i in range(n)]))", "(n, k) = map(int, input().split())\nss = input()\nmn = 'z' * k\nfor i in range(n):\n    s = ss[:n - i]\n    while True:\n        if len(s * 2) > k:\n            break\n        else:\n            s = s * 2\n    if len(s) == k:\n        if s < mn:\n            mn = s\n    else:\n        p = s * 2\n        q = p[:k]\n        if q < mn:\n            mn = q\n        if k % 2 == 0:\n            r = s[:k // 2]\n            r = r * 2\n            if r < mn:\n                mn = r\nprint(mn)", "(n, k) = map(int, input().split())\nss = input()\nmn = 'z' * k\nfor i in range(n):\n    s = ss[:n - i]\n    while True:\n        if len(s * 2) > k:\n            break\n        else:\n            s = s * 2\n    if len(s) == k:\n        if s < mn:\n            mn = s\n    else:\n        p = s * 2\n        q = p[:k]\n        if q < mn:\n            mn = q\nprint(mn)", "(n, k) = map(int, input().split())\ns = input()\nfor i in range(n):\n    if s[i] > s[0]:\n        s = s[:i]\n        break\nwhile True:\n    prevlen = len(s)\n    for i in range(1, prevlen):\n        if s[i] == s[0]:\n            tmp = s[i:] + s\n            tmp2 = s\n            if tmp[:prevlen] > tmp2:\n                s = s[:i]\n                break\n    if len(s) == prevlen:\n        break\nans = ''\nwhile len(ans) < k:\n    ans += s\nwhile len(ans) > k:\n    ans = ans[:-1]\nprint(ans)", "import sys\n\ndef input():\n    return sys.stdin.readline()\n(n, k) = map(int, input().split())\ns = input().strip()\nfor i in range(n):\n    if s[i] > s[0]:\n        s = s[:i]\n        break\nprevlen = len(s)\nfor i in range(1, prevlen):\n    if s[i] == s[0]:\n        tmp = s[i:] + s\n        tmp2 = s\n        if tmp[:prevlen] > tmp2:\n            s = s[:i]\n            break\nans = ''\nans = s * (k // len(s) + 1)\nprint(ans[:k])", "import sys, io, os\n\ndef fast_i():\n    s = sys.stdin.readline().strip()\n    return s\n(n, k) = map(int, fast_i().split())\ns = fast_i().strip()\nfor i in range(n):\n    if s[i] > s[0]:\n        s = s[:i]\n        break\nprevlen = len(s)\nfor i in range(1, prevlen):\n    if s[i] == s[0]:\n        tmp = s[i:] + s\n        tmp2 = s\n        if tmp[:prevlen] > tmp2:\n            s = s[:i]\n            break\nans = ''\nans = s * (k // len(s) + 1)\nsys.stdout.write(ans[:k] + '\\n')", "from math import *\n(n, k) = [int(i) for i in input().split()]\na = input()\nb = (a * ceil(k / n))[:k]\nci = 0\nmb = -1\nind = -1\nfor i in range(1, k):\n    if ord(b[ci]) < ord(b[i]):\n        ind = i\n        if mb != -1:\n            ind = mb\n        break\n    elif ord(b[ci]) == ord(b[i]):\n        ci += 1\n        if mb == -1:\n            mb = i\n    elif ord(b[ci]) > ord(b[i]):\n        ci = 0\n        mb = -1\nans = ''\nif ind == -1:\n    ans = b\nelse:\n    c = b[:ind]\n    ans = (c * ceil(k / ind))[:k]\nprint(ans)", "import itertools\n\ndef validate_prefix(s, prefix):\n    n = len(s)\n    source = 0\n    for i in range(prefix, n):\n        if s[i] > s[source]:\n            return prefix\n        elif s[i] == s[source]:\n            source += 1\n            if source == prefix:\n                source = 0\n            continue\n        assert s[i] < s[source]\n        prefix = i + 1\n        source = 0\n    return prefix\n\ndef determine_initial_prefix(s):\n    prefix = 1\n    while True:\n        new_prefix = validate_prefix(s, prefix)\n        if new_prefix == prefix:\n            break\n        prefix = new_prefix\n    return prefix\n\ndef solve():\n    (n, k) = [int(x) for x in input().split()]\n    s = list(input())\n    pref = determine_initial_prefix(s)\n    return ''.join(itertools.islice(itertools.cycle(s[:pref]), k))\nprint(solve())", "(n, k) = map(int, input().split())\ns = input()\nmi = 'z' * k\nfor i in range(1, n + 1):\n    news = s[0:i]\n    mi = min(mi, news * (k // i) + news[0:k % i])\nprint(mi)", "(n, k) = [int(x) for x in input().split()]\ns = input()\nlal = ''\nl = []\nfor i in range(n):\n    lal += s[i]\n    string = lal * (k // (i + 1))\n    leftover = s[:k % (i + 1)]\n    l.append(string + leftover)\nprint(min(l))", "(n, k) = map(int, input().strip().split())\nstring = input()\nl = string * (k // n) + string[:k % n]\nfor i in range(1, n):\n    temp = string[:-i]\n    l = min(l, temp * (k // (n - i)) + temp[:k % (n - i)])\nprint(l)", "inp = input().split()\nlength = int(inp[0])\nrequired = int(inp[1])\ns = input()\ncount = 1\nfor i in range(1, length):\n    if s[i] > s[i % count]:\n        break\n    if s[i] < s[i % count]:\n        count = i + 1\nfor i in range(required):\n    print(s[i % count], end='')", "(n, k) = map(int, input().split())\ns = input()\nprint(min([(s[:i + 1] * (k // (i + 1) + 1))[:k] for i in range(n)]))", "(n, k) = map(int, input().split())\nstr = input()\nans = None\nfor i in range(1, len(str) + 1):\n    cnt = int(k / i)\n    if cnt * i != k:\n        cnt += 1\n    tmp = str[0:i] * cnt\n    if i == 1:\n        ans = tmp[:k]\n    elif tmp < ans:\n        ans = tmp[:k]\nprint(ans)", "from math import ceil\n(n, k) = list(map(int, input().split()))\ns = input()\ncur = ''\nans = 'z' * k\nfor i in range(n):\n    temp = cur + s[i]\n    x = ceil(k / len(temp))\n    temp = temp * x\n    temp = temp[:k]\n    cur += s[i]\n    ans = min(ans, temp)\nprint(ans)", "(n, k) = map(int, input().split())\ns = input()\nall_strings = []\nfor num in range(n, 0, -1):\n    m = k // num\n    new_s = s[:num]\n    all_strings.append(''.join((new_s for _ in range(m + 1)))[:k])\nprint(min(all_strings))", "def bestPref(s):\n    pref = s[0]\n    for i in range(1, len(s)):\n        ind = i % len(pref)\n        if pref[ind] < s[i]:\n            break\n        elif pref[ind] > s[i]:\n            while len(pref) < i + 1:\n                pref += s[len(pref)]\n    return pref\n\ndef solve(n, k, s):\n    pref = bestPref(s)\n    cur = ''\n    while len(cur) + len(pref) <= k:\n        cur += pref\n    cur += pref[:k - len(cur)]\n    return cur\n(n, k) = list(map(int, input().split()))\nans = solve(n, k, input())\nprint(ans)", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ns = str(input())\np = 1\nfor i in range(1, n):\n    if s[i % p] < s[i]:\n        break\n    if s[i % p] > s[i]:\n        p = i + 1\nx = m // p\ny = m - x * p\nprint(s[0:p] * x + s[0:y])", "def sec(init, i, e, flag):\n    i1 = i\n    while i < n and ord(s[init]) == ord(s[i]) and (init < i1):\n        init += 1\n        i += 1\n        e += 1\n    if i == n or (i != n and ord(s[init]) < ord(s[i])):\n        flag = 1\n    return (e, flag, i)\n(n, k) = map(int, input().split())\ns = input()\ninit = 0\ne = 1\ni = 1\nflag = 0\nwhile i < n:\n    if ord(s[i]) > ord(s[init]):\n        break\n    elif s[i] == s[init]:\n        e1 = e\n        (e, flag, i) = sec(init, i, e, flag)\n        if flag == 1:\n            e = e1\n            break\n        else:\n            init = 0\n            continue\n    e += 1\n    i += 1\nt = k // e + 1\ns = s[:e]\nx = s\nfor i in range(t):\n    s += x\nprint(*s[:k], sep='')", "(n, k) = map(int, input().split())\ns = input()\nans = ''\nfor i in range(1, len(s) + 1):\n    g = s[:i]\n    while len(g) < k:\n        g += g\n    g = g[:k]\n    if ans == '':\n        ans = g\n    if g < ans:\n        ans = g\nprint(ans)", "def string(c: str, k: int) -> str:\n    while len(c) < k:\n        c = c + c\n    if len(c) > k:\n        sub = len(c) - k\n        c = c[:len(c) - sub]\n    return c\n\ndef solution(n: int, k: int, s: str) -> None:\n    first = s[0]\n    lex = string(first, k)\n    for i in range(1, n):\n        if s[i] > s[0]:\n            break\n        first += s[i]\n        lex = min(lex, string(first, k))\n    print(lex)\n(n, k) = map(int, input().strip().split())\ns = input()\nsolution(n, k, s)", "def solve(N, K, A):\n    tok_size = 1\n    ti = 0\n    i = 1\n    while i < N:\n        if A[ti] > A[i]:\n            ti = 0\n            tok_size = i + 1\n        elif A[ti] == A[i]:\n            ti = (ti + 1) % tok_size\n        else:\n            break\n        i += 1\n    tok = A[:tok_size]\n    if len(tok) >= K:\n        return tok[:K]\n    else:\n        d = K // len(tok)\n        m = K % len(tok)\n        return tok * d + tok[:m]\n(N, K) = tuple(map(int, input().split()))\nA = input()\nprint(solve(N, K, A))", "(n, desired) = map(int, input().split())\ns = list(input())\nstack = [s[0]]\nptr = 0\nfor i in range(1, n):\n    if ptr == len(stack):\n        ptr = 0\n    if s[i] < stack[ptr]:\n        stack.append(s[i])\n        ptr = 0\n    elif s[i] == stack[ptr]:\n        stack.append(s[i])\n        ptr += 1\n    else:\n        stack = stack[:len(stack) - ptr]\n        break\nwhile stack[-1] == stack[0] and len(stack) > 1:\n    stack.pop()\nans = []\nfor i in range(desired):\n    ptr = i % len(stack)\n    ans.append(stack[ptr])\nprint(*ans, sep='')", "from math import ceil\n(n, k) = [int(s) for s in input().split(' ')]\ns = input()\nprefix_idx = 0\nidx = n - 1\nfor i in range(1, n):\n    if s[i] == s[prefix_idx]:\n        if idx == n - 1:\n            idx = i - 1\n        prefix_idx += 1\n    elif s[i] < s[prefix_idx]:\n        prefix_idx = 0\n        idx = n - 1\n    else:\n        if idx == n - 1:\n            idx = i - 1\n        break\nmultiply = ceil(k / (idx + 1))\nprint((s[:idx + 1] * multiply)[:k])", "from math import ceil\n(n, k) = [int(s) for s in input().split(' ')]\ns = input()\nprefix_idx = 0\nidx = n - 1\nfor i in range(1, n):\n    if s[i] == s[prefix_idx]:\n        if idx == n - 1:\n            idx = i - 1\n        prefix_idx += 1\n    elif s[i] < s[prefix_idx]:\n        prefix_idx = 0\n        idx = n - 1\n    else:\n        if idx == n - 1:\n            idx = i - 1\n        break\nmultiply = ceil(k / (idx + 1))\nprint((s[:idx + 1] * multiply)[:k])", "(n, k) = map(int, input().split(' '))\ns = input()\nbest_ss = s + s\nfor r in range(n - 1, 0, -1):\n    ss = s[:r] * (2 * n // r + 1)\n    if ss <= best_ss:\n        best_ss = ss\nwhile len(best_ss) < k:\n    best_ss += best_ss\nprint(best_ss[:k])", "def asmaller(a, b):\n    if len(a) == len(b):\n        return a < b\n    if len(a) > len(b):\n        return a < b + (len(a) - len(b)) * b[-1]\n(n, k) = map(int, input().split())\ns = input()\npref = s\nans = ''\nfor i in range(1, n):\n    if ord(s[i]) > ord(s[0]):\n        pref = s[:i]\n        break\n    elif ord(s[i]) == ord(s[0]):\n        if asmaller(s[:i], s[i:2 * i]):\n            pref = s[:i]\n            break\n        elif s[:i] == s[i:2 * i]:\n            if 2 * i < n and asmaller(s[:i], s[2 * i:]):\n                pref = s[:i]\n                break\nt = len(pref)\nfor i in range(k // t + 1):\n    ans += pref\nc = len(ans)\nfor j in range(c - k):\n    ans = ans[:-1]\nprint(ans)", "import math\n(n, k) = map(int, input().split())\ns = input()\nj = k\nlst = list()\nfor i in range(len(s)):\n    s2 = s[:i + 1] * j\n    j = math.ceil(k / (i + 1))\n    lst.append(s2[:k])\nprint(min(lst))", "from sys import stdin, stdout\nimport collections, heapq, bisect, math\ninput = stdin.readline\n\ndef rint():\n    return int(input())\n\ndef rstr():\n    return input().strip()\n\ndef rlstr():\n    return list(input().strip().split())\n\ndef rlint():\n    return list(map(int, input().split()))\n\ndef main():\n    (n, k) = rlint()\n    s = rstr()\n    x = s[0]\n    res = s * (k // n) + s[:k % n]\n    for i in range(1, n):\n        temp = x * (k // i) + x[:k % i]\n        if temp < res:\n            return temp\n        x += s[i]\n    return res\nprint(main())", "(n, k) = input().split(' ')\nn = int(n)\nk = int(k)\nstring_a = input()\nstrings = []\nfor i in range(n):\n    strings.append(string_a[:i + 1])\nfor i in range(n):\n    aux = strings[i]\n    while len(aux) < k:\n        aux += aux\n    aux = aux[:k]\n    strings[i] = aux\nstrings.sort()\nprint(strings[0])", "def helper(s, k):\n    while len(s) < k:\n        s = s + s\n    return s[:k]\n(n, k) = list(map(int, input().split()))\ns = input()\ninp = s\nl = []\nwhile s != '':\n    l.append(helper(s, k))\n    s = s[:len(s) - 1]\nl.sort()\nprint(l[0])", "import math\nfrom functools import reduce\nfrom math import comb\nfrom collections import defaultdict\nfrom sys import stdout\nNO = 'NO'\nYES = 'YES'\nMOD = 1000000007\nALPH = 'abcdefghijklmnopqrstuvwxyz'\n\ndef input_int():\n    return int(input())\n\ndef input_list():\n    return input().split(' ')\n\ndef input_list_int():\n    return list(map(int, input_list()))\n\ndef list_int_to_str(a, sep=' '):\n    return sep.join((str(x) for x in a))\nglobal_ans = []\n\ndef pr(a):\n    global_ans.append(a)\n\ndef solve():\n    (n, k) = input_list_int()\n    s = input()\n    ans = 'z' * k\n    for i in range(n):\n        t = s[0:n - i]\n        l = len(t)\n        v = t * math.ceil(k / l)\n        v = v[0:k]\n        if v < ans:\n            ans = v\n    pr(ans)\nquery_count = 1\nwhile query_count:\n    query_count -= 1\n    solve()\nfor global_ans_line in global_ans:\n    print(global_ans_line)", "(n, k) = map(int, input().split())\ns = input()\na = []\nfor i in range(n):\n    a.append((s[:i + 1] * (k // (i + 1) + 1))[:k])\nprint(min(a))", "(n, m) = input().split()\nn = int(n)\nm = int(m)\ns = str(input())\np = 1\nfor i in range(1, n):\n    if s[i % p] < s[i]:\n        break\n    if s[i % p] > s[i]:\n        p = i + 1\nx = m // p\ny = m - x * p\nprint(s[0:p] * x + s[0:y])", "(n, k) = map(int, input().split())\ns = input()\na = []\nfor i in range(n):\n    a.append((s[:i + 1] * (k // (i + 1) + 1))[:k])\nprint(min(a))", "import math\n(n, k) = map(int, input().split())\nont = 54685\na = input()\ntwoooo = 543\nck = []\nh = True\nfor i in range(1, n + 1):\n    t = a[:i]\n    ck.append([t * math.ceil((n + 10) / len(t)), i])\nejhgj = 3333333\nck.sort()\nesfjh = 68743684684\ns = ck[0][0][:ck[0][1]]\nsrg = 74158\nt = len(s)\nrgdsj = 7854\nans = s * math.ceil(k / t)\nsrfv = 24\nans = [i for i in ans]\nrfv = 6468\nwhile len(ans) != k:\n    ans.pop()\nsrfbhjk = 5463456\nprint(''.join(ans))", "(n, k) = list(map(int, input().split()))\nstri = input()\ninp = stri\nl = []\nwhile stri != '':\n    stri1 = stri\n    while len(stri1) < k:\n        stri1 = stri1 + stri1\n    l.append(stri1[:k])\n    stri = stri[:len(stri) - 1]\nl.sort()\nprint(l[0])", "(n, m) = list(map(int, input().split()))\ns = input()\ns = list(s)\nans = ''\nfor i in range(m):\n    ans += 'z'\nt = ''\nfor i in range(n):\n    t += s[i]\n    p = t\n    while len(t) + len(p) < m:\n        p += t\n    p += p[:m - len(p)]\n    if ans > p:\n        ans = p\nprint(ans)", "(n, k) = [int(i) for i in input().split(' ')]\ns = input()\nnew = []\nfor i in range(1, n + 1):\n    a = s[:i]\n    while len(a) < k:\n        a += a\n    new.append(a[:k])\nnew.sort()\nprint(new[0])", "(n, k) = map(int, input().split(' '))\ns = input()\nall_strings = []\nfor i in range(1, len(s) + 1):\n    temp = s[0:i]\n    while len(temp) < k:\n        temp = temp * 2\n    all_strings.append(temp[0:k])\nprint(min(all_strings))", "import math\nimport re\nimport sys\nfrom itertools import permutations\nfrom collections import Counter\nimport itertools\nMOD = 1000000007\n\ndef inp():\n    return map(int, input().split(' '))\n\ndef ninp():\n    return int(input())\n(n, k) = inp()\ns = input()\nres = []\nfor i in range(n):\n    res.append((s[:i + 1] * (k // (i + 1) + 1))[:k])\nprint(min(res))", "from math import ceil\n(n, k) = map(int, input().split())\ns = input()\nt = s[0]\nans = []\nfor i in range(n):\n    if s[i] > t:\n        break\n    ans.append(s[i])\nfind = []\nfor i in range(len(ans)):\n    if ans[i] == ans[0]:\n        find.append(i)\nfor i in range(1, len(find)):\n    if ans[:find[i]] < ans[find[i]:2 * find[i]]:\n        ans = ans[:find[i]]\n        break\nfor i in range(len(ans) - 1, 0, -1):\n    if ans[i] == ans[0]:\n        ans.pop()\n    else:\n        break\nrepeat = ''.join(ans)\nif len(ans) > k:\n    print(repeat[:k])\nelse:\n    repeat = repeat * ceil(k / len(ans))\n    print(repeat[:k])", "(n, k) = [int(i) for i in input().split(' ')]\ns = input()\nnew = []\nfor i in range(1, n + 1):\n    a = s[:i]\n    while len(a) < k:\n        a += a\n    new.append(a[:k])\nnew.sort()\nprint(new[0])", "(n, m) = map(int, input().split())\ns = input()\ni = 1\nans = s[0] * m\nwhile i < n:\n    if s[i] > s[0]:\n        break\n    i += 1\n    t = s[:i]\n    a = m // len(t)\n    b = m % len(t)\n    ans = min(ans, t * a + t[:b])\nprint(ans)", "def solve(st, n, k):\n    pref = ''\n    ans = None\n    for it in st:\n        pref += it\n        cur = ''\n        ln = 0\n        while len(pref) + len(cur) <= k:\n            cur += pref\n        if len(cur) < k:\n            cur += pref[:k - len(cur)]\n        if ans == None:\n            ans = cur\n        elif ans > cur:\n            ans = cur\n    return ans\n(n, k) = list(map(int, input().split()))\nst = input()\nans = solve(st, n, k)\nprint(ans)", "(n, k) = list(map(int, input().split()))\nst = input()\nf = st[0]\nfor i in range(1, n):\n    if st[i] >= f:\n        ind = i\n        rep = k // ind\n        temp = st[:ind] * (rep + 1)\n        temp2 = st * (rep + 1)\n        if temp[:k] < temp2[:k]:\n            print(temp[:k])\n            break\nelse:\n    l = len(st)\n    rep = k // l\n    st = st * (rep + 1)\n    print(st[:k])", "import math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n(n, k) = get_ints()\ns = get_string()\n(i, j, x) = (1, 0, 1)\nwhile i < n and i < k:\n    if s[i] > s[0]:\n        break\n    while i < n and s[i] == s[j]:\n        i += 1\n        j += 1\n    if i >= n or (i < n and s[i] > s[j]):\n        break\n    i += 1\n    j = 0\n    x = i\nans = s[:x]\nwhile len(ans) < k:\n    ans += ans\nans = ans[:k]\nsys.stdout.write(ans + '\\n')", "(n, k) = map(int, input().split())\ns = input()\nstart = s[0]\nsave = -1\nbuild = ''\npref = []\nz = list(range(1, n + 1))\nfor i in range(n):\n    build += s[i]\n    pref.append(build * (n // len(build) + 1))\nres = sorted(zip(pref, z))\nsave = res[0][1]\ns = s[:save]\nwhile len(s) < k:\n    s = s + s\ns = s[:k]\nprint(s)", "(n, k) = list(map(int, input().split()))\ns = input()\npos = []\nfor i in range(1, n + 1):\n    pos.append((s[:i] * (k // i + 100))[:k])\nprint(sorted(pos)[0])", "from math import *\nfrom collections import *\nfrom functools import *\nfrom bisect import *\nfrom itertools import *\nfrom heapq import *\nimport sys\ninf = float('inf')\nninf = -float('inf')\nip = input\nalphal = 'abcdefghijklmnopqrstuvwxyz'\nalphau = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nmod = 10 ** 9 + 7\n\ndef ipl():\n    return list(map(int, ip().split()))\n\ndef ipn():\n    return int(ip())\n\ndef ipf():\n    return float(ip())\n\ndef solve():\n    (n, k) = ipl()\n    s = list(ip())\n    r = 'z' * k\n    for i in range(n):\n        r = min(r, (''.join(s) * ceil(k / len(s)))[:k])\n        s.pop()\n    print(r)\nt = 1\nfor _ in range(t):\n    solve()", "(n, k) = [int(x) for x in input().split()]\ns = input()\ns1 = list(s)\nfinalans = 'z' * k\nfor i in range(0, n):\n    leng = i + 1\n    s2 = ''.join(s1[0:i + 1])\n    cnt = k // leng\n    ans = ''\n    for i in range(0, cnt):\n        ans += s2\n    if len(ans) < k:\n        rem = k - len(ans)\n        s3 = ''.join(s1[0:rem])\n        ans += s3\n    if ans < finalans:\n        finalans = ans\nprint(finalans)", "import sys\ninput = sys.stdin.readline\n(n, k) = map(int, input().split())\ns = list(input().rstrip())\nli = []\nfor (i, t) in enumerate(s):\n    if t > s[0]:\n        break\n    elif t == s[0]:\n        if str(s[0:i]) < str(s[i:i * 2]):\n            break\n    li.append(t)\nl = len(li)\nprint(''.join(li * (k // l) + li[0:k % l]))", "(n, k) = map(int, input().split())\nl = list(input())\nm = 'z' * 2 * k\nfor i in range(n):\n    c = ''.join(l) * 100\n    l.pop()\n    if c < m:\n        m = c\nwhile len(m) < k:\n    m += m\nprint(m[:k])", "from sys import stdin, stdout\nimport collections, heapq, bisect, math\ninput = stdin.readline\n\ndef rint():\n    return int(input())\n\ndef rstr():\n    return input().strip()\n\ndef rlstr():\n    return list(input().strip().split())\n\ndef rlint():\n    return list(map(int, input().split()))\n\ndef main():\n    (n, k) = rlint()\n    s = rstr()\n    for i in range(1, n):\n        if s[0] < s[i]:\n            return s[:i] * (k // i) + s[:k % i]\n        elif s[0] == s[i]:\n            pos = i\n            start = 0\n            temp = pos\n            while temp < n and s[start] == s[temp]:\n                start += 1\n                temp += 1\n            if temp < n and s[start] < s[temp]:\n                return s[:pos] * (k // pos) + s[:k % pos]\n    pos = n\n    for i in range(n - 1, -1, -1):\n        if s[i] < s[0]:\n            pos = i + 1\n            break\n    return s[:pos] * (k // pos) + s[:k % pos]\nprint(main())"]