["import math\n\ndef prime_factors(n):\n    assert n > 0\n    if n == 1:\n        return [1]\n    f = []\n    while n % 2 == 0:\n        f.append(2)\n        n /= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            f.append(i)\n            n /= i\n    if n > 1:\n        f.append(int(n))\n    return f\n\ndef factors_in(i, e, p):\n    d = 0\n    n = i + (p - i % p)\n    while n >= i and n < e:\n        d += 1\n        n += p\n    return d\n\ndef solve_slow():\n    (a, m) = map(int, input().split())\n    gcd = math.gcd(a, m)\n    sol = 0\n    for x in range(m):\n        if gcd == math.gcd(a + x, m):\n            sol += 1\n    print(sol)\n\ndef eulers_phi_fun(n):\n    f = prime_factors(n)\n    val = n\n    for i in set(f):\n        val *= 1 - 1 / i\n    return int(val)\n\ndef solve():\n    (a, m) = map(int, input().split())\n    gcd = math.gcd(a, m)\n    n = m / gcd\n    phi = eulers_phi_fun(n)\n    print(phi)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from math import gcd, sqrt\n\ndef primeFactors(n, s):\n    while n % 2 == 0:\n        s.add(2)\n        n //= 2\n    x = int(sqrt(n)) + 1\n    for i in range(3, x, 2):\n        while n % i == 0:\n            s.add(i)\n            n //= i\n    if n > 2:\n        s.add(n)\nt = int(input())\nfor _ in range(t):\n    (a, m) = map(int, input().split())\n    g = gcd(a, m)\n    s = set({})\n    m2 = m // g\n    primeFactors(m2, s)\n    s = list(s)\n    n = len(s)\n    count1 = 0\n    for i in range(2 ** n):\n        b = bin(i)[2:]\n        b = '0' * (n - len(b)) + b\n        count = 0\n        prod = g\n        for j in range(n):\n            if b[j] == '1':\n                count += 1\n                prod *= s[j]\n        if count % 2 == 0:\n            count1 += (a + m - 1) // prod\n        else:\n            count1 -= (a + m - 1) // prod\n    count2 = 0\n    for i in range(2 ** n):\n        b = bin(i)[2:]\n        b = '0' * (n - len(b)) + b\n        count = 0\n        prod = g\n        for j in range(n):\n            if b[j] == '1':\n                count += 1\n                prod *= s[j]\n        if count % 2 == 0:\n            count2 += (a - 1) // prod\n        else:\n            count2 -= (a - 1) // prod\n    print(count1 - count2)", "def gcd(x, y):\n    if x == 0 or y == 0:\n        return max(round(x), round(y))\n    elif x > y:\n        return gcd(round(x % y), round(y))\n    else:\n        return gcd(round(x), round(y % x))\n\ndef fi(x):\n    fac = []\n    remain = round(x)\n    res = round(x)\n    if round(remain % 2) == 0:\n        fac.append(2)\n        while round(remain % 2) == 0:\n            remain = round(remain / 2)\n    for k in range(3, 100000, 2):\n        if round(remain % k) == 0:\n            fac.append(k)\n            while round(remain % k) == 0:\n                remain = round(remain / k)\n    if remain > 1.5:\n        fac.append(round(remain))\n    for fa in fac:\n        res = round(res * (1 - 1 / fa))\n    return round(res)\nT = input()\nT = int(T)\nA = []\nM = []\nfor i in range(T):\n    (a1, m1) = input().split()\n    a1 = int(a1)\n    m1 = int(m1)\n    A.append(a1)\n    M.append(m1)\nfor i in range(T):\n    a = A[i]\n    m = M[i]\n    d = gcd(a, m)\n    b = round(m / d)\n    print(fi(b))", "def mcd(a, b):\n    while b != 0:\n        c = a % b\n        a = b\n        b = c\n    return a\n\ndef primeFactors(n):\n    factores = []\n    if n % 2 == 0:\n        exp = 0\n        while n % 2 == 0:\n            exp += 1\n            n //= 2\n        factores.append((2, exp))\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            exp = 0\n            while n % i == 0:\n                exp += 1\n                n //= i\n            factores.append((i, exp))\n        i += 2\n    if n > 2:\n        factores.append((n, 1))\n    return factores\n\ndef Phi(n):\n    phi = 1\n    for fact in primeFactors(n):\n        phi *= fact[0] ** (fact[1] - 1) * (fact[0] - 1)\n    return phi\nfor _ in range(int(input())):\n    (a, m) = map(int, input().split())\n    print(Phi(m // mcd(a, m)))", "def gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\nfor testcase in range(int(input())):\n    (a, m) = list((int(x) for x in input().split(' ')))\n    m = m // gcd(a, m)\n    res = m\n    if m % 2 == 0:\n        res //= 2\n    while m % 2 == 0:\n        m //= 2\n    i = 3\n    while i * i <= m:\n        if m % i == 0:\n            while m % i == 0:\n                m //= i\n            res = res // i * (i - 1)\n        i += 2\n    if m != 1:\n        res = res // m * (m - 1)\n    print(res)", "import math\nts = int(input())\nfor case in range(ts):\n    (a, b) = map(int, input().split())\n    gc = math.gcd(a, b)\n    koto = (b - 1) // gc\n    baki = b // gc\n    gc_lis = []\n    for i in range(2, int(math.sqrt(baki)) + 1):\n        if baki % i == 0:\n            gc_lis.append(i)\n            while baki % i == 0:\n                baki //= i\n    if baki > 1:\n        gc_lis.append(baki)\n    total = koto\n    for j in range(1, 1 << len(gc_lis)):\n        mul = 1\n        cnt = 0\n        for k in range(0, len(gc_lis)):\n            if j & 1 << k != 0:\n                mul *= gc_lis[k]\n                cnt += 1\n        if cnt % 2 == 1:\n            total -= koto // mul\n        else:\n            total += koto // mul\n    print(total)", "import sys\ninput = sys.stdin.readline\nimport math\nt = int(input())\nfor test in range(t):\n    (a, m) = map(int, input().split())\n    GCD = math.gcd(a, m)\n    x = m // GCD\n    L = int(math.sqrt(x))\n    FACT = dict()\n    for i in range(2, L + 2):\n        while x % i == 0:\n            FACT[i] = FACT.get(i, 0) + 1\n            x = x // i\n    if x != 1:\n        FACT[x] = FACT.get(x, 0) + 1\n    ANS = m // GCD\n    for f in FACT:\n        ANS = ANS * (f - 1) // f\n    print(ANS)", "def gcdcalc(a, m):\n    if m % a == 0:\n        return a\n    return gcdcalc(m % a, a)\n\ndef gcdnumber(m):\n    temp = m\n    ans = m\n    d = 2\n    cnt = 0\n    while d * d <= temp:\n        if temp % d == 0:\n            ans = ans - ans // d\n            while temp % d == 0:\n                temp = temp // d\n            cnt = 1\n        d += 1\n    if temp > 0 and temp != 1:\n        ans = ans - ans // temp\n    return ans\nt = int(input())\nl = []\nfor i in range(t):\n    (a, m) = map(int, input().strip().split())\n    gcd = gcdcalc(a, m)\n    ans = gcdnumber(m // gcd)\n    l.append(ans)\nfor i in l:\n    print(i)", "import math\n\ndef Phi_Euler(val):\n    ans = val\n    i = 2\n    while i * i <= val:\n        if val % i == 0:\n            ans -= ans // i\n            while val % i == 0:\n                val //= i\n        i += 1\n    if val > 1:\n        ans -= ans // val\n    return ans\nt = int(input())\nwhile t > 0:\n    (a, m) = map(int, input().split())\n    print(Phi_Euler(m // math.gcd(a, m)))\n    t -= 1", "def GCD(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef factors(n):\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            yield p\n        else:\n            p += 1\n    if n > 1:\n        yield n\n\ndef phi(n):\n    result = n\n    for p in factors(n):\n        result *= p - 1\n        result //= p\n    return result\n\ndef solve(a, m):\n    return phi(m // GCD(a, m))\nT = int(input())\nfor i in range(T):\n    print(solve(*map(int, input().split())))", "def phi(n):\n    l = []\n    i = 2\n    pro = n\n    while i * i <= n:\n        if n % i == 0:\n            l.append(i)\n            while n % i == 0:\n                n = n // i\n        i += 1\n    if n != 1:\n        l.append(n)\n    for i in l:\n        pro = pro // i * (i - 1)\n    return pro\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    return gcd(b, a % b)\nt = int(input())\nfor you in range(t):\n    l = input().split()\n    a = int(l[0])\n    m = int(l[1])\n    k = m // gcd(a, m)\n    print(phi(k))", "def gcd(a, b):\n    while b != 0:\n        c = a % b\n        a = b\n        b = c\n    return a\n\ndef totient(n):\n    i = 2\n    ret = n\n    while i * i <= n:\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            ret = ret * (i - 1) // i\n        i += 1\n    if n > 1:\n        ret = ret * (n - 1) // n\n    return ret\ntc = int(input())\nfor _ in range(tc):\n    (a, m) = map(int, input().split())\n    d = gcd(a, m)\n    v = m // d\n    ans = totient(v)\n    print(ans)", "def R():\n    return map(int, input().split())\n\ndef I():\n    return int(input())\n\ndef S():\n    return str(input())\n\ndef L():\n    return list(R())\nfrom collections import Counter\nimport math\nimport sys\n\ndef check(t):\n    return [True, False][any((t[i] < t[i + 1] for i in range(1, len(t) - 1)))]\nfrom itertools import permutations\n\ndef psi(n):\n    n2 = n\n    factors = []\n    i = 1\n    while i * i <= n:\n        i += 1\n        if n % i == 0:\n            factors.append(i)\n            while n % i == 0:\n                n //= i\n    if n > 1:\n        factors.append(n)\n    for p in factors:\n        n2 *= p - 1\n        n2 //= p\n    return n2\nfor _ in range(I()):\n    (a, m) = R()\n    m //= math.gcd(a, m)\n    print(psi(m))", "def gcd(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef getPrimeFactors(n):\n    factorSet = set()\n    factor = 2\n    while factor * factor <= n:\n        while n % factor == 0:\n            factorSet.add(factor)\n            n //= factor\n        factor += 1\n    if n > 1:\n        factorSet.add(n)\n    return factorSet\n\ndef calculateTotient(n):\n    for p in getPrimeFactors(n):\n        n *= p - 1\n        n //= p\n    return n\nn = int(input())\nfor _ in range(n):\n    (a, m) = [int(i) for i in input().split()]\n    print(calculateTotient(m // gcd(a, m)))", "import math\n\ndef euler_totient(m):\n    ans = m\n    i = 2\n    while i * i <= m:\n        if m % i == 0:\n            ans -= ans // i\n            while m % i == 0:\n                m //= i\n        i += 1\n    if m > 1:\n        ans -= ans // m\n    return ans\nt = int(input())\nwhile t > 0:\n    (a, m) = map(int, input().split())\n    print(euler_totient(m // math.gcd(a, m)))\n    t -= 1", "from collections import defaultdict\nfrom math import gcd\n\ndef phi(m):\n    (ans, i) = (m, 2)\n    while i * i <= m:\n        if m % i != 0:\n            i += 1\n            continue\n        while m % i == 0:\n            m //= i\n        ans -= ans // i\n        i += 1\n    if m > 1:\n        ans -= ans // m\n    return ans\n\ndef solve():\n    (a, m) = map(int, input().split())\n    m = m // gcd(a, m)\n    print(phi(m))\nfor _ in range(int(input())):\n    solve()", "from collections import defaultdict\n\ndef totient(n):\n    primes = defaultdict(int)\n    d = 2\n    diver = n\n    while d * d <= n:\n        while diver % d == 0:\n            primes[d] += 1\n            diver //= d\n        d += 1\n    if diver != 1:\n        primes[diver] += 1\n    tot = 1\n    for (p, k) in primes.items():\n        tot *= (p - 1) * p ** (k - 1)\n    return tot\n\ndef gcd(a, b):\n    while a % b != 0:\n        a %= b\n        (a, b) = (b, a)\n    return b\nfor _ in range(int(input())):\n    (a, m) = map(int, input().split())\n    print(totient(m // gcd(a, m)))", "def gcd(a, b):\n    if a == 0:\n        return b\n    elif b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef ph(a):\n    i = 2\n    ans = a\n    while i * i <= a:\n        flag = False\n        while a % i == 0:\n            a = a // i\n            flag = True\n        if flag:\n            ans = ans - ans // i\n        i += 1\n    if a > 1:\n        ans = ans - ans // a\n    return ans\nt = int(input())\nfor _ in range(t):\n    (a, b) = (int(i) for i in input().split())\n    print(ph(b // gcd(a, b)))", "from math import sqrt, gcd\n\ndef factors(x):\n    t = sqrt(x)\n    s = set()\n    i = 2\n    while x > 1 and i <= t:\n        if x % i == 0:\n            s.add(i)\n            x = x // i\n        else:\n            i += 1\n    if x > 1:\n        s.add(x)\n    return list(s)\nfor _ in range(int(input())):\n    (a, b) = map(int, input().split())\n    b = b // gcd(a, b)\n    l = factors(b)\n    for i in l:\n        b = b * (i - 1)\n        b = b // i\n    print(b)", "from math import gcd\n\ndef phi(n):\n    m = n\n    factors = set()\n    q = 2\n    while n > 1 and q * q <= n:\n        if n % q == 0:\n            factors.add(q)\n            n //= q\n        else:\n            q += 1\n    if n > 1:\n        factors.add(n)\n    for p in factors:\n        m *= p - 1\n        m //= p\n    return m\nfor _ in range(int(input())):\n    (a, m) = map(int, input().split())\n    m //= gcd(a, m)\n    print(phi(m))", "import math\n\ndef phi(n):\n    m = n\n    factors = set()\n    q = 2\n    while n > 1 and q * q <= n:\n        if n % q == 0:\n            factors.add(q)\n            n //= q\n        else:\n            q += 1\n    if n > 1:\n        factors.add(n)\n    for p in factors:\n        m *= p - 1\n        m //= p\n    return m\nt = int(input())\nfor _ in range(t):\n    (a, b) = map(int, input().split())\n    g = math.gcd(a, b)\n    b //= g\n    print(phi(b))", "import math\n\ndef phi(n):\n    m = n\n    factors = set()\n    q = 2\n    while n > 1 and q * q <= n:\n        if n % q == 0:\n            factors.add(q)\n            n //= q\n        else:\n            q += 1\n    if n > 1:\n        factors.add(n)\n    for p in factors:\n        m *= p - 1\n        m //= p\n    return m\nt = int(input())\nfor _ in range(t):\n    (a, b) = map(int, input().split())\n    g = math.gcd(a, b)\n    b //= g\n    print(phi(b))", "import math\n\ndef phi(n):\n    m = n\n    factors = set()\n    q = 2\n    while n > 1 and q * q <= n:\n        if n % q == 0:\n            factors.add(q)\n            n //= q\n        else:\n            q += 1\n    if n > 1:\n        factors.add(n)\n    for p in factors:\n        m *= p - 1\n        m //= p\n    return m\nt = int(input())\nfor _ in range(t):\n    (a, b) = map(int, input().split())\n    g = math.gcd(a, b)\n    b //= g\n    print(phi(b))", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef getphi(x):\n    (y, i) = (1, 2)\n    while i * i <= x:\n        if x % i == 0:\n            y *= i - 1\n            x /= i\n            while x % i == 0:\n                y *= i\n                x /= i\n        i += 1\n    if x > 1:\n        y *= x - 1\n    return y\nT = int(input())\nfor o in range(T):\n    (a, m) = map(int, input().split())\n    print('%d' % getphi(m / gcd(a, m)))", "import math\n\ndef phi(n):\n    m = n\n    factors = set()\n    q = 2\n    while n > 1 and q * q <= n:\n        if n % q == 0:\n            factors.add(q)\n            n //= q\n        else:\n            q += 1\n    if n > 1:\n        factors.add(n)\n    for p in factors:\n        m *= p - 1\n        m //= p\n    return m\nt = int(input())\nfor _ in range(t):\n    (a, b) = map(int, input().split())\n    g = math.gcd(a, b)\n    b //= g\n    print(phi(b))", "def gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef totient(x):\n    tot = x\n    n = x\n    i = 1\n    prime_factors = []\n    q = 2\n    while n > 1 and q * q <= n:\n        if n % q == 0:\n            prime_factors.append(q)\n            while n % q == 0:\n                n //= q\n        q += 1\n    if n > 1:\n        prime_factors.append(n)\n    for p in prime_factors:\n        tot = tot / p * (p - 1)\n    return int(tot)\nfor _ in range(int(input())):\n    (a, m) = map(int, input().split())\n    g = gcd(m, a)\n    ans = 0\n    count = 0\n    prime_factors = []\n    m1 = m // g\n    ans = totient(m1)\n    print(ans)", "def mcd(a, b):\n    return b if a == 0 else mcd(b % a, a)\n\ndef phi(a):\n    tmp = a\n    ans = a\n    d = 2\n    while d * d <= tmp:\n        cnt = 0\n        while tmp % d == 0:\n            tmp /= d\n            cnt += 1\n        if cnt > 0:\n            ans -= ans / d\n        d += 1\n    if tmp > 1:\n        ans -= ans / tmp\n    return ans\nn = int(input())\nforprint = []\nfor i in range(n):\n    (a, m) = map(int, input().split())\n    forprint.append(str(int(phi(m / mcd(a, m)))))\nprint('\\n'.join(forprint))", "def gcd(a, b):\n    if a == 0:\n        return b\n    else:\n        return gcd(b % a, a)\n\ndef phitrue(a):\n    (tmp, ans) = (a, a)\n    d = 2\n    while d * d <= tmp:\n        cnt = 0\n        while tmp % d == 0:\n            tmp /= d\n            cnt += 1\n        if cnt > 0:\n            ans -= ans / d\n        d += 1\n    if tmp > 1:\n        ans -= ans / tmp\n    return ans\nt = int(input())\nans = []\nfor i in range(t):\n    (a, m) = map(int, input().split())\n    print(round(phitrue(m / gcd(a, m))))", "def gcd(a, b):\n    if a < b:\n        (a, b) = (b, a)\n    n = a // b\n    r = a % b\n    if r == 0:\n        return b\n    return gcd(b, r)\n\ndef gcds(a, m):\n    d = gcd(a, m)\n    n = m // d\n    add_primes(n)\n    ans = n\n    n0 = n\n    for p in primes:\n        if n0 % p == 0:\n            ans = ans * (p - 1) // p\n        while n0 % p == 0:\n            n0 = n0 // p\n    if n0 != 1:\n        ans = ans * (n0 - 1) // n0\n    if ans == n:\n        ans = ans - 1\n    return int(max(1, ans))\n\ndef is_prime(n):\n    for p in primes:\n        if p * p > n:\n            break\n        if n % p == 0:\n            return False\n    return True\n\ndef add_primes(n):\n    for i in range(n):\n        if i * i > n:\n            break\n        if i < primes[-1]:\n            continue\n        if is_prime(i):\n            primes.append(i)\nprimes = [2, 3, 5, 7]\nt = int(input())\nfor _ in range(t):\n    (a, m) = [int(s) for s in input().split(' ')]\n    print(gcds(a, m))", "from math import gcd\nfor _ in range(int(input())):\n    x = input().split(' ')\n    a = int(x[0])\n    m = int(x[1])\n    val = gcd(a, m)\n    n = m // val\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n = n // p\n            result = result - int(result / p)\n        p = p + 1\n    if n > 1:\n        result = result - int(result / n)\n    print(result)"]