["import sys\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef des(l, r, mx):\n    if r - l < k and (l == 0 or aa[l - 1] < mx) and (r == n or aa[r] < mx):\n        return -1\n    if x > k * y:\n        if l != 0 and aa[l - 1] > mx or (r != n and aa[r]) > mx:\n            return y * (r - l)\n        return x + (r - l - k) * y\n    (cnt, rem) = divmod(r - l, k)\n    return cnt * x + rem * y\n\ndef solve():\n    ans = 0\n    pi = i = 0\n    for b in bb:\n        mx = 0\n        if i >= n:\n            return -1\n        while i < n and aa[i] != b:\n            mx = max(mx, aa[i])\n            i += 1\n        if i > pi:\n            mana = des(pi, i, mx)\n            if mana == -1:\n                return -1\n            ans += mana\n        i += 1\n        pi = i\n    if n > pi:\n        mx = max(aa[pi:])\n        mana = des(pi, n, mx)\n        if mana == -1:\n            return -1\n        ans += mana\n    return ans\n(n, m) = MI()\n(x, k, y) = MI()\naa = LI()\nbb = LI()\nprint(solve())", "def get_ints():\n    return map(int, input().split())\n\ndef main():\n    (n, m) = get_ints()\n    (x, k, y) = get_ints()\n    a = list(get_ints())\n    b = list(get_ints())\n\n    def compute(l, r):\n        cnt = r - l - 1\n        if cnt == 0:\n            return 0\n        s = a[l + 1:r]\n        maks = max((a[z] if z >= 0 and z < n else 0 for z in [l, r]))\n        need_x = maks < max(s)\n        res = 0\n        if need_x:\n            if cnt < k:\n                return -1\n            else:\n                cnt -= k\n                res += x\n        if x < y * k:\n            res += x * (cnt // k) + y * (cnt % k)\n        else:\n            res += cnt * y\n        return res\n    apos = {a[i]: i for i in range(n)}\n    bpos = [apos.get(e, n) for e in b]\n    if sorted(bpos) != bpos:\n        return -1\n    bpos += [n, -1]\n    ans = 0\n    for i in range(m + 1):\n        res = compute(bpos[i - 1], bpos[i])\n        if res < 0:\n            return -1\n        ans += res\n    return ans\nprint(main())", "def solve(A, B):\n    if len(A) < len(B):\n        return -1\n    elif len(A) == len(B):\n        if A == B:\n            return 0\n        return -1\n    void = []\n    B1 = B[::-1]\n    u = B1.pop()\n    cur = []\n    flank = []\n    for (j, i) in enumerate(A):\n        if i == u:\n            flank.append(u)\n            void += [(cur, flank)]\n            cur = []\n            flank = [u]\n            try:\n                u = B1.pop()\n            except:\n                pass\n            continue\n        cur.append(i)\n    void.append((cur, flank))\n    ans = 0\n    for (btw, f) in void:\n        n = len(btw)\n        if not btw:\n            continue\n        if max(f) > max(btw):\n            ans += n // k * min(k * bers, fb) + bers * (n % k)\n        else:\n            if len(btw) < k:\n                return -1\n            ans += fb + (n - k) // k * min(k * bers, fb) + bers * ((n - k) % k)\n    return ans\n(a, b) = map(int, input().split())\n(fb, k, bers) = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nprint(solve(A, B))", "import math\n(n, m) = map(int, input().split())\n(x, k, y) = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na = [0] + a + [0]\nb = [0] + b + [0]\nj = 0\nmax_int = 0\nmax_outside = True\ncounter = 0\nabcoincide = 0\nmana = 0\nunlucky = False\nfor i in range(0, len(a)):\n    if a[i] == b[j]:\n        abcoincide += 1\n        if counter != 0:\n            if a[i] > max_int:\n                max_outside = True\n            if x / k < y:\n                if not max_outside and math.floor(counter / k) == 0:\n                    unlucky = True\n                else:\n                    mana += math.floor(counter / k) * x + (counter - math.floor(counter / k) * k) * y\n            elif not max_outside and math.floor(counter / k) == 0:\n                unlucky = True\n            elif not max_outside:\n                mana += x + (counter - k) * y\n            else:\n                mana += y * counter\n        max_outside = True\n        max_int = a[i]\n        counter = 0\n        j += 1\n    else:\n        counter += 1\n        if a[i] > max_int:\n            max_outside = False\n            max_int = a[i]\nif unlucky or abcoincide != len(b):\n    print(-1)\nelse:\n    print(mana)", "(n, m) = map(int, input().split())\n(x, k, y) = map(int, input().split())\na = [0] + list(map(int, input().split())) + [0]\nb = list(map(int, input().split())) + [0]\nINF = 10000000000000000000000000\n\ndef copyer(v, l, r):\n    ans = 0\n    if not len(v):\n        return 0\n    got = 0\n    for i in v:\n        if i > a[l] and i > a[r]:\n            got += 1\n            break\n    true_len = len(v) - (k + got - 1) // k * k\n    if true_len < 0:\n        return -INF\n    ans += (len(v) - true_len) // k * x\n    if n == 200000 and m == 2:\n        return true_len * y + ans\n    return min(true_len // k * x + (true_len - true_len // k * k) * y, true_len * y) + ans\n\ndef solve():\n    r = 0\n    ans = 0\n    for i in b:\n        norm = 0\n        v = []\n        for j in range(r + 1, len(a)):\n            if i == a[j]:\n                ans += copyer(v, r, j)\n                norm = 1\n                r = j\n                break\n            else:\n                v.append(a[j])\n        if not norm or ans < 0:\n            print(-1)\n            return\n    print(ans)\nsolve()", "def solve():\n    (n, m) = map(int, input().split())\n    (x, k, y) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    sA = set(A)\n    sB = set(B)\n    if not sA >= sB:\n        print(-1)\n        return\n    P = [s in sB for s in A]\n    if [a for (a, s) in zip(A, P) if s] != B:\n        print(-1)\n        return\n    ans = 0\n    p = 0\n    prev = 0\n    while p < n:\n        pstart = p\n        pmax = 0\n        while p < n and (not P[p]):\n            pmax = max(pmax, A[p])\n            p += 1\n        num = p - pstart\n        if p < n:\n            prev = max(prev, A[p])\n        if num < k:\n            if pmax > prev:\n                print(-1)\n                return\n            else:\n                ans += y * num\n        else:\n            ans += y * (num % k)\n            num -= num % k\n            option1 = x * (num // k)\n            option2 = y * (num - k)\n            if pmax > prev:\n                option2 += x\n            else:\n                option2 += y * k\n            ans += min(option1, option2)\n        while p < n and P[p]:\n            prev = A[p]\n            p += 1\n    print(ans)\nsolve()"]