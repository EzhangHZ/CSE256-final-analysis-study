["import sys\nfor _ in range(int(input())):\n    s = input()\n    (p, a) = ('', '')\n    (i, j) = (0, len(s) - 1)\n    while i <= j and s[i] == s[j]:\n        p += s[i]\n        if i < j:\n            a = s[j] + a\n            j -= 1\n        i += 1\n    s = s[i:j + 1]\n\n    def manacher(ms):\n        ms = '$#' + '#'.join(ms) + '#%'\n        l = len(ms)\n        p = [0] * len(ms)\n        ind = mx = 0\n        for i in range(1, l - 1):\n            if i < mx:\n                p[i] = min(p[2 * ind - i], mx - i)\n            while ms[i - p[i] - 1] == ms[i + p[i] + 1]:\n                p[i] += 1\n            if mx < i + p[i]:\n                (ind, mx) = (i, i + p[i])\n        return p\n    t = manacher(s)\n    ans = ''\n    for i in range(1, len(t)):\n        if i - t[i] == 1 and t[i] > len(ans):\n            ans = s[:t[i]]\n        if i + t[i] == len(t) - 2 and t[i] > len(ans):\n            ans = s[-t[i]:]\n    print(p + ans + a)", "def is_palindrome(s):\n    return s == s[::-1]\nfor t in range(int(input())):\n    s = input()\n    (l, r) = (0, len(s) - 1)\n    while l <= r:\n        if s[l] == s[r]:\n            l += 1\n            r -= 1\n        else:\n            break\n    l -= 1\n    r += 1\n    if l == r:\n        print(s)\n        continue\n    (a, b) = (s[:l + 1], s[r:])\n    sub_s = s[l + 1:r]\n    ans = ''\n    (l, r) = (0, len(sub_s) - 1)\n    while l <= r:\n        if is_palindrome(sub_s[:l]):\n            ans = sub_s[:l]\n        l += 1\n    while r >= 0:\n        if is_palindrome(sub_s[r:]) and len(ans) < len(sub_s[r:]):\n            ans = sub_s[r:]\n        r -= 1\n    print(a + ans + b)", "for _ in range(int(input())):\n    s = input()\n    (l, r) = (0, len(s) - 1)\n    while l < r:\n        if s[l] == s[r]:\n            l += 1\n            r -= 1\n        else:\n            break\n    (left, right) = (s[:l], s[r + 1:])\n    t = s[l:r + 1]\n    mid = ''\n    for i in range(len(t)):\n        if t[:i + 1][::-1] == t[:i + 1] and len(t[:i + 1]) > len(mid):\n            mid = t[:i + 1]\n    t = t[::-1]\n    for i in range(len(t)):\n        if t[:i + 1][::-1] == t[:i + 1] and len(t[:i + 1]) > len(mid):\n            mid = t[:i + 1]\n    print(left + mid + right)", "def palindrome(str):\n    temp = str + '?'\n    str = str[::-1]\n    temp += str\n    nn = len(temp)\n    lps = [0] * nn\n    for i in range(1, nn, 1):\n        length = lps[i - 1]\n        while length > 0 and temp[length] != temp[i]:\n            length = lps[length - 1]\n        if temp[i] == temp[length]:\n            length = length + 1\n        lps[i] = length\n    return temp[0:lps[nn - 1]]\nt = int(input())\nfor j in range(0, t):\n    s = input()\n    ss = s[::-1]\n    n = len(s)\n    a = 0\n    for i in range(0, n // 2):\n        if s[i] == s[n - 1 - i] and i != n - 1 - i:\n            a = a + 1\n        else:\n            break\n    pre = palindrome(s[a:n - a])\n    suff = palindrome(ss[a:n - a])\n    if len(pre) >= len(suff):\n        print(s[0:a] + pre + s[n - a:n])\n    else:\n        print(s[0:a] + suff + s[n - a:n])", "def isPalindrome(string):\n    return string == string[::-1]\n\ndef longestPrefixPalindrome(string):\n    end = len(string) - 1\n    while end >= 0:\n        if string[0] == string[end] and isPalindrome(string[:end + 1]):\n            return string[:end + 1]\n        else:\n            end -= 1\nt = int(input())\nfor _ in range(t):\n    string = input()\n    output_prefix = ''\n    start = 0\n    end = len(string) - 1\n    while string[start] == string[end] and start < end:\n        output_prefix += string[start]\n        start += 1\n        end -= 1\n    if start <= end:\n        cut = len(output_prefix)\n        newstring = string[cut:len(string) - cut]\n        output_middle = max(longestPrefixPalindrome(newstring), longestPrefixPalindrome(newstring[::-1]), key=len)\n        print(output_prefix + output_middle + output_prefix[::-1])\n    else:\n        print(output_prefix + output_prefix[::-1])", "t = int(input())\nwhile t > 0:\n    t -= 1\n    s = input()\n    sr = s[::-1]\n    mid = len(s) // 2\n    line = 0\n    for i in range(0, mid):\n        if s[i] != sr[i]:\n            line = i\n            break\n    sn = s[line:len(s) - line]\n    ans = ''\n    for mode in range(2):\n        for i in range(len(sn)):\n            if sn[0] == sn[len(sn) - 1 - i] and sn[0:len(sn) - i] == sn[0:len(sn) - i][::-1]:\n                if len(ans) < len(sn[0:len(sn) - i]):\n                    ans = sn[0:len(sn) - i]\n                break\n        sn = sn[::-1]\n    print(s[:line] + ans + s[len(s) - line:])", "t = int(input())\n\ndef palindrome(l):\n    (k, mod) = (37, 998244353)\n    (h1, h2, p, ans) = (0, 0, 1, 0)\n    for i in range(len(l)):\n        h1 = (h1 + (ord(l[i]) - 97) * p) % mod\n        h2 = (h2 * k % mod + ord(l[i]) - 97) % mod\n        p = p * k % mod\n        if h1 == h2:\n            ans = i + 1\n    return ans\nfor t_ in range(t):\n    s = list(input())\n    i = 0\n    while s[i] == s[len(s) - i - 1] and i < len(s) - i - 1:\n        i += 1\n    ans = s[:i]\n    print(''.join((str(i) for i in ans)), end='')\n    ans1 = palindrome(s[i:len(s) - i])\n    if i == 0:\n        ans2 = palindrome(s[len(s) - i - 1::-1])\n    else:\n        ans2 = palindrome(s[len(s) - i - 1:i - 1:-1])\n    if ans1 >= ans2:\n        print(''.join((str(i) for i in s[i:i + ans1])), end='')\n    else:\n        print(''.join((str(i) for i in s[len(s) - i - ans2:len(s) - i])), end='')\n    print(''.join((str(i) for i in reversed(ans))))", "def kmp(sub_t):\n    s = sub_t + '#' + sub_t[::-1]\n    c = 0\n    n = len(s)\n    pref = [0] * n\n    for i in range(1, n):\n        while c != 0 and s[c] != s[i]:\n            c = pref[c - 1]\n        if s[c] == s[i]:\n            c += 1\n        pref[i] = c\n    return sub_t[0:c]\n\ndef arg_max(a, b):\n    if len(b) > len(a):\n        return b\n    return a\n\ndef solve(t):\n    l = 0\n    n = len(t)\n    while l < n - l - 1:\n        if t[l] != t[n - l - 1]:\n            break\n        l += 1\n    a = ''\n    if n > 2 * l:\n        sub_t = t[l:n - l]\n        a = kmp(sub_t)\n        sub_t = sub_t[::-1]\n        b = kmp(sub_t)\n        a = arg_max(a, b)\n    print(t[:l] + a + t[n - l:])\nte = int(input())\nfor _ in range(te):\n    t = str(input())\n    solve(t)", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    q = II()\n    for _ in range(q):\n        s = SI()\n        n = len(s)\n        mid = ''\n        for i in range(n):\n            if i > n - 1 - i or s[i] != s[n - 1 - i]:\n                break\n        if i >= n - 1 - i:\n            print(s)\n            continue\n        pre = s[:i]\n        t = s[i:n - i]\n        tn = n - i - i\n        for w in range(tn, 1, -1):\n            w2 = w // 2\n            if t[:w2] == t[w - w2:w][::-1]:\n                mid = t[:w]\n                break\n            if t[tn - w:tn - w + w2] == t[tn - w2:tn][::-1]:\n                mid = t[tn - w:tn]\n                break\n        if mid == '':\n            mid = t[0]\n        print(pre + mid + pre[::-1])\nmain()", "import time\n\ndef solve():\n    s = input()\n    n = len(s)\n    istart = -1\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            istart = i\n            break\n    if istart == -1:\n        print(s)\n        return 0\n    best = 0\n    for i in range(istart, n - istart):\n        if s[i:n - istart] == s[i:n - istart][::-1]:\n            best = n - istart - i\n            break\n    for i in range(n - istart - 1, istart - 1, -1):\n        if s[istart:i] == s[istart:i][::-1]:\n            b2 = i - istart + 1\n            if b2 > best:\n                print(s[0:i] + s[n - istart:n])\n            else:\n                print(s[0:istart] + s[n - istart - best:n])\n            break\nfor t in range(int(input())):\n    solve()", "def reverse(s):\n    return s[::-1]\n\ndef isPalindrome(s):\n    rev = reverse(s)\n    if s == rev:\n        return True\n    return False\nT = int(input())\nwhile T:\n    inp = str(input())\n    if isPalindrome(inp):\n        print(inp)\n    else:\n        l = 0\n        r = len(inp) - 1\n        ans = ''\n        ans_temp = ''\n        temp = ''\n        max_temp = ''\n        while l <= r:\n            if inp[l] != inp[r]:\n                break\n            else:\n                ans += inp[l]\n                l += 1\n                r -= 1\n        t = r\n        ans_temp = ans\n        while t >= l:\n            if inp[t] == inp[l] and isPalindrome(inp[l:t + 1]) == 1:\n                temp = inp[l:t + 1]\n                if len(max_temp) < len(temp):\n                    max_temp = temp\n            t -= 1\n        t = l\n        while t <= r:\n            if inp[t] == inp[r] and isPalindrome(inp[t:r + 1]) == 1:\n                temp = inp[t:r + 1]\n                if len(max_temp) < len(temp):\n                    max_temp = temp\n            t += 1\n        ans += max_temp\n        ans += reverse(ans_temp)\n        print(ans)\n    T -= 1", "def main():\n    import sys\n    input = sys.stdin.readline\n    t = int(input())\n\n    def check(s, l):\n        if l == 0:\n            return ''\n        for i in range(l, 0, -1):\n            s_ = s[:i]\n            if s_ == s_[::-1]:\n                return s_\n            s_ = s[l - i:]\n            if s_ == s_[::-1]:\n                return s_\n    for _ in range(t):\n        s = input().rstrip()\n        l = len(s)\n        j = -1\n        for i in range(l // 2):\n            if s[i] != s[l - i - 1]:\n                break\n            else:\n                j += 1\n        ans = s[:j + 1] + check(s[j + 1:l - j - 1], l - 2 * j - 2) + s[l - j - 1:]\n        print(ans)\nmain()", "from sys import exit\n\ndef i():\n    return input()\n\ndef ii():\n    return int(input())\n\ndef iis():\n    return map(int, input().split())\n\ndef liis():\n    return list(map(int, input().split()))\n\ndef print_array(a):\n    print(' '.join(map(str, a)))\n\ndef get_mx_pl(s):\n    s += ' '\n    for i in range(1, len(s)):\n        s2 = s[:-i]\n        if s2 == s2[::-1]:\n            return s2\n    return ''\n\ndef get_mx_pl_r(s):\n    for i in range(len(s)):\n        s2 = s[i:]\n        if s2 == s2[::-1]:\n            return s2\n    return ''\nt = ii()\nfor _ in range(t):\n    s = input()\n    (pre, suf) = ('', '')\n    i = 0\n    while i < len(s) // 2 and s[i] == s[len(s) - 1 - i]:\n        pre += s[i]\n        suf += s[len(s) - 1 - i]\n        i += 1\n    pre2 = get_mx_pl(s[i:len(s) - len(suf)])\n    suf2 = get_mx_pl_r(s[len(pre):len(s) - len(suf)])\n    if len(pre2) >= len(suf2):\n        pre += pre2\n    else:\n        suf += suf2\n    print(pre + suf[::-1])", "from sys import stdin\n\ndef ispal(s):\n    if s == s[::-1]:\n        return 1\n    return 0\n\ndef func(s):\n    n = len(s)\n    for i in range(n, 0, -1):\n        if ispal(s[0:i]) == 1:\n            return i\nfor _ in range(int(stdin.readline())):\n    s = stdin.readline().strip()\n    m = s[::-1]\n    if s == m:\n        print(s)\n        continue\n    n = len(s)\n    (i, j) = (0, n - 1)\n    while j - 1 > 1:\n        if s[i] == s[j]:\n            i += 1\n            j -= 1\n        else:\n            break\n    pre = s[0:i]\n    suf = s[j + 1:]\n    s = s[i:j + 1]\n    m = s[::-1]\n    x = func(s)\n    y = func(m)\n    if x >= y:\n        pre += s[0:x]\n    else:\n        suf = m[0:y] + suf\n    print(pre + suf)", "for i in range(int(input())):\n    s = str(input())\n    n = len(s)\n\n    def reverse(s):\n        return s[::-1]\n\n    def isPalindrome(s):\n        rev = reverse(s)\n        if s == rev:\n            return True\n        return False\n    length = 0\n    string = s\n    front = s[:int(n / 2) + 1]\n    back = s[int(n / 2):]\n    if isPalindrome(s) == 1:\n        print(s)\n    else:\n        for j in range(int(n / 2) + 1):\n            if s[j] == s[n - j - 1]:\n                length += 1\n            else:\n                front = s[:length]\n                back = s[n - length:]\n                break\n        s1 = ''\n        for j in range(n - len(front) - len(back)):\n            if isPalindrome(s[j + len(front):n - len(back)]) == 1:\n                s1 = s[j + len(front):n - len(back)]\n                break\n            elif isPalindrome(s[len(front):n - len(back) - j - 1]) == 1:\n                s1 = s[len(front):n - len(back) - j - 1]\n                break\n        print(front + s1 + back)", "def manacher(s):\n    n = 2 * len(s)\n    rad = [0] * n\n    i = j = 0\n    while i < n:\n        while i >= j and i + j + 1 < n and (s[(i - j) // 2] == s[(i + j + 1) // 2]):\n            j += 1\n        rad[i] = j\n        k = 1\n        while i >= k and rad[i] >= k and (rad[i - k] != rad[i] - k):\n            rad[i + k] = min(rad[i - k], rad[i] - k)\n            k += 1\n        i += k\n        j = max(j - k, 0)\n    return rad\ntest = int(input())\nwhile test > 0:\n    test -= 1\n    s = input()\n    rad = manacher(s)\n    (i, j) = (0, len(s) - 1)\n    sol = ''\n    while s[i] == s[j] and i < j:\n        sol += s[i]\n        i += 1\n        j -= 1\n    print(sol, end='')\n    (best, index) = (0, -1)\n    (b, e) = (2 * (i - 1), 2 * (j + 1))\n    for it in range(b + 1, e):\n        l = it - b - 1\n        r = e - it - 1\n        x = y = -1\n        if rad[it] >= l:\n            x = l\n        if rad[it] >= r:\n            y = r\n        if x == -1 and y == -1:\n            continue\n        x = y if x == -1 else x\n        y = x if y == -1 else y\n        if best < min(x, y):\n            index = it\n            best = min(x, y)\n    for i in range(index - best + 1, index + best, 2):\n        print(s[i // 2], end='')\n    for item in reversed(sol):\n        print(item, end='')\n    print()", "import sys\n\ndef read():\n    return list(map(int, sys.stdin.readline().rstrip().split(' ')))\n\ndef poli(s):\n    for l in range(len(s), 0, -1):\n        if s[:l] == s[:l][::-1]:\n            return s[:l]\n    return ''\n(n,) = read()\nfor line in sys.stdin:\n    s = line.rstrip()\n    len_prefix = 0\n    for i in range(len(s) // 2):\n        if s[i] == s[-i - 1]:\n            len_prefix = i + 1\n        else:\n            break\n    prefix = ''\n    if len_prefix:\n        prefix = s[:len_prefix]\n        s = s[len_prefix:-len_prefix]\n    p = ''\n    left = poli(s)\n    right = poli(s[::-1])\n    if len(left) >= len(right):\n        p = prefix + left + prefix[::-1]\n    else:\n        p = prefix + right[::-1] + prefix[::-1]\n    print(p)", "def sol():\n    s = input()\n    x = ''\n    y = ''\n    a = 0\n    b = len(s) - 1\n    while a < b:\n        if s[a] == s[b]:\n            x += s[a]\n            y += s[a]\n            a += 1\n            b -= 1\n        else:\n            break\n    y = y[::-1]\n    r1 = ''\n    t1 = ''\n    for n in range(a, b + 1):\n        t1 += s[n]\n        if t1 == t1[::-1]:\n            r1 = t1\n    r2 = ''\n    t2 = ''\n    for n in range(b, a - 1, -1):\n        t2 += s[n]\n        if t2 == t2[::-1]:\n            r2 = t2\n    if len(r1) >= len(r2):\n        x += r1\n    else:\n        x += r2\n    x += y\n    print(x)\nfor n in range(int(input())):\n    sol()", "for _ in range(int(input())):\n    a = input()\n    n = len(a)\n    prefix = 0\n    suffix = n - 1\n    while a[prefix] == a[suffix] and prefix < suffix:\n        prefix = prefix + 1\n        suffix = suffix - 1\n    if prefix < suffix:\n        prefixinc = prefix\n        for i in range(prefix + 1, suffix + 1):\n            chunk = a[prefix:i]\n            if chunk == chunk[::-1]:\n                prefixinc = i\n        suffixinc = suffix\n        for i in range(prefix + 1, suffix):\n            chunk = a[i:suffix + 1]\n            if chunk == chunk[::-1]:\n                suffixinc = i\n                break\n        if abs(prefixinc - prefix) > abs(suffixinc - suffix):\n            ans = a[:prefixinc] + a[suffix + 1:]\n        else:\n            ans = a[:prefix] + a[suffixinc:]\n        print(ans)\n    else:\n        print(a)", "def checkpal(s):\n    return s == s[::-1]\n\ndef side(s):\n    l = r = ''\n    while len(s) > 1:\n        if s[0] == s[-1]:\n            l = l + s[0]\n            r = s[-1] + r\n            s = s[1:-1]\n        else:\n            break\n    return [l, s, r]\n\ndef mid(s):\n    l = len(s)\n    if l <= 1:\n        return s\n    else:\n        i = l + 1\n    while i > 0:\n        i = i - 1\n        if checkpal(s[:i]):\n            return s[:i]\n        elif checkpal(s[l - i:]):\n            return s[l - i:]\n        else:\n            continue\n    return ''\nt = int(input())\nwhile t > 0:\n    s = input()\n    if len(s) == 1:\n        print(s)\n    else:\n        a = side(s)\n        print(a[0] + mid(a[1]) + a[2])\n    t = t - 1", "t = int(input())\nfor _ in range(t):\n    s = input()\n    if s == s[::-1]:\n        print(s)\n    else:\n        left = ''\n        right = ''\n        for i in range(len(s)):\n            if s[i] == s[-i - 1]:\n                left += s[i]\n                right += s[i]\n            else:\n                break\n        rem = s[i:len(s) - i]\n        l = 0\n        r = 0\n        l_s = ''\n        r_s = ''\n        for i in range(len(rem)):\n            if rem[:i] == rem[:i][::-1]:\n                l = len(rem[:i])\n                l_s = rem[:i]\n            if rem[-i - 1:] == rem[-i - 1:][::-1]:\n                r = len(rem[-i - 1:])\n                r_s = rem[-i - 1:]\n        if len(s) <= 1:\n            ans = s\n        elif l >= r:\n            ans = left + l_s + right[::-1]\n            if len(ans) > len(s):\n                ans = s\n        else:\n            ans = left + r_s + right[::-1]\n            if len(ans) > len(s):\n                ans = s\n        print(ans)", "testCases = int(input())\nfor i1 in range(testCases):\n    sequence = input()\n    sequenceR = sequence[::-1]\n    length = len(sequence)\n    ends = 0\n    if length % 2 == 0:\n        while ends < length / 2 and sequence[ends] == sequenceR[ends]:\n            ends += 1\n    else:\n        while ends < (length - 1) / 2 and sequence[ends] == sequenceR[ends]:\n            ends += 1\n    sequenceLeft = sequence[ends:length - ends]\n    left = ''\n    right = ''\n    for i2 in range(len(sequenceLeft) + 1):\n        temp = sequenceLeft[0:i2]\n        if temp == temp[::-1]:\n            left = temp\n    for i2 in range(len(sequenceLeft) + 1):\n        temp = sequenceLeft[len(sequenceLeft) - i2:len(sequenceLeft)]\n        if temp == temp[::-1]:\n            right = temp\n    result = ''\n    if len(left) >= len(right):\n        result = sequence[0:ends] + left + sequence[length - ends:length]\n    else:\n        result = sequence[0:ends] + right + sequence[length - ends:length]\n    print(result)", "t = int(input())\nfor _ in range(t):\n    s = str(input())\n    p1 = 0\n    p2 = len(s) - 1\n    res = ''\n    if len(s) == 1:\n        print(s)\n    else:\n        while p1 < p2:\n            if s[p1] == s[p2]:\n                p1 = p1 + 1\n                p2 = p2 - 1\n            else:\n                break\n        s1 = s[0:p1]\n        s2 = s[p2 + 1:len(s)]\n        part = s[p1:p2 + 1]\n        for i in range(len(part)):\n            if part[0:i + 1][::-1] == part[0:i + 1]:\n                if len(part[0:i + 1]) > len(res):\n                    res = part[0:i + 1]\n        part = part[::-1]\n        for i in range(len(part)):\n            if part[0:i + 1][::-1] == part[0:i + 1]:\n                if len(part[0:i + 1]) > len(res):\n                    res = part[0:i + 1]\n        print(s1 + res, end='')\n        print(s2)", "testCases = int(input())\nfor i1 in range(testCases):\n    sequence = input()\n    sequenceR = sequence[::-1]\n    length = len(sequence)\n    ends = 0\n    if length % 2 == 0:\n        while ends < length / 2 and sequence[ends] == sequenceR[ends]:\n            ends += 1\n    else:\n        while ends < (length - 1) / 2 and sequence[ends] == sequenceR[ends]:\n            ends += 1\n    sequenceLeft = sequence[ends:length - ends]\n    left = ''\n    right = ''\n    for i2 in range(len(sequenceLeft) + 1):\n        temp = sequenceLeft[0:i2]\n        if temp == temp[::-1]:\n            left = temp\n    for i2 in range(len(sequenceLeft) + 1):\n        temp = sequenceLeft[len(sequenceLeft) - i2:len(sequenceLeft)]\n        if temp == temp[::-1]:\n            right = temp\n    result = ''\n    if len(left) >= len(right):\n        result = sequence[0:ends] + left + sequence[length - ends:length]\n    else:\n        result = sequence[0:ends] + right + sequence[length - ends:length]\n    print(result)", "def check(s):\n    p = s[::-1]\n    if s == p:\n        return True\n    else:\n        return False\nt = int(input())\nwhile t != 0:\n    s = input()\n    ind = -1\n    if check(s):\n        print(s)\n    else:\n        for i in range(len(s) // 2):\n            if s[i] != s[len(s) - i - 1]:\n                ind = i\n                break\n        prefix = s[:ind]\n        suffix = s[len(s) - ind:]\n        mid = s[ind:len(s) - ind]\n        maxi = ''\n        for i in range(len(mid)):\n            temp = mid[:i]\n            if check(temp):\n                maxi = temp\n        for i in range(len(mid) - 1, -1, -1):\n            temp = mid[i:]\n            if check(temp):\n                if len(temp) > len(maxi):\n                    maxi = temp\n        print(prefix + maxi + suffix)\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    s = input()\n    n = len(s)\n    x = ''\n    i = 0\n    while i < n // 2:\n        if s[i] == s[n - i - 1]:\n            x += s[i]\n            i += 1\n        else:\n            break\n    if len(x) == n // 2:\n        if n % 2:\n            print(x + s[n // 2] + x[::-1])\n        else:\n            print(x + x[::-1])\n    else:\n        w = s[i:n - i]\n        n = len(w)\n        c = ''\n        d = 0\n        for i in range(n):\n            l = w[:i + 1]\n            r = w[i:]\n            if l == l[::-1]:\n                if i + 1 > d:\n                    d = i + 1\n                    c = l\n            if r == r[::-1]:\n                if n - i > d:\n                    d = n - i\n                    c = r\n        print(x + c + x[::-1])", "for _ in range(int(input())):\n    s = input()\n    (l, r) = (0, len(s) - 1)\n    while l < r:\n        if s[l] == s[r]:\n            l += 1\n            r -= 1\n        else:\n            break\n    (left, right) = (s[:l], s[r + 1:])\n    t = s[l:r + 1]\n    curr = ''\n    for i in range(len(t)):\n        if t[:i + 1][::-1] == t[:i + 1] and len(t[:i + 1]) > len(curr):\n            curr = t[:i + 1]\n    t = t[::-1]\n    for i in range(len(t)):\n        if t[:i + 1][::-1] == t[:i + 1] and len(t[:i + 1]) > len(curr):\n            curr = t[:i + 1]\n    print(left + curr + right)", "for _ in range(int(input())):\n    s = input()\n    res1 = ''\n    res2 = ''\n    i = 0\n    j = len(s) - 1\n    cur1 = ''\n    cur2 = ''\n    while s[i] == s[j] and i < j:\n        res1 += s[i]\n        res2 = s[j] + res2\n        i += 1\n        j -= 1\n    if i == j:\n        res1 += s[i]\n    else:\n        for x in range(i, j):\n            temp = s[i:x + 1]\n            if temp == temp[::-1]:\n                cur1 = temp\n        for x in range(j, i, -1):\n            temp = s[x:j + 1]\n            if temp == temp[::-1]:\n                cur2 = temp\n        if len(cur1) >= len(cur2):\n            res1 += cur1\n        else:\n            res2 = cur2 + res2\n    if res1 == '' and res2 == '':\n        print(s[0])\n    else:\n        print(res1 + res2)", "for _ in range(int(input())):\n    a = input()\n    st = ''\n    if a == a[::-1]:\n        print(a)\n    else:\n        le = len(a)\n        for i in range(int(abs(-le // 2))):\n            if a[i] == a[le - i - 1]:\n                st += a[i]\n            else:\n                break\n        tem = ''\n        for j in range(i, le - i):\n            if a[i:j + 1] == a[i:j + 1][::-1]:\n                tem = a[i:j + 1]\n        c_1 = st + tem + st[::-1]\n        a = a[::-1]\n        tem = ''\n        for j in range(i, le - i):\n            if a[i:j + 1] == a[i:j + 1][::-1]:\n                tem = a[i:j + 1]\n        c_2 = st + tem + st[::-1]\n        if len(c_1) >= len(c_2):\n            print(c_1)\n        else:\n            print(c_2)", "def reverse(s):\n    return s[::-1]\n\ndef isPalindrome(s):\n    rev = reverse(s)\n    if s == rev:\n        return True\n    return False\n\ndef SubStr(S, s, e):\n    res = ''\n    for i in range(s, e):\n        res += S[i]\n    return res\n\ndef ProcessInputs():\n    S = input()\n    T = ''\n    for i in range(0, len(S)):\n        if i >= len(S) - i - 1:\n            break\n        if S[i] != S[len(S) - i - 1]:\n            break\n        else:\n            T += S[i]\n    newS = SubStr(S, i, len(S) - i)\n    newS1 = newS[::-1]\n    L1 = 1\n    for i in range(1, len(newS)):\n        string = newS[:i + 1]\n        if isPalindrome(string):\n            L1 = len(string)\n    L2 = 1\n    for i in range(1, len(newS1)):\n        string = newS1[:i + 1]\n        if isPalindrome(string):\n            L2 = len(string)\n    if L2 > L1:\n        res = newS1[:L2]\n    else:\n        res = newS[:L1]\n    print(T + res + T[::-1])\nT = int(input())\nfor _ in range(T):\n    ProcessInputs()", "for _ in range(int(input())):\n    s = input()\n    ans = [1, s[0]]\n    (l, r) = (0, len(s) - 1)\n    while l < r:\n        if s[l] == s[r]:\n            l += 1\n            r -= 1\n        else:\n            hehe = r\n            while hehe != l - 1:\n                cay = s[:hehe] + s[r + 1:]\n                if cay == cay[::-1]:\n                    ans = [len(cay), cay]\n                    break\n                hehe -= 1\n            hehe = l + 1\n            while hehe != r + 1:\n                cay = s[:l] + s[hehe:]\n                if len(cay) > ans[0] and cay == cay[::-1]:\n                    ans = [len(cay), cay]\n                    break\n                hehe += 1\n            break\n    if r <= l:\n        print(s)\n    else:\n        print(ans[1])", "for _ in range(int(input())):\n    s = input()\n    n = len(s)\n    left = ''\n    right = ''\n    i = 0\n    j = n - 1\n    while i < j:\n        if s[i] == s[j]:\n            left += s[i]\n            right += s[j]\n        else:\n            break\n        i += 1\n        j -= 1\n    rem = s[i:j + 1]\n    curr = ''\n    for i in range(len(rem)):\n        if rem[:i + 1] == rem[:i + 1][::-1] and len(rem[:i + 1]) > len(curr):\n            curr = rem[:i + 1]\n    rem = rem[::-1]\n    for i in range(len(rem)):\n        if rem[:i + 1] == rem[:i + 1][::-1] and len(rem[:i + 1]) > len(curr):\n            curr = rem[:i + 1]\n    print(left + curr + right[::-1])", "t = int(input())\nfor _ in range(0, t):\n    s = input()\n    (l, r) = ('', '')\n    (ll, rr) = (0, len(s) - 1)\n    while ll < rr:\n        if s[ll] == s[rr]:\n            l += s[ll]\n            r += s[rr]\n            ll += 1\n            rr -= 1\n        else:\n            break\n    left = s[ll:rr + 1]\n    middle = ''\n    for i in range(0, len(left)):\n        if left[:i + 1] == left[:i + 1][::-1] and len(middle) < len(left[:i + 1]):\n            middle = left[:i + 1]\n    for i in range(len(left) - 1, -1, -1):\n        if left[i:len(left)] == left[i:len(left)][::-1] and len(middle) < len(left[i:len(left)]):\n            middle = left[i:len(left)]\n    print(l + middle + r[::-1])", "n = int(input())\nfor i in range(n):\n    s = input()\n    t = 1\n    for i in range(len(s)):\n        q = i\n        if s[q] == s[-t]:\n            t = t + 1\n        else:\n            break\n    r = s[t - 1:len(s) - t + 1]\n    pre = ''\n    suf = ''\n    for i in range(len(r)):\n        if r[0:i] == r[0:i][::-1]:\n            pre = r[0:i]\n    re = r[::-1]\n    for i in range(0, len(r)):\n        if re[0:i] == re[0:i][::-1]:\n            suf = re[0:i]\n    if s == s[::-1]:\n        print(s)\n    elif len(pre) >= len(suf):\n        print(s[:t - 1] + pre + s[:t - 1][::-1])\n    else:\n        print(s[:t - 1] + suf + s[:t - 1][::-1])", "for _ in range(int(input())):\n    s = input()\n    l = len(s)\n    a = ''\n    p = 0\n    if s == s[::-1]:\n        print(s)\n        continue\n    for i in range(l // 2):\n        if s[i] == s[l - 1 - i]:\n            a = a + s[i]\n        else:\n            p = i\n            break\n    mid1 = ''\n    mid2 = ''\n    for i in range(p, l - p):\n        if s[p:i] == s[p:i][::-1]:\n            mid1 = s[p:i]\n    x = s[::-1]\n    for i in range(p, l - p):\n        if x[p:i] == x[p:i][::-1]:\n            mid2 = x[p:i]\n    ans1 = a + mid1 + a[::-1]\n    ans2 = a + mid2 + a[::-1]\n    if len(ans1) >= len(ans2):\n        print(ans1)\n    else:\n        print(ans2)", "t = int(input())\nfor counter in range(t):\n    s = input()\n    l = len(s)\n    left = right = ''\n    i = 0\n    j = l - 1\n    while i < j:\n        if s[i] == s[j]:\n            left += s[i]\n            right += s[j]\n            i += 1\n            j -= 1\n        else:\n            break\n    rem = s[i:j + 1]\n    req = ''\n    for i in range(len(rem)):\n        if rem[:i + 1] == rem[:i + 1][::-1] and len(rem[:i + 1]) > len(req):\n            req = rem[:i + 1]\n    rem = rem[::-1]\n    for i in range(len(rem)):\n        if rem[:i + 1] == rem[:i + 1][::-1] and len(rem[:i + 1]) > len(req):\n            req = rem[:i + 1]\n    print(right + req + left[::-1])", "testcase = int(input())\nwhile testcase:\n    s = input()\n    new = ''\n    front = ''\n    back = ''\n    i = 0\n    j = len(s) - 1\n    while i <= j and s[i] == s[j]:\n        front += s[i]\n        if i != j:\n            back += s[j]\n        i += 1\n        j -= 1\n    back = back[::-1]\n    if i >= j:\n        print(front + back)\n    else:\n        mid = ''\n        for l in range(1, j - i + 2):\n            sub = s[i:i + l]\n            if sub == sub[::-1]:\n                mid = sub\n        for l in range(1, j - i + 2):\n            sub = s[j - l + 1:j + 1]\n            x = sub[::-1]\n            if x == x[::-1]:\n                if len(x) > len(mid):\n                    mid = x\n        print(front + mid + back)\n    testcase -= 1", "import math, sys\nimport heapq\nfrom collections import Counter, defaultdict\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ls():\n    return list(map(int, list(input())))\n\ndef la():\n    return list(input())\n\ndef ii():\n    return int(input())\n\ndef dic(x):\n    return defaultdict(lambda : x)\n\ndef isPrime(n):\n    i = 2\n    if n == 1:\n        return False\n    while i <= int(math.sqrt(n)):\n        if n % i == 0:\n            return False\n        i = i + 1\n    return True\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef binarySearch(arr, x):\n    (l, r) = (0, len(arr) - 1)\n    while l <= r:\n        mid = l + (r - l) // 2\n        if arr[mid] == x:\n            return True\n        elif arr[mid] < x:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return False\nt = ii()\nfor _ in range(t):\n    s = la()\n    if len(s) == 1:\n        print(''.join(s))\n    else:\n        n = len(s)\n        for i in range(n // 2):\n            if s[i] != s[n - i - 1]:\n                break\n        a = s[0:i]\n        n = n - 2 * i\n        b = ''\n        for j in range(n, -1, -1):\n            s1 = s[i:i + j]\n            s2 = s[i + n - j:i + n]\n            if s1 == s1[::-1]:\n                b = s1\n                break\n            elif s2 == s2[::-1]:\n                b = s2\n                break\n        print(''.join(a + b + a[::-1]))", "def ispal(s):\n    for i in range(len(s) // 2):\n        if s[i] != s[-(i + 1)]:\n            return False\n    return True\n\ndef chunk(s):\n    n = len(s)\n    if n == 1:\n        return ('', s, '')\n    for i in range(n // 2):\n        if s[i] != s[-(i + 1)]:\n            break\n    return (s[:i], s[i:n - i], s[n - i:])\n\ndef longest(s):\n    n = len(s)\n    for i in range(n):\n        s0 = s[:n - i]\n        if ispal(s0):\n            return s0\n\ndef solve(s):\n    (pre, mid, suf) = chunk(s)\n    m1 = longest(mid)\n    m2 = longest(mid[::-1])\n    m = m1 if len(m1) >= len(m2) else m2\n    return pre + m + suf\nt = int(input().strip())\nfor _ in range(t):\n    s = input().strip()\n    print(solve(s))", "def palindrome(s: str) -> bool:\n    length = len(s)\n    pre = length // 2\n    for i in range(pre):\n        if s[i] != s[-i - 1]:\n            return False\n    return True\n\ndef longestPalindrome(line: str) -> str:\n    (b, e) = (0, len(line) - 1)\n    while b < e and line[b] == line[e]:\n        b += 1\n        e -= 1\n    if b >= e:\n        return line\n    i = e\n    while i > b:\n        if palindrome(line[b:i]) is True:\n            break\n        i -= 1\n    p = line[:i] + line[e + 1:]\n    i = b + 1\n    while i < e:\n        if palindrome(line[i:e + 1]) is True:\n            break\n        i += 1\n    p2 = line[:b] + line[i:]\n    return p2 if len(p2) > len(p) else p\nn = int(input())\nfor i in range(n):\n    line = input().strip(' \\r\\n')\n    print(longestPalindrome(line))", "def chk(s):\n    n = len(s) // 2\n    for i in range(n):\n        if s[i] != s[-1 - i]:\n            return False\n    return True\n\ndef left(s):\n    n = len(s)\n    for i in range(n - 1, 0, -1):\n        if chk(s[:i]):\n            return s[:i]\n\ndef right(s):\n    n = len(s)\n    for i in range(1, n):\n        if chk(s[i:]):\n            return s[i:]\n\ndef chk2(s):\n    l = left(s)\n    r = right(s)\n    if len(l) >= len(r):\n        return l\n    else:\n        return r\n\ndef chk1(s):\n    i = 0\n    while s[i] == s[-1 - i]:\n        i += 1\n    res = s[:i] + chk2(s[i:-i]) + s[-i:]\n    return res\n\ndef main(s):\n    if chk(s):\n        return s\n    if s[0] == s[-1]:\n        res = chk1(s)\n    else:\n        res = chk2(s)\n    return res\nt = int(input())\nfor i in range(t):\n    s = list(input())\n    print(''.join(main(s)))", "def isPalindrom(s):\n    i = 0\n    j = len(s) - 1\n    while i <= j:\n        if s[i] != s[j]:\n            return False\n        else:\n            i += 1\n            j -= 1\n    return True\nt = int(input())\nfor z in range(0, t):\n    s = input()\n    i = 0\n    j = len(s) - 1\n    while i <= j:\n        if s[i] != s[j]:\n            break\n        else:\n            i += 1\n            j -= 1\n    if j < i:\n        print(s)\n        continue\n    else:\n        end = s[j + 1:len(s)]\n        start = s[0:i]\n        left = i\n        right = j\n        leftSub = ''\n        rightSub = ''\n        j -= 1\n        while j >= i:\n            if isPalindrom(s[i:j + 1]):\n                leftSub = s[i:j + 1]\n                break\n            else:\n                j -= 1\n        j = right\n        i += 1\n        while i < j:\n            if isPalindrom(s[i:j + 1]):\n                rightSub = s[i:j + 1]\n                break\n            else:\n                i += 1\n        print(start + (rightSub if len(rightSub) > len(leftSub) else leftSub) + end)", "def isPalindrome(str):\n    for i in range(0, len(str) // 2):\n        if str[i] != str[len(str) - i - 1]:\n            return False\n    return True\nt = int(input())\nfor i in range(t):\n    s = input()\n    if len(s) == 1:\n        print(s)\n    else:\n        t = ''\n        a = ''\n        b = ''\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] == s[j]:\n                a += s[i]\n                b = s[j] + b\n                i += 1\n                j -= 1\n            else:\n                break\n        t1 = ''\n        t2 = ''\n        for x in range(j, i - 1, -1):\n            ans1 = isPalindrome(s[i:x + 1])\n            if ans1:\n                t1 = s[i:x + 1]\n                break\n        for x in range(i, j + 1):\n            ans1 = isPalindrome(s[x:j + 1])\n            if ans1:\n                t2 = s[x:j + 1]\n                break\n        n1 = len(t1)\n        n2 = len(t2)\n        if n1 >= n2:\n            t = a + t1 + b\n        else:\n            t = a + t2 + b\n        print(t)", "def find(s):\n    if len(s) <= 1:\n        return s\n    if s[0] == s[-1]:\n        index = 1\n        while index < len(s) // 2:\n            if s[index] == s[len(s) - index - 1]:\n                index += 1\n            else:\n                break\n        return s[0:index] + find(s[index:len(s) - index]) + s[len(s) - index:]\n    left = -1\n    for i in range(len(s), 0, -1):\n        if isPal(s[:i]):\n            left = i\n            break\n    right = -1\n    for i in range(0, len(s)):\n        if isPal(s[i:]):\n            right = i\n            break\n    if left >= len(s) - right:\n        return s[:left]\n    return s[right:]\n\ndef isPal(s):\n    for i in range(len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True\nn = int(input())\nfor i in range(n):\n    print(find(input()))", "def get_palindrome(s):\n    n = len(s)\n    res = ''\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return res\n        else:\n            res += s[i]\n    return res\n\ndef is_palindrome(s):\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return False\n    return True\nfor _ in range(int(input())):\n    s = input().strip()\n    n = len(s)\n    beg = get_palindrome(s)\n    x = len(beg)\n    temp = ''\n    a = ''\n    b = ''\n    for i in range(x, n - x):\n        temp += s[i]\n        if is_palindrome(temp):\n            a = temp\n    temp = ''\n    for i in range(n - x - 1, x - 1, -1):\n        temp = s[i] + temp\n        if is_palindrome(temp):\n            b = temp\n    if len(beg) == len(a) == len(b) == 0:\n        print(s[0])\n    if len(a) >= len(b):\n        temp = (beg + a + beg[::-1]).strip()\n        print(temp)\n    else:\n        temp = (beg + b + beg[::-1]).strip()\n        print(temp)", "def checkpallendrome(s, l):\n    for i in range(l // 2):\n        if s[i] != s[l - i - 1]:\n            return False\n    return True\nt = int(input())\nwhile t > 0:\n    s = input()\n    n = len(s)\n    start = ''\n    end = ''\n    i = 0\n    j = n - 1\n    if n == 1:\n        print(s)\n        t -= 1\n        continue\n    while i < j:\n        if s[i] == s[j]:\n            i += 1\n            j -= 1\n        else:\n            break\n    pointer1 = i\n    pointer2 = j\n    temp = ''\n    maxpall = ''\n    for k in range(pointer1, pointer2 + 1):\n        temp = s[pointer1:k + 1]\n        if checkpallendrome(temp, k - pointer1 + 1) and len(maxpall) < len(temp):\n            maxpall = temp\n    for k in range(pointer2, pointer1 - 1, -1):\n        temp = s[k:pointer2 + 1]\n        if checkpallendrome(temp, pointer2 - k + 1) and len(maxpall) < len(temp):\n            maxpall = temp\n    ans = s[0:i] + maxpall + s[j + 1:n]\n    print(ans)\n    t -= 1", "t = int(input())\n\ndef checkpal(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\nfor rep in range(t):\n    s = input()\n    a = []\n    b = []\n    i = 0\n    j = len(s) - 1\n    while i < j and s[i] == s[j]:\n        a.append(s[i])\n        b.append(s[j])\n        i += 1\n        j -= 1\n    temp1 = ''\n    temp2 = ''\n    maxi1 = ''\n    maxi2 = ''\n    for i in range(len(a), len(s) - len(a)):\n        temp1 = temp1 + s[i]\n        temp2 = s[len(s) - 1 - i] + temp2\n        if checkpal(temp1):\n            if len(temp1) > len(maxi1):\n                maxi1 = temp1\n        if checkpal(temp2):\n            if len(temp2) > len(maxi2):\n                maxi2 = temp2\n    b.reverse()\n    a = ''.join(a)\n    b = ''.join(b)\n    maxi = ''\n    if len(maxi1) >= len(maxi2):\n        maxi = maxi1\n    else:\n        maxi = maxi2\n    print(a + maxi + b)", "def palindrome(s, start, end):\n    i = 0\n    while start + i < end - i and s[start + i] == s[end - i]:\n        i += 1\n    if s[start + i] == s[end - i]:\n        return True\n    else:\n        return False\n\ndef prefix(s, l):\n    ans = ''\n    i = 0\n    while s[i] == s[l - i - 1] and i < l - i - 1:\n        i += 1\n    ans = s[:i]\n    start = i\n    end = l - i - 1\n    x = end\n    m = ''\n    n = ''\n    while x >= start:\n        if palindrome(s, start, x):\n            m = s[start:x + 1]\n            break\n        x -= 1\n    x = start\n    while x <= end:\n        if palindrome(s, x, end):\n            n = s[x:end + 1]\n            break\n        x += 1\n    l1 = len(m)\n    l2 = len(n)\n    if l1 >= l2:\n        ans += m\n    else:\n        ans += n\n    ans += s[end + 1:]\n    return ans\nfor _ in range(int(input())):\n    s = input()\n    l = len(s)\n    print(prefix(s, l))", "import sys\nsys.setrecursionlimit(2000000)\nT = int(input())\n\ndef is_palindrom(s, left, right):\n    if left == right:\n        return True\n    if left > right:\n        return True\n    if s[left] != s[right]:\n        return False\n    return is_palindrom(s, left + 1, right - 1)\nfor t in range(T):\n    s = input()\n    left = 0\n    right = len(s) - 1\n    len_common = 0\n    special = False\n    while left <= right:\n        if left == right:\n            break\n        if s[left] != s[right]:\n            break\n        else:\n            left += 1\n            right -= 1\n            len_common += 1\n    if left == right:\n        print(s)\n        continue\n    a = s[left:right + 1]\n    first = 0\n    second = 0\n    left = 0\n    right = len(a) - 1\n    while not is_palindrom(a, left, right):\n        right -= 1\n    first = a[left:right + 1]\n    right = len(a) - 1\n    left = 0\n    while not is_palindrom(a, left, right):\n        left += 1\n    second = a[left:right + 1]\n    if len(first) < len(second):\n        a = second\n    else:\n        a = first\n    res = s[0:len_common] + a + s[len(s) - len_common:]\n    print(res)", "t = int(input())\nfor _ in range(t):\n    s = input()\n    i = 0\n    j = len(s) - 1\n    pre = ''\n    sef = ''\n    flag = 0\n    while i < j:\n        if s[i] == s[j]:\n            pre = pre + s[i]\n            sef = s[j] + sef\n        else:\n            flag = 1\n            break\n        i += 1\n        j -= 1\n    if flag == 0:\n        print(s)\n    else:\n        mid1 = ''\n        mid2 = ''\n        start = i\n        end = j\n        while start <= end:\n            k = 0\n            flag = 0\n            while k <= (end - start) // 2:\n                if s[start + k] != s[end - k]:\n                    flag = 1\n                    break\n                k += 1\n            if flag == 0:\n                mid1 = mid1 + s[start:end + 1]\n                break\n            else:\n                end -= 1\n        start = i\n        end = j\n        while start <= end:\n            k = 0\n            flag = 0\n            while k <= (end - start) // 2:\n                if s[start + k] != s[end - k]:\n                    flag = 1\n                    break\n                k += 1\n            if flag == 0:\n                mid2 = mid2 + s[start:end + 1]\n                break\n            else:\n                start += 1\n        if len(mid1) < len(mid2):\n            print(pre + mid2 + sef)\n        else:\n            print(pre + mid1 + sef)", "import sys\nsys.setrecursionlimit(10000)\n\ndef palindrome(s, si, ei):\n    if si >= ei:\n        return True\n    if s[si] == s[ei]:\n        return palindrome(s, si + 1, ei - 1)\n    elif s[si] != s[ei]:\n        return False\n\ndef solve():\n    s = input()\n    n = len(s)\n    if n == 1:\n        print(s)\n        return\n    (i, j, l) = (0, n - 1, 0)\n    while i < j and s[i] == s[j]:\n        i += 1\n        j -= 1\n        l += 1\n    if i == j or i - j == 1:\n        print(s)\n        return\n    (pmaxx, smaxx) = (0, 0)\n    (pnote, snote) = (l, n - l)\n    for i in range(l + 1, n - l - 1):\n        stm = palindrome(s, l, i)\n        if stm and i - l + 1 > pmaxx:\n            pnote = i\n            pmaxx = i - l + 1\n    for j in range(n - l - 2, l - 1, -1):\n        stm = palindrome(s, j, n - l - 1)\n        if stm and n - l - j > smaxx:\n            snote = j\n            smaxx = n - l - j\n    if pmaxx == 0 and smaxx == 0 and (l == 0):\n        print(s[0])\n        return\n    if pmaxx >= smaxx:\n        final = s[0:l] + s[l:pnote + 1] + s[n - l:]\n    else:\n        final = s[0:l] + s[snote:n - l] + s[n - l:]\n    print(final)\n    return\nl = int(input())\nfor i in range(l):\n    solve()", "import sys\nsys.setrecursionlimit(10000)\n\ndef palindrome(s, si, ei):\n    if si >= ei:\n        return True\n    if s[si] == s[ei]:\n        return palindrome(s, si + 1, ei - 1)\n    elif s[si] != s[ei]:\n        return False\n\ndef solve():\n    s = input()\n    n = len(s)\n    if n == 1:\n        print(s)\n        return\n    (i, j, l) = (0, n - 1, 0)\n    while i < j and s[i] == s[j]:\n        i += 1\n        j -= 1\n        l += 1\n    if i == j or i - j == 1:\n        print(s)\n        return\n    (pmaxx, smaxx) = (0, 0)\n    (pnote, snote) = (l, n - l)\n    for i in range(l + 1, n - l - 1):\n        stm = palindrome(s, l, i)\n        if stm and i - l + 1 > pmaxx:\n            pnote = i\n            pmaxx = i - l + 1\n    for j in range(n - l - 2, l - 1, -1):\n        stm = palindrome(s, j, n - l - 1)\n        if stm and n - l - j > smaxx:\n            snote = j\n            smaxx = n - l - j\n    if pmaxx == 0 and smaxx == 0 and (l == 0):\n        print(s[0])\n        return\n    if pmaxx >= smaxx:\n        final = s[0:l] + s[l:pnote + 1] + s[n - l:]\n    else:\n        final = s[0:l] + s[snote:n - l] + s[n - l:]\n    print(final)\n    return\nt = int(input())\nfor i in range(t):\n    solve()", "def is_palind(s):\n    start = 0\n    end = len(s) - 1\n    valid = True\n    while valid and start <= len(s) / 2:\n        valid = s[start] == s[end]\n        start += 1\n        end -= 1\n    return valid\n\ndef left_palind(s):\n    start = 0\n    end = len(s)\n    found = False\n    while not found and start < end:\n        found = is_palind(s[:end])\n        end -= 1\n    return s[:end + 1]\n\ndef right_palind(s):\n    start = 0\n    end = len(s)\n    found = False\n    while not found and start < end:\n        found = is_palind(s[start:end])\n        start += 1\n    return s[start - 1:end]\n\ndef paland(s):\n    if len(s) <= 1 or is_palind(s):\n        return s\n    a = ''\n    b = ''\n    start = 0\n    end = len(s) - 1\n    valid = True\n    while valid and start <= len(s) / 2:\n        valid = s[start] == s[end]\n        if valid:\n            a = a + s[start]\n            b = s[start] + b\n            start += 1\n            end -= 1\n    if len(right_palind(s[start:end + 1])) > len(left_palind(s[start:end + 1])):\n        return a + right_palind(s[start:end + 1]) + b\n    else:\n        return a + left_palind(s[start:end + 1]) + b\nn_tests = int(input())\nstrings = []\nfor i in range(n_tests):\n    strings.append(input())\nfor s in strings:\n    print(paland(s))", "def ispalin(s):\n    ans = True\n    for i in range(len(s)):\n        if s[i] != s[len(s) - 1 - i]:\n            ans = False\n            break\n        if i > len(s) // 2:\n            break\n    return ans\nfor _ in range(int(input())):\n    s = input()\n    k = ''\n    l = ''\n    for j in range(len(s)):\n        if s[j] == s[len(s) - 1 - j]:\n            k += s[j]\n            l = s[j] + l\n        else:\n            break\n    if j != len(s) - 1:\n        t = ''\n        y = ''\n        for r in range(j, len(s) - j):\n            t += s[r]\n            if ispalin(t):\n                y = t\n        q = ''\n        v = ''\n        for r in range(len(s) - j - 1, j - 1, -1):\n            q = s[r] + q\n            if ispalin(q):\n                v = q\n        if len(v) > len(y):\n            print(k + v + l)\n        else:\n            print(k + y + l)\n    else:\n        print(s)"]