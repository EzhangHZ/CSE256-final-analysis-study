["t = int(input())\nfor tc in range(t):\n    (n, m) = map(int, input().split())\n    p = list(map(int, input().split()))\n    d = input().split()\n    a = [(p[i], d[i], i) for i in range(n)]\n    a = sorted(a)\n    sol = [-1 for _ in range(n)]\n    (odd, even) = ([], [])\n    for i in range(n):\n        q = odd if a[i][0] % 2 else even\n        if len(q) == 0:\n            q.append(a[i])\n        elif q[-1][1] == 'R' and a[i][1] == 'L':\n            sol[a[i][2]] = sol[q[-1][2]] = (a[i][0] - q[-1][0]) // 2\n            q.pop()\n        else:\n            q.append(a[i])\n    for q in (odd, even):\n        while len(q) >= 2 and q[-2][1] == 'R':\n            sol[q[-2][2]] = sol[q[-1][2]] = m - q[-1][0] + (q[-1][0] - q[-2][0]) // 2\n            q.pop()\n            q.pop()\n        i = 1\n        while i < len(q):\n            if q[i][1] != 'L':\n                break\n            sol[q[i - 1][2]] = sol[q[i][2]] = q[i - 1][0] + (q[i][0] - q[i - 1][0]) // 2\n            i += 2\n        if i + 1 <= len(q):\n            sol[q[-1][2]] = sol[q[-2][2]] = m - (q[-1][0] - q[-2][0]) // 2\n    print(' '.join(map(str, sol)))", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = list(zip(map(int, input().split()), input().split()))\n    r = [[], []]\n    for i in range(n):\n        j = arr[i][0] % 2\n        r[j].append((arr[i][0], arr[i][1], i))\n    (odd, even) = (r[1], r[0])\n    time = [-1] * n\n    s = []\n    for (c, d, idx) in sorted(odd):\n        if d == 'R':\n            s.append((idx, c))\n        elif s == []:\n            s.append((idx, -c))\n        else:\n            (tidx, tc) = s.pop()\n            time[idx] = (c - tc) // 2\n            time[tidx] = time[idx]\n    while len(s) > 1:\n        (idx1, c1) = s.pop()\n        (idx2, c2) = s.pop()\n        time[idx1] = (2 * m - c1 - c2) // 2\n        time[idx2] = time[idx1]\n    s = []\n    for (c, d, idx) in sorted(even):\n        if d == 'R':\n            s.append((idx, c))\n        elif s == []:\n            s.append((idx, -c))\n        else:\n            (tidx, tc) = s.pop()\n            time[idx] = (c - tc) // 2\n            time[tidx] = time[idx]\n    while len(s) > 1:\n        (idx1, c1) = s.pop()\n        (idx2, c2) = s.pop()\n        time[idx1] = (2 * m - c1 - c2) // 2\n        time[idx2] = time[idx1]\n    print(' '.join(map(str, time)))", "def collide_after(indices):\n    ans = [-1] * N\n    indices.sort(key=lambda i: A[i])\n    stack = []\n    for i in indices:\n        if D[i] == 'R':\n            stack.append(i)\n        elif len(stack) > 0:\n            j = stack.pop()\n            ans[i] = A[i] - A[j] >> 1\n            ans[j] = ans[i]\n        else:\n            stack.append(i)\n            A[i] = -A[i]\n    while len(stack) >= 2:\n        i = stack.pop()\n        j = stack.pop()\n        ans[i] = M - A[i] + (A[i] - A[j] >> 1)\n        ans[j] = ans[i]\n    return ans\n\ndef solve():\n    even = [i for i in range(N) if A[i] % 2 == 0]\n    odd = [i for i in range(N) if A[i] % 2 == 1]\n    even_soln = collide_after(even)\n    odd_soln = collide_after(odd)\n    ans = [0] * N\n    for i in range(N):\n        if A[i] % 2 == 0:\n            ans[i] = even_soln[i]\n        else:\n            ans[i] = odd_soln[i]\n    return ans\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    (N, M) = map(int, input().split())\n    A = list(map(int, input().split()))\n    D = input().split()\n    print(*solve())", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x1, dire, i1) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i1, -x1))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i1] = ans[i2] = (x1 - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i1, x1))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "import sys\n\ndef check(arr):\n    arr.sort(key=lambda x: x[1])\n    stack = []\n    for (idx, pos, way) in arr:\n        if way == 'L':\n            if not stack:\n                stack.append((idx, -pos))\n            else:\n                temp = stack.pop()\n                ans[idx] = ans[temp[0]] = (pos - temp[1]) // 2\n        else:\n            stack.append((idx, pos))\n    while len(stack) > 1:\n        fir = stack.pop()\n        sec = stack.pop()\n        ans[fir[0]] = ans[sec[0]] = (m + m - fir[1] - sec[1]) // 2\nt = int(sys.stdin.readline())\nfor i in range(t):\n    (n, m) = map(int, sys.stdin.readline().split())\n    start = list(map(int, sys.stdin.readline().split()))\n    direction = list(sys.stdin.readline().split())\n    data = [[], []]\n    ans = [-1] * len(start)\n    for j in range(len(start)):\n        data[start[j] % 2].append((j, start[j], direction[j]))\n    check(data[0])\n    check(data[1])\n    print(*ans)", "def solve(robot, m, res):\n    robot.sort()\n    stack = []\n    for (x, dire, i) in robot:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                res[i] = res[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        res[i1] = res[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robot = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robot[x & 1].append((x, dire, i))\n    res = [-1 for i in range(n)]\n    solve(robot[0], m, res)\n    solve(robot[1], m, res)\n    print(*res)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)", "def partners(robots):\n    robots.sort()\n    partnerships = []\n    stack = []\n    for robot in robots:\n        if len(stack) == 0 or robot[1] == 'R':\n            stack.append(robot)\n        else:\n            poppedRobot = stack.pop()\n            partnerships.append((poppedRobot, robot))\n    while len(stack) > 1:\n        poppedRobot1 = stack.pop()\n        poppedRobot2 = stack.pop()\n        partnerships.append((poppedRobot2, poppedRobot1))\n    return partnerships\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    coords = list(map(int, input().split()))\n    direction = list(input().split())\n    robots = list(zip(coords, direction, range(n)))\n    odds = []\n    evens = []\n    for robot in robots:\n        if robot[0] % 2 == 0:\n            evens.append(robot)\n        else:\n            odds.append(robot)\n    partnerships = partners(odds) + partners(evens)\n    distances = [-1] * n\n    for (a, b) in partnerships:\n        if a[1] == 'R' and b[1] == 'L':\n            distance = (b[0] - a[0]) // 2\n        elif a[1] == 'L' and b[1] == 'L':\n            distance = (b[0] + a[0]) // 2\n        elif a[1] == 'R' and b[1] == 'R':\n            distance = (2 * m - a[0] - b[0]) // 2\n        else:\n            distance = (2 * m + a[0] - b[0]) // 2\n        distances[a[2]] = distance\n        distances[b[2]] = distance\n    print(*distances)", "def solve(robots, m, ans):\n    robots.sort()\n    stack = []\n    for (x, dire, i) in robots:\n        if dire == 'L':\n            if not stack:\n                stack.append((i, -x))\n            else:\n                (i2, x2) = stack[-1]\n                ans[i] = ans[i2] = (x - x2) // 2\n                stack.pop()\n        else:\n            stack.append((i, x))\n    while len(stack) >= 2:\n        (i1, x1) = stack[-1]\n        stack.pop()\n        x1 = m + (m - x1)\n        (i2, x2) = stack[-1]\n        stack.pop()\n        ans[i1] = ans[i2] = (x1 - x2) // 2\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    info = list(zip(map(int, input().split()), input().split()))\n    robots = [[], []]\n    for i in range(n):\n        (x, dire) = info[i]\n        robots[x & 1].append((x, dire, i))\n    ans = [-1 for i in range(n)]\n    solve(robots[0], m, ans)\n    solve(robots[1], m, ans)\n    print(*ans)"]