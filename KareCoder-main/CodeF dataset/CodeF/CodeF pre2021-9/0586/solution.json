["from heapq import *\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LI1():\n    return list(map(int1, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    (n, m) = MI()\n    to = [[] for _ in range(n)]\n    ot = [[] for _ in range(n)]\n    for _ in range(m):\n        (u, v) = MI1()\n        to[u].append(v)\n        ot[v].append(u)\n    k = II()\n    pp = LI1()\n    hp = []\n    heappush(hp, (0, pp[-1]))\n    dist = [-1] * n\n    while hp:\n        (d, u) = heappop(hp)\n        if dist[u] != -1:\n            continue\n        dist[u] = d\n        for v in ot[u]:\n            if dist[v] != -1:\n                continue\n            heappush(hp, (d + 1, v))\n    mn = mx = 0\n    for (p0, p1) in zip(pp, pp[1:]):\n        if dist[p0] - 1 != dist[p1]:\n            mn += 1\n        for v in to[p0]:\n            if v == p1:\n                continue\n            if dist[p0] - 1 == dist[v]:\n                mx += 1\n                break\n    print(mn, mx)\nmain()", "from collections import deque\n(n, m) = map(int, input().split())\ne = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    (a, b) = map(int, input().split())\n    e[b].append(a)\n(plen, path) = (int(input()), list(map(int, input().split())))\ntg = path[-1]\npathfrom = [[] for _ in range(n + 1)]\npathsz = [0] * (n + 1)\nq = deque([(tg, tg, 1)])\nwhile q:\n    (frm, to, sz) = q.popleft()\n    if pathsz[to] == 0:\n        pathsz[to] = sz\n        pathfrom[to].append(frm)\n        for u in e[to]:\n            q.append((to, u, sz + 1))\n    elif pathsz[to] == sz:\n        pathfrom[to].append(frm)\n(mn, mx) = (0, 0)\nfor i in range(plen - 1):\n    (u, v) = (path[i], path[i + 1])\n    if v in pathfrom[u]:\n        if len(pathfrom[u]) > 1:\n            mx += 1\n    else:\n        mn += 1\n        mx += 1\nprint(mn, mx)", "import bisect\nimport collections\nimport copy\nimport enum\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(3001)\ninput = sys.stdin.readline\nng = collections.defaultdict(list)\nsp = collections.defaultdict(list)\n(n, m) = map(int, input().split())\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    ng[v].append(u)\nk = int(input())\nks = list(map(int, input().split()))\nq = []\nvis = [0] * (n + 1)\nq.append(ks[-1])\nvis[ks[-1]] = 1\nwhile q:\n    nxt = set()\n    for cq in q:\n        for nq in ng[cq]:\n            if vis[nq] == 0:\n                sp[nq].append(cq)\n                nxt.add(nq)\n    q = list(nxt)\n    for cq in q:\n        vis[cq] = 1\nmn = 0\nmx = 0\nfor i in range(1, k):\n    if ks[i] not in sp[ks[i - 1]]:\n        mn += 1\n        mx += 1\n    elif len(sp[ks[i - 1]]) > 1:\n        mx += 1\nprint(mn, mx)", "import collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\ndef solve(N, M, edges, K, path):\n    (s, t) = (path[0], path[-1])\n    after = [[] for _ in range(N + 1)]\n    dist = [N + 1 for _ in range(N + 1)]\n    dist[t] = 0\n    d = 0\n    q = [t]\n    while q:\n        d += 1\n        nq = []\n        for u in q:\n            for v in edges[u]:\n                if dist[v] > d:\n                    dist[v] = d\n                    after[v] = [u]\n                    nq.append(v)\n                elif dist[v] == d:\n                    after[v].append(u)\n        q = nq\n    (minRebuild, maxRebuild) = (0, 0)\n    for i in range(len(path) - 1):\n        if path[i + 1] in after[path[i]]:\n            if len(after[path[i]]) > 1:\n                maxRebuild += 1\n        else:\n            minRebuild += 1\n            maxRebuild += 1\n    return [minRebuild, maxRebuild]\n(N, M) = map(int, input().split())\nedges = collections.defaultdict(list)\nfor i in range(M):\n    (u, v) = map(int, input().split())\n    edges[v].append(u)\nK = int(input())\npath = [int(x) for x in input().split()]\nprint(' '.join(map(str, solve(N, M, edges, K, path))))", "from collections import defaultdict, deque\n(n, m) = map(int, input().split())\nadj = defaultdict(list)\nrev = defaultdict(list)\ndist = {}\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    rev[v].append(u)\nint(input())\npath = list(map(int, input().split()))\nqueue = deque([path[-1]])\ndist[path[-1]] = 0\nwhile queue:\n    cur = queue.popleft()\n    for neighbor in rev[cur]:\n        if neighbor in dist:\n            continue\n        dist[neighbor] = dist[cur] + 1\n        queue.append(neighbor)\n(mini, maxi) = (0, 0)\nfor ind in range(1, len(path) - 1):\n    cur = path[ind]\n    pre = path[ind - 1]\n    if dist[cur] + 1 == dist[pre]:\n        for neighbor in adj[pre]:\n            if cur != neighbor and dist[neighbor] == dist[cur]:\n                maxi += 1\n                break\n    else:\n        mini += 1\n        maxi += 1\nprint(mini, maxi)", "from collections import deque\n(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\ng_n = [[] for _ in range(n)]\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    g_n[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\nk = int(input())\npath = list(map(int, input().split()))\nq = deque()\ndistance = [-1 for _ in range(n)]\ndistance[path[k - 1] - 1] = 0\nq.append(path[k - 1] - 1)\nwhile len(q):\n    u = q.popleft()\n    for v in g[u]:\n        if distance[v] == -1:\n            distance[v] = distance[u] + 1\n            q.append(v)\nrebuild = 0\nrebuild_max = 0\nfor i in range(1, k - 1):\n    if distance[path[i] - 1] == distance[path[i - 1] - 1] - 1:\n        for w in g_n[path[i - 1] - 1]:\n            if w != path[i] - 1 and distance[w] == distance[path[i] - 1]:\n                rebuild_max += 1\n                break\n    else:\n        rebuild += 1\nprint(rebuild, rebuild + rebuild_max)", "from collections import deque\n(n, m) = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\ninverse = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    graph[u].append(v)\n    inverse[v].append(u)\nk = int(input())\nway = list(map(int, input().split()))\ns = way[0]\nt = way[-1]\nqueue = deque()\nqueue.append(t)\nd = [0] * (n + 1)\nused = [False] * (n + 1)\nused[t] = True\nwhile len(queue):\n    cur = queue[0]\n    queue.popleft()\n    for to in inverse[cur]:\n        if not used[to]:\n            d[to] = d[cur] + 1\n            queue.append(to)\n            used[to] = True\nans_max = 0\nans_min = 0\nfor i in range(k - 1):\n    if d[way[i]] > d[way[i + 1]]:\n        to_min = -1\n        for to in graph[way[i]]:\n            if to != way[i + 1] and d[to] <= d[way[i + 1]]:\n                to_min = to\n        if to_min != -1:\n            ans_max += 1\n    else:\n        ans_max += 1\n        ans_min += 1\nprint(ans_min, ans_max)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nsys.setrecursionlimit(1 << 30)\n(m, n) = [int(x) for x in input().strip().split()]\ngraph = [[] for x in range(m + 1)]\nfor ni in range(n):\n    (s, e) = [int(x) for x in input().strip().split()]\n    graph[s].append(e)\ngrapht = [[] for x in range(m + 1)]\nfor mi in range(1, m + 1):\n    for mij in graph[mi]:\n        grapht[mij].append(mi)\nk = int(input())\nkl = [int(x) for x in input().split()]\n(v, d, mina, maxa) = ([0] * (m + 1), [m + 10] * (m + 1), 0, 0)\n(start, end) = (kl[0], kl[-1])\n(d[end], dq, v[end]) = (0, deque([end]), 1)\nwhile dq:\n    node = dq.popleft()\n    for nn in grapht[node]:\n        if not v[nn]:\n            (d[nn], v[nn]) = (1 + d[node], 1)\n            dq.append(nn)\nfor kj in range(k - 1):\n    ki = kl[kj]\n    (mki, mcnt) = (float('inf'), 1)\n    for nn in graph[ki]:\n        if d[nn] < mki:\n            mki = d[nn]\n            mcnt = 1\n        elif d[nn] == mki:\n            mcnt += 1\n    if mki == d[kl[kj + 1]]:\n        if mcnt > 1:\n            maxa += 1\n    else:\n        mina += 1\n        maxa += 1\nprint(mina, maxa)", "import sys\n(n, m) = list(map(int, sys.stdin.readline().strip().split()))\nN = [[] for i in range(0, n + 1)]\nN2 = [[] for i in range(0, n + 1)]\nfor i in range(0, m):\n    (u, v) = list(map(int, sys.stdin.readline().strip().split()))\n    N[u].append(v)\n    N2[v].append(u)\nD = [n + 10] * (n + 1)\nk = int(sys.stdin.readline().strip())\np = list(map(int, sys.stdin.readline().strip().split()))\nD[p[k - 1]] = 0\nL = [p[k - 1]]\ni = 0\nwhile i < len(L):\n    u = L[i]\n    for v in N2[u]:\n        if D[v] > D[u] + 1:\n            D[v] = D[u] + 1\n            L.append(v)\n    i = i + 1\nm = 0\nM = 0\nfor i in range(0, k - 1):\n    q = p[i]\n    r = p[i + 1]\n    if D[q] != 1 + D[r]:\n        m = m + 1\n        M = M + 1\n    c = 0\n    for v in N[q]:\n        if D[v] + 1 == D[q]:\n            c = c + 1\n    if c != 1 and D[q] == 1 + D[r]:\n        M = M + 1\nprint(m, M)", "from sys import stdin, stdout\nimport math\n(n, m) = map(int, stdin.readline().rstrip().split(' '))\nroads = [[] for _ in range(n)]\nroadsTo = [[] for _ in range(n)]\nfor _ in range(m):\n    (u, v) = map(int, stdin.readline().rstrip().split(' '))\n    u -= 1\n    v -= 1\n    roads[v].append(u)\n    roadsTo[u].append(v)\nk = int(stdin.readline().rstrip())\np = list(map(int, stdin.readline().rstrip().split(' ')))\np = [i - 1 for i in p]\nvisited = set([p[k - 1]])\nlastBatch = set([p[k - 1]])\nminLen = [0] * n\nwhile len(visited) < n:\n    batch = set()\n    for i in lastBatch:\n        for j in roads[i]:\n            if j not in visited:\n                visited.add(j)\n                minLen[j] = minLen[i] + 1\n                batch.add(j)\n    lastBatch = batch\nminChg = 0\nmaxChg = 0\nfor i in range(len(p) - 1):\n    nextUp = minLen[p[i + 1]]\n    otherQuickest = min([minLen[j] for j in roadsTo[p[i]] if j != p[i + 1]] + [999999])\n    if otherQuickest < nextUp:\n        minChg += 1\n        maxChg += 1\n    elif otherQuickest == nextUp:\n        maxChg += 1\nprint(str(minChg) + ' ' + str(maxChg))", "from collections import deque\n\ndef bfs(source):\n    dis = [-1] * n\n    que = deque()\n    que.append(source)\n    dis[source] = 0\n    while que:\n        u = que.popleft()\n        for v in g1[u]:\n            if dis[v] == -1:\n                dis[v] = dis[u] + g1[u][v]\n                que.append(v)\n    return dis\n(n, m) = map(int, input().split())\ng = [{} for i in range(n)]\ng1 = [{} for i in range(n)]\nfor j in range(m):\n    (u, v) = map(int, input().split())\n    g[u - 1][v - 1] = 1\n    g1[v - 1][u - 1] = 1\nk = int(input())\np = list(map(int, input().split()))\nd = bfs(p[-1] - 1)\nans1 = ans2 = 0\nfor i in range(1, k - 1):\n    m = d[p[i] - 1]\n    k1 = k2 = 0\n    for j in g[p[i - 1] - 1]:\n        if d[j] <= m and j != p[i] - 1 and (k1 == 0):\n            ans1 += 1\n            k1 = 1\n        if d[j] < m:\n            ans2 += 1\n            k2 = 1\n        if k1 == 1 and k2 == 1:\n            break\nprint(ans2, ans1)", "from collections import defaultdict\nfrom collections import deque\n(n, m) = map(int, input().split())\nadj = defaultdict(list)\nrev = defaultdict(list)\ndist = {}\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    rev[v].append(u)\nk = int(input())\npath = list(map(int, input().split()))\ndt = {}\n\ndef bfs(t):\n    q = deque([t])\n    dt[t] = 0\n    while q:\n        c = q.popleft()\n        for y in rev[c]:\n            if y not in dt:\n                dt[y] = dt[c] + 1\n                q.append(y)\nmin_rebuild = 0\nmax_rebuild = 0\nbfs(path[k - 1])\nfor i in range(1, k - 1):\n    v = path[i - 1]\n    u = path[i]\n    if dt[u] + 1 > dt[v]:\n        min_rebuild += 1\n        max_rebuild += 1\n    elif dt[u] + 1 == dt[v]:\n        for w in adj[v]:\n            if u != w and dt[u] == dt[w]:\n                max_rebuild += 1\n                break\nprint(min_rebuild, max_rebuild)", "from heapq import *\n(n, m) = map(int, input().split())\ng = [[] for i in range(n + 1)]\nto = [[] for i in range(n + 1)]\nd = [1061109567 for i in range(n + 1)]\nvis = [0 for i in range(n + 1)]\n\ndef dij(s):\n    hp = []\n    d[s] = 0\n    heappush(hp, (0, s))\n    while hp:\n        (val, iid) = heappop(hp)\n        if vis[iid] == 1:\n            continue\n        vis[iid] = 1\n        for son in g[iid]:\n            if d[son] > d[iid] + 1:\n                d[son] = d[iid] + 1\n                heappush(hp, (d[son], son))\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    g[v].append(u)\n    to[u].append(v)\nk = int(input())\np = list(map(int, input().split()))\ndij(p[-1])\nmn = 0\nmx = 0\nfor i in range(len(p) - 1):\n    u = p[i]\n    v = p[i + 1]\n    if d[u] != d[v] + 1:\n        mn += 1\n    for iid in to[u]:\n        if iid == v:\n            continue\n        if d[u] == d[iid] + 1:\n            mx += 1\n            break\nprint(mn, mx)", "import sys\nfrom collections import deque\nsys.setrecursionlimit(1 << 30)\n(m, n) = [int(x) for x in input().strip().split()]\ngraph = [[] for x in range(m + 1)]\nfor ni in range(n):\n    (s, e) = [int(x) for x in input().strip().split()]\n    graph[s].append(e)\ngrapht = [[] for x in range(m + 1)]\nfor mi in range(1, m + 1):\n    for mij in graph[mi]:\n        grapht[mij].append(mi)\nk = int(input())\nkl = [int(x) for x in input().split()]\n(v, d, mina, maxa) = ([0] * (m + 1), [m + 10] * (m + 1), 0, 0)\n(start, end) = (kl[0], kl[-1])\n(d[end], dq, v[end]) = (0, deque([end]), 1)\nwhile dq:\n    node = dq.popleft()\n    for nn in grapht[node]:\n        if not v[nn]:\n            (d[nn], v[nn]) = (1 + d[node], 1)\n            dq.append(nn)\nfor kj in range(k - 1):\n    ki = kl[kj]\n    (mki, mcnt) = (float('inf'), 1)\n    for nn in graph[ki]:\n        if d[nn] < mki:\n            mki = d[nn]\n            mcnt = 1\n        elif d[nn] == mki:\n            mcnt += 1\n    if mki == d[kl[kj + 1]]:\n        if mcnt > 1:\n            maxa += 1\n    else:\n        mina += 1\n        maxa += 1\nprint(mina, maxa)", "from collections import defaultdict\n(n, m) = map(int, input().split())\nadj = defaultdict(list)\nrev = defaultdict(list)\ndist = {}\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    adj[u].append(v)\n    rev[v].append(u)\nk = int(input())\npath = list(map(int, input().split()))\ndt = {}\n\ndef bfs(t):\n    q = [t]\n    dt[t] = 0\n    while q:\n        c = q.pop(0)\n        for y in rev[c]:\n            if y not in dt:\n                dt[y] = dt[c] + 1\n                q.append(y)\nmin_rebuild = 0\nmax_rebuild = 0\nbfs(path[k - 1])\nfor i in range(1, k - 1):\n    v = path[i - 1]\n    u = path[i]\n    if dt[u] + 1 > dt[v]:\n        min_rebuild += 1\n        max_rebuild += 1\n    elif dt[u] + 1 == dt[v]:\n        for w in adj[v]:\n            if u != w and dt[u] == dt[w]:\n                max_rebuild += 1\n                break\nprint(min_rebuild, max_rebuild)", "inf = int(10000000000.0)\n(n, m) = map(int, input().split())\ntrans = [[] for i in range(n)]\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    trans[b - 1].append(a - 1)\n    graph[a - 1].append(b - 1)\nk = int(input())\nlis = [x - 1 for x in map(int, input().split())]\n(s, d) = (lis[0], lis[-1])\nv = [0] * n\ndis = [inf] * n\nv[d] = 1\ndis[d] = 0\nq = [d]\nwhile q:\n    node = q.pop(0)\n    for i in trans[node]:\n        if not v[i] and dis[i] > dis[node] + 1:\n            dis[i] = dis[node] + 1\n            q.append(i)\n(reb, ad) = (0, 0)\nprev = s\nfor i in range(1, k - 1):\n    if dis[lis[i]] + 1 > dis[prev]:\n        reb += 1\n    for j in graph[prev]:\n        if j != lis[i] and dis[j] + 1 == dis[prev]:\n            ad += 1\n            break\n    prev = lis[i]\nprint(reb, ad)", "import math\n(n, m) = map(int, input().strip().split())\noutadj = [set() for _ in range(n + 1)]\ninadj = [set() for _ in range(n + 1)]\ncost = [math.inf] * (n + 1)\ndiscovered = [False] * (n + 1)\nfor _ in range(m):\n    (u, v) = map(int, input().strip().split())\n    outadj[u].add(v)\n    inadj[v].add(u)\nk = int(input())\npath = list(map(int, input().strip().split()))\nsrc = path[0]\ndest = path[-1]\nq = [dest]\ncost[dest] = 0\ndiscovered[dest] = True\nwhile len(q) != 0:\n    u = q.pop(0)\n    for v in inadj[u]:\n        if discovered[v]:\n            continue\n        discovered[v] = True\n        cost[v] = cost[u] + 1\n        q.append(v)\nminim = 0\nmaxim = 0\nfor i in range(k - 1):\n    if cost[path[i]] - 1 != cost[path[i + 1]]:\n        minim += 1\n        maxim += 1\n    else:\n        for v in outadj[path[i]]:\n            if cost[path[i]] - 1 == cost[v] and v != path[i + 1]:\n                maxim += 1\n                break\nprint(minim, maxim)", "from collections import deque\n\ndef check(h):\n    ans = 0\n    for i in range(len(zapadlo[h])):\n        if colors[zapadlo[h][i]] == colors[h] - 1:\n            ans += 1\n    return ans\n(n, m) = map(int, input().split())\nmas = [0] * n\nzapadlo = [0] * n\nfor i in range(n):\n    mas[i] = []\n    zapadlo[i] = []\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    mas[b - 1] += [a - 1]\n    zapadlo[a - 1] += [b - 1]\nk = int(input())\npath = list(map(int, input().split()))\nq = deque()\nv = path[-1] - 1\nq.append(v)\ncolors = [-1] * n\npred = [-1] * n\ncolors[v] = 0\nwhile q:\n    f = q.popleft()\n    for j in range(len(mas[f])):\n        i = mas[f][j]\n        if colors[i] == -1:\n            colors[i] = colors[f] + 1\n            pred[i] = f\n            q.append(i)\na = 0\nb = 0\nfor i in range(1, k):\n    g = path[i] - 1\n    z = path[i - 1] - 1\n    e = colors[g]\n    f = colors[z]\n    if e + 1 != f:\n        a += 1\n        b += 1\n    elif check(z) > 1:\n        b += 1\nprint(a, b)"]