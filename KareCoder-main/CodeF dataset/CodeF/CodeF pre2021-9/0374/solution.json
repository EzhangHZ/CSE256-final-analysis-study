["import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    powers = []\n    for i in range(N):\n        (M, *cave) = list(map(int, input().split()))\n        for j in range(M):\n            cave[j] = cave[j] - j + 1\n        powers.append((max(cave), M))\n    powers.sort()\n    power = powers[0][0]\n    output = power\n    for (p, n) in powers:\n        if power >= p:\n            power += n\n        else:\n            output += p - power\n            power = p + n\n    print(output)", "import sys\nimport math\nfrom collections import Counter\ninput = sys.stdin.readline\nT = int(input().strip())\nfor t in range(T):\n    n = int(input().strip())\n    need = []\n    for c in range(n):\n        lst = [int(hp) for hp in input().strip().split()]\n        ch = 0\n        for i in range(1, lst[0] + 1):\n            ch = max(ch, lst[i] - i + 1)\n        need.append((ch + 1, lst[0]))\n    need.sort()\n    (ans, last) = (need[0][0], need[0][1])\n    for i in range(1, n):\n        ans = need[i][0] - last if need[i][0] - last > ans else ans\n        last = last + need[i][1]\n    print(ans)", "exec('\\nimport sys\\n\\ninput = sys.stdin.readline\\n\\n\\n\\n\\ndef give(a):\\n    m = len(a)\\n    c = a[0] + 1\\n    for i in range(m):\\n        #print(c, a[i])\\n        if c <= a[i]:\\n            c = a[i] + 2\\n        else:\\n            c += 1\\n    return [c - m, c]\\n\\n\\ndef solve(res):\\n    ans = res[0][0]\\n    c = res[0][1]\\n    for i in range(1, len(res)):\\n        if res[i][0] > c:\\n            ans += res[i][0] - c\\n            c = res[i][1]\\n        else:\\n            c = res[i][1] + c - res[i][0]\\n    return ans\\n\\n\\n\\nfor _ in range(int(input())):\\n    n = int(input())\\n    mat = []\\n    res = []\\n    for i in range(n):\\n        a = list(map(int, input().split()))\\n        res.append(give(a[1:]))\\n    #print(res)\\n    #t1 = sorted(res, key=lambda x:x[1])\\n    t2 = sorted(res, key=lambda x:x[0])\\n    sys.stdout.write(str(solve(t2)) + \"\\\\n\")\\n')", "import sys\nfrom collections import deque\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_list_strings():\n    return list(map(str, sys.stdin.readline().strip().split()))\n\ndef solve(n, arr):\n    final = []\n    bonus = []\n    for ele in arr:\n        k = ele[0]\n        temp = ele[1:]\n        best = 0\n        for i in range(k):\n            best = max(best, temp[i] - i)\n        final.append([best, -k])\n    final.sort()\n    best = final[0][0]\n    k = abs(final[0][1])\n    for i in range(1, n):\n        best = max(best, final[i][0] - k)\n        k += abs(final[i][1])\n    ans = best + 1\n    sys.stdout.write(str(ans) + '\\n')\nT = get_int()\nwhile T:\n    n = get_int()\n    arr = []\n    tempN = n\n    while tempN:\n        arr1 = get_list()\n        arr.append(arr1)\n        tempN -= 1\n    solve(n, arr)\n    T -= 1", "from sys import stdin\nread = lambda : stdin.readline()\nfor _ in range(int(read())):\n    n = int(read())\n    levels = []\n    main = []\n    for i in range(n):\n        main.append(list(map(int, read().split())))\n    main.sort(reverse=True)\n    op = []\n    for temp in main:\n        ans = 0\n        s = 0\n        for num in temp[1:]:\n            if s <= num:\n                ans += num - s + 1\n                s = num + 2\n            else:\n                s += 1\n        op.append((ans, temp[0]))\n    op.sort()\n    ans = 0\n    s = ans\n    tot = 0\n    for (minpow, inc) in op:\n        if s < minpow:\n            ans = minpow - tot\n            s = minpow\n        s += inc\n        tot += inc\n    print(ans)", "def find_power(lst):\n    powers = []\n    power = 0\n    chambers = 0\n    for a in lst:\n        power = 0\n        for (i, item) in enumerate(a):\n            if item >= power:\n                power = item + 1\n            power += 1\n        powers.append([power - len(a), len(a)])\n    powers.sort()\n    res = powers[0][0]\n    current_power = powers[0][0]\n    for i in range(len(powers) - 1):\n        current_power += powers[i][1]\n        chambers += powers[i][1]\n        if current_power < powers[i + 1][0]:\n            res = powers[i + 1][0] - chambers\n            current_power = powers[i + 1][0]\n    return res\nn = int(input())\nlst = []\nfor item in range(n):\n    p = int(input())\n    lst_sub = []\n    for i in range(p):\n        lst_sub.append([int(item) for item in input().split()[1:]])\n    lst.append(find_power(lst_sub))\nprint(*lst, sep='\\n')", "def getlistint():\n    return list(map(int, stdin.readline().split()))\n\ndef getmapint():\n    return map(int, stdin.readline().split())\n\ndef getliststr():\n    return list(stdin.readline().split())\n\ndef getint():\n    return int(stdin.readline().strip())\n\ndef getstr():\n    return stdin.readline().strip()\n\ndef pr(s):\n    stdout.write(str(s) + '\\n')\n\ndef prlist(l):\n    stdout.write(' '.join(list(map(str, l))) + '\\n')\nfrom sys import stdin, stdout\nfor _ in range(getint()):\n    n = getint()\n    mat = []\n    for i in range(n):\n        mat.append(getlistint())\n        startpow = 0\n        endpow = 0\n        for j in range(1, len(mat[i])):\n            if startpow + endpow <= mat[i][j]:\n                startpow += mat[i][j] - (startpow + endpow) + 1\n            endpow += 1\n        mat[i] = (startpow, startpow + endpow)\n    mat = sorted(mat)\n    power = mat[0][1]\n    s = 0\n    for i in range(1, n):\n        if power < mat[i][0]:\n            s += mat[i][0] - power\n            power = mat[i][1]\n        else:\n            power += mat[i][1] - mat[i][0]\n    pr(mat[0][0] + s)", "from collections import deque, Counter\nfrom collections import defaultdict as dfd\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial\nfrom heapq import heapify, heappush, heappop\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef readfl():\n    return list(map(float, input().strip().split()))\n\ndef readffl():\n    return list(map(float, file.readline().strip().split()))\n\ndef f(arr):\n    maxi = 0\n    for i in range(len(arr)):\n        maxi = max(maxi, arr[i] - i + 1)\n    return maxi\n\ndef solve():\n    for _ in range(nin()):\n        n = nin()\n        heap = []\n        for i in range(n):\n            arr = read()\n            k = arr[0]\n            heap.append((f(arr[1:]), k))\n        ans = 0\n        k_sum = 0\n        heap.sort()\n        for (curr, k) in heap:\n            if ans + k_sum < curr:\n                ans += curr - (ans + k_sum)\n            k_sum += k\n        ans_.append(ans)\nsolve()\nfor i in ans_:\n    print(i)", "def argsort(seq):\n    return sorted(range(len(seq)), key=seq.__getitem__)\nans = []\nnum_data = int(input())\nfor data in range(num_data):\n    num_peser = int(input())\n    pesery = []\n    for peser in range(num_peser):\n        pesera = list(map(int, input().split()[1:]))\n        pesery.append(pesera)\n    max_strengthes = []\n    for (i, j) in enumerate(pesery):\n        max_strengthes.append((0, 0, 0))\n        for (ind, element) in enumerate(j):\n            max_strength = element\n            res = max_strength - ind + 1\n            if res > max_strengthes[i][0]:\n                max_strengthes[i] = (max_strength - ind + 1, -ind, len(j))\n    new_indices = argsort(max_strengthes)\n    for (i, j) in enumerate(new_indices):\n        if i != 0:\n            max_strengthes[j] = (max_strengthes[j][0] - max_strengthes[new_indices[i - 1]][2], max_strengthes[j][1], max_strengthes[j][2] + max_strengthes[new_indices[i - 1]][2])\n    ans.append(max(max_strengthes)[0])\nprint('\\n'.join(map(str, ans)))", "import sys\ninput = sys.stdin.readline\n\ndef func(ai):\n    ct = 0\n    val = ai[0] + 1\n    ret = ai[0] + 1\n    for iii in range(len(ai)):\n        if val > ai[iii]:\n            val += 1\n        else:\n            val = ai[iii] + 1\n            ret = max(ret, val - ct)\n        ct += 1\n    return [ret, -len(ai)]\nfor x in range(int(input())):\n    n = int(input())\n    li = []\n    for _ in range(n):\n        ki = list(map(int, input().split()))[1:]\n        li.append(ki)\n    li.sort(key=lambda i: func(i))\n    mini = li[0][0] + 1\n    ans = li[0][0] + 1\n    ct = 0\n    for i in li:\n        for ii in range(len(i)):\n            if mini > i[ii]:\n                mini += 1\n            else:\n                mini = i[ii] + 1\n                ans = max(ans, mini - ct)\n                mini += 1\n            ct += 1\n    print(ans)", "import sys\nfrom math import sqrt, ceil, floor, gcd\nfrom collections import Counter\ninput = lambda : sys.stdin.readline()\n\ndef int_arr():\n    return list(map(int, input().split()))\n\ndef str_arr():\n    return list(map(str, input().split()))\n\ndef get_str():\n    return map(str, input().split())\n\ndef get_int():\n    return map(int, input().split())\n\ndef get_flo():\n    return map(float, input().split())\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\nmod = 1000000007\n\ndef solve(n, mat):\n    pass\nfor _ in range(int(input())):\n    n = int(input())\n    tmp = []\n    for i in range(n):\n        arr = int_arr()\n        maxx = 0\n        for j in range(1, arr[0] + 1):\n            maxx = max(maxx, arr[j] - j + 2)\n        tmp.append([maxx, arr[0]])\n    tmp.sort(key=lambda x: x[0])\n    ans = 0\n    num = 0\n    for i in tmp:\n        if i[0] > num:\n            ans += i[0] - num\n            num = i[0]\n        num += i[1]\n    print(ans)", "def func():\n    t = int(input().strip())\n    cases = []\n    for _ in range(t):\n        n = int(input().strip())\n        caves = []\n        for _ in range(n):\n            a = list(map(int, input().split()))\n            tmp = []\n            for i in range(1, a[0] + 1):\n                tmp.append(a[i] - (i - 1))\n            caves.append((max(tmp) + 1, a[0]))\n        cases.append(caves)\n    for case in cases:\n        print(video_game(case))\n\ndef video_game(caves):\n    caves.sort()\n    (ans, cnt) = (caves[0][0], caves[0][1])\n    for i in range(1, len(caves)):\n        cave = caves[i]\n        curr = ans + cnt\n        if curr < cave[0]:\n            ans += cave[0] - curr\n        cnt += cave[1]\n    return ans\nfunc()", "import math, bisect, heapq, random, sys, itertools\nsys.setrecursionlimit(10 ** 6 + 10)\ninput = sys.stdin.readline\nints = lambda : list(map(int, input().split()))\np = 10 ** 9 + 7\nalpha = 'abcdefghijklmnopqrstuvwxyz'\np2 = [1]\nfor i in range(30):\n    p2.append(p2[i] * 2)\nfor t in range(int(input())):\n    (n,) = ints()\n    a = [ints()[1:] for i in range(n)]\n    b = []\n    for i in a:\n        x = 0\n        for j in range(len(i)):\n            x = max(i[j] - j + 1, x)\n        b.append([x, len(i)])\n    b.sort()\n    ans = 0\n    x = 0\n    for i in b:\n        if x < i[0]:\n            ans += i[0] - x\n            x = i[0]\n        x += i[1]\n    print(ans)", "test_cases = input()\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef solve(arr, caves):\n    max_ = []\n    for i in arr:\n        max_power = i[0] + 1\n        exit_power = max_power + len(i)\n        for j in range(len(i)):\n            if max_power < i[j] + 1 - j:\n                max_power = i[j] + 1 - j\n                exit_power = max_power + len(i)\n        max_.append([max_power, exit_power])\n    max_.sort(key=lambda max_: max_[0])\n    for i in range(len(max_)):\n        if max_[-i][0] < max_[-1 - i][1]:\n            continue\n        elif max_[-i][0] >= max_[-1 - i][1]:\n            diff = max_[-i][0] - max_[-1 - i][1]\n            max_[-1 - i][1] = max_[-1 - i][1] + diff\n            max_[-1 - i][0] = max_[-1 - i][0] + diff\n    return max_[0][0]\nans = []\nfor i in range(int(test_cases)):\n    lis = []\n    caves = int(input())\n    for i in range(caves):\n        lis.append(inlt()[1:])\n    ans.append(solve(lis, caves))\nfor i in ans:\n    print(i)", "t = int(input())\nresults = [None] * t\nfor l in range(t):\n    n = int(input())\n    caves = [[int(x) for x in input().split()][1:] for _ in range(n)]\n    min_levels = [(max((x - i + 1 for (i, x) in enumerate(cave))), len(cave)) for cave in caves]\n    min_levels.sort(key=lambda x: x[0])\n    sub = 0\n    for (i, x) in enumerate(min_levels):\n        min_levels[i] = x[0] - sub\n        sub += x[1]\n    results[l] = max((x for x in min_levels))\n[print(x) for x in results]", "t = int(input())\nresults = [None] * t\nfor l in range(t):\n    n = int(input())\n    caves = [[int(x) for x in input().split()][1:] for _ in range(n)]\n    min_levels = [(max((x - i + 1 for (i, x) in enumerate(cave))), len(cave)) for cave in caves]\n    min_levels.sort(key=lambda x: x[0])\n    sub = 0\n    for (i, x) in enumerate(min_levels):\n        min_levels[i] = (x[0] - sub, x[1])\n        sub += x[1]\n    results[l] = max((x[0] for x in min_levels))\n[print(x) for x in results]", "t = int(input())\nresults = [None] * t\nfor l in range(t):\n    n = int(input())\n    caves = [[int(x) for x in input().split()][1:] for _ in range(n)]\n    min_levels = [(max((x - i + 1 for (i, x) in enumerate(cave))), len(cave)) for cave in caves]\n    min_levels.sort(key=lambda x: x[0])\n    sub = 0\n    for (i, x) in enumerate(min_levels):\n        min_levels[i] = (x[0] - sub, x[1])\n        sub += x[1]\n    results[l] = max((x[0] for x in min_levels))\n[print(x) for x in results]", "solution = []\n\ndef find_least_power_cave(cave):\n    values = [int(cave[i]) - int(i) for i in range(len(cave))]\n    return (max(values), len(cave))\n\ndef find_least_power(order):\n    possible_max = list()\n    for (key, value) in order.items():\n        (value, length) = find_least_power_cave(value)\n        possible_max.append([value, length])\n    possible_max.sort(key=lambda x: x[0])\n    possible_least = []\n    total = 0\n    for i in range(len(possible_max)):\n        if i == 0:\n            possible_least.append(possible_max[i][0])\n        else:\n            total += possible_max[i - 1][1]\n            possible_least.append(possible_max[i][0] - total)\n    return max(possible_least)\ntest_cases = int(input())\nfor test in range(test_cases):\n    number_of_caves = int(input())\n    order = dict()\n    for cave in range(number_of_caves):\n        monsters = input().split()\n        order[cave] = [i for i in monsters]\n        del order[cave][0]\n    least_power = find_least_power(order)\n    solution.append(least_power)\nfor i in solution:\n    print(i + 1)", "t = int(input())\nfor w in range(t):\n    n = int(input())\n    Minimums = []\n    find = False\n    for i in range(n):\n        Data = input().split()\n        candidate = int(Data[1]) + 1\n        for j in range(1, int(Data[0])):\n            if int(Data[j + 1]) - j + 1 > candidate:\n                candidate = int(Data[j + 1]) - j + 1\n        Minimums.append((candidate, candidate + int(Data[0]), int(Data[0])))\n    Minimums.sort()\n    answer = Minimums[0][0]\n    count = 0\n    for i in range(len(Minimums) - 1):\n        count += Minimums[i][2]\n        if answer + count < Minimums[i + 1][0]:\n            answer = Minimums[i + 1][0] - count\n    print(answer)", "import math\n\ndef solve():\n    n = int(input())\n    L = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        req = 0\n        for j in range(1, len(row)):\n            req = max(req, row[j] - j + 2)\n        L.append((req, len(row) - 1))\n    L.sort()\n    a = L[0][0]\n    k = 0\n    for i in range(1, n):\n        k += L[i - 1][1]\n        a = max(a, L[i][0] - k)\n    print(a)\nfor _ in range(int(input())):\n    solve()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        k = a.pop(0)\n        mx = a[0]\n        for j in range(1, k):\n            mx = max(mx, a[j] - j)\n        d.append([mx + 1, k])\n    d.sort(key=lambda x: (x[0], x[1]))\n    res = d[0][0]\n    plus_power = d[0][1]\n    for i in range(1, n):\n        if plus_power + res < d[i][0]:\n            res = d[i][0] - plus_power\n        plus_power += d[i][1]\n    print(res)", "for i in range(int(input())):\n    n = int(input())\n    a = []\n    for j in range(n):\n        b = list(map(int, input().split()))\n        ans = 0\n        for k in range(b[0]):\n            ans = max(ans, b[k + 1] - k + 1)\n        a.append((ans, b[0]))\n    a.sort()\n    final = a[0][0]\n    c = final\n    for j in range(1, n):\n        c += a[j - 1][1]\n        if a[j][0] >= c:\n            inc = a[j][0] - c\n            final += inc\n            c += inc\n    print(final)", "def get_min_energy(monsters: list):\n    return max((a - i + 1 for (i, a) in enumerate(monsters)))\n\ndef solve_one():\n    n = int(input())\n    min_energy_list = []\n    for _ in range(n):\n        (monster_num, *monsters) = [int(x) for x in input().split()]\n        min_energy = get_min_energy(monsters)\n        min_energy_list.append((min_energy, monster_num))\n    min_energy_list.sort()\n    global_min_energy = min_energy_list[0][0]\n    cur_energy = global_min_energy\n    for (min_energy, monster_num) in min_energy_list:\n        if cur_energy < min_energy:\n            gap = min_energy - cur_energy\n            global_min_energy += gap\n            cur_energy += gap\n        cur_energy += monster_num\n    print(global_min_energy)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        solve_one()\nsolve()", "tt = int(input())\nfor _ in range(tt):\n    n = int(input())\n    k = []\n    c = []\n    for i in range(n):\n        cave = list(map(int, input().split()))\n        k.append(cave[0])\n        sh = cave[1] + 1\n        for j in range(2, k[-1] + 1):\n            sh = max(sh, cave[j] - j + 2)\n        c.append((sh, i))\n    c.sort(key=lambda x: x[0])\n    ans = c[0][0]\n    strength = ans + k[c[0][1]]\n    for i in range(1, n):\n        j = c[i][1]\n        add = 0 if strength > c[i][0] else c[i][0] - strength\n        ans += add\n        strength += add + k[j]\n    print(ans)", "def min_power(N, nums):\n    output = nums[-1] + 1\n    for i in range(N - 2, -1, -1):\n        output = max(output - 1, nums[i] + 1)\n    return output\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    powers = []\n    for j in range(N):\n        cave = list(map(int, input().split()))\n        powers.append((min_power(cave[0], cave[1:]), cave[0]))\n    powers.sort()\n    power = powers[0][0]\n    output = power\n    for (p, n) in powers:\n        if power >= p:\n            power += n\n        else:\n            output += p - power\n            power = p + n\n    print(output)", "for i in range(int(input())):\n    n = int(input())\n    a = []\n    for j in range(n):\n        b = list(map(int, input().split()))\n        ans = 0\n        for k in range(b[0]):\n            ans = max(ans, b[k + 1] - k + 1)\n        a.append((ans, b[0]))\n    a.sort()\n    final = a[0][0]\n    c = final\n    for j in range(1, n):\n        c += a[j - 1][1]\n        if a[j][0] >= c:\n            inc = a[j][0] - c\n            final += inc\n            c += inc\n    print(final)", "t = int(input())\nfor dalskjd in range(t):\n    n = int(input())\n    l = []\n    ll = []\n    for i in range(n):\n        l.append([int(j) for j in input().split()])\n    minn = 1000000000.0 + 10\n    for i in l:\n        tmp = i[1] + 1\n        for j in range(2, i[0] + 1):\n            if i[j] >= tmp + j - 1:\n                tmp = i[j] + 2 - j\n        ll.append([tmp, tmp + i[0]])\n    ll = sorted(ll, key=lambda i: i[0])\n    right = 0\n    left = 0\n    last = 0\n    for i in ll:\n        if left >= i[0]:\n            left += i[1] - i[0]\n        else:\n            right = i[0] - (left - right)\n            left = i[1]\n    print(right)", "for _ in range(int(input())):\n    D = []\n    N = int(input())\n    for _ in range(N):\n        A = list(map(int, input().split()))\n        tmp = 0\n        for i in range(1, A[0] + 1):\n            tmp = max(tmp, A[i] - (i - 1) + 1)\n        D.append((tmp, A[0]))\n    D.sort()\n    ans = D[0][0]\n    cnt = D[0][1]\n    for i in range(1, N):\n        d = D[i]\n        cur = ans + cnt\n        if cur < d[0]:\n            ans += d[0] - cur\n        cnt += d[1]\n    print(ans)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    need = []\n    for c in range(n):\n        lst = [int(hp) for hp in input().split()]\n        ch = 0\n        for i in range(1, lst[0] + 1):\n            ch = max(ch, lst[i] - i + 1)\n        need.append((ch + 1, lst[0]))\n    need.sort()\n    (ans, last) = (need[0][0], need[0][1])\n    for i in range(1, n):\n        ans = need[i][0] - last if need[i][0] - last > ans else ans\n        last = last + need[i][1]\n    print(ans)", "import heapq\ntst = int(input())\nfor _ in range(tst):\n    n = int(input())\n    q = []\n    for i in range(n):\n        arr = list(map(int, input().split(' ')))\n        k = arr[0]\n        arr = arr[1:]\n        current = arr[0] + 1\n        need = arr[0] + 1\n        for i in range(1, k):\n            current += 1\n            if current <= arr[i]:\n                excessneed = arr[i] + 1 - current\n                need += excessneed\n                current = arr[i] + 1\n        heapq.heappush(q, (need, k, i))\n    (power, up, i) = heapq.heappop(q)\n    result = power\n    power += up\n    while q:\n        (cavepower, caveup, i) = heapq.heappop(q)\n        if power >= cavepower:\n            power += caveup\n        else:\n            result += cavepower - power\n            power = cavepower\n            power += caveup\n    print(result)", "n = int(input())\nfor i in range(n):\n    k = int(input())\n    delta = []\n    for i in range(k):\n        arr = list(map(int, input().split()))\n        kol = arr[0]\n        a = 1\n        minhp = arr[1] + 1\n        for j in range(2, kol + 1):\n            minhp = max(arr[j] + 1 - a, minhp)\n            a += 1\n        delta.append([minhp, kol])\n    delta.sort(key=lambda x: x[0])\n    minhp = delta[0][0]\n    hp = minhp + delta[0][1]\n    for i in range(1, len(delta)):\n        if delta[i][0] - hp > 0:\n            sum = delta[i][0] - hp\n            hp += sum\n            minhp += sum\n        hp += delta[i][1]\n    print(minhp)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    for _ in range(n):\n        temp = [int(w) for w in input().split(' ')]\n        x = temp[0]\n        temp = temp[1:]\n        b = 0\n        for i in range(x):\n            b = max(temp[i] - i, b)\n        arr.append([b, x])\n    arr.sort()\n    ans = arr[0][0]\n    prev = arr[0][1]\n    for (x, y) in arr[1:]:\n        ans = max(ans, x - prev)\n        prev = prev + y\n    print(ans + 1)", "t = int(input())\nfor tc in range(t):\n    n = int(input())\n    L = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        req = 0\n        for j in range(1, len(row)):\n            req = max(req, row[j] - j + 2)\n        L.append((req, len(row) - 1))\n    enter = 0\n    now = 0\n    L.sort()\n    for row in L:\n        if now < row[0]:\n            enter += row[0] - now\n            now = row[0]\n        now += row[1]\n    print(enter)", "for _ in range(int(input())):\n    n = int(input())\n    c = []\n    for cave in range(n):\n        a = list(map(int, input().split()))\n        k = a[0]\n        maxx = -1000000000.0\n        for mon in range(k):\n            maxx = max(a[1 + mon] - mon, maxx)\n        c.append((maxx, k))\n    c.sort()\n    power = c[0][0] + 1\n    power += c[0][1]\n    ans = c[0][0] + 1\n    for i in range(1, n):\n        if power < c[i][0] + 1:\n            ans += c[i][0] + 1 - power\n            power += c[i][0] + 1 - power\n        power += c[i][1]\n    print(ans)", "def minp(l, n):\n    minpow = l[0] + 1\n    for i in range(n):\n        if l[i] - minpow - i < 0:\n            continue\n        else:\n            minpow = l[i] - i + 1\n    return minpow\nfor t in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l2 = list(map(int, input().split()))\n        kt = l2[0]\n        l2 = l2[1:]\n        l.append([minp(l2, kt), kt])\n    l.sort()\n    ans = l[0][0]\n    tpow = 0\n    for i in range(0, n - 1):\n        if ans + tpow + l[i][1] >= l[i + 1][0]:\n            tpow += l[i][1]\n        else:\n            ans = l[i + 1][0] - tpow - l[i][1]\n            tpow += l[i][1]\n    print(ans)", "for _ in range(int(input())):\n    D = []\n    N = int(input())\n    for _ in range(N):\n        A = list(map(int, input().split()))\n        tmp = []\n        for i in range(1, A[0] + 1):\n            tmp.append(A[i] - (i - 1))\n        D.append((max(tmp) + 1, A[0]))\n    D.sort()\n    ans = D[0][0]\n    cnt = D[0][1]\n    for i in range(1, N):\n        d = D[i]\n        cur = ans + cnt\n        if cur < d[0]:\n            ans += d[0] - cur\n        cnt += d[1]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    K = []\n    K2 = []\n    n = int(input())\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        l = temp[0]\n        Max = 0\n        for k in range(l):\n            Max = max(temp[k + 1] - k + 1, Max)\n        K.append((Max, l))\n    K.sort()\n    Max = 0\n    S = 0\n    for k in range(n):\n        Max = max(K[k][0] - S, Max)\n        S += K[k][1]\n    print(Max)", "def fun():\n    n = int(input())\n    All = []\n    s = []\n    for k in range(n):\n        a = [int(x) for x in input().split()]\n        x = a[0]\n        del a[0]\n        b = [int(a[i] + 1 - i) for i in range(x)]\n        start = max(b)\n        All.append([start, x])\n    All.sort()\n    m = All[0][0]\n    total = All[0][0] + All[0][1]\n    for i in range(1, n):\n        if total < All[i][0]:\n            m += max(0, All[i][0] - total)\n        total += All[i][1] + max(0, All[i][0] - total)\n    print(m)\nt = int(input())\nfor _ in range(t):\n    fun()", "t = int(input())\nfor _ in range(t):\n    (n, ipowers) = (int(input()), [])\n    for i in range(n):\n        ls = [int(x) for x in input().split()]\n        k = ls[0]\n        ipowers.append((max((ls[j] - j + 1 for j in range(1, k + 1))) + 1, k))\n    ipowers.sort()\n    basepower = power = ipowers[0][0]\n    for j in range(1, n):\n        power += ipowers[j - 1][1]\n        if power < ipowers[j][0]:\n            basepower += ipowers[j][0] - power\n            power = ipowers[j][0]\n    print(basepower)", "for _ in range(int(input())):\n    n = int(input())\n    mons = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        mons.append(temp)\n    atleast = []\n    for i in range(n):\n        start = mons[i][1] + 1\n        curr = mons[i][1] + 2\n        for j in range(2, mons[i][0] + 1):\n            if curr > mons[i][j]:\n                curr += 1\n            else:\n                diff = mons[i][j] + 1 - curr\n                start += diff\n                curr = mons[i][j] + 2\n        atleast.append([start, mons[i][0]])\n    atleast.sort()\n    ans = atleast[0][0]\n    curr = atleast[0][0] + atleast[0][1]\n    for i in range(1, n):\n        if curr >= atleast[i][0]:\n            curr += atleast[i][1]\n        else:\n            diff = atleast[i][0] - curr\n            ans += diff\n            curr = atleast[i][0] + atleast[i][1]\n    print(ans)", "def solve(n, c):\n    se = []\n    for i in range(n):\n        l = c[i]\n        initial = c[i][1] + 1\n        cur = initial\n        for j in range(1, c[i][0] + 1):\n            if l[j] > cur:\n                initial = initial + (l[j] - cur + 1)\n                cur = l[j] + 1\n            elif l[j] == cur:\n                initial += 1\n                cur = l[j] + 1\n            cur += 1\n        se.append([initial, c[i][0]])\n    se.sort()\n    initial = se[0][0]\n    cur = initial\n    for i in range(n):\n        if se[i][0] > cur:\n            initial += se[i][0] - cur\n            cur += se[i][0] - cur\n        cur += se[i][1]\n    return initial\nfor _ in range(int(input())):\n    n = int(input())\n    c = []\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        c.append(arr)\n    print(solve(n, c))", "t = int(input())\nfor z in range(t):\n    n = int(input())\n    en = []\n    for x in range(n):\n        k = list(map(int, input().split()))\n        s = k[0]\n        m = 0\n        for j in range(1, s + 1):\n            m = max(m, k[j] - j + 1)\n        en.append([m, s])\n    en.sort()\n    m = 0\n    b = 0\n    for l in en:\n        m = max(m, l[0] - b)\n        b += l[1]\n    print(m + 1)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "n = int(input())\nfor i in range(n):\n    k = int(input())\n    delta = []\n    for i in range(k):\n        arr = list(map(int, input().split()))\n        kol = arr[0]\n        a = 1\n        minhp = arr[1] + 1\n        for j in range(2, kol + 1):\n            minhp = max(arr[j] + 1 - a, minhp)\n            a += 1\n        delta.append([minhp, kol])\n    delta.sort(key=lambda x: x[0])\n    minhp = delta[0][0]\n    hp = minhp + delta[0][1]\n    for i in range(1, len(delta)):\n        if delta[i][0] - hp > 0:\n            sum = delta[i][0] - hp\n            hp += sum\n            minhp += sum\n        hp += delta[i][1]\n    print(minhp)", "def minpower(a):\n    (mi, i) = ([], 0)\n    for k in a[1:]:\n        mi += [k + 1 - i]\n        i += 1\n    return [(max(mi), a[0])]\nfor _ in range(int(input())):\n    res = []\n    n = int(input())\n    for _ in range(n):\n        a = [int(i) for i in input().split()]\n        res += minpower(a)\n    res = sorted(res)\n    s = res[0]\n    p = 0\n    for k in res:\n        if k[0] > s[0] + p:\n            s = (s[0] + (k[0] - s[0] - p), k[1])\n        p += k[1]\n    print(s[0])", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    table = []\n    for i in range(n):\n        a = [int(f) for f in input().split()]\n        k = a[0]\n        a = a[1:]\n        entry_lvl = a[0] + 1\n        for j in range(1, k):\n            entry_lvl = max(entry_lvl, a[j] - j + 1)\n        bonus_lvl = k\n        table.append((entry_lvl, bonus_lvl))\n    table.sort()\n    lvl = table[0][0]\n    start = lvl\n    rewards = 0\n    for i in range(n - 1):\n        rewards += table[i][1]\n        lvl += table[i][1]\n        if lvl < table[i + 1][0]:\n            start = table[i + 1][0] - rewards\n            lvl = table[i + 1][0]\n    print(start)", "for _ in range(int(input())):\n    dem = []\n    n = int(input())\n    for _ in range(n):\n        a = list(map(int, input().split()))\n        temp = []\n        for i in range(1, a[0] + 1):\n            temp.append(a[i] - (i - 1))\n        dem.append((max(temp) + 1, a[0]))\n    dem.sort()\n    ans = dem[0][0]\n    cont = dem[0][1]\n    for i in range(1, n):\n        d = dem[i]\n        current = ans + cont\n        if current < d[0]:\n            ans += d[0] - current\n        cont += d[1]\n    print(ans)", "from operator import itemgetter\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    caves = []\n    for _ in range(n):\n        (k, *armor_values) = list(map(int, input().split()))\n        total_req_strength = armor_values[0] + 1\n        for i in range(1, k):\n            req_strength = armor_values[i] + 1 - i\n            if req_strength > total_req_strength:\n                total_req_strength = req_strength\n        cave = (total_req_strength, armor_values)\n        caves.append(cave)\n    caves.sort(key=itemgetter(0))\n    res = caves[0][0]\n    accumulated_length = len(caves[0][1])\n    for (req_strength, armor_values) in caves[1:]:\n        updated_req_strength = req_strength - accumulated_length\n        if updated_req_strength > res:\n            res = updated_req_strength\n        accumulated_length += len(armor_values)\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    power = []\n    for _ in range(n):\n        maxx = 0\n        deep = list(map(int, input().split()))\n        for i in range(1, deep[0] + 1):\n            maxx = max(maxx, deep[i] - i + 2)\n        power.append([maxx, deep[0]])\n    power.sort()\n    num = 0\n    ans = 0\n    for i in power:\n        if i[0] > num:\n            ans += i[0] - num\n            num = i[0]\n        num += i[1]\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    powers = []\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        for a in range(1, arr[0] + 1):\n            arr[a] -= a - 2\n        m = max(arr[1:])\n        p = m\n        powers.append([p, p + arr[0]])\n    powers.sort(key=lambda x: x[0])\n    ans = powers[0][0]\n    curval = powers[0][1]\n    for p in powers[1:]:\n        if p[0] > curval:\n            ans += p[0] - curval\n            curval = p[1]\n        else:\n            curval += p[1] - p[0]\n    print(ans)", "for _ in range(int(input())):\n    size = int(input())\n    arr_arr = []\n    for dungeon in range(size):\n        (mass, *arr) = list(map(int, input().split()))\n        for ind in range(mass):\n            arr[ind] -= ind\n        arr_arr.append([max(arr) + 1, mass])\n    arr_arr = sorted(arr_arr)\n    ans = arr_arr[0][0]\n    take = arr_arr[0][1]\n    for ind in range(1, len(arr_arr)):\n        ans += max(0, arr_arr[ind][0] - ans - take)\n        take += arr_arr[ind][1]\n    print(ans)", "def fight():\n    cnt_caves = int(input())\n    caves = []\n    for i in range(cnt_caves):\n        inputs = [int(x) for x in input().split(' ')]\n        caves.append(inputs[1:])\n    gmap = []\n    for c in caves:\n        (p, n) = stats_caves(c)\n        gmap.append((p, n))\n    gmap.sort(key=lambda k: k[0])\n    cur_p = min_p = sum = 0\n    l = len(gmap)\n    for i in range(l):\n        if cur_p < gmap[i][0]:\n            cur_p = gmap[i][0] + gmap[i][1]\n            min_p = gmap[i][0] - sum\n        else:\n            cur_p += gmap[i][1]\n        sum += gmap[i][1]\n    return min_p\n\ndef stats_caves(mns):\n    cnt = 0\n    min_p = 0\n    cur_p = 0\n    for m in mns:\n        if cur_p <= m:\n            cur_p = m + 1\n            min_p = cur_p - cnt\n        else:\n            cur_p += 1\n        cnt += 1\n    return (min_p, len(mns))\ntest_count = int(input())\nfor i in range(test_count):\n    print(fight())", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        ma = 0\n        for j in range(a[0]):\n            ma = max(a[j + 1] - j, ma)\n        arr.append((ma, a[0]))\n    arr.sort()\n    ans = 0\n    s = 0\n    for x in range(n):\n        ans = max(ans, arr[x][0] - s)\n        s += arr[x][1]\n    print(ans + 1)", "for _ in range(int(input())):\n    n = int(input())\n    vp = []\n    for i in range(n):\n        v = list(map(int, input().split()))\n        ma = 0\n        for j in range(v[0]):\n            ma = max(v[j + 1] - j, ma)\n        vp.append((ma, v[0]))\n    vp.sort()\n    ans = 0\n    c = 0\n    for x in range(n):\n        ans = max(ans, vp[x][0] - c)\n        c += vp[x][1]\n    print(ans + 1)", "t = int(input())\n\ndef check_min_entry(lst):\n    min = 0\n    extra = 0\n    for i in lst:\n        if min + extra <= i:\n            min = i - extra + 1\n        extra += 1\n    return min\n\ndef check_main_entry(lst):\n    min = 0\n    extra = 0\n    for i in lst:\n        if min + extra < i[0]:\n            min = i[0] - extra\n        extra += i[1]\n    return min\nwhile t != 0:\n    n = int(input())\n    array = []\n    min_entry = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        temp.pop(0)\n        array.append(temp)\n    for i in array:\n        temp = [check_min_entry(i), len(i)]\n        min_entry.append(temp)\n    min_entry.sort(key=lambda x: x[0])\n    print(check_main_entry(min_entry))\n    t -= 1", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    powers = []\n    for i in range(N):\n        (M, *cave) = list(map(int, input().split()))\n        for j in range(M):\n            cave[j] = cave[j] - j + 1\n        powers.append((max(cave), M))\n    powers.sort()\n    power = powers[0][0]\n    output = power\n    for (p, n) in powers:\n        if power >= p:\n            power += n\n        else:\n            output += p - power\n            power = p + n\n    print(output)", "def run():\n    t = int(input())\n    for i in range(t):\n        P = []\n        n = int(input())\n        k = []\n        for j in range(n):\n            L = input().split(' ')\n            L = [int(i) for i in L]\n            k += [L[0]]\n            L = [L[i] - i + 1 for i in range(1, k[j] + 1)]\n            m = max(L)\n            P += [[m, L, j]]\n        P.sort(key=fn)\n        s = 0\n        for j in range(1, len(P)):\n            s += k[P[j - 1][2]]\n            P[j][0] = P[j][0] - s\n        P.sort(key=fn)\n        print(P[-1][0] + 1)\n\ndef fn(x):\n    return x[0]\nrun()", "for _ in range(int(input())):\n    i = int(input())\n    t = []\n    for _ in range(i):\n        c = list(map(int, input().split()))\n        t.append([max((c[x + 1] - x + 1 for x in range(c[0]))), c[0]])\n    t.sort(key=lambda test: test[0])\n    ans = pans = t[0][0]\n    for x in t:\n        if ans < x[0]:\n            pans += x[0] - ans\n            ans += x[0] - ans\n        ans += x[1]\n    print(pans)", "for _ in range(int(input())):\n    n = int(input())\n    p = []\n    for q in range(n):\n        a = list(map(int, input().split()))\n        b = []\n        ind = 0\n        for i in range(1, a[0] + 1):\n            b.append(a[i] - ind)\n            ind += 1\n        p.append([max(b), a[0]])\n    p.sort()\n    k = p[0][1]\n    for i in range(1, len(p)):\n        p[i][0] = p[i][0] - k\n        k += p[i][1]\n    ans = max(p)\n    print(ans[0] + 1)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l1 = []\n    for j in range(n):\n        l = [int(x) for x in input().split()]\n        m = l[0]\n        l.pop(0)\n        c = 0\n        current = 0\n        for i in range(m):\n            if l[i] + 1 > current:\n                c = c + l[i] + 1 - current\n                current = c + i + 1\n            else:\n                current += 1\n        l1.append([c, m])\n    l1.sort()\n    current = l1[0][1] + l1[0][0]\n    c = l1[0][0]\n    for i in range(1, n):\n        if current < l1[i][0]:\n            c = c + l1[i][0] - current\n            current = l1[i][0]\n        current = current + l1[i][1]\n    print(c)", "_ = int(input())\nfor __ in range(_):\n    n = int(input())\n    a = []\n    for ___ in range(n):\n        tmp_l = list(map(int, input().split()))\n        a.append(tmp_l[1:])\n    for z in a:\n        c_val = z[0] + 1\n        beg_val = z[0] + 1\n        for zz in range(1, len(z)):\n            c_val += 1\n            if z[zz] >= c_val:\n                beg_val = z[zz] + 1 - zz\n                c_val = z[zz] + 1\n        z.append(beg_val)\n        z.append(len(z) - 1)\n    a = sorted(a, key=lambda x: (x[-2], -x[-1]))\n    if len(a) == 1:\n        print(a[0][-2])\n        continue\n    beg_val = a[0][-2] + len(a[0]) - 2\n    wyn = a[0][-2]\n    for z in range(1, len(a), +1):\n        if beg_val < a[z][-2]:\n            wyn += a[z][-2] - beg_val\n            beg_val = a[z][-2]\n        beg_val += len(a[z]) - 2\n    print(wyn)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        ma = 0\n        for j in range(a[0]):\n            ma = max(a[j + 1] - j, ma)\n        arr.append((ma, a[0]))\n    arr.sort()\n    ans = 0\n    s = 0\n    for x in range(n):\n        ans = max(ans, arr[x][0] - s)\n        s += arr[x][1]\n    print(ans + 1)", "for i in range(int(input())):\n    n = int(input())\n    res = []\n    for j in range(n):\n        l = list(map(int, input().split()))\n        s = l[0]\n        for k in range(1, s + 1):\n            l[k] = l[k] - k + 2\n        ans = max(l[1:])\n        res.append((ans, s))\n    res.sort()\n    f_ans = 0\n    a = 0\n    for i in range(len(res)):\n        f_ans = max(f_ans, res[i][0] - a)\n        a += res[i][1]\n    print(f_ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    cs = []\n    for _ in range(n):\n        (k, *ars) = map(int, input().split())\n        maxx = 0\n        for i in range(k):\n            if maxx < max(ars[i] - i, 0):\n                maxx = max(ars[i] - i, 0)\n        cs.append((maxx + 1, k))\n    cs.sort()\n    minn_ = 0\n    p = 0\n    out = 0\n    for c in cs:\n        if p < c[0]:\n            minn_ += c[0] - p\n            p = c[0] + c[1]\n        else:\n            p += c[1]\n    print(minn_)", "t = int(input())\nfor tt in range(t):\n    n = int(input())\n    size = []\n    monsters = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        strongest = max([temp[i] - i + 1 for i in range(1, temp[0] + 1)])\n        monsters.append((strongest, temp[0]))\n    monsters.sort()\n    ans = 0\n    curr = 0\n    for ele in monsters:\n        ans = max(ans, ele[0] - curr)\n        curr += ele[1]\n    print(ans + 1)", "for _ in range(int(input())):\n    n = int(input())\n    temp = []\n    l = []\n    for _ in range(n):\n        temp = [i for i in map(int, input().split())]\n        mn = 0\n        for i in range(1, len(temp)):\n            mn = max(mn, temp[i] + 1 - (i - 1))\n        l.append([mn, temp[0]])\n    l.sort(reverse=True)\n    posbl = 0\n    for i in range(len(l)):\n        if posbl < l[i][0]:\n            posbl = l[i][0]\n        if i + 1 != len(l):\n            posbl -= l[i + 1][1]\n    print(posbl)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "from collections import deque\n\nclass Solution:\n\n    def beat_monsters(self, caves_data):\n        caves_data.sort(key=lambda x: x[0])\n        (total_monsters, minimum_power) = (0, caves_data[0][0])\n        for (max_armor_cave, monsters) in caves_data:\n            extra_power = max(max_armor_cave - total_monsters - minimum_power, 0)\n            minimum_power += extra_power\n            total_monsters += monsters\n        print(minimum_power)\ns = Solution()\ncases = int(input())\nfor case in range(cases):\n    caves_data = []\n    t_caves = int(input())\n    for cave in range(t_caves):\n        cave_info = input().split(' ')\n        (max_armor_cave, monsters_in_cave, beated_monsters) = (0, int(cave_info[0]), 0)\n        for monster in range(1, monsters_in_cave + 1):\n            current_monster = int(cave_info[monster])\n            max_armor_cave = max(current_monster - beated_monsters + 1, max_armor_cave)\n            beated_monsters += 1\n        caves_data.append([max_armor_cave, monsters_in_cave])\n    s.beat_monsters(caves_data)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    (w, c) = ([], [])\n    for j in range(n):\n        w.append([int(k) for k in input().split()][1:])\n    for j in w:\n        eta = 0\n        mx = 0\n        for k in j:\n            mx = max(mx, k - eta + 1)\n            eta += 1\n        c.append([mx, j])\n    zxc = []\n    c.sort(key=lambda x: x[0])\n    for j in c:\n        zxc.extend(j[1])\n    eta = 0\n    mx = 0\n    for j in zxc:\n        mx = max(mx, j - eta + 1)\n        eta += 1\n    print(mx)", "t = int(input())\nfor q in range(t):\n    k = int(input())\n    maxs = []\n    for i in range(k):\n        cp = [int(i) for i in input().split()][1:]\n        massc = 0\n        for i in range(len(cp)):\n            if cp[i] - i > massc:\n                massc = cp[i] - i\n        maxs.append((massc + 1, len(cp)))\n    maxs = sorted(maxs, key=lambda student: student[0])\n    ms = 0\n    cs = 0\n    for p in maxs:\n        if cs < p[0]:\n            ms += p[0] - cs\n            cs = p[0]\n        cs += p[1]\n    print(ms)", "import math\n\ndef solve():\n    n = int(input())\n    l = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        mx = 0\n        for j in range(1, a[0] + 1):\n            mx = max(a[j] + 2 - j, mx)\n        l.append([mx, a[0]])\n    l.sort()\n    ans = 0\n    s = 0\n    for i in range(n):\n        ans = max(ans, l[i][0] - s)\n        s += l[i][1]\n    print(ans)\n    return\nt = int(input())\nwhile t:\n    t -= 1\n    solve()", "def tmp_sort(n):\n    return n[0]\nt = int(input())\nfor i in range(t):\n    num_caves = int(input())\n    monsters = []\n    strongest = []\n    for j in range(num_caves):\n        lst = [int(x) for x in input().split()]\n        monsters.append(lst[1:])\n    for cave in monsters:\n        strong = 0\n        for j in range(len(cave)):\n            cave[j] -= j\n            if cave[j] > strong:\n                strong = cave[j]\n        strongest.append((strong, len(cave)))\n    strongest.sort(key=tmp_sort)\n    min_start = strongest[0][0] + 1\n    current = min_start\n    for strong in strongest:\n        if current <= strong[0]:\n            tmp = strong[0] + 1 - current\n            min_start += tmp\n            current += tmp\n        current += strong[1]\n    print(min_start)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    entry = []\n    for i in range(n):\n        cave = list(map(int, input().split()))\n        s = cave[0]\n        m = 0\n        for j in range(1, s + 1):\n            m = max(m, cave[j] - j + 1)\n        entry.append([m, s])\n    entry.sort()\n    m = 0\n    a = 0\n    for e in entry:\n        m = max(m, e[0] - a)\n        a += e[1]\n    print(m + 1)", "t = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    levels = []\n    for i in range(n):\n        level = list(map(int, input().strip().split()))\n        maxi = level[1] + 1\n        index = 0\n        for (i, e) in enumerate(level[1:]):\n            if e - i + 1 > maxi:\n                maxi = e - i + 1\n                index = i\n        d = [maxi, level[0]]\n        levels.append(d)\n    levels.sort(key=lambda x: x[0])\n    mini = levels[0][0]\n    monsters = 0\n    for l in levels:\n        mini = max(mini, l[0] - monsters)\n        monsters += l[1]\n    print(mini)", "t = int(input())\nfor cycl in range(t):\n    n = int(input())\n    ans = 0\n    power = 0\n    power_list = []\n    for cave in range(n):\n        cave_data = list(map(int, input().split()))\n        n_m = cave_data[0]\n        chan_power = 0\n        for m_id in range(1, n_m + 1):\n            chan_power = max(cave_data[m_id] - m_id + 2, chan_power)\n        power_list.append([chan_power, n_m])\n    power_list.sort()\n    for l in power_list:\n        if l[0] > power:\n            ans += l[0] - power\n            power = l[0]\n        power += l[1]\n    print(ans)", "t = int(input())\nfor cycl in range(t):\n    n = int(input())\n    ans = 0\n    power = 0\n    power_list = []\n    for cave in range(n):\n        cave_data = list(map(int, input().split()))\n        n_m = cave_data[0]\n        chan_power = 0\n        for m_id in range(1, n_m + 1):\n            chan_power = max(cave_data[m_id] - m_id + 2, chan_power)\n        power_list.append([chan_power, n_m])\n    power_list.sort()\n    for l in power_list:\n        if l[0] > power:\n            ans += l[0] - power\n            power = l[0]\n        power += l[1]\n    print(ans)", "from collections import defaultdict\nfor _ in range(int(input())):\n    n = int(input())\n    dic = []\n    for i in range(n):\n        lst = list(map(int, input().split()))\n        k = lst[0]\n        mx = 0\n        for j in range(1, k + 1):\n            mx = max(mx, lst[j] - j + 1)\n        dic.append([mx, 0, k])\n    ls = []\n    dic.sort()\n    ls = dic.copy()\n    ans = []\n    prev = 0\n    for i in ls:\n        val = i[0] - prev\n        ans.append(val)\n        prev += i[2]\n    print(max(ans) + 1)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    cl = []\n    for j in range(n):\n        a = list(map(int, input().split()))\n        c = -69420\n        for k in range(1, a[0] + 1):\n            c = max(a[k] - k + 2, c)\n        cl.append([c, a[0]])\n    cl.sort()\n    ex = cl[0][1]\n    for j in range(1, len(cl)):\n        cl[j][0] -= ex\n        ex += cl[j][1]\n    cl.sort()\n    print(cl[len(cl) - 1][0])", "for _ in range(int(input())):\n    n_cave = int(input())\n    dun = []\n    for __ in range(n_cave):\n        a = list(map(int, input().split()))\n        dun.append([max((a[i + 1] - i + 1 for i in range(a[0]))), a[0]])\n    dun.sort(key=lambda x: x[0])\n    ans = dun[0][0]\n    power = dun[0][0]\n    for hero in dun:\n        if power < hero[0]:\n            ans += hero[0] - power\n            power = hero[0] + hero[1]\n        else:\n            power += hero[1]\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    M = []\n    for _ in range(n):\n        tmp = list(map(int, input().split()))\n        k = tmp[0]\n        m = 0\n        for i in range(1, len(tmp)):\n            m = max(m, tmp[i] - i + 2)\n        M.append((m, k))\n    M.sort()\n    ans = 0\n    tot = 0\n    for (m, k) in M:\n        if tot < m:\n            ans += m - tot\n            tot = m\n        tot += k\n    print(ans)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "for t in range(int(input())):\n    n = int(input())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = []\n    for i in range(n):\n        start = 0\n        cur = 0\n        for j in range(1, len(a[i])):\n            if cur <= a[i][j]:\n                delta = a[i][j] + 1 - cur\n                cur += 1 + delta\n                start += delta\n            else:\n                cur += 1\n        b.append([start, cur])\n    b.sort()\n    start = 0\n    cur = 0\n    for i in range(n):\n        if cur < b[i][0]:\n            delta = b[i][0] - cur\n            cur = b[i][1]\n            start += delta\n        else:\n            cur += b[i][1] - b[i][0]\n    print(start)", "def I():\n    return [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        (m, *p) = [int(x) for x in input().split()]\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    (l, v, id) = ([], [], [])\n    for i in range(n):\n        l.append(list(map(int, input().split()[1:])))\n        (cur, add) = (0, 0)\n        for x in l[-1]:\n            if cur <= x:\n                add += x - cur + 1\n                cur = x + 1\n            cur += 1\n        v.append(add)\n        id.append(i)\n    id.sort(key=lambda x: v[x])\n    (cur, add) = (0, 0)\n    for i in id:\n        for x in l[i]:\n            if cur <= x:\n                add += x - cur + 1\n                cur = x + 1\n            cur += 1\n    print(add)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    t = []\n    for _ in range(n):\n        c = list(map(int, input().split()))\n        t.append([max((c[x + 1] - x + 1 for x in range(c[0]))), c[0]])\n    t.sort(key=lambda x: x[0])\n    ans = res = t[0][0]\n    for x in t:\n        if ans < x[0]:\n            res += x[0] - ans\n            ans += x[0] - ans\n        ans += x[1]\n    print(res)", "def giveLast(array):\n    return array[-1]\n\ndef deepDownBelow(n, grid):\n    for x in range(n):\n        m = 0\n        for y in range(1, grid[x][0] + 1):\n            e = grid[x][y] + (2 - y)\n            if e > m:\n                m = e\n        grid[x].append(m)\n    grid.sort(key=giveLast)\n    ans = 0\n    k = 1\n    for x in range(n):\n        for y in range(1, grid[x][0] + 1):\n            if grid[x][y] + k > ans:\n                ans = grid[x][y] + k\n            k -= 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    grid = []\n    for x in range(n):\n        grid.append(list(map(int, input().split())))\n    print(deepDownBelow(n, grid))", "for i in range(int(input())):\n    n = int(input())\n    res = []\n    for j in range(n):\n        l = list(map(int, input().split()))\n        s = l[0]\n        max_t = 0\n        for k in range(1, s + 1):\n            max_t = max(max_t, l[k] - k + 2)\n        res.append((max_t, s))\n    res.sort()\n    f_ans = 0\n    a = 0\n    for i in range(len(res)):\n        f_ans = max(f_ans, res[i][0] - a)\n        a += res[i][1]\n    print(f_ans)", "for _ in range(int(input())):\n    i = int(input())\n    t = []\n    for _ in range(i):\n        c = list(map(int, input().split()))\n        t.append([max((c[x + 1] - x + 1 for x in range(c[0]))), c[0]])\n    t.sort(key=lambda test: test[0])\n    ans = pans = t[0][0]\n    for x in t:\n        if ans < x[0]:\n            pans += x[0] - ans\n            ans += x[0] - ans\n        ans += x[1]\n    print(pans)", "for _ in range(int(input())):\n    i = int(input())\n    t = []\n    for _ in range(i):\n        c = list(map(int, input().split()))\n        t.append([max((c[x + 1] - x + 1 for x in range(c[0]))), c[0]])\n    t.sort(key=lambda test: test[0])\n    ans = pans = t[0][0]\n    for x in t:\n        if ans < x[0]:\n            pans += x[0] - ans\n            ans += x[0] - ans\n        ans += x[1]\n    print(pans)", "for t in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        x = list(map(int, input().split()))\n        k = x[0]\n        x = x[1:]\n        m = 0\n        jj = 0\n        for j in range(k):\n            if x[j] - i + 1 > m:\n                jj = j\n            m = max(m, x[j] - j + 1)\n        l.append([m, k])\n    l.sort()\n    openn = l[0][0]\n    add = l[0][1]\n    for i in range(len(l) - 1):\n        openn += max(0, l[i + 1][0] - openn - add)\n        add += l[i + 1][1]\n    print(openn)", "t = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    levels = []\n    for i in range(n):\n        level = list(map(int, input().strip().split()))\n        maxi = level[1] + 1\n        index = 0\n        for (i, e) in enumerate(level[1:]):\n            if e - i + 1 > maxi:\n                maxi = e - i + 1\n                index = i\n        d = [maxi, level[0]]\n        levels.append(d)\n    levels.sort(key=lambda x: x[0])\n    mini = levels[0][0]\n    monsters = 0\n    for l in levels:\n        mini = max(mini, l[0] - monsters)\n        monsters += l[1]\n    print(mini)", "t = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    levels = []\n    for i in range(n):\n        level = list(map(int, input().strip().split()))\n        maxi = level[1] + 1\n        index = 0\n        for (i, e) in enumerate(level[1:]):\n            if e - i + 1 > maxi:\n                maxi = e - i + 1\n                index = i\n        d = [maxi, level[0]]\n        levels.append(d)\n    levels.sort(key=lambda x: x[0])\n    mini = levels[0][0]\n    monsters = 0\n    for l in levels:\n        mini = max(mini, l[0] - monsters)\n        monsters += l[1]\n    print(mini)", "for _ in range(int(input())):\n    n = int(input())\n    temp = []\n    l = []\n    for _ in range(n):\n        temp = [i for i in map(int, input().split())]\n        mn = 0\n        for i in range(1, len(temp)):\n            mn = max(mn, temp[i] + 1 - (i - 1))\n        l.append([mn, temp[0]])\n    l.sort(reverse=True)\n    posbl = 0\n    for i in range(len(l)):\n        if posbl < l[i][0]:\n            posbl = l[i][0]\n        if i + 1 != len(l):\n            posbl -= l[i + 1][1]\n    print(posbl)", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    n = I()[0]\n    l = []\n    for i in range(n):\n        (m, *p) = I()\n        for j in range(m):\n            p[j] = p[j] - j + 1\n        l.append([max(p), m])\n    l = sorted(l)\n    ans = l[0][0]\n    c = l[0][1]\n    for j in range(1, n):\n        ans += max(0, l[j][0] - ans - c)\n        c += l[j][1]\n    print(ans)", "import math\nimport sys\nimport collections\nimport bisect\nimport time\nimport random\nimport itertools\nfrom collections import Counter, defaultdict\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_string():\n    return sys.stdin.readline().strip()\nfor t in range(int(input())):\n    n = int(input())\n    arr = []\n    order = []\n    for i in range(n):\n        row = get_list()\n        maxim = 0\n        for j in range(1, len(row)):\n            v = row[j] - (j - 1)\n            maxim = max(maxim, v)\n        order.append([maxim, i])\n        arr.append(row[1:])\n    order.sort()\n    defeated = 0\n    ans = 0\n    for (maxim_power, pos) in order:\n        curr = ans\n        for monster_power in arr[pos]:\n            if curr + defeated > monster_power:\n                defeated += 1\n                continue\n            diff = monster_power - (curr + defeated)\n            curr += diff + 1\n            defeated += 1\n        ans = max(ans, curr)\n    print(ans)", "testcase = int(input())\nfor _ in range(testcase):\n    max_armor = []\n    monsters = []\n    count = 0\n    cave = int(input())\n    for _ in range(cave):\n        level = [int(x) for x in input().split()]\n        monster = level[0]\n        level = level[1:]\n        for i in range(monster):\n            level[i] = level[i] + 1 - i\n        max_armor.append(max(level))\n        monsters.append(monster)\n    monster_num = [x for (_, x) in sorted(zip(max_armor, monsters))]\n    max_armor.sort()\n    for i in range(1, len(max_armor)):\n        count += monster_num[i - 1]\n        max_armor[i] -= count\n    print(max(max_armor))"]