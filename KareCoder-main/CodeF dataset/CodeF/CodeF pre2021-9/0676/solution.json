["from collections import defaultdict\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\na = [0] + list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = defaultdict(list)\nnum_list = [0] * (n + 1)\nfor (index, nxt) in enumerate(b):\n    if nxt != -1:\n        f[index + 1].append(nxt)\n        num_list[nxt] += 1\nq = [i for (i, v) in enumerate(num_list) if i > 0 and v == 0]\nres = 0\nres_list = []\nreverse_nege_list = []\nwhile q:\n    p = []\n    for i in q:\n        if a[i] > 0:\n            res_list.append(i)\n        else:\n            reverse_nege_list.append(i)\n        res += a[i]\n        for nxt in f[i]:\n            num_list[nxt] -= 1\n            if num_list[nxt] == 0:\n                p.append(nxt)\n            if a[i] > 0:\n                a[nxt] += a[i]\n    q = p\nprint(res)\nans_list = res_list + reverse_nege_list[::-1]\nprint(' '.join(map(str, ans_list)))", "from sys import *\n\ndef main():\n    n = int(stdin.readline().rstrip())\n    a = [int(x) for x in stdin.readline().rstrip().split()]\n    b = [int(x) for x in stdin.readline().rstrip().split()]\n    countLink = dict()\n    for i in b:\n        countLink[i - 1] = countLink.get(i - 1, 0) + 1\n    preselect = []\n    for i in range(n):\n        if countLink.get(i, 0) == 0:\n            preselect.append(i)\n    selected = []\n    stack = []\n    result = 0\n    while len(preselect) > 0:\n        i = preselect.pop()\n        if countLink.get(i, 0) == 0:\n            result += a[i]\n            if a[i] > 0:\n                selected.append(i + 1)\n                if b[i] != -1:\n                    a[b[i] - 1] += a[i]\n            else:\n                stack.append(i + 1)\n            countLink[b[i] - 1] = countLink.get(b[i] - 1, 0) - 1\n            countLink[i] = -1\n            if countLink[b[i] - 1] == 0 and b[i] - 1 >= 0:\n                preselect.append(b[i] - 1)\n    print(result)\n    for i in selected:\n        print(i, end=' ')\n    for i in reversed(stack):\n        print(i, end=' ')\nmain()", "from sys import stdin\nfrom collections import deque\nn = int(stdin.readline())\na = list(map(int, stdin.readline().split()))\np = list(map(int, stdin.readline().split()))\nchnum = [0] * n\nfor i in range(n):\n    if p[i] - 1 >= 0:\n        chnum[p[i] - 1] += 1\nq = deque([])\nfor i in range(n):\n    if chnum[i] == 0:\n        q.append(i)\nans = 0\nalis = []\nend = []\nwhile len(q) > 0:\n    v = q.popleft()\n    ans += a[v]\n    if a[v] >= 0:\n        alis.append(v + 1)\n        if p[v] - 1 >= 0:\n            chnum[p[v] - 1] -= 1\n            a[p[v] - 1] += a[v]\n            if chnum[p[v] - 1] == 0:\n                q.append(p[v] - 1)\n    else:\n        end.append(v + 1)\n        if p[v] - 1 >= 0:\n            chnum[p[v] - 1] -= 1\n            if chnum[p[v] - 1] == 0:\n                q.append(p[v] - 1)\nend.reverse()\nfor i in end:\n    alis.append(i)\nprint(ans)\nprint(*alis)", "import sys\ninput = sys.stdin.readline\nn = int(input())\nA = list(map(int, input().split()))\nB = map(int, input().split())\nIncomList = [[] for _ in range(n)]\nweight = [None] * n\nendpoints = list()\nfor (i, d) in enumerate(B):\n    if d == -1:\n        endpoints.append(i)\n    else:\n        IncomList[d - 1].append(i)\n(serial, last) = (list(), list())\nans = 0\nwhile endpoints:\n    e = endpoints[-1]\n    flag = True\n    for h in IncomList[e]:\n        if weight[h] is None:\n            endpoints.append(h)\n            flag = False\n    if flag:\n        endpoints.pop()\n        weight[e] = A[e] + sum(map(lambda x: max(0, weight[x]), IncomList[e]))\n        ans += weight[e]\n        if weight[e] >= 0:\n            serial.append(e + 1)\n        else:\n            last.append(e + 1)\nserial.extend(reversed(last))\nprint(ans)\nprint(' '.join(map(str, serial)))", "import sys\ninput = sys.stdin.readline\nprint = sys.stdout.write\nn = int(input())\nA = list(map(int, input().split()))\nB = map(int, input().split())\nIncomList = [[] for _ in range(n)]\nweight = [None] * n\nendpoints = list()\nfor (i, d) in enumerate(B):\n    if d == -1:\n        endpoints.append(i)\n    else:\n        IncomList[d - 1].append(i)\n(serial, last) = (list(), list())\nans = 0\nwhile endpoints:\n    e = endpoints[-1]\n    flag = True\n    for h in IncomList[e]:\n        if weight[h] is None:\n            endpoints.append(h)\n            flag = False\n    if flag:\n        endpoints.pop()\n        weight[e] = A[e] + sum(map(lambda x: max(0, weight[x]), IncomList[e]))\n        ans += weight[e]\n        if weight[e] >= 0:\n            serial.append(e + 1)\n        else:\n            last.append(e + 1)\nserial.extend(reversed(last))\nprint(str(ans) + '\\n' + ' '.join(map(str, serial)) + '\\n')", "from sys import stdin, setrecursionlimit as srl\nfrom threading import stack_size, Thread\nsrl(int(1000000000.0) + 7)\nstack_size(int(100000000.0))\nip = stdin.readline\n\ndef solve():\n    n = int(ip())\n    a = list(map(int, ip().split()))\n    b = list(map(int, ip().split()))\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        if not b[i] == -1:\n            adj[i].append(b[i] - 1)\n    visited = [0] * n\n    stk = []\n    for x in range(n):\n\n        def topsort(v):\n            if visited[v] == 2:\n                return\n            visited[v] = 1\n            for i in adj[v]:\n                topsort(i)\n            visited[v] = 2\n            stk.append(v)\n        if not visited[x]:\n            topsort(x)\n    laterstk = []\n    extra = [0] * n\n    ans = 0\n    soln = []\n    while stk:\n        i = stk.pop()\n        if a[i] + extra[i] < 0:\n            laterstk.append(i)\n        else:\n            ans += a[i] + extra[i]\n            if len(adj[i]) == 1:\n                j = adj[i][0]\n                extra[j] += extra[i] + a[i]\n            soln.append(i + 1)\n    while laterstk:\n        i = laterstk.pop()\n        ans += a[i] + extra[i]\n        soln.append(i + 1)\n    print(ans)\n    print(*soln)\nThread(target=solve).start()", "from sys import stdin, setrecursionlimit as srl\nfrom threading import stack_size, Thread\nsrl(int(1000000.0) + 7)\nstack_size(int(100000000.0))\nip = stdin.readline\n\ndef solve():\n    n = int(ip())\n    a = list(map(int, ip().split()))\n    b = list(map(int, ip().split()))\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        if not b[i] == -1:\n            adj[i].append(b[i] - 1)\n    visited = [0] * n\n    stk = []\n    for x in range(n):\n\n        def topsort(v):\n            if visited[v] == 2:\n                return\n            visited[v] = 1\n            for i in adj[v]:\n                topsort(i)\n            visited[v] = 2\n            stk.append(v)\n        if not visited[x]:\n            topsort(x)\n    laterstk = []\n    extra = [0] * n\n    ans = 0\n    soln = []\n    while stk:\n        i = stk.pop()\n        if a[i] + extra[i] < 0:\n            laterstk.append(i)\n        else:\n            ans += a[i] + extra[i]\n            if len(adj[i]) == 1:\n                j = adj[i][0]\n                extra[j] += extra[i] + a[i]\n            soln.append(i + 1)\n    while laterstk:\n        i = laterstk.pop()\n        ans += a[i] + extra[i]\n        soln.append(i + 1)\n    print(ans)\n    print(*soln)\nThread(target=solve).start()", "import bisect\nimport collections\nimport copy\nimport enum\nimport functools\nimport heapq\nimport itertools\nimport math\nimport random\nimport re\nimport sys\nimport time\nimport string\nfrom typing import List\nsys.setrecursionlimit(3001)\ninput = sys.stdin.readline\nn = int(input())\nans = 0\nsl = []\narr = list(map(int, input().split()))\nbrr = list(map(int, input().split()))\ng = collections.defaultdict(list)\nfor (i, c) in enumerate(brr):\n    g[c].append(i + 1)\nq = collections.deque()\nfor c in g[-1]:\n    q.append(c)\nwhile q:\n    ind = q.popleft()\n    sl.append(ind)\n    for nc in g[ind]:\n        q.append(nc)\npre = []\naft = []\ncrr = arr[:]\nfor ind in sl[::-1]:\n    if crr[ind - 1] > 0:\n        ans += crr[ind - 1]\n        if brr[ind - 1] != -1:\n            crr[brr[ind - 1] - 1] += crr[ind - 1]\n        pre.append(ind)\n    else:\n        ans += crr[ind - 1]\n        aft.append(ind)\nprint(ans)\nprint(*pre + aft[::-1])", "from collections import deque\n(n, a, b) = (int(input()), list(map(int, input().split())), list(map(int, input().split())))\nans = 0\nent = [0] * n\nfor x in b:\n    if x >= 0:\n        ent[x - 1] += 1\nq = deque()\nG = [list() for _ in range(n)]\nfor i in range(n):\n    if not ent[i]:\n        q.append(i)\nwhile q:\n    v = q.popleft()\n    ans += a[v]\n    if b[v] < 0:\n        continue\n    x = b[v] - 1\n    if a[v] >= 0:\n        G[v].append(x)\n        a[x] += a[v]\n    else:\n        G[x].append(v)\n    ent[x] -= 1\n    if not ent[x]:\n        q.append(x)\nent = [0] * n\nfor l in G:\n    for x in l:\n        ent[x] += 1\nq = deque()\nl = list()\nfor i in range(n):\n    if not ent[i]:\n        q.append(i)\nwhile q:\n    v = q.popleft()\n    l.append(v + 1)\n    for x in G[v]:\n        ent[x] -= 1\n        if not ent[x]:\n            q.append(x)\nprint(ans)\nprint(*l)", "from collections import Counter\nn = int(input())\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\nindeg = Counter(b)\ns = []\nfor i in range(n):\n    if i + 1 not in indeg:\n        s.append(i)\nans = 0\nsteps = []\nwhile s:\n    index = s.pop()\n    if a[index] >= 0:\n        steps.append(index + 1)\n        ans += a[index]\n    if b[index] != -1:\n        if a[index] >= 0:\n            a[b[index] - 1] += a[index]\n        indeg[b[index]] -= 1\n        if indeg[b[index]] == 0:\n            s.append(b[index] - 1)\noutdeg = {}\nadj = {}\nfor i in range(n):\n    if b[i] != -1 and a[i] < 0 and (a[b[i] - 1] < 0):\n        if b[i] - 1 in adj:\n            adj[b[i] - 1].append(i)\n        else:\n            adj[b[i] - 1] = [i]\ns = []\nfor i in range(n):\n    if a[i] < 0:\n        if b[i] != -1 and a[b[i] - 1] < 0:\n            outdeg[i] = 1\n        else:\n            s.append(i)\nwhile s:\n    index = s.pop()\n    ans += a[index]\n    steps.append(index + 1)\n    if index in adj:\n        for ele in adj[index]:\n            outdeg[ele] -= 1\n            if outdeg[ele] == 0:\n                s.append(ele)\nprint(ans)\nfor ele in steps:\n    print(ele, end=' ')", "import sys\nfrom queue import Queue\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\nq = Queue()\nn = ni()\na = nl()\nb = nl()\na.insert(0, 0)\nb.insert(0, 0)\ndeg = [0] * (max(b) * 10)\nfor i in range(1, n + 1):\n    if b[i] != -1:\n        deg[b[i]] += 1\nfor i in range(1, n + 1):\n    if deg[i] == 0:\n        q.put(i)\nans = 0\nM1 = []\nM2 = []\nwhile not q.empty():\n    x = q.get()\n    if a[x] >= 0:\n        M1.append(x)\n        ans += a[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\n            a[b[x]] += a[x]\n    else:\n        M2.append(x)\n        ans += a[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\nprint(ans)\nprint(' '.join(map(str, M1)), end=' ')\nM2.reverse()\nprint(' '.join(map(str, M2)))", "import sys\nfrom queue import Queue\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\nq = Queue()\nn = ni()\na = nl()\nb = nl()\na.insert(0, 0)\nb.insert(0, 0)\ndeg = [0] * (max(b) * 10)\nfor i in range(1, n + 1):\n    if b[i] != -1:\n        deg[b[i]] += 1\nfor i in range(1, n + 1):\n    if deg[i] == 0:\n        q.put(i)\nans = 0\nv1 = []\nv2 = []\nwhile not q.empty():\n    x = q.get()\n    if a[x] >= 0:\n        v1.append(x)\n        ans += a[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\n            a[b[x]] += a[x]\n    else:\n        v2.append(x)\n        ans += a[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\nprint(ans)\nprint(' '.join(map(str, v1)), end=' ')\nv2.reverse()\nprint(' '.join(map(str, v2)))", "import sys\nfrom queue import Queue\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\nq = Queue()\nn = ni()\nz = nl()\nb = nl()\nz.insert(0, 0)\nb.insert(0, 0)\ndeg = [0] * (max(b) * 10)\nfor i in range(1, n + 1):\n    if b[i] != -1:\n        deg[b[i]] += 1\nfor i in range(1, n + 1):\n    if deg[i] == 0:\n        q.put(i)\nPNS = 0\nM1 = []\nM2 = []\nwhile not q.empty():\n    x = q.get()\n    if z[x] >= 0:\n        M1.append(x)\n        PNS += z[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\n            z[b[x]] += z[x]\n    else:\n        M2.append(x)\n        PNS += z[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\nprint(PNS)\nprint(' '.join(map(str, M1)), end=' ')\nM2.reverse()\nprint(' '.join(map(str, M2)))", "import sys\nfrom queue import Queue\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nUs = lambda : readline().rstrip()\nUi = lambda : int(readline().rstrip())\nUm = lambda : map(int, readline().split())\nUl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\nq = Queue()\nn = Ui()\nz = Ul()\nb = Ul()\nz.insert(0, 0)\nb.insert(0, 0)\ndeg = [0] * (max(b) * 10)\nfor i in range(1, n + 1):\n    if b[i] != -1:\n        deg[b[i]] += 1\nfor i in range(1, n + 1):\n    if deg[i] == 0:\n        q.put(i)\nPNS = 0\nM1 = []\nM2 = []\nwhile not q.empty():\n    x = q.get()\n    if z[x] >= 0:\n        M1.append(x)\n        PNS += z[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\n            z[b[x]] += z[x]\n    else:\n        M2.append(x)\n        PNS += z[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\nprint(PNS)\nprint(' '.join(map(str, M1)), end=' ')\nM2.reverse()\nprint(' '.join(map(str, M2)))", "import sys\nfrom queue import Queue\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\nq = Queue()\nn = ni()\na = nl()\nb = nl()\na.insert(0, 0)\nb.insert(0, 0)\ndeg = [0] * (max(b) * 10)\nfor i in range(1, n + 1):\n    if b[i] != -1:\n        deg[b[i]] += 1\nfor i in range(1, n + 1):\n    if deg[i] == 0:\n        q.put(i)\nPNS = 0\nM1 = []\nM2 = []\nwhile not q.empty():\n    x = q.get()\n    if a[x] >= 0:\n        M1.append(x)\n        PNS += a[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\n            a[b[x]] += a[x]\n    else:\n        M2.append(x)\n        PNS += a[x]\n        if b[x] != -1:\n            deg[b[x]] -= 1\n            if deg[b[x]] == 0:\n                q.put(b[x])\nprint(PNS)\nprint(' '.join(map(str, M1)), end=' ')\nM2.reverse()\nprint(' '.join(map(str, M2)))"]