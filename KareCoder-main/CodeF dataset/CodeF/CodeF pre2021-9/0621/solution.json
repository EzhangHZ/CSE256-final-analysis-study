["import sys\nfrom os import path\nif path.exists('Input.txt'):\n    sys.stdin = open('Input.txt', 'r')\n    sys.stdout = open('Output.txt', 'w')\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef solve_tc():\n    (n, k) = map(int, input().split())\n    a = n - k\n    ans = (a - 1) * a // 2\n    ll = [0 for _ in range(n * 2)]\n    p = []\n    for _ in range(k):\n        (a, b) = map(int, input().split())\n        if a > b:\n            p.append([b, a])\n        else:\n            p.append([a, b])\n        ll[a - 1] = b\n        ll[b - 1] = a\n    for _ in range(len(p)):\n        a = p[_][0] - 1\n        b = p[_][1] - 1\n        ans1 = ans2 = 0\n        for j in range(a + 1, b):\n            if ll[j]:\n                if ll[j] - 1 < a or ll[j] - 1 > b:\n                    ans += 0.5\n            else:\n                ans1 += 1\n        for j in range(0, a):\n            if not ll[j]:\n                ans2 += 1\n        for j in range(b + 1, n * 2):\n            if not ll[j]:\n                ans2 += 1\n        ans += min(ans2, ans1)\n    return str(int(ans))\nt = int(input())\nfor _ in range(t):\n    sys.stdout.write(solve_tc() + '\\n')", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, k) = map(int, input().split())\n    z = [None] * (2 * n)\n    a = [tuple(map(int, input().split())) for i in range(k)]\n    i = 0\n    for (x, y) in a:\n        z[x - 1] = i\n        z[y - 1] = i\n        i += 1\n    w = i\n    for j in range(2 * n):\n        if z[j] is None:\n            if len(a) != n:\n                z[j] = i\n                a.append([j + 1, None])\n                i += 1\n            elif len(a) == n:\n                if i == n:\n                    i = w\n                z[j] = i\n                a[i][1] = j + 1\n                i += 1\n    r = 0\n    for i in range(n):\n        (x, y) = a[i]\n        if x > y:\n            (x, y) = (y, x)\n        c = [0] * n\n        for j in range(x - 1, y):\n            c[z[j]] ^= 1\n        r += sum(c)\n    print(r // 2)\nfor i in range(int(input())):\n    solve()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split(' '))\n    rads = []\n    nd = [x for x in range(1, 2 * n + 1)]\n    for x in range(k):\n        (a, b) = map(int, input().split(' '))\n        nd.remove(a)\n        nd.remove(b)\n        rads.append(sorted([a, b]))\n    b = len(nd) // 2\n    for x in range(b):\n        rads.append([nd[x], nd[x + b]])\n    rads.sort(key=lambda x: x[0])\n    ct = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            if rads[y][0] < rads[x][1] and rads[y][1] > rads[x][1]:\n                ct += 1\n    print(ct)", "for tests in range(int(input())):\n    (n, k) = map(int, input().split())\n    ls = [sorted(list(map(int, input().split()))) for i in range(k)]\n    ans = 0\n    arr = [-1 for i in range(2 * n)]\n    for i in range(k):\n        arr[ls[i][1] - 1] = ls[i][0] - 1\n        arr[ls[i][0] - 1] = ls[i][0] - 1\n    ar = []\n    for i in range(2 * n):\n        if arr[i] == -1:\n            ar.append(i + 1)\n    for i in range(n - k):\n        ls.append([ar[i], ar[i + n - k]])\n    ls.sort()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ls[i][0] < ls[j][0] < ls[i][1] < ls[j][1]:\n                ans += 1\n    print(ans)", "T = int(input())\nfor _ in range(T):\n    s = set()\n    (N, K) = [int(s) for s in input().split()]\n    arr = [i for i in range(1, 2 * N + 1)]\n    res = 0\n    for _ in range(K):\n        (a, b) = [int(s) for s in input().split()]\n        if a > b:\n            (a, b) = (b, a)\n        for i in s:\n            if (not a > i[0] or not b < i[1]) and (not a < i[0] or not b > i[1]):\n                if a < i[1] and b > i[0]:\n                    res += 1\n        s.add((a, b))\n        arr.remove(a)\n        arr.remove(b)\n    while arr:\n        mid = len(arr) // 2\n        a = arr[0]\n        b = arr[mid]\n        arr.remove(a)\n        arr.remove(b)\n        for i in s:\n            if (not a > i[0] or not b < i[1]) and (not a < i[0] or not b > i[1]):\n                if a < i[1] and b > i[0]:\n                    res += 1\n        s.add((a, b))\n    print(res)", "for _ in range(int(input())):\n    (n_chords, n_drawn) = [int(a) for a in input().split(' ')]\n    if n_drawn == 0:\n        print(n_chords * (n_chords - 1) // 2)\n        continue\n    if n_chords == 1:\n        print(0)\n        input()\n        continue\n    points_remaining = {i + 1 for i in range(n_chords * 2)}\n    intersections = 0\n    structure = []\n\n    def num_intersects(p0, p1):\n        return sum([int((p0 - a0) * (p0 - a1) * (p1 - a0) * (p1 - a1) < 0) for (a0, a1) in structure])\n    for i in range(n_drawn):\n        (p0, p1) = [int(j) for j in input().split(' ')]\n        if p0 > p1:\n            (p0, p1) = (p1, p0)\n        intersections += num_intersects(p0, p1)\n        structure.append([p0, p1])\n        points_remaining.remove(p0)\n        points_remaining.remove(p1)\n    points_remaining = sorted(points_remaining)\n    lpr = len(points_remaining) // 2\n    for (p0, p1) in zip(points_remaining[:lpr], points_remaining[lpr:]):\n        intersections += num_intersects(p0, p1)\n        structure.append([p0, p1])\n    print(intersections)", "def intersect(a, b):\n    if a[0] > b[0]:\n        (a, b) = (b, a)\n    return a[1] > b[0] and a[1] < b[1]\n\ndef f(q, n, k):\n    vis = [0] * (2 * n + 1)\n    for (l, r) in q:\n        vis[l] = 1\n        vis[r] = 1\n    unvis = []\n    for i in range(1, 2 * n + 1):\n        if vis[i] == 0:\n            unvis.append(i)\n    for i in range(n - k):\n        q.append((unvis[i], unvis[i + n - k]))\n    ans = 0\n    for i in range(len(q)):\n        for j in range(i):\n            ans += intersect(q[i], q[j])\n    return ans\nfor _ in range(int(input())):\n    (n, k) = map(int, input().strip().split())\n    q = []\n    for i in range(k):\n        (x, y) = map(int, input().strip().split())\n        q.append(sorted([x, y]))\n    print(f(q, n, k))", "for __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (clis, taken) = ([], [])\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        taken += [x, y]\n        if x > y:\n            clis.append([y, x])\n        else:\n            clis.append([x, y])\n    n_taken = []\n    for i in range(1, 2 * n + 1):\n        if i in taken:\n            continue\n        n_taken.append(i)\n    n_taken.sort()\n\n    def intersect(a, b):\n        if a[1] > b[1] > a[0] > b[0] or b[1] > a[1] > b[0] > a[0]:\n            return True\n        return False\n    intersections = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            if intersect(clis[i], clis[j]):\n                intersections += 1\n    while True:\n        if len(n_taken) <= 0:\n            break\n        a = n_taken.pop(0)\n        b = n_taken.pop(len(n_taken) // 2)\n        for i in clis:\n            if intersect([a, b], i):\n                intersections += 1\n        clis.append([a, b])\n    print(intersections)", "def ch(x, y):\n    if y[0] < x[0] < y[1] and (not y[0] < x[1] < y[1]) or (y[0] < x[1] < y[1] and (not y[0] < x[0] < y[1])):\n        return 1\n    return 0\nt = int(input())\nfor i in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    m = []\n    use = [0] * (2 * n + 1)\n    for j in range(k):\n        (l, r) = [int(i) for i in input().split()]\n        if l > r:\n            (l, r) = (r, l)\n        use[l] = 1\n        use[r] = 1\n        m.append([l, r])\n    dontuse = []\n    for j in range(1, 2 * n + 1):\n        if not use[j]:\n            dontuse.append(j)\n    ll = len(dontuse)\n    for j in range(ll // 2):\n        m.append([dontuse[j], dontuse[j + ll // 2]])\n    m.sort()\n    ans = 0\n    for j in range(n):\n        for k in range(j + 1, n):\n            if ch(m[j], m[k]):\n                ans += 1\n    print(ans)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    r = []\n    l = []\n    points = {i for i in range(1, 2 * n + 1)}\n    for i in range(m):\n        r.append(sorted(list(map(int, input().split()))))\n        points.remove(r[-1][0])\n        points.remove(r[-1][1])\n    ans = 0\n\n    def inter(i, j, k):\n        return k[0] < i < k[1] and (not k[0] < j < k[1]) or (k[0] < j < k[1] and (not k[0] < i < k[1]))\n    for i in range(m):\n        for j in range(i + 1, m):\n            if inter(r[i][0], r[i][1], r[j]):\n                ans += 1\n    for _ in range(n - m):\n        maxi = 0\n        p = []\n        l = sorted(points)\n        p = [l[0], l[len(l) // 2]]\n        for i in r:\n            if inter(l[0], l[len(l) // 2], i):\n                maxi += 1\n        r.append(sorted(p))\n        points.remove(p[0])\n        points.remove(p[1])\n        ans += maxi\n    print(ans)", "def check(a, b):\n    if a[0] > b[0]:\n        (a, b) = (b, a)\n    return a[1] < b[1] and a[1] > b[0]\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    s = {i for i in range(1, 2 * n + 1)}\n    pairs = []\n    for i in range(k):\n        (a, b) = sorted(map(int, input().split()))\n        s.remove(a)\n        s.remove(b)\n        pairs.append((a, b))\n    s = sorted(s)\n    m = len(s) >> 1\n    (a, b) = (s[:m], s[m:])\n    for (x, y) in zip(a, b):\n        pairs.append((x, y))\n    ans = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            ans += check(pairs[i], pairs[j])\n    print(ans)", "def check(x, y):\n    return (y[0] < x[0] < y[1]) != (y[0] < x[1] < y[1])\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    f = [False] * (n * 2 + 1)\n    c = []\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        if x > y:\n            (x, y) = (y, x)\n        c.append((x, y))\n        f[x] = True\n        f[y] = True\n    a = []\n    for i in range(1, 2 * n + 1):\n        if not f[i]:\n            a.append(i)\n    k = len(a) // 2\n    for i in range(k):\n        c.append((a[i], a[i + k]))\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if check(c[i], c[j]):\n                res += 1\n    print(res)", "T = int(input())\nfor t in range(T):\n    (n, k) = list(map(int, input().split()))\n    chords = []\n    for i in range(k):\n        chords.append(list(map(int, input().split())))\n        chords[i].sort()\n    used = [False] * (2 * n + 1)\n    for i in range(k):\n        used[chords[i][0]] = True\n        used[chords[i][1]] = True\n    unused = []\n    for i in range(1, 2 * n + 1):\n        if not used[i]:\n            unused.append(i)\n    for i in range(n - k):\n        chords.append([unused[i], unused[n - k + i]])\n    ans = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if chords[i][0] < chords[j][0]:\n                if chords[j][0] < chords[i][1] < chords[j][1]:\n                    ans += 1\n            elif chords[i][0] < chords[j][1] < chords[i][1]:\n                ans += 1\n    print(ans)", "from math import floor, gcd, sqrt, ceil\nfrom collections import Counter, defaultdict\nfrom itertools import combinations\nfrom heapq import heapify, heappop, heappush\n\ndef main():\n    for _ in range(int(input())):\n        (n, k) = map(int, input().split())\n        coord = [list(map(int, input().split())) for i in range(k)]\n        visited = [False] * (2 * n + 1)\n        for (i, j) in coord:\n            visited[i] = True\n            visited[j] = True\n        m = []\n        for i in range(1, 2 * n + 1):\n            if not visited[i]:\n                visited[i] = True\n                m.append(i)\n        w = len(m) // 2\n        for i in range(w):\n            coord.append([m[i], m[w + i]])\n        ans = 0\n        for i in range(len(coord)):\n            coord[i].sort()\n        a = coord\n        for i in range(len(coord)):\n            for k in range(len(coord)):\n                if i != k:\n                    if a[i][0] < a[k][0] < a[i][1] and (not a[i][0] < a[k][1] < a[i][1]):\n                        ans += 1\n        print(ans)\nmain()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    visited = [False for _ in range(2 * n + 1)]\n    arr = []\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        visited[x] = True\n        visited[y] = True\n        if x > y:\n            (x, y) = (y, x)\n        arr.append((x, y))\n    z = []\n    for i in range(1, 2 * n + 1):\n        if visited[i] == False:\n            z.append(i)\n    l = 0\n    r = n - k\n    while r < 2 * (n - k):\n        arr.append((z[l], z[r]))\n        l += 1\n        r += 1\n    count = 0\n    arr.sort()\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i][0] < arr[j][0] and arr[i][1] < arr[j][1] and (arr[i][1] > arr[j][0]):\n                count += 1\n            if arr[i][0] > arr[j][0] and arr[i][1] > arr[j][1] and (arr[i][1] < arr[j][0]):\n                count += 1\n    print(count)", "cases = int(input())\n\ndef intersect(pair_1, pair_2):\n    (x_1, y_1) = pair_1\n    (x_2, y_2) = pair_2\n    if x_1 > x_2:\n        (x_1, x_2) = (x_2, x_1)\n        (y_1, y_2) = (y_2, y_1)\n    return y_1 > x_2 and y_1 < y_2\nfor i in range(cases):\n    (halfpoints, chords) = [int(x) for x in input().split()]\n    chordpairs = []\n    drawn_points = [False for x in range(halfpoints * 2)]\n    pairs = []\n    for k in range(chords):\n        (x, y) = [int(x) for x in input().split()]\n        drawn_points[x - 1] = True\n        drawn_points[y - 1] = True\n        if x > y:\n            (x, y) = (y, x)\n        pairs.append((x - 1, y - 1))\n    not_drawn_points = []\n    for j in range(halfpoints * 2):\n        if not drawn_points[j]:\n            not_drawn_points.append(j)\n    for j in range(halfpoints - chords):\n        pairs.append((not_drawn_points[j], not_drawn_points[j + halfpoints - chords]))\n    counter = 0\n    for j in range(halfpoints):\n        for k in range(halfpoints):\n            if intersect(pairs[j], pairs[k]):\n                counter += 1\n    print(int(counter / 2))", "t = int(input())\nfor i in range(t):\n    a = []\n    (n, k) = map(int, input().split())\n    r = list(range(1, 2 * n + 1))\n    for j in range(k):\n        l = list(map(int, input().split()))\n        r.remove(l[0])\n        r.remove(l[1])\n        a.append(l)\n    lr = len(r)\n    for j in range(lr // 2):\n        a.append([r[j], r[j + lr // 2]])\n    for j in range(n):\n        a[j].sort()\n    it = 0\n    for j in range(n):\n        for k in range(n):\n            if j < k:\n                if (a[j][0] < a[k][0] < a[j][1]) + (a[j][0] < a[k][1] < a[j][1]) == 1:\n                    it += 1\n    print(it)", "import itertools\n\ndef readline():\n    return map(int, input().split())\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nt = int(input())\nfor __ in range(t):\n    (n, k) = readline()\n    chords = [(*readline(),) for __ in range(k)]\n    free = set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords))\n    seq = sorted(free)\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "def cross(point, other):\n    if point[0] > other[0]:\n        (point, other) = (other, point)\n    if point[1] < other[0] or point[0] < other[0] < other[1] < point[1]:\n        return False\n    return True\n\ndef main(N, points):\n    drawn = set((x for point in points for x in point))\n    left = [x for x in range(1, N * 2 + 1) if x not in drawn]\n    for i in range(len(left) // 2):\n        points += [[left[i], left[i + len(left) // 2]]]\n    ret = 0\n    for (i, point) in enumerate(points):\n        for (j, other) in enumerate(points):\n            if i != j and cross(point, other):\n                ret += 1\n    return ret // 2\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    li = [list(sorted(map(int, input().split()))) for _ in range(M)]\n    print(main(N, li))", "t = int(input())\nfor tt in range(t):\n    (n, k) = map(int, input().split())\n    start = []\n    end = []\n    done = [0] * (2 * n)\n    for i in range(k):\n        (a, b) = map(int, input().split())\n        a -= 1\n        b -= 1\n        start.append(min(a, b))\n        end.append(max(a, b))\n        (done[a], done[b]) = (1, 1)\n    todo = []\n    for i in range(2 * n):\n        if not done[i]:\n            todo.append(i)\n    left = len(todo)\n    for i in range(left // 2):\n        start.append(todo[i])\n        end.append(todo[i + left // 2])\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            a1 = start[i]\n            a2 = start[j]\n            b1 = end[i]\n            b2 = end[j]\n            if start[i] > start[j]:\n                (a1, a2) = (a2, a1)\n                (b1, b2) = (b2, b1)\n            ans += int(a1 < a2 and a2 < b1 and (b1 < b2))\n    print(ans)", "import itertools\n\ndef readline():\n    return map(int, input().split())\n\ndef intersect(pair_of_chords):\n    (a, b) = pair_of_chords\n    return sum((x < y for x in a for y in b)) & 1\n\ndef solve():\n    (n, k) = readline()\n    chords = [(*readline(),) for __ in range(k)]\n    is_free = [True] * (2 * n)\n    for point in itertools.chain.from_iterable(chords):\n        is_free[point - 1] = False\n    free = [i for (i, f) in enumerate(is_free, start=1) if f]\n    chords.extend(zip(free, free[n - k:]))\n    print(sum(map(intersect, itertools.combinations(chords, 2))))\nt = int(input())\nfor __ in range(t):\n    solve()", "import itertools\n\ndef readline():\n    return map(int, input().split())\n\ndef intersect(first, second):\n    return sum((x < y for x in first for y in second)) & 1\n\ndef test_intersect():\n    assert intersect((2, 5), (3, 1))\n    assert intersect((2, 5), (4, 7))\n    assert not intersect((2, 5), (1, 7))\n    assert not intersect((2, 5), (4, 3))\n\ndef solve():\n    (n, k) = readline()\n    chords = [tuple(readline()) for __ in range(k)]\n    is_free = [True] * (2 * n)\n    for point in itertools.chain.from_iterable(chords):\n        is_free[point - 1] = False\n    free = [i for (i, f) in enumerate(is_free, start=1) if f]\n    chords.extend(zip(free, free[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))\nt = int(input())\nfor __ in range(t):\n    solve()", "import itertools\n\ndef readline():\n    return map(int, input().split())\n\ndef intersect(first, second):\n    return sum((x < y for x in first for y in second)) & 1\n\ndef solve():\n    (n, k) = readline()\n    chords = [tuple(readline()) for __ in range(k)]\n    is_free = [True] * (2 * n)\n    for point in itertools.chain.from_iterable(chords):\n        is_free[point - 1] = False\n    free = [i for (i, f) in enumerate(is_free, start=1) if f]\n    chords.extend(zip(free, free[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))\nt = int(input())\nfor __ in range(t):\n    solve()", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nt = int(input())\nfor __ in range(t):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    free = set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords))\n    seq = sorted(free)\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nfor __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    seq = sorted(set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords)))\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nfor __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    seq = sorted(set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords)))\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nfor __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    seq = sorted(set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords)))\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nfor __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    seq = sorted(set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords)))\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nfor __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    seq = sorted(set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords)))\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef intersect(a, b):\n    return sum((x < y for x in a for y in b)) & 1\nfor __ in range(int(input())):\n    (n, k) = map(int, input().split())\n    chords = [list(map(int, input().split())) for __ in range(k)]\n    seq = sorted(set(range(1, 2 * n + 1)) - set(itertools.chain.from_iterable(chords)))\n    chords.extend(zip(seq, seq[n - k:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))", "import itertools\n\ndef readline():\n    return map(int, input().split())\n\ndef intersect(first, second):\n    return sum((x < y for x in first for y in second)) & 1\n\ndef solve():\n    (n, k) = readline()\n    chords = [tuple(readline()) for __ in range(k)]\n    total = 2 * n\n    l = n - k\n    is_free = [True] * total\n    for (a, b) in chords:\n        is_free[a - 1] = is_free[b - 1] = False\n    free = [i for (i, f) in enumerate(is_free, start=1) if f]\n    assert len(free) == 2 * l\n    chords.extend(zip(free, free[l:]))\n    print(sum((intersect(a, b) for (a, b) in itertools.combinations(chords, 2))))\nt = int(input())\nfor __ in range(t):\n    solve()", "def getSide(pair, p):\n    return p > min(pair[0], pair[1]) and p < max(pair[0], pair[1])\n\ndef findMaxIntersection(n, k, pairs):\n    checked = [True for i in range(n * 2)]\n    for p in pairs:\n        checked[p[0]] = checked[p[1]] = False\n    available = [i for i in range(n * 2) if checked[i]]\n    for i in range(n - k):\n        pairs.append((available[i], available[i + n - k]))\n    result = 0\n    for pId in range(n):\n        for pId1 in range(pId + 1, n):\n            if getSide(pairs[pId], pairs[pId1][0]) != getSide(pairs[pId], pairs[pId1][1]):\n                result += 1\n    return result\nt = int(input())\nfor test in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    pairs = []\n    for i in range(k):\n        (x, y) = [int(i) - 1 for i in input().split()]\n        pairs.append((x, y))\n    print(findMaxIntersection(n, k, pairs))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    fill = [True] * 2 * n\n    s = []\n    for i in range(k):\n        (a, b) = map(int, input().split())\n        s.append([a - 1, b - 1])\n        fill[a - 1] = False\n        fill[b - 1] = False\n    t = n - k\n    ans = t * (t - 1) / 2\n    for i in s:\n        left = 0\n        right = 0\n        for j in range(2 * n):\n            if fill[j]:\n                if j > min(i[0], i[1]) and j < max(i[0], i[1]):\n                    left += 1\n                else:\n                    right += 1\n        ans += min(left, right)\n    x = 0\n    for i in s:\n        for j in s:\n            if (i[0] > min(j) and i[0] < max(j)) and (not (i[1] > min(j) and i[1] < max(j))):\n                x += 1\n            elif (i[1] > min(j) and i[1] < max(j)) and (not (i[0] > min(j) and i[0] < max(j))):\n                x += 1\n    print(int(ans + x // 2))", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = []\n    for i in range(k):\n        a.append([i for i in map(int, input().split())])\n    taken_point = []\n    remain_point = []\n    for i in a:\n        taken_point.append(i[0])\n        taken_point.append(i[1])\n        i.sort()\n    for i in range(1, 2 * n + 1):\n        if i not in taken_point:\n            remain_point.append(i)\n    remain_point.sort()\n    (i, j) = (0, len(remain_point) // 2)\n    for val in range(len(remain_point) // 2):\n        a.append([i for i in [remain_point[i], remain_point[j]]])\n        i += 1\n        j += 1\n    count = 0\n    for i in range(len(a) - 1):\n        for j in range(i + 1, len(a)):\n            if a[i][0] in range(a[j][0], a[j][1]) and a[i][1] not in range(a[j][0], a[j][1]):\n                count += 1\n            elif a[i][1] in range(a[j][0], a[j][1]) and a[i][0] not in range(a[j][0], a[j][1]):\n                count += 1\n    print(count)", "def intersect(l1, l2):\n    l1.sort()\n    l2.sort()\n    if (l2[0] < l1[0] or l2[0] > l1[1]) and l2[1] < l1[1] and (l2[1] > l1[0]):\n        return True\n    if (l2[1] < l1[0] or l2[1] > l1[1]) and l2[0] < l1[1] and (l2[0] > l1[0]):\n        return True\n    return False\nt = int(input())\nfor _ in range(t):\n    (n, k) = [int(i) for i in input().split(' ')]\n    lis = []\n    rec = []\n    for i in range(k):\n        p = [int(j) for j in input().split()]\n        p.sort()\n        lis += [p]\n        rec += p\n    pts = [i + 1 for i in range(2 * n)]\n    rem = [i for i in pts if i not in rec]\n    l = len(rem) // 2\n    rem2 = [[rem[i], rem[(i + l) % (2 * l)]] for i in range(l)]\n    lis += rem2\n    lis.sort()\n    ans = 0\n    for w1 in lis:\n        for e1 in lis:\n            if w1[0] == e1[0]:\n                continue\n            if intersect(w1, e1):\n                ans += 1\n    print(ans // 2)"]