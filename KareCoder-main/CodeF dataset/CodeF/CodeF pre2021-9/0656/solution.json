["import sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\ndef solve(n, m, a, x):\n    p = list(accumulate(a))\n    s = p[-1]\n    for i in range(1, n):\n        p[i] = max(p[i], p[i - 1])\n    ans = list()\n    for i in range(m):\n        if s <= 0 and x[i] > p[-1]:\n            ans.append(-1)\n            continue\n        elif s <= 0 or x[i] <= p[-1]:\n            k = 0\n        else:\n            k = (x[i] - p[-1]) // s\n            if (x[i] - p[-1]) % s > 0:\n                k += 1\n        x[i] -= k * s\n        index = bisect_left(p, x[i])\n        ans.append(k * n + index)\n    return ans\n\ndef main(argv=None):\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        x = list(map(int, input().split()))\n        print(' '.join(map(str, solve(n, m, a, x))))\n    return 0\nSTATUS = main()\nsys.exit(STATUS)", "import bisect\nN = int(input())\n\ndef solve(n, m, a, x):\n    B = []\n    mx_pref = -float('inf')\n    s = 0\n    for i in range(len(a)):\n        s += a[i]\n        mx_pref = max(mx_pref, s)\n        B.append(mx_pref)\n    ans = []\n    for xi in x:\n        if xi > mx_pref and s <= 0:\n            ans.append(-1)\n            continue\n        if xi <= mx_pref:\n            ans.append(bisect.bisect_left(B, xi))\n        else:\n            if (xi - mx_pref) % s == 0:\n                k = (xi - mx_pref) // s - 1\n            else:\n                k = (xi - mx_pref) // s\n            k += 1\n            res = k * n - 1\n            xi -= s * k\n            if xi > 0:\n                res += 1 + bisect.bisect_left(B, xi)\n            ans.append(res)\n    return ans\nfor _ in range(N):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    ans = solve(n, m, a, x)\n    print(' '.join((str(x) for x in ans)))", "import sys\nfrom bisect import bisect_left\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    M = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n        M[i + 1] = max(M[i], p[i + 1])\n    s = p[-1]\n    ans = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r += t * n\n            x -= t * s\n        if x > M[-1]:\n            ans.append('-1')\n        else:\n            pos = bisect_left(M, x)\n            ans.append(str(r + pos - 1))\n    print(' '.join(ans))\nfor i in range(int(input())):\n    solve()", "from bisect import bisect_left\ntc = int(input())\nfor _ in range(tc):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    Val = sum(a)\n    process = []\n    ret = []\n    curr = 0\n    index = {}\n    for i in range(n):\n        curr += a[i]\n        if i == 0:\n            process.append(curr)\n            index[curr] = i\n        elif curr > process[-1]:\n            process.append(curr)\n            index[curr] = i\n    localBig = process[-1]\n    for num in x:\n        if localBig < num and Val <= 0:\n            ret.append('-1')\n            continue\n        spins = 0\n        if localBig < num:\n            spins = (num - localBig + Val - 1) // Val\n        num -= spins * Val\n        pos = spins * n + index[process[bisect_left(process, num)]]\n        ret.append(str(pos))\n    print(' '.join(ret))", "__version__ = '3.2'\n__date__ = '2021-03-14'\nimport sys\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\ndef solve(n, m, a, x):\n    p = list(accumulate(a))\n    s = p[-1]\n    for i in range(1, n):\n        p[i] = max(p[i], p[i - 1])\n    ans = list()\n    for i in range(m):\n        if s <= 0 and x[i] > p[-1]:\n            ans.append(-1)\n            continue\n        elif s <= 0 or x[i] <= p[-1]:\n            k = 0\n        else:\n            k = (x[i] - p[-1]) // s\n            if (x[i] - p[-1]) % s > 0:\n                k += 1\n        x[i] -= k * s\n        index = bisect_left(p, x[i])\n        ans.append(k * n + index)\n    return ans\n\ndef main(argv=None):\n    t = int(input())\n    for _ in range(t):\n        (n, m) = map(int, input().split())\n        a = list(map(int, input().split()))\n        x = list(map(int, input().split()))\n        print(' '.join(map(str, solve(n, m, a, x))))\n    return 0\nSTATUS = main()\nsys.exit(STATUS)", "from bisect import bisect_left\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    M = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n        M[i + 1] = max(M[i], p[i + 1])\n    s = p[-1]\n    ans = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r += t * n\n            x -= t * s\n        if x > M[-1]:\n            ans.append('-1')\n        else:\n            pos = bisect_left(M, x)\n            ans.append(str(r + pos - 1))\n    print(' '.join(ans))", "from itertools import accumulate\nimport bisect\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    p = list(accumulate(a))\n    s = p[-1]\n    max_val = max(p)\n    for i in range(1, n):\n        p[i] = max(p[i], p[i - 1])\n    res = []\n    for xi in x:\n        if s <= 0 and xi > max_val:\n            res.append(-1)\n            continue\n        cnt = 0\n        if xi > max_val:\n            c = (xi - max_val + s - 1) // s\n            cnt += c * n\n            xi -= c * s\n        idx = bisect.bisect_left(p, xi)\n        res.append(cnt + idx)\n    return res\nt = int(input())\nfor _ in range(t):\n    print(*solve())", "import sys\nfrom bisect import bisect_left\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\ndef solve():\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    X = list(map(int, input().split()))\n    pref = []\n    ind = []\n    step = 0\n    for (i, a) in enumerate(A):\n        step += a\n        if not pref or step > pref[-1]:\n            pref.append(step)\n            ind.append(i)\n    res = [0] * m\n    for (j, x) in enumerate(X):\n        if pref[-1] < x and step <= 0:\n            res[j] = -1\n        else:\n            loop = 0\n            if pref[-1] < x:\n                loop = (x - pref[-1] + step - 1) // step\n            x -= loop * step\n            idx = bisect_left(pref, x)\n            res[j] = loop * n + ind[idx]\n    print(*res)\n\ndef resolve():\n    t = int(input())\n    for t in range(t):\n        solve()\nresolve()", "from bisect import bisect_left\ntc = int(input())\nfor _ in range(tc):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    Val = sum(a)\n    process = []\n    ret = []\n    curr = 0\n    index = {}\n    for i in range(n):\n        curr += a[i]\n        if i == 0:\n            process.append(curr)\n            index[curr] = i\n        elif curr > process[-1]:\n            process.append(curr)\n            index[curr] = i\n    localBig = process[-1]\n    for num in x:\n        if localBig < num and Val <= 0:\n            ret.append('-1')\n            continue\n        spins = 0\n        if localBig < num:\n            spins = (num - localBig + Val - 1) // Val\n        num -= spins * Val\n        pos = spins * n + index[process[bisect_left(process, num)]]\n        ret.append(str(pos))\n    print(' '.join(ret))", "from bisect import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, m) = I()\n    p = [0]\n    M = [0]\n    for v in I():\n        p += (p[-1] + v,)\n        M += (max(M[-1], p[-1]),)\n    s = p[-1]\n    a = []\n    for x in I():\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r = t * n\n            x -= t * s\n        a += ([r + bisect_left(M, x), 0][x > M[-1]] - 1,)\n    print(*a)", "from bisect import bisect_left\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    M = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n        M[i + 1] = max(M[i], p[i + 1])\n    s = p[-1]\n    ans = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r += t * n\n            x -= t * s\n        if x > M[-1]:\n            ans.append('-1')\n        else:\n            pos = bisect_left(M, x)\n            ans.append(str(r + pos - 1))\n    print(' '.join(ans))\nfor i in range(int(input())):\n    solve()", "import bisect\nt = int(input())\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    asum = sum(a)\n    t = 0\n    p = []\n    for (i, x) in enumerate(a):\n        t += x\n        if len(p) == 0 or p[-1][0] < t:\n            p.append((t, i))\n    pp = [y[0] for y in p]\n    ans = []\n    for x in b:\n        r = 0\n        if p[-1][0] < x:\n            if asum <= 0:\n                ans.append(-1)\n                continue\n            r = (x - p[-1][0]) // asum\n            if (x - p[-1][0]) % asum > 0:\n                r += 1\n            x -= r * asum\n        i = bisect.bisect_left(pp, x)\n        ans.append(p[i][1] + r * n)\n    print(' '.join(map(str, ans)))", "from bisect import bisect_left\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    M = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n        M[i + 1] = max(M[i], p[i + 1])\n    s = p[-1]\n    ans = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r += t * n\n            x -= t * s\n        ans.append('-1' if x > M[-1] else str(r + bisect_left(M, x) - 1))\n    print(' '.join(ans))", "from bisect import bisect_left\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    M = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n        M[i + 1] = max(M[i], p[i + 1])\n    s = p[-1]\n    ans = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r += t * n\n            x -= t * s\n        if x > M[-1]:\n            ans.append('-1')\n        else:\n            pos = bisect_left(M, x)\n            ans.append(str(r + pos - 1))\n    print(' '.join(ans))", "from bisect import bisect_left\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = [0] * (n + 1)\n    M = [0] * (n + 1)\n    for i in range(n):\n        p[i + 1] = p[i] + a[i]\n        M[i + 1] = max(M[i], p[i + 1])\n    s = p[-1]\n    ans = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r += t * n\n            x -= t * s\n        if x > M[-1]:\n            ans.append('-1')\n        else:\n            pos = bisect_left(M, x)\n            ans.append(str(r + pos - 1))\n    print(' '.join(ans))", "from bisect import *\nI = lambda : map(int, input().split())\nfor _ in range(*I()):\n    (n, m) = I()\n    p = [0]\n    M = [0]\n    for v in I():\n        p += (p[-1] + v,)\n        M += (max(M[-1], p[-1]),)\n    s = p[-1]\n    a = []\n    for x in map(int, input().split()):\n        r = 0\n        if s > 0:\n            t = max((x - M[-1] + s - 1) // s, 0)\n            r = t * n\n            x -= t * s\n        a += ([str(r + bisect_left(M, x) - 1), '-1'][x > M[-1]],)\n    print(*a)", "from math import ceil\nfrom bisect import bisect_left\n\ndef find():\n    (n, m) = map(int, input().split())\n    sum_a = 0\n    pref = {}\n    pref_s = [0]\n    ind = 0\n    for j in input().split():\n        sum_a += int(j)\n        if sum_a not in pref:\n            pref[sum_a] = ind\n        if sum_a > pref_s[-1]:\n            pref_s.append(sum_a)\n        ind += 1\n    for j in input().split():\n        j = int(j)\n        ans = 0\n        if j <= pref_s[-1]:\n            my_pref = j\n        elif sum_a <= 0:\n            print(-1, end=' ')\n            continue\n        else:\n            tmp = ceil((j - pref_s[-1]) / sum_a)\n            my_pref = max(0, j - tmp * sum_a)\n            ans += tmp * n\n        print(ans + pref[pref_s[bisect_left(pref_s, my_pref, lo=1)]], end=' ')\n    print()\nfor i in range(int(input())):\n    find()", "import bisect\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dp = [0] * n\n    check_point = []\n    cnt = 0\n    for i in range(n):\n        if i == 0:\n            dp[i] = a[i]\n        else:\n            dp[i] = dp[i - 1] + a[i]\n        if cnt == 0 and dp[i] > 0:\n            check_point.append((dp[i], i))\n            cnt += 1\n        elif cnt != 0 and dp[i] > check_point[cnt - 1][0]:\n            check_point.append((dp[i], i))\n            cnt += 1\n    for i in range(m):\n        ans = -1\n        if cnt != 0:\n            if b[i] > check_point[cnt - 1][0] and dp[n - 1] > 0:\n                tmp = b[i]\n                tmp -= check_point[cnt - 1][0]\n                if tmp % dp[n - 1] == 0:\n                    ans = tmp // dp[n - 1] * n + check_point[cnt - 1][1]\n                else:\n                    to_find = b[i] - (tmp // dp[n - 1] + 1) * dp[n - 1]\n                    pos = bisect.bisect_left(check_point, (to_find, 0))\n                    ans = (tmp // dp[n - 1] + 1) * n + check_point[pos][1]\n            elif b[i] > check_point[cnt - 1][0]:\n                ans = -1\n            else:\n                pos = bisect.bisect_left(check_point, (b[i], 0))\n                ans = check_point[pos][1]\n        print(ans, end=' ')\n    print()", "def findIncrementIndex(sumIncrementIndices, x):\n    l = 0\n    r = len(sumIncrementIndices)\n    while l < r:\n        m = (l + r) // 2\n        if sumIncrementIndices[m][0] < x:\n            l = m + 1\n        else:\n            r = m\n    return sumIncrementIndices[r][1]\n\ndef solve(A, n, X, m):\n    runningSum = 0\n    lastIncrementedSum = 0\n    sumIncrementIndices = []\n    for i in range(n):\n        runningSum += A[i]\n        if runningSum > lastIncrementedSum:\n            sumIncrementIndices.append((runningSum, i))\n            lastIncrementedSum = runningSum\n    result = []\n    totalSum = runningSum\n    for i in range(m):\n        x = X[i]\n        seconds = 0\n        if x > lastIncrementedSum:\n            if totalSum <= 0:\n                result.append(-1)\n                continue\n            roundsCount = (x - lastIncrementedSum + totalSum - 1) // totalSum\n            seconds = roundsCount * n\n            x -= roundsCount * totalSum\n        seconds += findIncrementIndex(sumIncrementIndices, x)\n        result.append(seconds)\n    return result\nt = int(input())\nfor tc in range(t):\n    (n, m) = map(int, input().split())\n    A = list(map(int, input().split()))\n    X = list(map(int, input().split()))\n    result = solve(A, n, X, m)\n    print(*result)", "from math import ceil\n\ndef solve():\n    (n, m) = map(int, input().split())\n    l = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    s = 0\n    pref = {}\n    pref_s = [0]\n    for j in range(n):\n        s += l[j]\n        if s not in pref:\n            pref[s] = j\n        if l[j] > 0 and s > pref_s[-1]:\n            pref_s.append(s)\n    for j in x:\n        ans = 0\n        if j <= pref_s[-1]:\n            my_pref = j\n        elif s <= 0:\n            print(-1, end=' ')\n            continue\n        else:\n            tmp = ceil((j - pref_s[-1]) / s)\n            my_pref = max(0, j - tmp * s)\n            ans += tmp * n\n        ind_min = 1\n        ind_max = len(pref_s) - 1\n        while ind_min != ind_max:\n            ind_new = (ind_min + ind_max) // 2\n            if pref_s[ind_new] < my_pref:\n                ind_min = ind_new + 1\n            else:\n                ind_max = ind_new\n        print(ans + pref[pref_s[ind_max]], end=' ')\n    print()\nfor test in range(int(input())):\n    solve()", "from math import ceil\n\ndef find():\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    sum_a = 0\n    pref = {}\n    pref_s = [0]\n    for j in range(n):\n        sum_a += a[j]\n        if sum_a not in pref:\n            pref[sum_a] = j\n        if a[j] > 0 and sum_a > pref_s[-1]:\n            pref_s.append(sum_a)\n    for j in x:\n        ans = 0\n        if j <= pref_s[-1]:\n            my_pref = j\n        elif sum_a <= 0:\n            print(-1, end=' ')\n            continue\n        else:\n            tmp = ceil((j - pref_s[-1]) / sum_a)\n            my_pref = max(0, j - tmp * sum_a)\n            ans += tmp * n\n        ind_min = 1\n        ind_max = len(pref_s) - 1\n        while ind_min != ind_max:\n            ind_new = (ind_min + ind_max) // 2\n            if pref_s[ind_new] < my_pref:\n                ind_min = ind_new + 1\n            else:\n                ind_max = ind_new\n        print(ans + pref[pref_s[ind_max]], end=' ')\n    print()\nfor i in range(int(input())):\n    find()"]