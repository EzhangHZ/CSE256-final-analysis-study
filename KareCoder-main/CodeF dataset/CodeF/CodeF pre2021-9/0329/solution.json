["import sys\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, m) = map(int, sys.stdin.readline().split())\n    paths = []\n    b = list(map(int, sys.stdin.readline().split()))\n    for bi in b:\n        paths.append([bi, [bi]])\n    paths = sorted(paths)\n    for _ in range(n - 1):\n        b = list(map(int, sys.stdin.readline().split()))\n        b = sorted(b, reverse=True)\n        for i in range(len(b)):\n            paths[i][0] = min(paths[i][0], b[i])\n            paths[i][1].append(b[i])\n        paths = sorted(paths)\n    for i in range(n):\n        for j in range(m):\n            print(paths[j][1][i], end=' ')\n        print()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m) = map(int, input().split())\n    a = [None] * (n * m)\n    b = [None] * n\n    w = [None] * n\n    for i in range(n):\n        j = 0\n        c = [None] * m\n        w[i] = [None] * m\n        for v in map(int, input().split()):\n            a[i * m + j] = (v, i, j)\n            c[j] = v\n            j += 1\n        b[i] = c\n    a.sort()\n    k = 0\n    for (v, i, j) in a[:m]:\n        w[i][k] = j\n        k += 1\n    for i in range(n):\n        h = [False] * m\n        for j in w[i]:\n            if j is not None:\n                h[j] = True\n        k = 0\n        for j in range(m):\n            if w[i][j] is None:\n                while k < m and h[k]:\n                    k += 1\n                w[i][j] = k\n                k += 1\n        print(' '.join((str(b[i][j]) for j in w[i])))\nfor i in range(int(input())):\n    solve()", "import sys\nfrom collections import deque\n\ndef rl():\n    return sys.stdin.readline().strip()\n\ndef rl_types(types):\n    str_list = [x for x in sys.stdin.readline().strip().split(' ')]\n    return [types[i](str_list[i]) for i in range(len(str_list))]\n\ndef pr(something):\n    sys.stdout.write(str(something) + '\\n')\n\ndef pra(array):\n    sys.stdout.write(' '.join([str(x) for x in array]) + '\\n')\n\ndef solve(bvals, nrunners):\n    tiredness = 0\n    paths = []\n    for ri in range(nrunners):\n        mn = min([opts[0] for opts in bvals])\n        n = len(bvals)\n        curp = []\n        found = False\n        for i in range(n):\n            if found:\n                curp.append(bvals[i].pop())\n            elif bvals[i][0] == mn:\n                curp.append(bvals[i].popleft())\n                found = True\n            else:\n                curp.append(bvals[i].pop())\n        paths.append(curp)\n    return paths\nNT = int(rl())\nfor ti in range(NT):\n    (n, m) = [int(x) for x in rl().split(' ')]\n    bvals = []\n    for _ in range(n):\n        opts = deque(sorted([int(x) for x in rl().split(' ')]))\n        bvals.append(opts)\n    paths = solve(bvals, m)\n    for j in range(n):\n        pra([paths[i][j] for i in range(m)])", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\nt = inp()\nfor case in range(0, t):\n    nm = inlt()\n    n = nm[0]\n    m = nm[1]\n    all = []\n    ls = []\n    lans = []\n    for i in range(0, n):\n        l = inlt()\n        ls.append(l)\n        all.extend(l)\n        lans.append([])\n    all.sort()\n    p = []\n    for i in range(0, m):\n        looking = True\n        for k in range(0, n):\n            if min(ls[k]) == all[i] and looking:\n                lans[k].append(all[i])\n                ls[k].remove(all[i])\n                looking = False\n            else:\n                lans[k].append(max(ls[k]))\n                ls[k].remove(max(ls[k]))\n    for i in range(0, n):\n        print(' '.join(map(str, lans[i])))", "class Path:\n\n    def __init__(self, checkpoint, length):\n        self.c = checkpoint\n        self.l = length\n\nclass PathList:\n\n    def __init__(self, l):\n        self.l = l\n\n    def pop(self):\n        return self.l.pop()\nt = int(input())\nr = []\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    b = []\n    paths = []\n    for i in range(n):\n        checkpointPaths = list(map(int, input().split()))\n        checkpointPaths.sort()\n        b.append(PathList(checkpointPaths))\n        paths.extend([Path(i, j) for j in checkpointPaths])\n    paths.sort(key=lambda x: (x.l, x.c))\n    result = [[] for _ in range(n)]\n    for i in range(m):\n        smallestPath = paths[i]\n        result[smallestPath.c].append(smallestPath.l)\n        for j in range(n):\n            if len(result[j]) < i + 1:\n                result[j].append(b[j].pop())\n    resStr = '\\n'.join([' '.join([str(i) for i in x]) for x in result])\n    r.append(resStr)\nprint('\\n'.join(r))", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, m) = R()\n    a = []\n    b = []\n    j = 0\n    while n:\n        n -= 1\n        a += zip(R(), [~n] * m)\n        b += ([0] * m,)\n    for (x, i) in sorted(a):\n        while b[i][j % m]:\n            j += 1\n        b[i][j % m] = x\n        j += 1\n    for r in b:\n        print(*r)", "from decimal import Decimal\nimport collections as coll\nimport sys\nimport math as mt\nimport random as rd\nimport bisect as bi\nimport time\nsys.setrecursionlimit(1000000)\n\ndef uno():\n    return int(sys.stdin.readline().strip())\n\ndef dos():\n    return sys.stdin.readline().strip()\n\ndef tres():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef cuatro():\n    return sys.stdin.readline().strip().split()\nfor _ in range(uno()):\n    (n, m) = tres()\n    b = []\n    for i in range(n):\n        b.append(list(tres()))\n    d = []\n    for i in range(n):\n        for j in b[i]:\n            d.append([j, i])\n    d.sort()\n    b = [[-1 for i in range(m)] for j in range(n)]\n    a = [0] * n\n    for i in range(m):\n        b[d[i][1]][i] = d[i][0]\n    for i in range(m, m * n):\n        while b[d[i][1]][a[d[i][1]]] != -1:\n            a[d[i][1]] += 1\n        b[d[i][1]][a[d[i][1]]] = d[i][0]\n        a[d[i][1]] += 1\n    for i in range(n):\n        print(*b[i])", "from sys import stdin, stdout\ninput = stdin.readline\nI = int\nR = range\nlistInput = lambda : list(map(int, input().strip().split()))\nlineInput = lambda : map(int, input().strip().split())\n\ndef main():\n    for _ in R(I(input())):\n        (n, m) = lineInput()\n        ans = [[-1] * m for i in range(n)]\n        pathAndRow = []\n        for i in range(n):\n            for j in listInput():\n                pathAndRow.append((j, i))\n        pathAndRow.sort()\n        for i in range(m):\n            ele = pathAndRow.pop(0)\n            ans[ele[1]][i] = ele[0]\n        while pathAndRow:\n            ele = pathAndRow.pop(0)\n            itr = 0\n            while ans[ele[1]][itr] != -1:\n                itr += 1\n            ans[ele[1]][itr] = ele[0]\n        for i in range(n):\n            print(*ans[i])\nmain()", "ans = []\ntests = int(input())\nfor test in range(tests):\n    int_input = [int(x) for x in input().split(' ')]\n    n = int_input[0]\n    m = int_input[1]\n    paths = []\n    for i in range(n):\n        path = sorted([int(x) for x in input().split(' ')])\n        paths.append(path)\n    checkpoints = [[] for x in paths]\n    for j in range(m):\n        min_val = min(range(n), key=lambda x: paths[x][0])\n        for i in range(len(paths)):\n            if i == min_val:\n                checkpoints[i].append(paths[i].pop(0))\n            else:\n                checkpoints[i].append(paths[i].pop())\n    for t in checkpoints:\n        ans_str = ''\n        for i in t:\n            ans_str += str(i) + ' '\n        ans.append(ans_str)\nfor i in ans:\n    print(i)", "import sys\ninput = sys.stdin.readline\n\ndef inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef printlst(lst):\n    print(' '.join(list(map(str, lst))))\nt = inp()\nfor _ in range(t):\n    b = []\n    (n, m) = invr()\n    for _ in range(n):\n        b += [inlt()]\n        b[-1].sort(reverse=True)\n    path = [[-1 for j in range(n)] for i in range(m)]\n    for i in range(m):\n        mn = float('inf')\n        mni = -1\n        for j in range(n):\n            if b[j][-1] < mn:\n                (mn, mni) = (b[j][-1], j)\n        b[mni].pop()\n        path[i][mni] = mn\n    for i in range(m):\n        for j in range(n):\n            if path[i][j] == -1:\n                path[i][j] = b[j].pop()\n    for i in range(n):\n        printlst([row[i] for row in path])", "import heapq\nimport sys\nfrom collections import *\nfrom heapq import *\nimport math\nimport bisect\n\ndef input():\n    return sys.stdin.readline()\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    mat = []\n    for _ in range(n):\n        row = sorted(list(map(int, input().split())))\n        mat.append(row)\n    ans = []\n    dic = defaultdict(int)\n    for _ in range(m):\n        temp = []\n        minn = 10 ** 18\n        ind = -1\n        for i in range(n):\n            if mat[i][dic[i]] < minn:\n                minn = mat[i][dic[i]]\n                ind = i\n        for j in range(n):\n            if ind == j:\n                temp.append(mat[j][dic[j]])\n                dic[j] += 1\n            else:\n                temp.append(mat[j][-1])\n                mat[j].pop()\n        ans.append(temp)\n    for i in range(n):\n        temp1 = []\n        for j in range(m):\n            temp1.append(ans[j][i])\n        print(*temp1)", "from sys import stdin, stdout\nimport sys\nimport math\nimport itertools\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\ndef shortrunner(barr, n, m):\n    paths = []\n    runway = {}\n    c = 0\n    for ckpt in barr:\n        runway[c] = []\n        for i in ckpt:\n            paths.append(i)\n        c += 1\n    runner = 1\n    while runner <= m:\n        a = min(paths)\n        paths = []\n        run = []\n        c = 0\n        covered = 0\n        for ckpt in barr:\n            b = min(ckpt)\n            if b == a and covered == 0:\n                ckpt.remove(b)\n                covered = 1\n            else:\n                b = max(ckpt)\n                ckpt.remove(b)\n            for i in ckpt:\n                paths.append(i)\n            runway[c].append(b)\n            c += 1\n        runner += 1\n    return runway\n\ndef main():\n    t = int(stdin.readline().strip())\n    for i in range(1, t + 1):\n        (n, m) = map(int, stdin.readline().split())\n        barr = []\n        for j in range(n):\n            arr = [int(x) for x in stdin.readline().split()]\n            barr.append(arr)\n        ans = shortrunner(barr, n, m)\n        for i in ans.values():\n            print(*i)\nmain()", "from sys import *\nimport math\ninput = stdin.readline\nI = int\nR = range\nlistInput = lambda : list(map(int, input().strip().split()))\nlineInput = lambda : map(int, input().strip().split())\nsJoin = lambda a, sep: '{}'.format(sep).join(a)\narrJoin = lambda a, sep: '{}'.format(sep).join(map(str, a))\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(5, int(math.sqrt(n) + 1), 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef main():\n    for _ in R(I(input())):\n        (n, m) = lineInput()\n        ans = [[-1] * m for i in range(n)]\n        pathAndRow = []\n        for i in range(n):\n            for j in listInput():\n                pathAndRow.append((j, i))\n        pathAndRow.sort()\n        for i in range(m):\n            ele = pathAndRow.pop(0)\n            ans[ele[1]][i] = ele[0]\n        while pathAndRow:\n            ele = pathAndRow.pop(0)\n            itr = 0\n            while ans[ele[1]][itr] != -1:\n                itr += 1\n            ans[ele[1]][itr] = ele[0]\n        for i in range(n):\n            print(*ans[i])\nmain()", "def morning_jogging(data, m, n):\n    result = list()\n    for _ in range(n):\n        result.append(list())\n    for _ in range(m):\n        min_v = data[0][0]\n        min_i = 0\n        for i in range(n):\n            if data[i][0] < min_v:\n                min_v = data[i][0]\n                min_i = i\n        for i in range(n):\n            if i == min_i:\n                result[i].append(ds[i].pop(0))\n            else:\n                result[i].append(ds[i].pop(-1))\n    return result\nn_test_case = int(input())\ntest_cases = list()\nfor _ in range(n_test_case):\n    s = input()\n    s = s.split(' ')\n    n = int(s[0])\n    m = int(s[1])\n    ds = list()\n    for j in range(n):\n        s = input()\n        s = s.split(' ')\n        d = map(int, s)\n        ds.append(sorted(d))\n    test_cases.append((ds, m, n))\nfor (ds, m, n) in test_cases:\n    res = morning_jogging(ds, m, n)\n    for d in res:\n        print(' '.join(map(str, d)))", "for _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    b = []\n    for _ in range(n):\n        a = [int(i) for i in input().split()]\n        b.append(a)\n    l = []\n    for i in range(n):\n        for j in range(m):\n            l.append([b[i][j], i, j])\n    l.sort()\n    c = l[m:]\n    s = [[-1] * m for _ in range(n)]\n    for i in range(m):\n        s[l[i][1]][i] = l[i][0]\n    for x in c:\n        g = s[x[1]].index(-1)\n        s[x[1]][g] = x[0]\n    for i in s:\n        print(*i)", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    lst = []\n    for j in range(n):\n        lst1 = list(map(int, input().split()))\n        lst.append(lst1)\n    dic = {}\n    for k in range(n):\n        dic[k] = []\n    c = 0\n    for g in range(m):\n        ind = -1\n        mi = 1000000000\n        for f in range(n):\n            lst2 = lst[f]\n            if min(lst2) < mi:\n                mi = min(lst2)\n                ind = f\n        for d in range(n):\n            lst3 = lst[d]\n            if d != ind:\n                dic[d].append(max(lst3))\n                lst[d].remove(max(lst3))\n            else:\n                dic[d].append(mi)\n                lst3.remove(mi)\n    for w in dic.keys():\n        print(*dic[w])", "t = int(input())\nfor case in range(1, t + 1):\n    (n, m) = [int(x) for x in input().split(' ')]\n    b = []\n    for _ in range(n):\n        b.append([int(x) for x in input().split(' ')])\n    print(*b[0])\n    tiredness = b[0].copy()\n    for bb in b[1:]:\n        bb.sort(reverse=True)\n        tt = sorted(enumerate(tiredness), key=lambda x: x[1])\n        aa = [-1] * m\n        for (i, (j, tire)) in enumerate(tt):\n            aa[j] = bb[i]\n            tiredness[j] = min(bb[i], tire)\n        print(*aa)", "I = lambda : map(int, input().split())\nfor _ in [0] * int(input()):\n    (n, m) = I()\n    linit = list(I())\n    linit.sort()\n    print(*linit)\n    l = [[linit[i], i] for i in range(m)]\n    for i in range(1, n):\n        x = list(I())\n        x.sort(reverse=1)\n        y = [0] * m\n        k = 0\n        for jj in range(m):\n            y[l[jj][1]] = x[k]\n            if l[jj][0] > x[k]:\n                l[jj][0] = x[k]\n            k = k + 1\n        l.sort()\n        print(*y)", "trials = int(input())\nwhile trials > 0:\n    trials -= 1\n    (n, m) = input().split(' ')\n    (n, m) = (int(n), int(m))\n    x = 0\n    r = 0\n    while r != n:\n        r += 1\n        b = list(input().split(' '))\n        globals()['i' + f'{x + 1}'] = list(map(int, b))\n        x += 1\n    l = []\n    z = 1\n    for i in i1:\n        l.append((i,))\n    while z != n:\n        l.sort(key=lambda x: min(x))\n        globals()['i' + f'{z + 1}'].sort(reverse=True)\n        k = 0\n        for i in globals()['i' + f'{z + 1}']:\n            l[k] += (i,)\n            k += 1\n        z += 1\n    p = 0\n    for i in l[0]:\n        for i in l:\n            print(i[p], end=' ')\n        p += 1\n        print()", "def get_input(first=False):\n    l = [int(e) for e in input().split()]\n    if first:\n        return l[0]\n    return l\nfor _ in range(get_input(True)):\n    (n, m) = get_input()\n    S = []\n    sol = []\n    for i in range(n):\n        sol.append([None] * m)\n        for bj in get_input():\n            S.append((bj, i))\n    S.sort()\n    for k in range(m):\n        (b, i) = S.pop(0)\n        sol[i][k] = b\n    ind = [0] * n\n    while S:\n        (b, i) = S.pop()\n        while sol[i][ind[i]] is not None:\n            ind[i] += 1\n        sol[i][ind[i]] = b\n        ind[i] += 1\n    for b in sol:\n        print(*b)", "for _ in range(int(input())):\n    (n, m) = [int(i) for i in input().split()]\n    b = []\n    for _ in range(n):\n        a = [int(i) for i in input().split()]\n        b.append(a)\n    l = []\n    for i in range(n):\n        for j in range(m):\n            l.append([b[i][j], i, j])\n    l.sort()\n    c = l[m:]\n    s = [[-1] * m for _ in range(n)]\n    for i in range(m):\n        s[l[i][1]][i] = l[i][0]\n    for x in c:\n        g = s[x[1]].index(-1)\n        s[x[1]][g] = x[0]\n    for i in s:\n        print(*i)", "def main():\n    (N, M) = map(int, input().split())\n    B = []\n    for i in range(N):\n        b = list(map(int, input().split()))\n        for j in range(M):\n            B.append([b[j], i])\n    B.sort()\n    Ans = [[-1] * M for _ in range(N)]\n    for i in range(M):\n        (Val, n) = B[i]\n        Ans[n][i] = Val\n        B[i][0] = -1\n    Indexs = [0] * N\n    for (Val, n) in B:\n        if Val == -1:\n            continue\n        while Ans[n][Indexs[n]] != -1:\n            Indexs[n] += 1\n        Ans[n][Indexs[n]] = Val\n    for i in Ans:\n        print(*i)\nT = int(input())\nfor _ in range(T):\n    main()", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        a.sort(reverse=True)\n        l.append(a)\n    for i in range(m - 1):\n        ind = -1\n        minn = 1000000000\n        for j in range(n):\n            if l[j][-1] < minn:\n                minn = l[j][-1]\n                ind = j\n        ele = l[ind].pop()\n        l[ind].insert(i, ele)\n    for i in l:\n        print(' '.join(map(str, i)))", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split(' '))\n    lis = []\n    min = [0 for i in range(m)]\n    for i in range(n):\n        x = list(map(int, input().split(' ')))\n        if i == 0:\n            lis.append(x)\n            mini = lis[i].copy()\n        else:\n            y = x.copy()\n            x.sort()\n            temp = mini.copy()\n            for i in range(len(mini)):\n                y[temp.index(max(temp))] = x[i]\n                temp[temp.index(max(temp))] = 0\n            x = y.copy()\n            lis.append(x)\n            temp = [0] * len(mini)\n            for i in range(len(temp)):\n                if mini[i] > x[i]:\n                    mini[i] = x[i]\n    for i in lis:\n        for j in i:\n            print(j, end=' ')\n        print()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, m) = R()\n    a = []\n    b = []\n    i = j = 0\n    while i < n:\n        a += zip(R(), [i] * m)\n        b += ([0] * m,)\n        i += 1\n    for (x, i) in sorted(a):\n        while b[i][j % m]:\n            j += 1\n        b[i][j % m] = x\n        j += 1\n    for r in b:\n        print(*r)", "from sys import stdin, stdout\nimport math\n\ndef ii():\n    return int(stdin.readline())\n\ndef mi():\n    return map(int, stdin.readline().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return stdin.readline()\nfor _ in range(ii()):\n    A = []\n    (n, m) = mi()\n    for i in range(n):\n        l1 = li()\n        for j in range(m):\n            A.append([l1[j], i, j])\n    A.sort()\n    ans = [[-1 for j in range(m)] for i in range(n)]\n    for i in range(m * n):\n        (v, a, b) = A[i]\n        if i < m:\n            ans[a][i] = v\n        else:\n            for j in range(m):\n                if ans[a][j] == -1:\n                    ans[a][j] = v\n                    break\n    for i in ans:\n        print(*i)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        b = [int(i) for i in input().split()]\n        grid.append(b)\n    flat = []\n    for (i, row) in enumerate(grid):\n        for num in row:\n            flat.append((num, i))\n    flat.sort()\n    ans = [[-1] * m for i in range(n)]\n    for j in range(m):\n        (num, i) = flat[j]\n        ans[i][j] = num\n    pos = [0] * n\n    for (num, i) in flat[m:]:\n        while ans[i][pos[i]] != -1:\n            pos[i] += 1\n        ans[i][pos[i]] = num\n        pos[i] += 1\n    for row in ans:\n        print(*row)", "def read_ints():\n    return map(int, input().split())\nfor _ in range(int(input())):\n    (n, m) = read_ints()\n    A = [[num, cp] for cp in range(n) for num in read_ints()]\n    A.sort()\n    solution = [[0] * m for _ in range(n)]\n    for i in range(m):\n        assign = A.pop(0)\n        checkpoint = assign[1]\n        solution[checkpoint][i] = assign[0]\n    while A:\n        assign = A.pop(0)\n        checkpoint = assign[1]\n        for runner in range(m):\n            if not solution[checkpoint][runner]:\n                solution[checkpoint][runner] = assign[0]\n                break\n    for row in solution:\n        print(*row)", "def main():\n    cases = int(input())\n    from collections import deque\n    for case in range(cases):\n        (n, m) = map(int, input().split())\n        stacks = [sorted(map(int, input().split())) for i in range(n)]\n        paths = []\n        for i in range(m):\n            minis = [stacks[i][0] for i in range(n)]\n            i_mini = minis.index(min(minis))\n            path = [0] * n\n            path[i_mini] = stacks[i_mini].pop(0)\n            for j in range(n):\n                if j != i_mini:\n                    path[j] = stacks[j].pop()\n            paths.append(path)\n        for i in range(n):\n            print(*[paths[j][i] for j in range(m)])\nmain()", "def readline():\n    return map(int, input().split())\n\ndef solve(n, m, b):\n    runners = []\n    for __ in range(m):\n        runner = []\n        (shortest_i, __) = min(enumerate(b), key=lambda x: x[1])\n        for (i, bi) in enumerate(b):\n            runner.append(bi.pop(0) if i == shortest_i else bi.pop())\n        runners.append(runner)\n    assert all((not bi for bi in b))\n    return zip(*runners)\n\ndef main():\n    (t,) = readline()\n    for __ in range(t):\n        (n, m) = readline()\n        b = [sorted(readline()) for __ in range(n)]\n        ans = solve(n, m, b)\n        for row in ans:\n            print(*row)\nmain()", "t = int(input())\nfor _ in range(t):\n    (n, m) = [int(x) for x in input().split()]\n    ll = []\n    for i in range(n):\n        l = [int(x) for x in input().split()]\n        l.sort()\n        ll.append(l)\n    st = 0\n    ans = [0] * m\n    for i in range(n):\n        if i == 0:\n            print(*ll[i])\n            ans = ll[i]\n            for aa in range(m):\n                ans[aa] = [aa, ans[aa]]\n        else:\n            ans = sorted(ans, key=lambda x: x[1])\n            ans.reverse()\n            y = [0] * m\n            for aa in range(m):\n                y[ans[aa][0]] = ll[i][aa]\n            print(*y)\n            for aa in range(m):\n                ans[aa][1] = min(ans[aa][1], y[ans[aa][0]])", "from collections import Counter\nimport math\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, m) = list(map(int, input().split()))\n        b = []\n        for _ in range(n):\n            b.append(sorted(list(map(int, input().split()))))\n        all = [0] * n\n        maxi = 10000000000\n        mini = maxi\n        for i in range(0, m):\n            mini = maxi\n            for j in range(n):\n                if mini > b[j][all[j]]:\n                    mini = b[j][all[j]]\n                    temp = j\n            for k in range(m - i - 1):\n                b[temp][k] = b[temp][k + 1]\n            b[temp][m - i - 1] = mini\n        for i in range(n):\n            s = ''\n            for j in range(m):\n                s += str(b[i][j]) + ' '\n            print(s)\nmain()", "import math\n\ndef main():\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split(' '))\n        j = []\n        for _ in range(n):\n            b = list(map(int, input().split(' ')))\n            j.append(b)\n        print(get(n, m, j))\n\ndef get(n, m, b):\n    runners = []\n    for i in range(m):\n        res = []\n        (minimum, indexm) = minx(b)\n        temp = b[indexm]\n        temp.remove(minimum)\n        b[indexm] = temp\n        for (index, val) in enumerate(b):\n            if index == indexm:\n                res.append(minimum)\n            else:\n                res.append(max(val))\n                b = delet(b, max(val), index)\n        runners.append(res)\n    res = ''\n    for i in range(len(runners[0])):\n        for (iv, j) in enumerate(runners):\n            res += str(j[i])\n            if iv != len(runners) - 1:\n                res += ' '\n        res += '\\n'\n    return res.strip()\n\ndef delet(b, val, index):\n    temp = b[index]\n    temp.remove(val)\n    b[index] = temp\n    return b\n\ndef minx(a):\n    last = min(a[0])\n    index = 0\n    for (v, i) in enumerate(a):\n        if min(i) < last:\n            index = v\n            last = min(i)\n    return (last, index)\nmain()", "t = int(input())\nfor z in range(t):\n    (n, m) = map(int, input().split())\n    ans = []\n    fin = []\n    kk = []\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        ans.append([0] * m)\n        kk.append(arr)\n        for j in range(m):\n            fin.append([arr[j], j, i])\n    fin.sort()\n    index = 0\n    for i in range(m):\n        ans[fin[i][2]][i] = fin[i][0]\n    for i in range(m - 1, -1, -1):\n        kk[fin[i][2]][fin[i][1]] = 0\n    i = 0\n    while i < n:\n        p = 0\n        j = 0\n        while j < m:\n            if ans[i][j] == 0:\n                while kk[i][p] == 0:\n                    p = p + 1\n                ans[i][j] = kk[i][p]\n                p = p + 1\n            j = j + 1\n        i = i + 1\n    for ar in ans:\n        print(*ar)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, m) = R()\n    a = []\n    b = []\n    j = 0\n    while n:\n        n -= 1\n        a += zip(R(), [~n] * m)\n        b += ([0] * m,)\n    for (x, i) in sorted(a):\n        while b[i][j % m]:\n            j += 1\n        b[i][j % m] = x\n        j += 1\n    for r in b:\n        print(*r)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    a = []\n    for _ in range(n):\n        b = list(map(int, input().split()))\n        b.sort()\n        a.append(b)\n    ans = []\n    for i in range(m):\n        inside = []\n        for j in range(len(a)):\n            inside.append(a[j][0])\n        mini = min(inside)\n        miniIndex = inside.index(mini)\n        inside2 = []\n        for j in range(len(a)):\n            if j != miniIndex:\n                inside2.append(a[j][-1])\n                a[j].pop(-1)\n            else:\n                inside2.append(a[j][0])\n                a[j].pop(0)\n        ans.append(inside2)\n    i = 0\n    while i < n:\n        ans1 = ''\n        for j in range(len(ans)):\n            ans1 += str(ans[j][i]) + ' '\n        print(ans1)\n        i += 1", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    lst = []\n    for i in range(n):\n        l = list(map(int, input().split(' ')))\n        for j in l:\n            lst.append([j, i])\n    ans = [[0] * m for i in range(n)]\n    lst.sort()\n    for i in range(m):\n        ans[lst[i][1]][i] = lst[i][0]\n    temp = [[] for i in range(n)]\n    for i in range(m, m * n):\n        temp[lst[i][1]].append(lst[i][0])\n    for i in range(n):\n        for j in range(m):\n            if ans[i][j] == 0:\n                ans[i][j] = temp[i][-1]\n                temp[i].pop()\n    for k in ans:\n        print(*k)", "for case in range(int(input())):\n    (n, m) = (int(i) for i in input().split())\n    p = [sorted([int(i) for i in input().split()]) for j in range(n)]\n    pp = [[] for i in p]\n    for iii in range(m):\n        mn = min(range(n), key=lambda x: p[x][0])\n        for i in range(len(p)):\n            pp[i].append(p[i].pop(0) if i == mn else p[i].pop())\n    for t in pp:\n        print(*t)", "for t in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(0, n):\n        a = list(map(int, input().split()))\n        if i == 0:\n            a.sort()\n            l.append(a)\n        else:\n            a.sort()\n            l.append(a)\n    res = []\n    for j in range(0, m):\n        min1 = 1000000000\n        ind1 = -1\n        for i in range(0, n):\n            if l[i][0] < min1:\n                min1 = l[i][0]\n                ind1 = i\n        a = []\n        for i in range(0, n):\n            if ind1 == i:\n                a.append(l[i][0])\n                l[i].pop(0)\n            else:\n                a.append(l[i][-1])\n                l[i].pop()\n        res.append(a)\n    for i in range(0, n):\n        for j in range(0, m):\n            print(res[j][i], end=' ')\n        print()", "t = int(input())\nfor i in range(t):\n    line = input()\n    line = line.split(' ')\n    n = int(line[0])\n    m = int(line[1])\n    nums = []\n    answer = []\n    for k in range(n):\n        line = input()\n        line = line.split(' ')\n        answer.append(line)\n    index = 0\n    for k in range(n):\n        for j in range(m):\n            nums.append((int(answer[k][j]), k, j))\n    nums.sort(key=lambda tup: tup[0])\n    best_nums = nums[:m]\n    index = 0\n    for k in best_nums:\n        value = k[0]\n        row = k[1]\n        if int(value) == int(answer[row][index]):\n            index += 1\n            continue\n        temp = answer[row][index]\n        answer[row][index] = value\n        for j in range(1, m + 1):\n            if int(answer[row][(index + j) % m]) == value:\n                answer[row][(index + j) % m] = temp\n                break\n        index += 1\n    for k in range(n):\n        out = ''\n        for num in answer[k]:\n            out += str(num) + ' '\n        print(out[:-1])", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = []\n    for i in range(n):\n        a.append(sorted(map(int, input().split())))\n    v = [[] for i in range(n)]\n    for i in range(m):\n        k = 0\n        for j in range(1, n):\n            if a[j][0] < a[k][0]:\n                k = j\n        for j in range(n):\n            if k == j:\n                v[j].append(a[j][0])\n                a[j] = a[j][1:]\n            else:\n                v[j].append(a[j][-1])\n                a[j] = a[j][:-1]\n    for i in range(n):\n        print(' '.join(map(str, v[i])))", "cases = int(input())\nfor case in range(0, cases):\n    first_input = [int(x) for x in input().split(' ')]\n    n = first_input[0]\n    m = first_input[1]\n    b = []\n    flat_b = []\n    for i in range(0, n):\n        b.append([int(x) for x in input().split(' ')])\n        for x in b[i]:\n            flat_b.append(x)\n    flat_b = sorted(flat_b)\n    flat_b = flat_b[0:m]\n    not_finished = [i for i in range(0, m)]\n    finished = []\n    for i in range(0, n):\n        row_finished = []\n        for j in range(0, m):\n            num = b[i][j]\n            if j in row_finished:\n                continue\n            if i == 0:\n                if b[i][j] in flat_b:\n                    not_finished.remove(j)\n                    flat_b.remove(num)\n            else:\n                if b[i][j] in flat_b and j not in not_finished:\n                    for k in range(0, m):\n                        if k == j or b[i][k] in flat_b or k not in not_finished:\n                            continue\n                        (b[i][j], b[i][k]) = (b[i][k], b[i][j])\n                        not_finished.remove(k)\n                        flat_b.remove(num)\n                        row_finished.append(k)\n                        break\n                if b[i][j] in flat_b and j in not_finished:\n                    not_finished.remove(j)\n                    flat_b.remove(num)\n            if len(not_finished) == 0:\n                break\n        if len(not_finished) == 0:\n            break\n    for row in b:\n        print(*row)", "def ii():\n    return int(input())\n\ndef li():\n    return [int(i) for i in input().split()]\nfor t in range(ii()):\n    (n, m) = li()\n    b = []\n    for i in range(n):\n        temp = li()\n        temp.sort()\n        b.append(temp)\n    ans = [[-1 for j in range(m)] for i in range(n)]\n    for i in range(m):\n        index = -1\n        mini = 10000000000000\n        for j in range(n):\n            if b[j][0] < mini:\n                mini = b[j][0]\n                index = j\n        for j in range(n):\n            if j != index:\n                ans[j][i] = b[j][-1]\n                b[j].pop()\n            else:\n                ans[j][i] = b[j][0]\n                b[j].remove(b[j][0])\n    for i in ans:\n        print(*i)", "def print_list(l):\n    for k in l:\n        print(k, end=' ')\n    print('')\nT = int(input())\nfor t in range(T):\n    A = []\n    (n, m) = map(int, input().split())\n    for i in range(n):\n        A.append(list(map(int, input().split())))\n    A[0].sort()\n    ans = []\n    print_list(A[0])\n    for j in range(m):\n        ans.append((A[0][j], j))\n    ans.reverse()\n    for i in range(1, n):\n        A[i].sort()\n        temp = [-1] * m\n        for j in range(m):\n            ans[j] = (min(A[i][j], ans[j][0]), ans[j][1])\n            temp[ans[j][1]] = A[i][j]\n        print_list(temp)\n        ans.sort()\n        ans.reverse()", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    b = []\n    for i in range(n):\n        b.append(list(map(int, input().split())))\n    arr = []\n    for i in range(n):\n        for j in range(m):\n            arr.append((b[i][j], i))\n    arr.sort()\n    l = arr[:m]\n    r = arr[m:]\n    x = [[] for i in range(n)]\n    for i in r:\n        x[i[1]].append(i[0])\n    ans = [[] for i in range(n)]\n    while len(l):\n        p = l.pop()\n        for i in range(n):\n            if i != p[1]:\n                ans[i].append(x[i].pop())\n            else:\n                ans[i].append(p[0])\n    for i in range(n):\n        print(*ans[i])", "I = lambda : [*map(int, input().split())]\nfor _ in ' ' * I()[0]:\n    (n, b) = I()\n    l = [sorted(I()) for i in range(n)]\n    ans = [[] for i in range(n)]\n    for i in range(b):\n        m = int(2000000000.0)\n        x = -1\n        for j in range(n):\n            if m > l[j][0]:\n                m = l[j][0]\n                x = j\n        for j in range(n):\n            if x == j:\n                ans[j] += [l[j][0]]\n                l[j].pop(0)\n            else:\n                ans[j] += [l[j][-1]]\n                l[j].pop(-1)\n    for i in ans:\n        print(*i)", "t = int(input())\nfor hh in range(0, t):\n    (n, m) = [int(x) for x in input().split()]\n    li = []\n    mat = []\n    ans = []\n    for i in range(0, n):\n        a = [int(x) for x in input().split()]\n        a.sort()\n        mat.append(a)\n    while 1:\n        li = []\n        mn = 1000000000\n        for i in range(0, n):\n            if mat[i][0] < mn:\n                mn = mat[i][0]\n                mnidx = i\n        for i in range(0, n):\n            if i == mnidx:\n                li.append(mat[i][0])\n                mat[i].pop(0)\n            else:\n                li.append(mat[i][-1])\n                sz = len(mat[i])\n                mat[i].pop(sz - 1)\n        ans.append(li)\n        if len(mat[0]) == 0:\n            break\n    finalans = []\n    for i in range(0, len(ans[0])):\n        li = []\n        for j in range(0, len(ans)):\n            li.append(ans[j][i])\n        finalans.append(li)\n    for i in range(0, len(finalans)):\n        print(*finalans[i])", "def inputi():\n    return int(input())\n\ndef inputli():\n    return list(map(int, input().split(' ')))\n\ndef inputls():\n    return list(map(str, input().split(' ')))\n\ndef print_list(lista):\n    s = ''\n    for i in lista[:-1]:\n        s += str(i) + ' '\n    s += str(lista[-1])\n    return s\n\ndef solve():\n    [n, m] = inputli()\n    aux = []\n    ans = [[] for i in range(n)]\n    for i in range(n):\n        b = inputli()\n        b = sorted(b)\n        aux.append(b)\n    for i in range(m):\n        minis = [aux[j][0] for j in range(n)]\n        mini = min(minis)\n        idx = minis.index(mini)\n        ans[idx].append(mini)\n        aux[idx].pop(0)\n        for j in range(n):\n            if idx != j:\n                ans[j].append(aux[j].pop())\n    for i in range(n):\n        print(print_list(ans[i]))\n    return 0\nt = inputi()\nfor i in range(t):\n    solve()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, m) = R()\n    a = [[*R()] for _ in [0] * n]\n    b = []\n    r = [[0] * n for _ in [0] * m]\n    i = j = 0\n    for x in a:\n        b += zip(x, [i] * m)\n        i += 1\n    for (x, i) in sorted(b):\n        while r[j % m][i]:\n            j += 1\n        r[j % m][i] = x\n        j += 1\n    for x in zip(*r):\n        print(*x)", "t = int(input())\nfor t in range(t):\n    (p, q) = map(int, input().split())\n    lst = []\n    d = {}\n    for i in range(p):\n        lst1 = list(map(int, input().split()))\n        lst.append(lst1)\n        j = 0\n        while j < q:\n            if lst1[j] in d:\n                d[lst1[j]] += 1\n            else:\n                d[lst1[j]] = 1\n            j += 1\n    lst2 = []\n    for i in d:\n        q1 = d[i]\n        for j in range(q1):\n            lst2.append(i)\n    lst2.sort()\n    q1 = 0\n    lst3 = []\n    for i in range(q):\n        l = []\n        for l1 in lst:\n            if q1 != 0:\n                max1 = max(l1)\n                l1.remove(max1)\n                l.append(max1)\n            elif lst2[i] in l1:\n                l.append(lst2[i])\n                l1.remove(lst2[i])\n                q1 = 1\n            else:\n                max1 = max(l1)\n                l1.remove(max1)\n                l.append(max1)\n        q1 = 0\n        lst3.append(l)\n    for i in range(p):\n        for j in range(q):\n            print(lst3[j][i], end=' ')\n        print()", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, m) = R()\n    (a, b) = zip(*((R(), [0] * m) for _ in [0] * n))\n    c = []\n    i = j = 0\n    for x in a:\n        c += zip(x, [i] * m)\n        i += 1\n    for (x, i) in sorted(c):\n        while b[i][j % m]:\n            j += 1\n        b[i][j % m] = x\n        j += 1\n    for r in b:\n        print(*r)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    lst_lst = []\n    for _ in range(n):\n        lst_lst.append(sorted(map(int, input().split())))\n    ans = ['' for _ in range(n)]\n    for _ in range(m):\n        min_idx = min(range(len(lst_lst)), key=lambda x: lst_lst[x])\n        lst_lst[min_idx] = lst_lst[min_idx][1:] + [lst_lst[min_idx][0]]\n        for idx in range(n):\n            ans[idx] += str(lst_lst[idx].pop()) + ' '\n    print('\\n'.join(ans))", "import sys, os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        temp.sort()\n        l.append(temp)\n    for i in range(len(l)):\n        l[i].sort()\n    ans = [[] for i in range(n)]\n    for i in range(m):\n        temp = []\n        ind = 0\n        m1 = l[0][0]\n        for j in range(1, n):\n            if l[j][0] < m1:\n                ind = j\n            m1 = min(m1, l[j][0])\n        for j in range(n):\n            if j == ind:\n                temp.append(l[j][0])\n                l[j].pop(0)\n            else:\n                temp.append(l[j][-1])\n                l[j].pop(-1)\n        for k in range(len(temp)):\n            ans[k].append(temp[k])\n    for i in range(n):\n        print(*ans[i])", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().strip().split(' '))\n    l = []\n    l1 = []\n    for j in range(n):\n        lst = list(map(int, input().strip().split(' ')))\n        l.append(lst)\n        l1 = l1 + lst\n    l1.sort()\n    m1 = 0\n    t1 = 0\n    for j in range(n):\n        l[j].sort()\n        if m1 == m or l[j][0] > l1[m - 1]:\n            for j1 in range(m):\n                print(l[j][j1], end=' ')\n            print()\n        else:\n            t1 = m1\n            k1 = []\n            for j1 in range(m):\n                if m1 < m and l[j][j1] <= l1[m - 1 - m1]:\n                    ind = l1.index(l[j][j1])\n                    del l1[ind]\n                    m1 += 1\n                else:\n                    k1.append(l[j][j1])\n            for j1 in range(t1):\n                print(k1[j1], end=' ')\n            for j1 in range(t1, m1):\n                print(l[j][j1 - t1], end=' ')\n            for j1 in range(m1, m):\n                print(l[j][j1], end=' ')\n            print()", "def solve():\n    (n, m) = (int(x) for x in input().split())\n    b = [sorted([int(x) for x in input().split()]) for _ in range(n)]\n    ans = [[] for _ in range(n)]\n    for i in range(m):\n        mn = min(range(n), key=lambda x: b[x][0])\n        for j in range(len(b)):\n            if j == mn:\n                ans[j].append(b[j].pop(0))\n            else:\n                ans[j].append(b[j].pop())\n    for row in ans:\n        for col in row:\n            print(col, end=' ')\n        print()\nfor _ in range(int(input())):\n    solve()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    seq_in = []\n    seq_out = []\n    ss = []\n    for i in range(n):\n        s = list(map(int, input().split()))\n        seq_in.append(s)\n        seq_out.append([0] * len(s))\n        ss.extend(s)\n    ss.sort()\n    for i in range(m):\n        p = ss.pop(0)\n        for j in range(n):\n            if p in seq_in[j]:\n                seq_in[j].remove(p)\n                seq_out[j][i] = p\n                break\n    for j in range(n):\n        for i in range(m):\n            if seq_out[j][i] == 0:\n                seq_out[j][i] = seq_in[j].pop()\n    for line in seq_out:\n        print(' '.join(map(str, line)))", "import sys\nimport math\nimport bisect\nimport functools\nfrom functools import lru_cache\nfrom sys import stdin, stdout\nfrom math import gcd, floor, sqrt, log, ceil\nfrom heapq import heappush, heappop, heapify\nfrom collections import defaultdict as dd\nfrom collections import Counter as cc\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\nsys.setrecursionlimit(100000000)\nintinp = lambda : int(input().strip())\nstripinp = lambda : input().strip()\nfltarr = lambda : list(map(float, input().strip().split()))\nintarr = lambda : list(map(int, input().strip().split()))\nceildiv = lambda x, d: x // d if x % d == 0 else x // d + 1\nMOD = 1000000007\nnum_cases = intinp()\nfor _ in range(num_cases):\n    (n, m) = intarr()\n    arr = []\n    h = [[0, -math.inf, []] for _ in range(m)]\n    for _ in range(n):\n        for v in sorted(intarr()):\n            (ind, val, path) = heappop(h)\n            heappush(h, [ind + 1, -min(-val, v), path + [v]])\n    for j in range(n):\n        for i in range(m):\n            print(h[i][2][j], end=' ')\n        print()", "T = int(input())\nfor _ in range(T):\n    (n, m) = [int(x) for x in input().split()]\n    b = []\n    for i in range(n):\n        b.append([int(x) for x in input().split()])\n    a = sorted(b[0][:])\n    tired = [(j, a[j], [a[j]]) for j in range(m)]\n    tired.sort(key=lambda x: (-x[1], x[0]))\n    for i in range(1, n):\n        a = sorted(b[i][:])\n        tired = [(t[0], min(t[1], a[j]), t[2] + [a[j]]) for (j, t) in enumerate(tired)]\n        tired.sort(key=lambda x: (-x[1], x[0]))\n    tired.sort()\n    result = list(zip(*list(zip(*tired))[2]))\n    for row in result:\n        print(*row)", "tc = int(input())\nfor _ in range(tc):\n    (n, m) = map(int, input().split())\n    l = []\n    x = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n        for j in range(m):\n            x.append((l[-1][j], i, j))\n    x.sort()\n    mat = [[0] * m for _ in range(n)]\n    for (a, b, c) in x[:m]:\n        mat[b][c] = 1\n    copy = []\n    curr = 0\n    for i in range(n):\n        y = []\n        hold = []\n        for j in range(m):\n            if mat[i][j]:\n                hold.append(l[i][j])\n            else:\n                y.append(l[i][j])\n        for z in hold:\n            y.insert(curr, z)\n            curr += 1\n        copy.append(y)\n    for i in copy:\n        print(*i)", "T = int(input())\nfor case in range(T):\n    (n, m) = map(int, input().split())\n    stacks = [sorted(map(int, input().split())) for i in range(n)]\n    paths = []\n    for i in range(m):\n        minis = []\n        for i in range(n):\n            minis.append(stacks[i][0])\n        i_mini = minis.index(min(minis))\n        path = [0] * n\n        path[i_mini] = stacks[i_mini].pop(0)\n        for j in range(n):\n            if j != i_mini:\n                path[j] = stacks[j].pop()\n        paths.append(path)\n    for i in range(n):\n        p = [paths[j][i] for j in range(m)]\n        print(*p)", "import sys\nfrom heapq import heapify, heappop, heappush\nfrom itertools import *\nfrom collections import *\nfrom math import *\nsys.setrecursionlimit(10 ** 6)\n\ndef power_with_mod(x, y):\n    res = 1\n    while y:\n        if y % 2 == 0:\n            x = x * x % mod\n            y = y // 2\n        else:\n            res = res * x % mod\n            y -= 1\n    return res % mod\nTT = int(input())\nfor y in range(TT):\n    (n, m) = map(int, input().split())\n    lst = []\n    ans = []\n    fnl = []\n    vis = []\n    for i in range(n):\n        lst.append(list(map(int, input().split())))\n        fnl.append([0] * m)\n        vis.append([0] * m)\n        for j in range(m):\n            ans.append([lst[i][j], i, j])\n    ans.sort()\n    for i in range(m):\n        vis[ans[i][1]][ans[i][2]] = 1\n        fnl[ans[i][1]][i] = ans[i][0]\n    for i in range(n):\n        k = 0\n        for j in range(m):\n            if vis[i][j] == 0:\n                while k < m and fnl[i][k] != 0:\n                    k += 1\n                fnl[i][k] = lst[i][j]\n    for i in fnl:\n        print(*i)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    s = []\n    s1 = [[0 for i in range(m)] for j in range(n)]\n    max_num = 10000000001\n    y = 0\n    ans = 0\n    for i in range(n):\n        a = [int(i) for i in input().split()]\n        a.sort()\n        s.append(a)\n    for i in range(m):\n        x = s[0][0]\n        y = 0\n        for j in range(1, n):\n            if s[j][0] < x:\n                s1[y][i] = s[y][-1]\n                s[y].pop(-1)\n                x = s[j][0]\n                y = j\n            else:\n                s1[j][i] = s[j][-1]\n                s[j].pop(m - i - 1)\n        s1[y][i] = x\n        s[y].pop(0)\n    for i in range(n):\n        for j in range(m):\n            print(s1[i][j], end=' ')\n        print()", "def helper(a, m):\n    pool = sum(a, [])\n    pool.sort()\n    tar = pool[:m]\n    used = [0] * m\n    res = [[0] * m for j in range(len(a))]\n    for i in range(len(a)):\n        a[i].sort()\n        for j in range(m):\n            if used[j] == 0 and a[i][0] == tar[j]:\n                res[i][j] = a[i].pop(0)\n                used[j] = 1\n            else:\n                res[i][j] = a[i].pop()\n    return res\nt = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split(' '))\n    b = [[] for j in range(n)]\n    for j in range(n):\n        b[j] = list(map(int, input().split(' ')))\n    res = helper(b, m)\n    for j in range(n):\n        print(' '.join(map(str, res[j])))", "import sys\nimport heapq\n\ndef main(n, m, P):\n    ans = [[-1 for j in range(m)] for i in range(n)]\n    for p in P:\n        heapq.heapify(p)\n    P = [[P, i] for (i, P) in enumerate(P)]\n    heapq.heapify(P)\n    for j in range(m):\n        ans[P[0][1]][j] = heapq.heappop(P[0][0])\n        heapq.heapify(P)\n    P.sort(key=lambda x: x[1])\n    for i in range(n):\n        for j in range(m):\n            if ans[i][j] == -1:\n                ans[i][j] = P[i][0].pop()\n    return [[str(y) for y in x] for x in ans]\nn_test = int(input())\nfor i in range(n_test):\n    (n, m) = [int(x) for x in input().split(' ')]\n    P = []\n    for j in range(n):\n        P.append([int(x) for x in input().split(' ')])\n    res = main(n, m, P)\n    for tmp in res:\n        print(' '.join(tmp))", "for t in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    l = []\n    for i in range(n):\n        l.append(sorted([int(x) for x in input().split()]))\n    sol = []\n    for j in range(m):\n        x = 10 ** 9\n        ind = -1\n        for i in range(n):\n            if x > l[i][0]:\n                x = l[i][0]\n                ind = i\n        sol.append([])\n        for i in range(n):\n            if i != ind:\n                sol[j].append(l[i].pop())\n            else:\n                sol[j].append(l[i].pop(0))\n    for i in range(n):\n        for j in range(m):\n            print(sol[j][i], end=' ')\n        print('')", "for testcase in range(int(input())):\n    arr = [int(x) for x in input().split()]\n    (n, mind) = (arr[0], arr[1])\n    arr = []\n    for i in range(n):\n        li = [int(x) for x in input().split()]\n        li.sort()\n        arr.append(li)\n    ans = [[-1 for j in range(mind)] for i in range(n)]\n    s = set()\n    for j in range(mind):\n        if j in s:\n            continue\n        else:\n            m = float('inf')\n            for k in range(n):\n                ele = arr[k]\n                m1 = ele[0]\n                if m1 < m:\n                    m = m1\n                    ind = k\n            ans[ind][j] = m\n            arr[ind].remove(m)\n            s.add(j)\n    for j in range(mind):\n        for i in range(n):\n            if ans[i][j] == -1:\n                ans[i][j] = arr[i][-1]\n                arr[i] = arr[i][:-1]\n    for ele in ans:\n        print(*ele)", "import sys\nsys.setrecursionlimit(10000)\nfrom collections import defaultdict\nfrom heapq import heappush\nfrom heapq import heappop\nfrom math import ceil\n\ndef solve():\n    (n, m) = map(int, input().split())\n    d = {}\n    for i in range(m):\n        d[i] = []\n    heap1 = []\n    heap2 = []\n    for i in range(m):\n        heappush(heap2, (-float('inf'), i))\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        for i in arr:\n            heappush(heap1, i)\n        ans = []\n        for i in range(m):\n            a = heappop(heap1)\n            (b, c) = heappop(heap2)\n            d[c].append(a)\n            ans.append([max(-a, b), c])\n        for i in range(m):\n            heappush(heap2, (ans[i][0], ans[i][1]))\n    ans = []\n    for j in range(n):\n        ans = ''\n        for i in range(m):\n            ans += str(d[i][j])\n            ans += ' '\n        print(ans)\nfor i in range(int(input())):\n    solve()", "from heapq import heappush, heappop, heapify\nfrom collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    mat = []\n    for i in range(n):\n        v = list(map(int, input().split()))\n        mat.append(v)\n    hp = []\n    for i in range(n):\n        for j in range(m):\n            hp.append((mat[i][j], i, j))\n    heapify(hp)\n    vis = [False for i in range(m)]\n    idx = 0\n    dq = deque()\n    for i in range(m):\n        ele = heappop(hp)\n        if vis[ele[2]] == False:\n            vis[ele[2]] = True\n        else:\n            dq.append(ele)\n    l = len(dq)\n    for i in range(l):\n        ele = dq.popleft()\n        if vis[ele[2]] == False:\n            vis[ele[2]] = True\n        else:\n            while idx < m and vis[idx]:\n                idx += 1\n            val = ele[0]\n            x = ele[1]\n            y = ele[2]\n            temp = mat[x][idx]\n            mat[x][idx] = val\n            mat[x][y] = temp\n            vis[idx] = True\n            idx += 1\n    for i in range(n):\n        for j in range(m):\n            print(mat[i][j], end=' ')\n        print()", "import bisect\nt = int(input())\n\ndef solution(arr, n, m):\n    result = []\n    min_indexes = []\n    for i in range(n):\n        arr[i].sort()\n        bisect.insort(min_indexes, [arr[i][0], i])\n        result.append([])\n    while len(arr[0]) != 0:\n        min_i = min_indexes[0][1]\n        for i in range(n):\n            if i == min_i:\n                result[i].append(arr[i][0])\n                arr[i] = arr[i][1:]\n            else:\n                result[i].append(arr[i][-1])\n                arr[i] = arr[i][:-1]\n        min_indexes = min_indexes[1:]\n        if len(arr[0]) != 0:\n            bisect.insort(min_indexes, [arr[min_i][0], min_i])\n    return result\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().split(' ')]\n    arr = []\n    for i in range(n):\n        arr.append([int(a) for a in input().split(' ')])\n    res = solution(arr, n, m)\n    for line in res:\n        print(' '.join([str(i) for i in line]))", "for ii in range(int(input())):\n    (n, m) = map(int, input().split())\n    (a, z, d) = ([], [0] * n, [])\n    for jj in range(n):\n        d.append([0] * m)\n    e = d[:]\n    for jj in range(n):\n        h = sorted(list(map(int, input().split())))\n        a.append(h)\n    for jj in range(m):\n        (r, f) = (0, 10 ** 9)\n        for kk in range(n):\n            if m > z[kk]:\n                if f > a[kk][z[kk]]:\n                    r = kk\n                    f = a[kk][z[kk]]\n        e[r][jj] = 1\n        d[r][jj] = a[r][z[r]]\n        z[r] = 1 + z[r]\n    for jj in range(n):\n        for kk in range(m):\n            if not e[jj][kk]:\n                d[jj][kk] = a[jj][z[jj]]\n                z[jj] = 1 + z[jj]\n        print(*d[jj])", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    b = []\n    caminos = []\n    for i in range(n):\n        b.append(list(map(int, input().split())))\n        caminos.extend(b[i])\n    resp = [[0] * m for _ in range(n)]\n    caminos.sort()\n    for i in b:\n        i.sort()\n    for j in range(m):\n        mejor = caminos[0]\n        band = False\n        for i in range(n):\n            if b[i][0] == mejor and (not band):\n                caminos.pop(0)\n                b[i].pop(0)\n                band = True\n                resp[i][j] = mejor\n            else:\n                peor = b[i][-1]\n                caminos.pop(-1)\n                b[i].pop(-1)\n                resp[i][j] = peor\n    for i in range(n):\n        for j in range(m):\n            print(resp[i][j], end=' ')\n        print()", "from collections import defaultdict, Counter\nfrom math import log10\nfor i in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = [[-1 for j in range(m)] for k in range(n)]\n    final = []\n    for j in range(n):\n        b = list(map(int, input().split()))\n        for k in range(m):\n            final.append((b[k], j))\n    final.sort()\n    pos = 0\n    for j in range(m):\n        ans[final[j][1]][pos] = final[j][0]\n        pos += 1\n    pos = m\n    for k in range(m, len(final)):\n        row = final[k][1]\n        for col in range(0, m):\n            if ans[row][col] == -1:\n                ans[row][col] = final[k][0]\n                break\n    for j in ans:\n        print(*j)", "def fun(ls, n, m):\n    ans = ls\n    show = [[] for _ in range(n)]\n    count = m\n    while count > 0:\n        mn = 10 ** 10\n        mn_index = -1\n        for i in range(n):\n            for j in range(count):\n                if mn > ans[i][j]:\n                    mn = ans[i][j]\n                    mn_index = [i, j]\n        for i in range(n):\n            if i != mn_index[0]:\n                mx = -1\n                mx_index = -1\n                for j in range(count):\n                    if mx < ans[i][j]:\n                        mx = ans[i][j]\n                        mx_index = [i, j]\n                ans[i].pop(mx_index[1])\n                show[i].append(mx)\n            else:\n                ans[mn_index[0]].pop(mn_index[1])\n                show[mn_index[0]].append(mn)\n        count -= 1\n    for i in show:\n        print(*i)\nT = int(input())\nfor i in range(T):\n    (n, m) = list(map(int, input().split()))\n    ls = []\n    for i in range(n):\n        ks = list(map(int, input().split()))\n        ls.append(ks)\n    fun(ls, n, m)", "R = lambda : map(int, input().split())\n(t,) = R()\nwhile t:\n    t -= 1\n    (n, m) = R()\n    a = []\n    b = [m * [0] for _ in [0] * n]\n    i = j = 0\n    while i < n:\n        a += zip(R(), [i] * m)\n        i += 1\n    for (x, i) in sorted(a):\n        while b[i][j % m]:\n            j += 1\n        b[i][j % m] = x\n        j += 1\n    for r in b:\n        print(*r)", "import heapq\nt = int(input())\n\ndef print_list(l):\n    for element in l[:-1]:\n        print(element, end=' ')\n    print(l[len(l) - 1])\nfor _ in range(t):\n    (n, m) = list(map(int, input().split()))\n    b = []\n    b_copy = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        b.append(l)\n        b_copy.append(l.copy())\n    heap = b_copy[0]\n    heapq.heapify(heap)\n    for row in b_copy[1:]:\n        for ele in row:\n            heapq.heappush(heap, ele)\n    smallest = dict()\n    for i in range(m):\n        x = heapq.heappop(heap)\n        if x in smallest.keys():\n            smallest[x] += 1\n        else:\n            smallest.setdefault(x, 1)\n    del b_copy\n    index = 0\n    for i in range(len(b)):\n        small = []\n        large = []\n        for element in b[i]:\n            if element in smallest.keys() and smallest[element] > 0:\n                small.append(element)\n                smallest[element] -= 1\n            else:\n                large.append(element)\n        b[i] = large[:index] + small + large[index:]\n        index += len(small)\n    for row in b:\n        print_list(row)", "T = int(input())\nfor t in range(T):\n    (n, m) = map(int, input().split())\n    g = []\n    a = []\n    z = []\n    for i in range(n):\n        l = list(map(int, input().split()))\n        a.append(l)\n        z = z + l\n    li = []\n    for i in range(len(z)):\n        li.append([z[i], i])\n    li.sort()\n    sort_index = []\n    for x in li:\n        sort_index.append(x[1])\n    for i in range(m):\n        g.append(sort_index[i] // m)\n    c = 0\n    q = []\n    for i in range(n):\n        if g.count(i) != 0:\n            q = a[i].copy()\n            q.sort()\n            answer = q[len(q) - c:] + q[:len(q) - c]\n            print(*answer, sep=' ')\n            c = c + g.count(i)\n        else:\n            print(*a[i], sep=' ')", "for test in range(int(input())):\n    (n, m) = map(int, input().split())\n    (lst, arr) = ([[0] for i in range(n)], [])\n    for i in range(n):\n        temp = sorted(map(int, input().split()))\n        arr.extend(temp)\n        arr = sorted(arr)[:m]\n        lst[i] = temp.copy()\n    ind = 0\n    for i in range(n):\n        if arr:\n            temp = []\n            for j in range(m):\n                if lst[i][j] in arr:\n                    temp.append(lst[i][j])\n                    arr.remove(lst[i][j])\n            for j in temp:\n                lst[i].remove(j)\n            for j in temp:\n                lst[i].insert(ind, j)\n                ind += 1\n    for i in lst:\n        print(*i)", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    arr = []\n    mat = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        arr += list(zip(temp, [i] * m))\n        mat.append(temp)\n    arr.sort()\n    tempArr = arr[:m]\n    newArr = [[] for i in range(n)]\n    for i in range(m):\n        newArr[tempArr[i][1]].append(tempArr[i][0])\n    mark = 0\n    for i in range(n):\n        row = sorted(mat[i])\n        l = len(newArr[i])\n        result = row[-mark:] + row[:-mark]\n        print(*result)\n        mark += l", "import math\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    b = []\n    for _ in range(n):\n        a = list(map(int, input().split()))\n        b.append(a)\n    l = []\n    for i in range(n):\n        for j in range(m):\n            l.append([b[i][j], i, j])\n    l.sort()\n    c = l[m:]\n    s = [[-1] * m for _ in range(n)]\n    for i in range(m):\n        s[l[i][1]][i] = l[i][0]\n    for x in c:\n        g = s[x[1]].index(-1)\n        s[x[1]][g] = x[0]\n    for x in s:\n        print(*(i for i in x))", "import heapq\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    paths = []\n    for i in range(N):\n        row = list(map(int, input().split()))\n        for j in range(M):\n            paths.append((row[j], i, j))\n    paths.sort()\n    assign = []\n    for _ in range(N):\n        assign.append([-1 for _ in range(M)])\n    person = 0\n    for (value, i, j) in paths:\n        prev = person\n        while assign[i][person] != -1:\n            person += 1\n            person %= M\n        assign[i][person] = value\n        person = (prev + 1) % M\n    for i in range(N):\n        for j in range(M):\n            print(assign[i][j], end=' ')\n        print()", "try:\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        final = []\n        for i in range(n):\n            t = []\n            for j in range(m):\n                t.append(0)\n            final.append(t)\n        main = []\n        for i in range(n):\n            arr = list(map(int, input().split()))\n            if i == 0:\n                final[0] = arr\n                main = arr.copy()\n            else:\n                temp_main = []\n                for j in range(m):\n                    temp_main.append([main[j], j])\n                temp_main = sorted(temp_main, key=lambda x: (x[0], x[1]))\n                temp_main.reverse()\n                arr.sort()\n                for j in range(m):\n                    final[i][temp_main[j][1]] = arr[j]\n                for j in range(m):\n                    main[temp_main[j][1]] = min(main[temp_main[j][1]], arr[j])\n        for i in final:\n            print(*i)\nexcept EOFError:\n    print(' ')", "from pprint import pprint\n\ndef p(rows):\n    for row in rows:\n        for col in row:\n            print(col, end=' ')\n        print()\n\ndef main():\n    T = int(input())\n    for t in range(T):\n        (n, m) = [int(v) for v in input().split()]\n        rows = [[int(v) for v in input().split()] for i in range(n)]\n        triples = []\n        for i in range(n):\n            for j in range(m):\n                triples.append((rows[i][j], i, j))\n        triples = sorted(triples, key=lambda x: x[0])\n        remains = [list() for _ in range(n)]\n        for i in range(n):\n            remains[i].extend(rows[i])\n        for i in range(n):\n            for j in range(m):\n                rows[i][j] = -1\n        for r in range(m):\n            (v, i, j) = triples[r]\n            rows[i][r] = v\n            remains[i].remove(v)\n        for i in range(n):\n            for j in range(m):\n                if rows[i][j] == -1:\n                    rows[i][j] = remains[i].pop()\n        p(rows)\nmain()", "for t in range(int(input())):\n    (n, m) = map(int, input().split())\n    paths = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        for j in range(m):\n            paths.append([row[j], i, j])\n    paths.sort()\n    order = []\n    for i in range(n):\n        order.append([-1 for i in range(m)])\n    person = 0\n    for (val, i, j) in paths:\n        prev = person\n        while order[i][person] != -1:\n            person += 1\n            person %= m\n        order[i][person] = val\n        person = (prev + 1) % m\n    for i in range(n):\n        for j in range(m):\n            print(order[i][j], end=' ')\n        print()", "tests = int(input())\nfor case in range(tests):\n    (n, m) = (int(i) for i in input().split())\n    p = [sorted([int(i) for i in input().split()]) for j in range(n)]\n    pp = [[] for i in p]\n    for iii in range(m):\n        mn = min(range(n), key=lambda x: p[x][0])\n        for i in range(len(p)):\n            if i == mn:\n                pp[i].append(p[i].pop(0))\n            else:\n                pp[i].append(p[i].pop())\n    for t in pp:\n        for i in t:\n            print(i, end=' ')\n        print()", "for _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    G = [list(sorted(map(int, input().split()))) for i in range(n)]\n    mins = [[10 ** 9, i] for i in range(m)]\n    for i in range(n):\n        o = list(sorted(mins, reverse=True))\n        ans = [0] * m\n        for j in range(m):\n            mins[o[j][1]][0] = min(o[j][0], G[i][j])\n            ans[o[j][1]] = G[i][j]\n        print(*ans)", "def mapit():\n    temp = list(map(int, input().split()))\n    return temp\n\ndef solution():\n    (n, m) = mapit()\n    paths = []\n    main = []\n    for i in range(n):\n        temp = mapit()\n        main += temp\n        paths.append(temp)\n    main.sort(reverse=True)\n    ele = {}\n    for i in main[-m:]:\n        if i not in ele:\n            ele[i] = 1\n        else:\n            ele[i] += 1\n    cols = [i for i in range(m - 1, -1, -1)]\n    for i in range(n):\n        curr = []\n        notused = []\n        for j in range(m):\n            if cols != [] and paths[i][j] in ele and ele[paths[i][j]]:\n                curr.append(paths[i][j])\n                ele[paths[i][j]] -= 1\n            else:\n                notused.append(paths[i][j])\n        eleidx = set()\n        while curr:\n            col = cols.pop()\n            eleidx.add(col)\n            paths[i][col] = curr.pop()\n        for j in range(m):\n            if j not in eleidx:\n                paths[i][j] = notused.pop()\n    for i in range(n):\n        print(*paths[i])\n    return\nt = int(input())\nwhile t:\n    t -= 1\n    solution()"]