["N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    n = N * a[i]\n    a[i * i:n:i] = [0] * -(-n // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "a = [1] * 8 ** 5\ni = 2\nwhile (b := ([0] * -(-8 ** 5 // i + i))):\n    a[i * i::i] = b\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "a = [1] * 8 ** 5\ni = 2\nwhile (b := ([0] * -(-8 ** 5 // i + i))):\n    a[i * i::i] = b\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "a = [1] * 8 ** 5\ni = 2\nwhile (b := ([0] * -(-8 ** 5 // i + i))):\n    a[i * i::i] = b\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while (j < N) * a[i]:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i:N:i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "from sys import stdin\nfrom itertools import repeat\n\ndef prime():\n    arr = list(repeat(True, 50000))\n    for i in range(2, int(50000 ** 0.5) + 1):\n        if arr[i]:\n            for j in range(i + i, 50000, i):\n                arr[j] = False\n    (arr[0], arr[1]) = (False, False)\n    return arr\n\ndef main():\n    (isprime, out) = (prime(), list())\n    inp = iter(stdin.read().split())\n    for t in range(int(next(inp))):\n        d = int(next(inp))\n        for a in range(d + 1, 50000):\n            if isprime[a]:\n                break\n        for b in range(a + d, 50000):\n            if isprime[b]:\n                break\n        out.append(a * b)\n    print(*out, sep='\\n')\nmain()", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 0\nN = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while (j < N) * a[i]:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while (j < N) * a[i]:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "resheto = [True for i in range(10000 * 3 + 2)]\nresheto[0] = False\nresheto[1] = False\nfor i in range(4, len(resheto), 2):\n    resheto[i] = False\nfor i in range(3, int(len(resheto) ** (1 / 2)) + 1, 2):\n    if resheto[i]:\n        for j in range(i ** 2, len(resheto), i):\n            resheto[j] = False\nfor i in range(int(input())):\n    d = int(input())\n    temp = 1\n    for j in range(d + temp, len(resheto)):\n        if resheto[j]:\n            temp = j\n            break\n    for j in range(d + temp, len(resheto)):\n        if resheto[j]:\n            print(j * temp)\n            break", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while (j < N) * a[i]:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    while (j < N) * a[i]:\n        a[j] = 0\n        j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    n = N * a[i]\n    a[i * i:n:i] = [0] * -(-n // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 3\nN = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "a = [1] * 8 ** 5\ni = 2\nwhile (b := ([0] * -(-8 ** 5 // i + i))):\n    a[i * i::i] = b\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "N = 2 ** 15\nis_prime = [1] * N\ni = 2\nwhile i * i < N:\n    is_prime[i * i:N:i] = [0] * -(-N // i + i)\n    i += 1\nfor _ in range(int(input())):\n    d = int(input())\n    i = is_prime.index(1, d + 1)\n    j = is_prime.index(1, i + d)\n    print(i * j)", "def main():\n    n = 30000\n    is_prime = [1] * n\n    for i in range(2, n):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = 0\n    for _ in range(int(input())):\n        d = int(input())\n        p = is_prime.index(1, d + 1)\n        q = is_prime.index(1, p + d)\n        print(p * q)\nmain()", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while (j < N) * a[i]:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "import bisect\nt = int(input())\np = [1] * 30001\np[0] = p[1] = 0\nfor i in range(2, 30001):\n    if p[i]:\n        for j in range(i + i, 30001, i):\n            p[j] = 0\np = [i for (i, v) in enumerate(p) if v]\nfor _ in range(t):\n    n = int(input())\n    f = 1 + n\n    f = p[bisect.bisect_left(p, f)]\n    s = f + n\n    s = p[bisect.bisect_left(p, s)]\n    print(f * s)", "I = input\nN = 8 ** 5\na = [1] * N\ni = 2\nwhile (j := (i * i)) < N:\n    if a[i]:\n        a[j::i] = [0] * ((N - j - 1) // i + 1)\n    i += 1\nfor _ in range(int(I())):\n    d = int(I())\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "def sieve(n):\n    sieve = [True] * n\n    i = 2\n    while i * i < n:\n        sieve[i * i::i] = [False] * -(-n // i + i)\n        i += 1\n    return [i for i in range(2, n) if sieve[i]]\nL = sieve(8 ** 5)\nfor i in range(int(input())):\n    from bisect import bisect_left\n    n = int(input())\n    i = bisect_left(L, n + 1)\n    j = bisect_left(L, n + L[i])\n    print(L[i] * L[j])", "import bisect\nprimes = []\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    c = 0\n    for p in range(2, n):\n        if prime[p]:\n            primes.append(p)\n            c += 1\n    return c\nc = SieveOfEratosthenes(50000)\nfor _ in range(int(input())):\n    d = int(input())\n    sum = 1\n    ind = 0\n    t2 = 1\n    i1 = bisect.bisect_left(primes, d + 1)\n    sum = primes[i1]\n    i2 = bisect.bisect_left(primes, sum + d)\n    t2 = primes[i2]\n    print(sum * t2)", "N = 89\nN = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    a[i * i::i] = [0] * -(-N // i + i)\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "def Sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    return prime\nprime = Sieve(100000)\nfor _ in range(int(input())):\n    n = int(input())\n    a = n + 1\n    for i in range(a, len(prime)):\n        if prime[i]:\n            p = i\n            break\n    for i in range(p + n, len(prime)):\n        if prime[i]:\n            q = i\n            break\n    print(p * q)", "N = 20020\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while j < N:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "def doit():\n    d = int(input())\n    p1 = a.index(True, d + 1)\n    p2 = a.index(True, p1 + d)\n    ans = min(p1 * p1 * p1, p1 * p2)\n    print(ans)\na = [True] * 30010\na[0] = False\na[1] = False\nfor i in range(2, 30001):\n    if a[i]:\n        for j in range(i * 2, 30001, i):\n            a[j] = False\nT = int(input())\nfor _ in range(T):\n    doit()", "import sys\n\ndef minp():\n    return sys.stdin.readline().strip()\n\ndef mint():\n    return int(minp())\n\ndef mints():\n    return map(int, minp().split())\n\ndef solve():\n    MAXN = int(100000.0)\n    primes = [True] * MAXN\n    for i in range(2, MAXN):\n        if i * i >= MAXN:\n            break\n        if primes[i]:\n            for j in range(i * i, MAXN, i):\n                primes[j] = False\n    primes[0] = False\n    primes[1] = False\n    for i in range(mint()):\n        d = mint()\n        for x in range(1 + d, MAXN):\n            if primes[x]:\n                break\n        for y in range(x + d, MAXN):\n            if primes[y]:\n                break\n        print(x * y)\nsolve()", "def psieve(n):\n    result = [True] * (n + 1)\n    for k in range(2, n + 1):\n        if result[k]:\n            result[2 * k::k] = [False] * (n // k - 1)\n    result[0] = False\n    result[1] = False\n    return result\nPrimes = psieve(21000)\nt = int(input().strip())\nfor _ in range(t):\n    d = int(input().strip())\n    r = 1\n    P = 1 + d\n    while not Primes[P]:\n        P += 1\n    r *= P\n    P += d\n    while not Primes[P]:\n        P += 1\n    print(r * P)", "rn = lambda : int(input())\nrl = lambda : list(map(int, input().split()))\nrns = lambda : map(int, input().split())\nrs = lambda : input()\nyn = lambda x: print('Yes') if x else print('No')\nYN = lambda x: print('YES') if x else print('NO')\nsieve = 20012 * [0]\nprimes = []\nfor i in range(2, len(sieve)):\n    if sieve[i] == 0:\n        primes.append(i)\n        for j in range(i, len(sieve), i):\n            sieve[j] = 1\nfor _ in range(rn()):\n    d = rn()\n    from bisect import bisect_left\n    a = primes[bisect_left(primes, 1 + d)]\n    b = primes[bisect_left(primes, a + d)]\n    print(a * b)", "def fun():\n    prime = [True for i in range(30000)]\n    p = 2\n    while p * p <= 30000:\n        if prime[p] == True:\n            for i in range(p * p, 30000, p):\n                prime[i] = False\n        p += 1\n    for _ in range(int(input())):\n        d = int(input())\n        c = -1\n        for i in range(1 + d, 30000):\n            if prime[i]:\n                c = i\n                break\n        e = -1\n        for i in range(c + d, 30000):\n            if prime[i]:\n                e = i\n                break\n        print(c * e)\nfun()", "import sys\ninput = sys.stdin.readline\n\ndef iin():\n    return int(input())\n\ndef sin():\n    return input().strip()\n\ndef nin():\n    return map(int, sin().split())\n\ndef lin():\n    return list(map(int, sin().split()))\n\ndef p(x):\n    print(x)\n\ndef pl(l):\n    for i in l:\n        print(i, end=' ')\n\ndef pnl(l):\n    pl(l)\n    print()\n\ndef pyn(x):\n    if x:\n        print('YES')\n    else:\n        print('NO')\nl = [0] * 21001\nfor i in range(2, 21001):\n    if l[i] == 0:\n        l[i] = 1\n        j = 2\n        while i * j <= 21000:\n            l[i * j] = 2\n            j += 1\nte = 1\nte = iin()\nwhile te > 0:\n    d = iin()\n    a = 1\n    f = 0\n    i = d + 1\n    while f != 2:\n        if l[i] == 1:\n            a *= i\n            f += 1\n            i += d\n            if f == 2:\n                break\n        else:\n            i += 1\n    print(a)\n    te -= 1", "(n, p) = (21000, 2)\nprime = [True for i in range(n + 1)]\n(prime[0], prime[1]) = (False, False)\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * p, n + 1, p):\n            prime[i] = False\n    p += 1\nfor _ in range(int(input())):\n    d = int(input())\n    (a, b) = (0, 0)\n    for i in range(d + 1, n):\n        if prime[i]:\n            a = i\n            break\n    for i in range(a + d, n):\n        if prime[i]:\n            b = i\n            break\n    print(a * b)", "from bisect import bisect_left as bl\nmax_n = 3 * 10 ** 4\n(isComposite, primes) = ([1] * 2 + [0] * (max_n - 2), [])\nfor i in range(2, max_n):\n    if isComposite[i] == 0:\n        primes.append(i)\n        for j in range(2 * i, max_n, i):\n            isComposite[j] += 1\nfor _ in range(int(input())):\n    d = int(input())\n    p1 = primes[bl(primes, d + 1)]\n    p2 = primes[bl(primes, d + p1)]\n    print(p1 * p2)", "from bisect import bisect_left as bsl\nt = int(input())\ncandidates = [2 * i + 1 for i in range(1, 10006)]\nprimelist = [2]\np = 3\nwhile p ** 2 <= 20011:\n    primelist.append(p)\n    candidates = [c for c in candidates if c % p]\n    p = candidates[0]\nprimelist += candidates\nmemo = [0] * 10000\nfor _ in range(t):\n    d = int(input())\n    if memo[d - 1]:\n        print(memo[d - 1])\n    else:\n        b1 = bsl(primelist, 1 + d)\n        p1 = primelist[b1]\n        b2 = bsl(primelist, p1 + d)\n        p2 = primelist[b2]\n        print(p1 * p2)\n        memo[d - 1] = p1 * p2", "N = 8 ** 5\na = [1] * N\ni = 2\nwhile i * i < N:\n    j = i * i\n    if a[i]:\n        while (j < N) * a[i]:\n            a[j] = 0\n            j += i\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "prime = [1] * 30000\nfor p in range(2, 30000):\n    if prime[p] == 1:\n        for i in range(p * p, 30000, p):\n            prime[i] = 0\nt = int(input())\nwhile t != 0:\n    d = int(input())\n    p = prime.index(1, d + 1)\n    q = prime.index(1, p + d)\n    print(p * q)\n    t -= 1", "prime = [1] * 30000\nfor p in range(2, 30000):\n    if prime[p] == 1:\n        for i in range(p * p, 30000, p):\n            prime[i] = 0\nt = int(input())\nwhile t != 0:\n    d = int(input())\n    p = prime.index(1, d + 1)\n    q = prime.index(1, p + d)\n    print(p * q)\n    t -= 1", "from sys import stdin\n\ndef sieve(size):\n    sie = [-1] * size\n    for i in range(2, int(size ** 0.5) + 1):\n        if sie[i] != -1:\n            continue\n        for j in range(i * i, size, i):\n            if sie[j] == -1:\n                sie[j] = i\n    return sie\ns = sieve(50000)\nfor _ in range(int(stdin.readline())):\n    d = int(stdin.readline())\n    min_div = d + 1\n    while s[min_div] != -1:\n        min_div += 1\n    sec_div = min_div + d\n    while s[sec_div] != -1:\n        sec_div += 1\n    print(min_div * sec_div)", "import math\n\ndef getint():\n    return [int(i) for i in input().split()]\n\ndef getstr():\n    return [str(i) for i in input().split()]\nprime = [1] * 30000\nfor p in range(2, 30000):\n    if prime[p] == 1:\n        for i in range(p * p, 30000, p):\n            prime[i] = 0\n\ndef solve():\n    d = int(input())\n    p = prime.index(1, d + 1)\n    q = prime.index(1, p + d)\n    print(p * q)\nfor _ in range(int(input())):\n    solve()", "import math\nN = 20011\nM = int(math.sqrt(N))\nsieve = [True for _ in range(N + 1)]\nsieve[0] = False\nsieve[1] = False\nfor p in range(2, M + 1):\n    if sieve[p]:\n        for j in range(p * p, N + 1, p):\n            sieve[j] = False\nt = int(input())\nfor _ in range(t):\n    d = int(input())\n    p1 = sieve.index(1, 1 + d)\n    p2 = sieve.index(1, p1 + d)\n    print(p1 * p2)", "from math import floor, sqrt\n\ndef sieve_of_eratosthenes(n):\n    prime_numbers = [True] * n\n    for i in range(2, floor(sqrt(n)) + 1):\n        if prime_numbers[i]:\n            for j in range(i * i, n, i):\n                prime_numbers[j] = False\n    return prime_numbers\nprimes_flags = sieve_of_eratosthenes(50000)\nfor t in range(int(input())):\n    d = int(input())\n    prime_divisors = [1]\n    i = 1 + d\n    while i < len(primes_flags):\n        if primes_flags[i]:\n            prime_divisors.append(i)\n            i += d - 1\n            if len(prime_divisors) >= 3:\n                print(prime_divisors[1] * prime_divisors[2])\n                break\n        i += 1", "def loda(n):\n    pussy = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if pussy[p] == True:\n            for i in range(p ** 2, n + 1, p):\n                pussy[i] = False\n        p += 1\n    pussy[0] = False\n    pussy[1] = False\n    return pussy\npussy = loda(100000)\nfor _ in range(int(input())):\n    n = int(input())\n    a = n + 1\n    for i in range(a, len(pussy)):\n        if pussy[i]:\n            p = i\n            break\n    for i in range(p + n, len(pussy)):\n        if pussy[i]:\n            q = i\n            break\n    print(p * q)", "import sys\nflag = {}\nq = [0, 0]\nmm = 30000\np = []\nfor i in range(2, mm):\n    q.append(len(p))\n    if i in flag:\n        continue\n    p.append(i)\n    j = 2\n    while i * j <= mm:\n        flag[i * j] = 1\n        j += 1\nT = int(sys.stdin.readline().strip())\nwhile T > 0:\n    T -= 1\n    n = int(sys.stdin.readline().strip())\n    a = p[q[1 + n]]\n    b = p[q[a + n]]\n    print(a * b)", "is_prime = [True] * 30000\nall_primes = set()\nfor i in range(len(is_prime)):\n    if is_prime[i]:\n        all_primes.add(i + 2)\n        for j in range(i, len(is_prime), i + 2):\n            is_prime[j] = False\nt = int(input())\nfor _ in range(t):\n    d = int(input())\n    first_prime = 0\n    second_prime = 0\n    for i in range(d - 1, len(is_prime)):\n        if i + 2 in all_primes:\n            first_prime = i + 2\n            break\n    for i in range(first_prime + d - 2, len(is_prime)):\n        if i + 2 in all_primes:\n            second_prime = i + 2\n            break\n    print(first_prime * second_prime)", "t = int(input())\np = [True for i in range(20012)]\np1 = 2\nwhile p1 * p1 <= 20012:\n    if p[p1] == True:\n        for j in range(p1 * 2, 20012, p1):\n            p[j] = False\n    p1 += 1\n    p[0] = False\nfor i in range(0, t):\n    m = int(input())\n    x = 1 + m\n    while x <= 20012:\n        if p[x] == True:\n            break\n        x += 1\n    y = x + m\n    while y <= 20012:\n        if p[y] == True:\n            break\n        y += 1\n    ans = x * y\n    print(int(ans))", "import sys\nMOD = 1000000007\nimport math\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return int(sys.stdin.readline())\n\ndef get_line():\n    return sys.stdin.readline().strip()\n\ndef write_line(out):\n    return sys.stdout.write(str(out) + '\\n')\nprimes = [True] * (4 * 10 ** 4 + 1)\nprimes[0] = False\nprimes[1] = False\ni = 2\nprime_numbers = []\nwhile i * i <= len(primes):\n    if primes[i]:\n        for j in range(i + i, len(primes), i):\n            primes[j] = False\n    i += 1\nfor (i, val) in enumerate(primes):\n    if val:\n        prime_numbers.append(i)\n\ndef bin_search(key):\n    l = 0\n    r = len(prime_numbers)\n    while l < r:\n        mid = (l + r) // 2\n        if prime_numbers[mid] >= key:\n            r = mid\n        else:\n            l = mid + 1\n    return prime_numbers[l]\n\ndef solve():\n    n = int(input())\n    first = bin_search(1 + n)\n    second = bin_search(first + n)\n    return first * second\nt = get_int()\nwhile t:\n    write_line(solve())\n    t -= 1", "import sys\nMOD = 1000000007\nimport math\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_int():\n    return int(sys.stdin.readline())\n\ndef get_line():\n    return sys.stdin.readline().strip()\n\ndef write_line(out):\n    return sys.stdout.write(str(out) + '\\n')\nprimes = [True] * (3 * 10 ** 4)\nprimes[0] = False\nprimes[1] = False\ni = 2\nprime_numbers = []\nwhile i * i <= len(primes):\n    if primes[i]:\n        for j in range(i + i, len(primes), i):\n            primes[j] = False\n    i += 1\nfor (i, val) in enumerate(primes):\n    if val:\n        prime_numbers.append(i)\n\ndef bin_search(key):\n    l = 0\n    r = len(prime_numbers)\n    while l < r:\n        mid = (l + r) // 2\n        if prime_numbers[mid] >= key:\n            r = mid\n        else:\n            l = mid + 1\n    return prime_numbers[l]\n\ndef solve():\n    n = int(input())\n    first = bin_search(1 + n)\n    second = bin_search(first + n)\n    return first * second\nt = get_int()\nwhile t:\n    write_line(solve())\n    t -= 1", "def sieve(n):\n    isPrime = [True] * (n + 1)\n    isPrime[0] = False\n    isPrime[1] = False\n    p = 2\n    while p * p <= n:\n        if isPrime[p]:\n            for j in range(p * p, n + 1, p):\n                isPrime[j] = False\n        p += 1\n    return isPrime\nprime = sieve(100000)\nfor _ in range(int(input())):\n    d = int(input())\n    m = 100001\n    x = d + 1\n    ans = 1\n    for i in range(x, m):\n        if prime[i]:\n            ans *= i\n            break\n    for i in range(ans + d, m):\n        if prime[i]:\n            ans *= i\n            break\n    print(ans)", "t = int(input())\nlst = [1] * 25001\nn = len(lst) - 1\np = 2\nwhile p * p <= n:\n    if lst[p] == 1:\n        for i in range(p * p, n + 1, p):\n            lst[i] = 0\n    p += 1\nprimelst = []\nfor i in range(2, n + 1):\n    if lst[i] == 1:\n        primelst.append(i)\n\ndef binS(lst, num):\n    start = 0\n    end = len(lst) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if lst[mid] == num:\n            return mid\n        elif lst[mid] < num:\n            start = mid + 1\n        else:\n            end = mid - 1\n    if lst[mid] < num:\n        mid += 1\n    return mid\nfor _ in range(t):\n    d = int(input())\n    pind = binS(primelst, 1 + d)\n    qind = binS(primelst, primelst[pind] + d)\n    p = primelst[pind]\n    q = primelst[qind]\n    print(min(p ** 3, p * q))", "t = int(input())\nlst = [1] * 25001\nn = len(lst) - 1\np = 2\nwhile p * p <= n:\n    if lst[p] == 1:\n        for i in range(p * p, n + 1, p):\n            lst[i] = 0\n    p += 1\nprimelst = []\nfor i in range(2, n + 1):\n    if lst[i] == 1:\n        primelst.append(i)\n\ndef binS(lst, num):\n    start = 0\n    end = len(lst) - 1\n    while start <= end:\n        mid = (start + end) // 2\n        if lst[mid] == num:\n            return mid\n        elif lst[mid] < num:\n            start = mid + 1\n        else:\n            end = mid - 1\n    if lst[mid] < num:\n        mid += 1\n    return mid\nfor _ in range(t):\n    d = int(input())\n    pind = binS(primelst, 1 + d)\n    qind = binS(primelst, primelst[pind] + d)\n    p = primelst[pind]\n    q = primelst[qind]\n    print(min(p ** 3, p * q))", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    out = []\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    for p in range(n + 1):\n        if prime[p]:\n            out.append(p)\n    return out\narr = SieveOfEratosthenes(10 ** 5)\nimport bisect\nfor _ in range(int(input())):\n    n = int(input())\n    a = bisect.bisect_left(arr, 1 + n)\n    out = arr[a]\n    b = bisect.bisect_left(arr, out + n)\n    out *= arr[b]\n    print(out)", "n = 20011\narr = [True for _ in range(n + 1)]\nfor x in range(2, n + 1):\n    if arr[x]:\n        z = 2\n        l = n // x\n        while z <= l:\n            tmp = x * z\n            if arr[tmp]:\n                arr[tmp] = False\n            z += 1\nfor _ in range(int(input())):\n    d = int(input())\n    ans = 1\n    for x in range(1 + d, n + 1):\n        if arr[x]:\n            ans *= x\n            break\n    for x in range(ans + d, n + 1):\n        if arr[x]:\n            ans *= x\n            break\n    print(ans)", "is_prime = [1] * 30000\nfor i in range(2, 30000):\n    if is_prime[i]:\n        for j in range(i * i, 30000, i):\n            is_prime[j] = 0\nn = int(input())\nfor i in range(n):\n    m = int(input())\n    a = 1 + m\n    while is_prime[a] == 0:\n        a += 1\n    b = a + m\n    while is_prime[b] == 0:\n        b += 1\n    print(a * b)", "from functools import lru_cache\nprime = [True for i in range(100000 + 1)]\n\ndef SieveOfEratosthenes(n):\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n\n@lru_cache(None)\ndef getPrime(n):\n    if n == 2:\n        return 2\n    while True:\n        if prime[n] == True:\n            return n\n        n = n + 1\nSieveOfEratosthenes(10 ** 5)\nt = int(input())\nfor i in range(t):\n    d = int(input())\n    a1 = getPrime(1 + d)\n    a2 = getPrime(a1 + d)\n    print(a1 * a2)", "def isprime(n):\n    while isPrime[n] == False:\n        n += 1\n    return n\n\ndef prime(n):\n    i = 2\n    while i < n:\n        if isPrime[i] == True:\n            j = 2\n            while i * j < n:\n                isPrime[i * j] = False\n                j += 1\n        i += 1\nt = int(input())\nisPrime = []\nfor i in range(30000):\n    isPrime.append(True)\nprime(30000)\nwhile t:\n    t -= 1\n    d = int(input())\n    ans = isprime(d + 1)\n    ans *= isprime(ans + d)\n    print(ans)", "def doit():\n    d = int(input())\n    for i in range(d + 1, 30001):\n        if a[i]:\n            if i * i - i >= d and i * i * i - i * i >= d:\n                ans = i * i * i\n                break\n    for i in range(d + 1, 30001):\n        if a[i]:\n            p1 = i\n            break\n    for i in range(p1 + d, 30001):\n        if a[i]:\n            p2 = i\n            break\n    ans = min(ans, p1 * p2)\n    print(ans)\na = [True] * 30010\na[0] = False\na[1] = False\nfor i in range(2, 30001):\n    if a[i]:\n        for j in range(i * 2, 30001, i):\n            a[j] = False\nT = int(input())\nfor _ in range(T):\n    doit()", "isprime = [1] * 20015\nisprime[0] = isprime[1] = 0\nfor i in range(2, 20015):\n    if i * i > 20015:\n        break\n    if isprime:\n        for j in range(i * i, 20015, i):\n            isprime[j] = 0\nprimes = []\nfor i in range(20015):\n    if isprime[i]:\n        primes.append(i)\n\ndef binsearch(d, x):\n    l = 0\n    r = len(primes)\n    m = -1\n    ans = -1\n    while l <= r:\n        m = l + (r - l) // 2\n        if primes[m] - x >= d:\n            ans = primes[m]\n            r = m - 1\n        else:\n            l = m + 1\n    return ans\nn = int(input())\nq = []\nfor i in range(n):\n    q.append(int(input()))\nfor d in q:\n    prime1 = binsearch(d, 1)\n    prime2 = binsearch(d, prime1)\n    print(prime1 * prime2)", "a = [1] * 8 ** 5\ni = 2\nwhile (b := ([0] * -(-8 ** 5 // i + i))):\n    a[i * i::i] = b\n    i += 1\nfor s in [*open(0)][1:]:\n    d = int(s)\n    i = a.index(1, d + 1)\n    print(i * a.index(1, i + d))", "prime = [False, False] + [True] * 20010\nfor i in range(2, 142):\n    if prime[i]:\n        for j in range(i * i, 20012, i):\n            prime[j] = False\nall_prime = [i for i in range(2, 20012) if prime[i]]\nnum_prime = len(all_prime)\ndel prime\nfor _ in [0] * int(input()):\n    d = int(input())\n    index = -1\n    left = 0\n    right = num_prime - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if all_prime[mid] <= d:\n            left = mid + 1\n            continue\n        if all_prime[mid] == d + 1:\n            index = mid\n            break\n        if all_prime[mid] > d:\n            if mid > 0 and all_prime[mid - 1] <= d:\n                index = mid\n                break\n            right = mid - 1\n            continue\n    left = index + 1\n    right = num_prime - 1\n    first = all_prime[index]\n    index = -1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if all_prime[mid] < first + d:\n            left = mid + 1\n            continue\n        if all_prime[mid] == first + d:\n            index = mid\n            break\n        if all_prime[mid] >= first + d:\n            if mid > 0 and all_prime[mid - 1] < first + d:\n                index = mid\n                break\n            right = mid - 1\n            continue\n    print(first * all_prime[index])", "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nall_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]\nfor i in range(24, 22000):\n    for p in all_primes:\n        if p > math.sqrt(i) + 2:\n            all_primes.append(i)\n            break\n        elif i % p == 0:\n            break\n\ndef solution(d, all_primes):\n    factors = [1]\n    for _ in range(2):\n        val = factors[-1] + d\n        pos = bisect.bisect_left(all_primes, val)\n        factors.append(all_primes[pos])\n    print(factors[-2] * factors[-1])\nT = int(input())\nfor t in range(T):\n    d = int(input())\n    solution(d, all_primes)", "M = 20020\nis_prime = [False, False] + [True for i in range(2, M)]\nfor d in range(2, M):\n    for k in range(2 * d, M, d):\n        is_prime[k] = False\nntests = int(input())\nfor t in range(ntests):\n    d = int(input())\n    p = d + 1\n    while not is_prime[p]:\n        p += 1\n    q = p + d\n    while not is_prime[q]:\n        q += 1\n    print(p * q)", "def SieveOfEratosthenes(n):\n    a = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            a.append(p)\n    return a\n\ndef bs(a, x, start, end):\n    if start > end:\n        return -1\n    if start == end:\n        return a[start]\n    mid = start + (end - start) // 2\n    if a[mid] == x:\n        return x\n    elif x < a[mid]:\n        return bs(a, x, start, mid)\n    else:\n        return bs(a, x, mid + 1, end)\nn = 25000\na = SieveOfEratosthenes(n)\nl = len(a)\nfor _ in range(int(input())):\n    d = int(input())\n    p1 = bs(a, 1 + d, 0, l - 1)\n    p2 = bs(a, p1 + d, 0, l - 1)\n    print(p1 * p2)", "def prime(n):\n    dicti = {}\n    dicti[0] = False\n    dicti[1] = False\n    for i in range(2, n):\n        if i not in dicti:\n            dicti[i] = True\n            for j in range(i * 2, n + 1, i):\n                dicti[j] = False\n    return dicti\ndicti = prime(20014)\nfor _ in range(int(input())):\n    d = int(input())\n    ans = 1\n    i = d + 1\n    if d == 1:\n        print('6')\n    else:\n        k = 0\n        for j in range(i, len(dicti)):\n            if dicti[j] == True:\n                k = j\n                break\n        ans *= k\n        i = ans + d\n        for j in range(i, len(dicti)):\n            if dicti[j] == True:\n                k = j\n                break\n        ans *= k\n        print(ans)", "from math import sqrt\nn = int(input())\n\ndef prime_up_to(n):\n    L = [True] * (n + 1)\n    for i in range(2, round(sqrt(n)) + 1):\n        if L[i]:\n            e = i * i\n            while e <= n:\n                L[e] = False\n                e += i\n    return [i for i in range(2, n + 1) if L[i]]\na = prime_up_to(20050)\nfor i in range(n):\n    k = int(input())\n    (l, r) = (0, len(a) - 1)\n    while l < r:\n        mid = (l + r) // 2\n        if a[mid] >= k + 1:\n            r = mid\n        else:\n            l = mid + 1\n    b = a[r]\n    (l, r) = (0, len(a) - 1)\n    while l < r:\n        mid = (l + r) // 2\n        if a[mid] >= k + b:\n            r = mid\n        else:\n            l = mid + 1\n    c = a[r]\n    print(b * c)", "dp = [True] * 100001\ndp[0] = False\ndp[1] = False\np = 2\nimport bisect\nwhile p * p <= 100001:\n    if dp[p] == True:\n        for i in range(p * p, 100001, p):\n            dp[i] = False\n    p += 1\nprime = []\nfor i in range(2, 100001):\n    if dp[i]:\n        prime.append(i)\ndel dp\nfor t in range(int(input())):\n    d = int(input())\n    if d == 1:\n        print(6)\n        continue\n    if d == 2:\n        print(15)\n    else:\n        fl = False\n        fl2 = False\n        l1 = 0\n        l2 = 0\n        l1 = bisect.bisect_left(prime, d + 1)\n        l2 = bisect.bisect_left(prime, prime[l1] + d)\n        print(prime[l1] * prime[l2])", "import math\n\ndef SieveOfEratosthenes(n):\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\nprime = [True for i in range(100001)]\nSieveOfEratosthenes(100000)\nfor j in range(int(input())):\n    l = int(input())\n    x = l + 1\n    ans_ = 1\n    for i in range(x, 100000):\n        if prime[i]:\n            ans_ *= i\n            break\n    for i in range(ans_ + l, 100000):\n        if prime[i]:\n            ans_ *= i\n            break\n    print(ans_)", "import math\nmaxm = 100001\nprimes = [True] * maxm\n\ndef seive():\n    for i in range(2, int(math.sqrt(maxm))):\n        if primes[i] == True:\n            for j in range(i * i, maxm, i):\n                primes[j] = False\nseive()\nfor t in range(int(input())):\n    d = int(input())\n    x = -1\n    y = -1\n    for i in range(1 + d, maxm):\n        if primes[i] == True:\n            x = i\n            break\n    for i in range(x + d, maxm):\n        if primes[i] == True:\n            y = i\n            break\n    print(x * y)", "import sys\n\ndef primes(n):\n    i = 2\n    prime = [True] * n\n    prime[0] = prime[1] = False\n    while i * i < n:\n        if prime[i]:\n            j = i + i\n            while j < n:\n                prime[j] = False\n                j += i\n        i += 1\n    return prime\n\ndef solve(x, prime):\n    p = x + 1\n    while not prime[p]:\n        p += 1\n    q = p + x\n    while not prime[q]:\n        q += 1\n    return p * q\nn = int(input())\np = primes(int(100000.0))\nfor _ in range(n):\n    x = int(input())\n    print(solve(x, p))", "def is_prime(n, primes):\n    for prime in primes:\n        if n % prime == 0:\n            return False\n    return True\n\ndef main():\n    t = int(input())\n    primes = [2]\n    for i in range(3, 200, 2):\n        if is_prime(i, primes) == True:\n            primes.append(i)\n    while t != 0:\n        d = int(input())\n        if d == 1:\n            a = 2\n        elif d % 2 == 0:\n            a = 1 + d\n        else:\n            a = 2 + d\n        while a not in primes:\n            if a > primes[-1]:\n                break\n            a += 2\n        if a > primes[-1]:\n            while is_prime(a, primes) != True:\n                a += 2\n        if a == 2:\n            b = 3\n        elif d % 2 == 0:\n            b = a + d\n        else:\n            b = a + d + 1\n        while b not in primes:\n            if b > primes[-1]:\n                break\n            b += 2\n        if b > primes[-1]:\n            while is_prime(b, primes) != True:\n                b += 2\n        print(a * b)\n        t -= 1\nmain()", "def is_prime(n, primes):\n    for prime in primes:\n        if n % prime == 0:\n            return False\n    return True\n\ndef main():\n    t = int(input())\n    primes = [2]\n    for i in range(3, 200, 2):\n        if is_prime(i, primes) == True:\n            primes.append(i)\n    while t != 0:\n        d = int(input())\n        if d == 1:\n            a = 2\n        elif d % 2 == 0:\n            a = 1 + d\n        else:\n            a = 2 + d\n        while a not in primes:\n            if a > primes[-1]:\n                break\n            a += 2\n        if a > primes[-1]:\n            while is_prime(a, primes) != True:\n                a += 2\n        if a == 2:\n            b = 3\n        elif d % 2 == 0:\n            b = a + d\n        else:\n            b = a + d + 1\n        while b not in primes:\n            if b > primes[-1]:\n                break\n            b += 2\n        if b > primes[-1]:\n            while is_prime(b, primes) != True:\n                b += 2\n        print(a * b)\n        t -= 1\nmain()", "def SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    l = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            l.append(p)\n    return l\n\ndef binarysearch(arr, a, b, element):\n    ans = 0\n    while a <= b:\n        m = a + (b - a) // 2\n        if arr[m] == element:\n            return arr[m]\n        elif arr[m] < element:\n            a = m + 1\n        else:\n            b = m - 1\n            ans = arr[m]\n    return ans\nfirst = SieveOfEratosthenes(100000)\nfor _ in range(int(input())):\n    n = int(input())\n    one = binarysearch(first, 0, len(first) + 1, n + 1)\n    two = binarysearch(first, 0, len(first) + 1, one + n)\n    print(one * two)", "def all_prime(n):\n    dicti = {}\n    dicti[0] = 0\n    dicti[1] = 0\n    for i in range(2, n):\n        if i not in dicti:\n            dicti[i] = 1\n            j = 2 * i\n            while j <= n:\n                dicti[j] = 0\n                j += i\n    return dicti\ndicti = all_prime(22000)\nfor i in range(int(input())):\n    d = int(input())\n    v = []\n    v.append(1)\n    sam = 1 + d\n    while True:\n        if len(v) == 3:\n            break\n        if dicti[sam] == 1:\n            v.append(sam)\n            sam += d\n        else:\n            sam += 1\n    print(v[1] * v[2])", "import math\ng = [0] * 20983\ng.append(20983)\nfor j in range(20982, 1, -1):\n    c = 0\n    for k in range(2, int(math.sqrt(j)) + 2):\n        if j % k == 0:\n            c = c + 1\n            break\n    if c == 0:\n        g[j] = j\n    else:\n        g[j] = g[j + 1]\nfor j in range(int(input())):\n    n = int(input())\n    if n == 1:\n        print('6')\n    else:\n        print(g[1 + n] * g[n + g[1 + n]])", "from math import sqrt\n\ndef prime(x):\n    flag = True\n    for i in range(2, int(sqrt(x)) + 1):\n        if x % i == 0:\n            flag = False\n            break\n    return flag\narr = []\nfor i in range(2, 25001):\n    if prime(i):\n        arr.append(i)\nans = []\npos1 = 0\npos2 = 0\nd = 1\nwhile d <= 10000:\n    while arr[pos1] - 1 < d:\n        pos1 += 1\n    while arr[pos2] - arr[pos1] < d:\n        pos2 += 1\n    ans.append(arr[pos1] * arr[pos2])\n    d += 1\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    print(ans[n - 1])", "def primes():\n    a = [0 for i in range(50000)]\n    a[0] = 1\n    for i in range(1, 50000):\n        if a[i] == 0:\n            j = 2 * i + 1\n            while j < 50000:\n                a[j] = 1\n                j += i + 1\n        else:\n            continue\n    a = [i + 1 for i in range(50000) if a[i] == 0]\n    return a\nr = primes()\n\ndef dico(l, x):\n    (i, j) = (0, len(l) - 1)\n    while i <= j:\n        ind = (i + j) // 2\n        if l[ind] == x:\n            i = ind\n            break\n        elif l[ind] < x:\n            i = ind + 1\n        else:\n            j = ind - 1\n    return i\n\ndef divis(r, d):\n    a = dico(r, d + 1)\n    b = dico(r, r[a] + d)\n    return r[a] * r[b]\nfor _ in range(int(input())):\n    d = int(input())\n    print(divis(r, d))", "t = int(input())\nprime = [True] * 40000\nprime[0] = False\nprime[1] = False\nfor i in range(2, 40000):\n    if prime[i]:\n        for j in range(i + i, 40000, i):\n            prime[j] = False\nfor i in range(t):\n    d = int(input())\n    factor = [1]\n    j = 1 + d\n    while True:\n        if len(factor) == 3:\n            break\n        if prime[j]:\n            if len(factor) == 2:\n                if factor[0] * factor[1] * j - j < d:\n                    continue\n            factor.append(j)\n            j += d\n            continue\n        j += 1\n    print(factor[0] * factor[1] * factor[2])", "T = int(input())\nMAX_P = 40000\nprimes = [False] + [True] * MAX_P\nplist = []\nfor (i, p) in enumerate(primes):\n    if not p:\n        continue\n    if i == 1:\n        continue\n    plist.append(i)\n    if i ** 2 > MAX_P:\n        continue\n    j = i\n    while i * j <= MAX_P:\n        primes[i * j] = False\n        j += 1\n\ndef bs(x, i, j):\n    if j == i + 1:\n        return plist[i]\n    m = (i + j - 1) // 2\n    if plist[m] >= x:\n        return bs(x, i, m + 1)\n    return bs(x, m + 1, j)\n\ndef do(N):\n    p = bs(N + 1, 0, len(plist))\n    q = bs(p + N, 0, len(plist))\n    return min(p ** 3, p * q)\nfor _ in range(T):\n    N = int(input())\n    print(do(N))", "primes = set()\nfor i in range(2, 20400):\n    primes.add(i)\nfor div in range(2, 20400):\n    j = 2 * div\n    while j <= 20400:\n        if j in primes:\n            primes.remove(j)\n        j += div\n\ndef isprime(i):\n    return i in primes\nfor _ in range(int(input())):\n    d = int(input())\n    p1 = -1\n    for num in range(d + 1, d + 1000):\n        if isprime(num):\n            p1 = num\n            break\n    p2 = -1\n    for num in range(p1 + d, p1 + d + 1000):\n        if isprime(num):\n            p2 = num\n            break\n    print(p1 * p2)", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\nT = int(input())\nwhile T > 0:\n    T = T - 1\n    diff = int(input())\n    a = 1\n    b = a + diff\n    if b % 2 == 0 and diff != 1:\n        b += 1\n    while True:\n        if isPrime(b) and b - a >= diff:\n            break\n        b += 2\n    c = b + diff\n    if c % 2 == 0:\n        c += 1\n    while True:\n        if isPrime(c) and c - b >= diff:\n            break\n        c += 2\n    print(b * c)", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef nextp(n):\n    while True:\n        n += 1\n        if isPrime(n):\n            return n\nfor _ in range(int(input())):\n    n = int(input())\n    number = nextp(n)\n    print(number * nextp(number + n - 1))", "l = []\n\ndef SieveOfEratosthenes(n):\n    l = []\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    for p in range(2, n + 1):\n        if prime[p]:\n            l.append(p)\n    return l\n\ndef binSearch(sc, lf, r):\n    if lf == r - 1 and sc != l[lf] and (sc != l[r]):\n        return r\n    if lf < r:\n        mid = (lf + r) // 2\n        if l[mid] == sc:\n            return mid\n        elif l[mid] > sc:\n            return binSearch(sc, lf, mid)\n        else:\n            return binSearch(sc, mid, r)\n    return r\nMAX = 100000\nl = SieveOfEratosthenes(MAX)\nfor _ in range(int(input())):\n    d = int(input())\n    k = binSearch(1 + d, 0, len(l) - 1)\n    p = binSearch(d + l[k], 0, len(l) - 1)\n    print(l[k] * l[p])", "from sys import stdin\ndct = {i: 1 for i in range(2, 30001)}\nfor i in range(2, 190):\n    if i not in dct:\n        continue\n    else:\n        for j in range(2, 30000 // i + 1):\n            if i * j in dct:\n                del dct[i * j]\nlst = sorted(dct.keys())\nlength = len(lst)\nt = int(stdin.readline())\nfor _ in range(t):\n    d = int(stdin.readline())\n    jump = length - 1\n    position1 = 0\n    while jump > 0:\n        if lst[position1 + jump] > d + 1:\n            jump //= 2\n        else:\n            position1 += jump\n    if lst[position1] >= d + 1:\n        so1 = lst[position1]\n    else:\n        so1 = lst[position1 + 1]\n    position2 = int(position1)\n    jump = length\n    while jump > 0:\n        if position2 + jump >= length or lst[position2 + jump] > d + so1:\n            jump //= 2\n        else:\n            position2 += jump\n    if lst[position2] >= d + so1:\n        so2 = lst[position2]\n    else:\n        so2 = lst[position2 + 1]\n    print(so1 * so2)", "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    k = 5\n    while k * k <= n:\n        if n % k == 0 or n % (k + 2) == 0:\n            return False\n        k += 6\n    return True\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    k = n + 1\n    while True:\n        if is_prime(k):\n            break\n        else:\n            k += 1\n    a = k + n\n    while True:\n        if is_prime(a):\n            break\n        else:\n            a += 1\n    print(k * a)", "import sys, os, time, json, random, math\nn = 10000 * 5\na = list(range(n + 1))\na[1] = 0\nlst = []\ni = 2\nwhile i <= n:\n    if a[i] != 0:\n        lst.append(a[i])\n        for j in range(i, n + 1, i):\n            a[j] = 0\n    i += 1\nnext_simp = {}\nc = 0\nfor i in range(n):\n    if i > lst[c]:\n        c += 1\n    if c >= len(lst):\n        break\n    next_simp[i] = lst[c]\ntt = int(input())\nres = []\nfor t in range(tt):\n    d = int(input())\n    s1 = next_simp[1 + d]\n    s2 = next_simp[s1 + d]\n    res.append(s1 * s2)\nfor r in res:\n    print(r)", "import math\nimport string\nimport random\nimport sys\nfrom random import randrange\nfrom collections import deque\nfrom collections import defaultdict\nfrom bisect import bisect, bisect_right, bisect_left\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return list(map(int, data().split()))\n\ndef outl(var):\n    sys.stdout.write(' '.join(map(str, var)) + '\\n')\n\ndef out(var):\n    sys.stdout.write(str(var) + '\\n')\nn = 200000\nprime = [True for i in range(n + 1)]\np = 2\nwhile p * p <= n:\n    if prime[p] == True:\n        for i in range(p * 2, n + 1, p):\n            prime[i] = False\n    p += 1\nprime[0] = False\nprime[1] = False\nfor _ in range(int(input())):\n    d = int(data())\n    a = [1]\n    k = d + 1\n    while not prime[k]:\n        k += 1\n    a.append(k)\n    k += d\n    while not prime[k]:\n        k += 1\n    a.append(k)\n    ans = 1\n    for i in a:\n        ans *= i\n    print(ans)", "from sys import stdin\ninput = stdin.readline\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\nfor _ in range(int(input())):\n    n = int(input())\n    a = 1 + n\n    while not isPrime(a):\n        a += 1\n    b = a + n\n    while not isPrime(b):\n        b += 1\n    print(a * b)", "import math\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    lst = int(math.sqrt(n)) + 1\n    for i in range(3, lst, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef getPrime(n):\n    if n == 2:\n        return 2\n    if n % 2 == 0:\n        n += 1\n    while True:\n        if isPrime(n):\n            return n\n        n += 2\nt = int(input())\nfor _ in range(t):\n    d = int(input())\n    a = getPrime(1 + d)\n    b = getPrime(a + d)\n    print(a * b)", "from math import sqrt\n\ndef isprime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\n\ndef next_prime(n, step):\n    n = n + step\n    while isprime(n) == False:\n        n += 1\n    return n\nfor _ in range(int(input())):\n    n = int(input())\n    a = next_prime(1, n)\n    b = next_prime(a, n)\n    print(a * b)", "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i = i + 6\n    return True\nfor _ in range(int(input())):\n    d = int(input())\n    a = 1 + d\n    while 1:\n        if isPrime(a):\n            break\n        a += 1\n    b = a + d\n    while 1:\n        if isPrime(b):\n            break\n        b += 1\n    print(a * b)", "import bisect\nfrom collections import defaultdict\nimport math\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(5, int(math.sqrt(n) + 1), 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef nextPrime(N):\n    if N <= 1:\n        return 2\n    prime = N - 1\n    found = False\n    while not found:\n        prime = prime + 1\n        if isPrime(prime) == True:\n            found = True\n    return prime\n\ndef solve(d):\n    x1 = nextPrime(1 + d)\n    x2 = nextPrime(x1 + d)\n    return x1 * x2\nt = int(input(''))\nans = []\nwhile t > 0:\n    n = int(input(''))\n    ans.append(solve(n))\n    t -= 1\nfor i in ans:\n    print(i)"]