["import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nMOD = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    R = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    points = [(r, c) for (r, c) in zip(R, C)]\n    points.sort()\n    res = 0\n    pr = pc = 1\n    for (r, c) in points:\n        if r - c == pr - pc:\n            if (r + c) % 2 == 0:\n                res += r - pr\n        else:\n            if pc != c:\n                pr += c - pc\n                pc = c\n            if (pr + pc) % 2 == 0:\n                res += (r - pr) // 2\n            else:\n                res += (r - pr + 1) // 2\n        (pr, pc) = (r, c)\n    print(res)\nt = int(input())\nfor _ in range(t):\n    solve()", "def solve():\n    n = int(input())\n    points = []\n    x = input()\n    x = [int(i) for i in x.split(' ')]\n    for i in x:\n        points.append([i, 0])\n    y = input()\n    y = [int(i) for i in y.split(' ')]\n    for (i, v) in enumerate(y):\n        points[i][1] = v\n    points.sort()\n    ans = 0\n    start = [1, 1]\n    for (x, y) in points:\n        (a, b) = start\n        if x - y == a - b:\n            if (a - b) % 2 == 0:\n                ans += y - b\n        else:\n            ans += (x - y) // 2 - (a - b) // 2\n        start = [x, y]\n    print(ans)\n\ndef main():\n    t = int(input())\n    while t:\n        solve()\n        t -= 1\nmain()", "def solve():\n    n = int(input())\n    points = []\n    x = input()\n    x = [int(i) for i in x.split(' ')]\n    for i in x:\n        points.append([i, 0])\n    y = input()\n    y = [int(i) for i in y.split(' ')]\n    for (i, v) in enumerate(y):\n        points[i][1] = v\n    points.sort()\n    ans = 0\n    start = [1, 1]\n    for (x, y) in points:\n        (a, b) = start\n        if x - y == a - b:\n            if (a - b) % 2 == 0:\n                ans += x - a\n        else:\n            ans += (x - y) // 2 - (a - b) // 2\n        start = [x, y]\n    print(ans)\n\ndef main():\n    t = int(input())\n    while t:\n        solve()\n        t -= 1\nmain()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        r = list(map(int, input().split()))\n        c = list(map(int, input().split()))\n        points = [(r[i], c[i]) for i in range(n)]\n        points.sort(key=lambda x: x[0])\n        if points[0] != (1, 1):\n            points = [(1, 1)] + points\n            n += 1\n        cost = 0\n        for i in range(n - 1):\n            prev = points[i]\n            now = points[i + 1]\n            prev_diff = prev[0] - prev[1]\n            now_diff = now[0] - now[1]\n            if prev_diff == now_diff:\n                if prev_diff % 2 == 0:\n                    cost += now[0] - prev[0]\n                else:\n                    pass\n            elif prev_diff + 1 == now_diff and prev_diff % 2 == 0:\n                pass\n            else:\n                cost += now_diff // 2 - prev_diff // 2\n        print(cost)\nmain()", "cas = int(input())\nwhile cas:\n    cas -= 1\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = list(zip(r, c))\n    a.sort()\n    now = 0\n    pre = 0\n    pr = 1\n    pz = 0\n    ans = 0\n    for i in range(n):\n        tmp = a[i]\n        now = tmp[0] - tmp[1]\n        zu = now // 2\n        if pre == now and now % 2 == 0:\n            ans += tmp[0] - pr\n        if pre != now and zu != pz:\n            ans += zu - pz\n        pre = now\n        pr = tmp[0]\n        pz = zu\n    print(ans)", "for t in range(int(input())):\n    n = int(input())\n    r_arr = tuple(map(int, input().split()))\n    c_arr = tuple(map(int, input().split()))\n    r_rminusc = [(r, r - c, c) for (r, c) in zip(r_arr, c_arr)]\n    r_rminusc.sort()\n    cost = 0\n    current_pos = (1, 0, 1)\n    for tup3 in r_rminusc:\n        diff1 = current_pos[1]\n        diff2 = tup3[1]\n        (c11, c12) = divmod(diff1, 2)\n        (c21, c22) = divmod(diff2, 2)\n        if c11 != c21:\n            cost += c21 - c11\n        elif c22 == 0 and c12 == 0:\n            cost += tup3[0] - current_pos[0]\n        current_pos = tup3\n    print(cost)", "for _ in range(int(input())):\n    n = int(input())\n    r = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    (sx, sy) = (1, 1)\n    cost = 0\n    for (dx, dy) in sorted(zip(r, c)):\n        sl = sx - sy\n        dl = dx - dy\n        if sl == dl:\n            if sl % 2 == 0:\n                points = dx - sx\n            else:\n                points = 0\n        else:\n            sdbl = sl // 2\n            ddbl = dl // 2\n            if sdbl == ddbl:\n                points = 0\n            else:\n                points = ddbl - sdbl\n        cost += points\n        (sx, sy) = (dx, dy)\n    print(f'{cost}')", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    z = []\n    z.append((1, 1))\n    for i in range(n):\n        z.append((r[i], c[i]))\n    z.sort()\n    node = z\n    res = 0\n    for i in range(n):\n        (r, c) = node[i]\n        (nr, nc) = node[i + 1]\n        res += (nr - nc) // 2 - (r - c) // 2 + (nr - r if r - c == nr - nc and (r - c) % 2 == 0 else 0)\n    print(res)", "for t in range(int(input())):\n    n = int(input())\n    r_arr = tuple(map(int, input().split()))\n    c_arr = tuple(map(int, input().split()))\n    r_rminusc = [(r, r - c, c) for (r, c) in zip(r_arr, c_arr)]\n    r_rminusc.sort()\n    cost = 0\n    current_pos = (1, 0, 1)\n    for tup3 in r_rminusc:\n        diff1 = current_pos[1]\n        diff2 = tup3[1]\n        (c11, c12) = divmod(diff1, 2)\n        (c21, c22) = divmod(diff2, 2)\n        if c11 != c21:\n            cost += c21 - c11\n        elif c22 == 0 and c12 == 0:\n            cost += tup3[0] - current_pos[0]\n        current_pos = tup3\n    print(cost)", "def dist(r1, c1, r2, c2):\n    if r1 - c1 == r2 - c2:\n        if (r1 + c1) % 2 == 0:\n            rez = r2 - r1\n        else:\n            rez = 0\n    else:\n        r2 = r2 - (r1 - 1)\n        c2 = c2 - (c1 - 1)\n        if (r1 + c1) % 2 == 0:\n            rez = (r2 - c2) // 2\n        else:\n            rez = (r2 - c2 + 1) // 2\n    return rez\nt = int(input())\nfor j in range(t):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = sorted(zip(r, c))\n    ans = 0\n    (r0, c0) = (1, 1)\n    for (r, c) in d:\n        ans += dist(r0, c0, r, c)\n        (r0, c0) = (r, c)\n    print(ans)", "t = int(input())\nwhile t:\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = list(zip(r, c))\n    a.sort()\n    now = 0\n    pre = 0\n    pr = 1\n    pz = 0\n    ans = 0\n    for i in range(n):\n        tmp = a[i]\n        now = tmp[0] - tmp[1]\n        zu = now // 2\n        if pre == now and now % 2 == 0:\n            ans += tmp[0] - pr\n        if pre != now and zu != pz:\n            ans += zu - pz\n        pre = now\n        pr = tmp[0]\n        pz = zu\n    print(ans)\n    t -= 1", "t = int(input())\nwhile t:\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = list(zip(r, c))\n    a.sort()\n    now = 0\n    pre = 0\n    pr = 1\n    pz = 0\n    ans = 0\n    for i in range(n):\n        tmp = a[i]\n        now = tmp[0] - tmp[1]\n        zu = now // 2\n        if pre == now and now % 2 == 0:\n            ans += tmp[0] - pr\n        if pre != now and zu != pz:\n            ans += zu - pz\n        pre = now\n        pr = tmp[0]\n        pz = zu\n    print(ans)\n    t -= 1", "def helper(a, b):\n    if a == b:\n        return 0\n    (x0, y0) = a\n    (x1, y1) = b\n    if (x0 + y0) % 2 == 0:\n        x0 += 1\n    y0 += x1 - x0\n    if y1 > y0:\n        return x1 - x0 + 1\n    elif y1 == y0:\n        return 0\n    else:\n        return (y0 - y1 + 1) // 2\nfor i in range(int(input())):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    pool = sorted([[1, 1]] + [[r[i], c[i]] for i in range(n)])\n    print(sum([helper(pool[i - 1], pool[i]) for i in range(1, n + 1)]))", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    rs = [int(ea) for ea in input().split(' ')]\n    cs = [int(ea) for ea in input().split(' ')]\n    points = []\n    for i in range(n):\n        points.append((rs[i], cs[i]))\n    points.sort()\n    if points[0] != (1, 1):\n        points.insert(0, (1, 1))\n    prev = 0\n    prevR = 1\n    cost = 0\n    for (r, c) in points[1:]:\n        cur = r - c\n        if cur == prev and cur % 2 == 0:\n            cost += r - prevR\n        else:\n            diff = cur - prev\n            if diff % 2 == 0:\n                cost += diff // 2\n            elif prev % 2 == 1:\n                cost += 1 + diff // 2\n            else:\n                cost += diff // 2\n        prev = cur\n        prevR = r\n    print(cost)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    rs = [int(ea) for ea in input().split(' ')]\n    cs = [int(ea) for ea in input().split(' ')]\n    points = []\n    for i in range(n):\n        points.append((rs[i], cs[i]))\n    points.sort()\n    if points[0] != (1, 1):\n        points.insert(0, (1, 1))\n    prev = 0\n    prevR = 1\n    cost = 0\n    for (r, c) in points[1:]:\n        cur = r - c\n        if cur == prev and cur % 2 == 0:\n            cost += r - prevR\n        else:\n            diff = cur - prev\n            cost += diff // 2\n            if diff % 2 == 1 and prev % 2 == 1:\n                cost += 1\n        prev = cur\n        prevR = r\n    print(cost)", "import sys\nP = lambda : map(int, sys.stdin.readline().split())\nfor _ in range(*P()):\n    (n,) = P()\n    d = [(1, 1)] + sorted(zip(P(), P()))\n    a = 0\n    for i in range(n):\n        (r, c) = d[i]\n        v = r - c\n        (R, C) = d[i + 1]\n        a += (R - C) // 2 - v // 2 + (R - r) * (v & 1 < 1 and v == R - C)\n    print(a)", "def calc_dist(r1, c1, r2, c2):\n    if r1 - c1 == r2 - c2:\n        if (r1 + c1) % 2 == 1:\n            return 0\n        else:\n            return r2 - r1\n    r2 -= r1 - 1\n    c2 -= c1 - 1\n    if (r1 + c1) % 2 == 0:\n        return (r2 - c2) // 2\n    else:\n        return (r2 - c2 + 1) // 2\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    r = [int(s) for s in input().split(' ')]\n    c = [int(s) for s in input().split(' ')]\n    pts = list(zip(r, c))\n    pts.sort()\n    cur_r = 1\n    cur_c = 1\n    ans = 0\n    for (nxt_r, nxt_c) in pts:\n        ans += calc_dist(cur_r, cur_c, nxt_r, nxt_c)\n        cur_r = nxt_r\n        cur_c = nxt_c\n    print(ans)", "import sys\nfor _ in range(int(input())):\n    n = int(input())\n    f = lambda : map(int, sys.stdin.readline().split())\n    node = [(1, 1)] + sorted(zip(f(), f()))\n    res = 0\n    for i in range(n):\n        (r, c) = node[i]\n        (nr, nc) = node[i + 1]\n        res += (nr - nc) // 2 - (r - c) // 2 + (nr - r if r - c == nr - nc and (r - c) % 2 == 0 else 0)\n    print(res)", "for _ in range(int(input())):\n    input()\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = sorted(((x, x + 1 - y) for (x, y) in zip(r, c)))\n    if a[0] != (1, 1):\n        a = [(1, 1)] + a\n    ans = 0\n    for ((x, y), (nx, ny)) in zip(a, a[1:]):\n        assert x < nx and y <= ny and (ny - y <= nx - x)\n        if y == ny and y % 2:\n            ans += nx - x\n        else:\n            ans += (ny + 1) // 2 - (y + 1) // 2\n    print(ans, sep='\\n')", "import sys\nfor _ in range(int(input())):\n    n = int(input())\n    f = lambda : map(int, sys.stdin.readline().split())\n    node = [(1, 1)] + sorted(zip(f(), f()))\n    res = 0\n    for i in range(n):\n        (r, c) = node[i]\n        (nr, nc) = node[i + 1]\n        res += (nr - nc) // 2 - (r - c) // 2 + (nr - r if r - c == nr - nc and (r - c) % 2 == 0 else 0)\n    print(res)", "P = lambda : map(int, input().split())\nfor _ in range(*P()):\n    (n,) = P()\n    d = [(1, 1)] + sorted(zip(P(), P()))\n    a = 0\n    for i in range(n):\n        (r, c) = d[i]\n        v = r - c\n        (R, C) = d[i + 1]\n        a += (R - C) // 2 - v // 2 + (R - r) * (v & 1 < 1 and v == R - C)\n    print(a)", "P = lambda : map(int, input().split())\nfor _ in range(*P()):\n    (n,) = P()\n    d = [(1, 1)] + sorted(zip(P(), P()))\n    a = 0\n    for i in range(n):\n        (r, c) = d[i]\n        v = r - c\n        (R, C) = d[i + 1]\n        a += (R - C) // 2 - v // 2 + (R - r) * (v & 1 < 1 and v == R - C)\n    print(a)", "P = lambda : map(int, input().split())\nfor _ in range(*P()):\n    (n,) = P()\n    d = [(1, 1)] + sorted(zip(P(), P()))\n    a = 0\n    for i in range(n):\n        (r, c) = d[i]\n        v = r - c\n        (R, C) = d[i + 1]\n        a += (R - C) // 2 - v // 2 + (R - r) * (v & 1 < 1 and v == R - C)\n    print(a)", "P = lambda : map(int, input().split())\nfor _ in range(*P()):\n    (n,) = P()\n    d = [(1, 1)] + sorted(zip(P(), P()))\n    a = 0\n    for i in range(n):\n        (r, c) = d[i]\n        v = r - c\n        (R, C) = d[i + 1]\n        a += (R - C) // 2 - v // 2 + (R - r) * (v & 1 < 1 and v == R - C)\n    print(a)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    z = []\n    z.append((1, 1))\n    for i in range(n):\n        z.append((r[i], c[i]))\n    z.sort()\n    node = z\n    res = 0\n    for i in range(n):\n        (r, c) = node[i]\n        (nr, nc) = node[i + 1]\n        res += (nr - nc) // 2 - (r - c) // 2 + (nr - r if r - c == nr - nc and (r - c) % 2 == 0 else 0)\n    print(res)", "import collections\nimport heapq\n\ndef isLeftArrow(r, c):\n    return (r + c) % 2 == 0\n\ndef isRightArrow(r, c):\n    return (r + c) % 2 == 1\n\ndef calcDist(r1, c1, r2, c2):\n    if r1 - c1 == r2 - c2:\n        return 0 if isRightArrow(r1, c1) else r2 - r1\n    r2 -= r1 - 1\n    c2 -= c1 - 1\n    if isLeftArrow(r1, c1):\n        return (r2 - c2) // 2\n    else:\n        return (r2 - c2 + 1) // 2\n\ndef process(n, r, c):\n    pts = []\n    for i in range(n):\n        pts.append((r[i], c[i]))\n    pts.sort()\n    (curR, curC) = (1, 1)\n    res = 0\n    for (nextR, nextC) in pts:\n        res += calcDist(curR, curC, nextR, nextC)\n        curR = nextR\n        curC = nextC\n    print(res)\ntcs = int(input())\nfor tc in range(tcs):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    process(n, r, c)", "for _ in range(int(input())):\n    input()\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = [(1, 1)] + sorted(((x, x + 1 - y) for (x, y) in zip(r, c)))\n    if a[0] == a[1]:\n        a = a[1:]\n    ans = 0\n    for ((x, y), (nx, ny)) in zip(a, a[1:]):\n        assert x < nx and y <= ny and (ny - y <= nx - x)\n        if y == ny and y % 2:\n            ans += nx - x\n        else:\n            ans += (ny + 1) // 2 - (y + 1) // 2\n    print(ans)", "def minCost(a, b):\n    if (b[0] + b[1]) % 2 == 0 and b[0] - b[1] == a[0] - a[1]:\n        return b[0] - a[0]\n    diagA = (a[0] - a[1]) // 2\n    diagB = (b[0] - b[1]) // 2\n    return diagB - diagA\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    nodes = list(zip(map(int, input().split()), map(int, input().split())))\n    nodes.insert(0, (1, 1))\n    nodes.sort()\n    res = 0\n    for i in range(len(nodes) - 1):\n        res += minCost(nodes[i], nodes[i + 1])\n    print(res)", "for _ in range(int(input())):\n    input()\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    a = [(1, 1)] + sorted(((x, x + 1 - y) for (x, y) in zip(r, c)))\n    if a[0] == a[1]:\n        a = a[1:]\n    ans = 0\n    for ((x, y), (nx, ny)) in zip(a, a[1:]):\n        assert x < nx and y <= ny and (ny - y <= nx - x)\n        if y == ny and y % 2:\n            ans += nx - x\n        else:\n            ans += (ny + 1) // 2 - (y + 1) // 2\n    print(ans)", "import copy\n\ndef helper(a, b):\n    if a == b:\n        return 0\n    (x0, y0) = a\n    (x1, y1) = b\n    if (x0 + y0) % 2 == 0:\n        x0 += 1\n    y0 += x1 - x0\n    if y1 > y0:\n        return x1 - x0 + 1\n    elif y1 == y0:\n        return 0\n    else:\n        return (y0 - y1 + 1) // 2\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    pool = [[1, 1]]\n    for i in range(n):\n        pool.append([r[i], c[i]])\n    pool.sort()\n    res = 0\n    for i in range(1, n + 1):\n        res += helper(pool[i - 1], pool[i])\n    print(res)", "for case in range(int(input())):\n    n = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    li = []\n    for i in range(n):\n        x = X[i]\n        y = Y[i]\n        li.append((abs(x - y + 1), min(x, y)))\n    li.sort()\n    prvblk = 1\n    prvplc = 1\n    cost = 0\n    for (blk, plc) in li:\n        hor = blk - prvblk\n        ver = plc - prvplc\n        if hor == 0:\n            if prvblk % 2:\n                cost += ver\n        elif prvblk % 2:\n            cost += hor // 2\n        else:\n            cost += (hor + 1) // 2\n        prvblk = blk\n        prvplc = plc\n    print(cost)", "P = lambda : map(int, input().split())\nfor _ in range(*P()):\n    (n,) = P()\n    d = [(1, 1)] + sorted(zip(P(), P()))\n    a = 0\n    for i in range(n):\n        (r, c) = d[i]\n        v = r - c\n        (R, C) = d[i + 1]\n        a += (R - C) // 2 - v // 2 + (R - r) * (v & 1 < 1 and v == R - C)\n    print(a)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    node = list()\n    node.append((1, 1))\n    for i in range(n):\n        node.append((r[i], c[i]))\n    node.sort()\n    result = 0\n    for i in range(n):\n        (r, c) = node[i]\n        (n_r, n_c) = node[i + 1]\n        cond = r - c == n_r - n_c and (r - c) % 2 == 0\n        result += int((n_r - n_c) / 2) - int((r - c) / 2) + (n_r - r) * int(cond)\n    print(result)", "import sys, math\n\ndef getCount(p1, p2):\n    if p2[1] - p1[1] == p2[0] - p1[0]:\n        if (p1[0] + p1[1]) % 2 == 0:\n            return p2[0] - p1[0]\n        else:\n            return 0\n    if (p1[0] + p1[1]) % 2 == 0:\n        p1[0] += 1\n    return math.ceil((p2[0] - p1[0] - p2[1] + p1[1]) / 2)\nt = int(sys.stdin.readline())\nfor tt in range(t):\n    n = int(sys.stdin.readline())\n    arr1 = list(map(int, sys.stdin.readline().split()))\n    arr2 = list(map(int, sys.stdin.readline().split()))\n    arr = sorted(list(zip(arr1, arr2)))\n    loc = [1, 1]\n    ans = 0\n    for i in arr:\n        if list(i) == loc:\n            continue\n        ans += getCount(loc, i)\n        (loc[0], loc[1]) = (i[0], i[1])\n    print(ans)", "import math\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = []\n    for i in range(n):\n        c.append((a[i], b[i]))\n    c.sort()\n    if c[0] != (1, 1):\n        c.insert(0, (1, 1))\n        n += 1\n    cost = 0\n    for u in range(n - 1):\n        (p, q) = (c[u][0], c[u][1])\n        (r, s) = (c[u + 1][0], c[u + 1][1])\n        if abs(p - q) == abs(r - s):\n            if abs(p - q) % 2:\n                continue\n            else:\n                cost += abs(p - r)\n        else:\n            x = abs(p - q)\n            y = abs(r - s)\n            if y % 2:\n                cost += abs(x - y) // 2\n            else:\n                cost += int(math.ceil(abs(x - y) / 2))\n    print(cost)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    rc = []\n    r = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    for i in range(n):\n        rc.append([r[i], c[i]])\n    rc.sort()\n    if rc[0] != [1, 1]:\n        rc.insert(0, [1, 1])\n        n += 1\n    s = 0\n    for i in range(n - 1):\n        if rc[i][1] - rc[i][0] == rc[i + 1][1] - rc[i + 1][0] and (rc[i][1] + rc[i][0]) % 2 == 0:\n            s += rc[i + 1][0] - rc[i][0]\n        elif rc[i][1] - rc[i][0] == rc[i + 1][1] - rc[i + 1][0] and (rc[i][1] + rc[i][0]) % 2 != 0:\n            s += 0\n        elif (rc[i][1] + rc[i][0]) % 2 == 0:\n            s += (rc[i + 1][0] - rc[i][0] - (rc[i + 1][1] - rc[i][1])) // 2\n        else:\n            s += (rc[i + 1][0] - rc[i][0] - (rc[i + 1][1] - rc[i][1]) + 1) // 2\n    print(s)"]