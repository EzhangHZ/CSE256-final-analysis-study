["def nPossibleConfigurations(row1_values, row2_values):\n    puzzle = dict(zip(row1_values, row2_values))\n    nConfigurations = 1\n    for row1_value in row1_values:\n        if row1_value in puzzle:\n            row2_value = puzzle.pop(row1_value)\n            while row2_value != row1_value:\n                row2_value = puzzle.pop(row2_value)\n            nConfigurations = nConfigurations * 2 % 1000000007\n    return nConfigurations\n\ndef testCase_1534c():\n    input()\n    return (input().split(), input().split())\ntuple((print(nPossibleConfigurations(*testCase_1534c())) for x in range(int(input()))))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = input().split()\n    b = input().split()\n    d = dict(zip(a, b))\n    count = 0\n    mod = 10 ** 9 + 7\n    while d:\n        count += 1\n        (k, v) = d.popitem()\n        while v != k:\n            v = d.pop(v)\n    print(pow(2, count, mod))", "def nPossibleConfigurations(row1_values, row2_values):\n    puzzle = {value1: value2 for (value1, value2) in zip(row1_values, row2_values)}\n    nConfigurations = 1\n    for row1_value in row1_values:\n        if row1_value in puzzle:\n            row2_value = puzzle.pop(row1_value)\n            while row2_value != row1_value:\n                row2_value = puzzle.pop(row2_value)\n            nConfigurations = nConfigurations * 2 % 1000000007\n    return nConfigurations\n\ndef testCase_1534c():\n    input()\n    return (input().split(), input().split())\ntuple((print(nPossibleConfigurations(*testCase_1534c())) for x in range(int(input()))))", "for _ in range(int(input())):\n    n = int(input())\n    a = input().split()\n    b = input().split()\n    d = dict(zip(a, b))\n    count = 0\n    mod = 10 ** 9 + 7\n    while d:\n        count += 1\n        (k, v) = d.popitem()\n        while v != k:\n            v = d.pop(v)\n    print(pow(2, count, mod))", "I = input\nfor _ in [0] * int(I()):\n    I()\n    d = dict(zip(I().split(), I().split()))\n    c = 0\n    while d:\n        c += 1\n        (x, y) = d.popitem()\n        while (y := d.pop(y, 0)):\n            y\n    print(pow(2, c, 10 ** 9 + 7))", "for _ in range(int(input())):\n    n = int(input())\n    a = input().split()\n    b = input().split()\n    d = dict(zip(a, b))\n    count = 0\n    mod = 10 ** 9 + 7\n    while d:\n        count += 1\n        (k, v) = d.popitem()\n        while v != k:\n            v = d.pop(v)\n    print(pow(2, count, mod))", "for _ in [0] * int(input()):\n    input()\n    d = dict(zip(input().split(), input().split()))\n    c = 0\n    while d:\n        c += 1\n        (x, y) = d.popitem()\n        while (y := d.pop(y, 0)):\n            continue\n    print(pow(2, c, 10 ** 9 + 7))", "def nPossibleConfigurations(puzzle):\n    nConfigurations = 1\n    row1_values = puzzle.copy().keys()\n    for row1_value in row1_values:\n        if row1_value in puzzle:\n            row2_value = puzzle.pop(row1_value)\n            while row2_value != row1_value:\n                row2_value = puzzle.pop(row2_value)\n            nConfigurations = nConfigurations * 2 % 1000000007\n    return nConfigurations\n\ndef testCase_1534c():\n    input()\n    return {value1: value2 for (value1, value2) in zip(input().split(), input().split())}\ntuple((print(nPossibleConfigurations(testCase_1534c())) for x in range(int(input()))))", "def nPossibleConfigurations(row1_values, puzzle):\n    nConfigurations = 1\n    for row1_value in row1_values:\n        if row1_value in puzzle:\n            row2_value = puzzle.pop(row1_value)\n            while row2_value != row1_value:\n                row2_value = puzzle.pop(row2_value)\n            nConfigurations = nConfigurations * 2 % 1000000007\n    return nConfigurations\n\ndef testCase_1534c():\n    input()\n    row1_values = input().split()\n    return (row1_values, {value1: value2 for (value1, value2) in zip(row1_values, input().split())})\ntuple((print(nPossibleConfigurations(*testCase_1534c())) for x in range(int(input()))))", "def nPossibleConfigurations(row1_values, row2_values):\n    puzzle = {value1: value2 for (value1, value2) in zip(row1_values, row2_values)}\n    nConfigurations = 1\n    for row1_value in row1_values:\n        if row1_value in puzzle:\n            row2_value = puzzle.pop(row1_value)\n            while row2_value != row1_value:\n                row2_value = puzzle.pop(row2_value)\n            nConfigurations = (nConfigurations + nConfigurations) % 1000000007\n    return nConfigurations\n\ndef testCase_1534c():\n    input()\n    return (input().split(), input().split())\ntuple((print(nPossibleConfigurations(*testCase_1534c())) for x in range(int(input()))))", "import sys\ninf = float('inf')\nmod = 1000000007\n\ndef inputl():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef inputt():\n    return map(int, sys.stdin.readline().split())\n\ndef inputi():\n    return int(sys.stdin.readline())\n\ndef inputs():\n    return sys.stdin.readline()\n\ndef main():\n    t = inputi()\n    for _ in range(t):\n        n = inputi()\n        a = [0] + inputl()\n        b = [0] + inputl()\n        c = [0] * (n + 1)\n        vis = [0] * (n + 1)\n        ans = 1\n        for i in range(1, n + 1):\n            c[a[i]] = b[i]\n        for i in range(1, n + 1):\n            if vis[i] == 0:\n                vis[i] = 1\n                j = c[i]\n                while j != i:\n                    vis[j] = 1\n                    j = c[j]\n                ans = ans * 2 % mod\n        print(ans)\nmain()", "I = input\nfor _ in [0] * int(I()):\n    I()\n    d = dict(zip(I().split(), I().split()))\n    c = 0\n    while d:\n        c += 1\n        (x, y) = d.popitem()\n        while (y := d.pop(y, 0)):\n            y\n    print(pow(2, c, 10 ** 9 + 7))", "def readline():\n    return map(int, input().split())\nMOD = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    f = readline()\n    s = readline()\n    d = dict(zip(f, s))\n    cnt = 0\n    while d:\n        cnt += 1\n        (k, v) = d.popitem()\n        while v != k:\n            v = d.pop(v)\n    print(pow(2, cnt, MOD))\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve()\nmain()", "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    d = dict(zip(map(int, input().split()), map(int, input().split())))\n    c = 0\n    while d:\n        c += 1\n        (x, y) = d.popitem()\n        while y != x:\n            y = d.pop(y)\n    print((1 << c) % int(1000000000.0 + 7))", "I = input\nfor _ in [0] * int(I()):\n    I()\n    d = dict(zip(I().split(), I().split()))\n    c = 0\n    while d:\n        c += 1\n        (x, y) = d.popitem()\n        while (y := d.pop(y, 0)):\n            y\n    print(pow(2, c, 10 ** 9 + 7))", "I = input\nfor _ in [0] * int(I()):\n    I()\n    d = dict(zip(I().split(), I().split()))\n    c = 0\n    while d:\n        c += 1\n        (x, y) = d.popitem()\n        while (y := d.pop(y, 0)):\n            y\n    print(pow(2, c, 10 ** 9 + 7))", "def num_cycles(d):\n    c = 0\n    seen = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if seen[i]:\n            continue\n        c += 1\n        p = d[i]\n        seen[i] = 1\n        while not seen[p]:\n            seen[p] = 1\n            p = d[p]\n    return c\nfor _ in range(int(input())):\n    n = int(input())\n    line1 = [0] + list(map(int, input().split()))\n    d = [0] * (n + 1)\n    for (i, x) in enumerate(map(int, input().split()), start=1):\n        d[x] = line1[i]\n    ans = pow(2, num_cycles(d), 10 ** 9 + 7)\n    print(ans)", "from math import *\nfrom collections import *\nfrom functools import *\nfrom bisect import *\nfrom itertools import *\nfrom heapq import *\ninf = float('inf')\nninf = -float('inf')\nip = input\nalphal = 'abcdefghijklmnopqrstuvwxyz'\nalphau = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nmod = 10 ** 9 + 7\n\ndef ipl():\n    return list(map(int, ip().split()))\n\ndef ipn():\n    return int(ip())\n\ndef ipf():\n    return float(ip())\n\ndef solve():\n    n = ipn()\n    (a, b) = (ipl(), ipl())\n    g = [-1 for _ in range(n + 1)]\n    for i in range(n):\n        g[a[i]] = b[i]\n    v = [False] * (n + 1)\n    r = 0\n    for i in range(1, n + 1):\n        if v[i]:\n            continue\n        r += 1\n        j = i\n        while not v[j]:\n            v[j] = True\n            j = g[j]\n    res = 1\n    for i in range(r):\n        res = res * 2 % mod\n    print(res)\nt = ipn()\nfor _ in range(t):\n    solve()", "t = int(input())\nmod = 10 ** 9 + 7\nfor i in range(t):\n    n = int(input())\n    r1 = list(map(int, input().split()))\n    r2 = list(map(int, input().split()))\n    mat = dict(zip(r1, r2))\n    cnt = 0\n    while len(mat) != 0:\n        cnt += 1\n        d = mat.popitem()\n        (a, b) = (d[0], d[1])\n        while a != b:\n            b = mat.pop(b)\n    print(2 ** cnt % mod)", "import math\nimport sys\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef input():\n    return sys.stdin.readline().strip()\nMOD = 10 ** 9 + 7\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = get_array()\n        b = get_array()\n        vis = [False] * n\n        ind_a = [-1] * (n + 1)\n        for i in range(n):\n            ind_a[a[i]] = i\n        ans = 0\n        for i in range(n):\n            if vis[i]:\n                continue\n            ans += 1\n            vis[i] = True\n            val = b[i]\n            while val != a[i]:\n                next_ind = ind_a[val]\n                vis[next_ind] = True\n                val = b[next_ind]\n        print(pow(2, ans, MOD))\nmain()", "def nPossibleConfigurations(puzzleLength, puzzle):\n    nConfigurations = 1\n    for row1_value in range(1, puzzleLength):\n        if row1_value in puzzle:\n            row2_value = puzzle.pop(row1_value)\n            while row2_value != row1_value:\n                row2_value = puzzle.pop(row2_value)\n            nConfigurations = nConfigurations * 2 % 1000000007\n    return nConfigurations\n\ndef testCase_1534c():\n    return (int(input()), {v1: v2 for (v1, v2) in zip(map(int, input().split()), map(int, input().split()))})\ntuple((print(nPossibleConfigurations(*testCase_1534c())) for x in range(int(input()))))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    d = dict(zip(a, b))\n    count = 0\n    mod = 10 ** 9 + 7\n    while d:\n        count += 1\n        (k, v) = d.popitem()\n        while v != k:\n            v = d.pop(v)\n    print(pow(2, count, mod))", "import math\n\ndef main_function():\n    test_cases = range(int(input()))\n    for test_case in test_cases:\n        n = int(input())\n        a = [int(j) for j in input().split(' ')]\n        hash_a = [0 for i in range(n + 1)]\n        b = [int(k) for k in input().split(' ')]\n        for i in range(len(a)):\n            hash_a[a[i]] = i\n        counter = 0\n        is_already_used = [False for i in range(len(a))]\n        for i in range(n):\n            if not is_already_used[i]:\n                real_start = a[i]\n                end = b[i]\n                is_already_used[i] = True\n                while real_start != end:\n                    index_i = hash_a[end]\n                    is_already_used[index_i] = True\n                    end = b[index_i]\n                else:\n                    counter += 1\n        if counter == 1:\n            print(2)\n        else:\n            print(2 ** counter % (10 ** 9 + 7))\nmain_function()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = 1\n    total = 0\n    d = dict(zip(list(map(int, input().split(' '))), list(map(int, input().split(' ')))))\n    (x, y) = d.popitem()\n    while len(d) > 0:\n        if y == x:\n            ans += 1\n            (x, y) = d.popitem()\n        else:\n            y = d.pop(y)\n    total = 2 ** ans\n    print(total % (10 ** 9 + 7))", "import os, sys, time, collections, math, pprint, itertools as it, operator as op, bisect as bs, functools as fn\n(maxx, localsys, mod) = (float('inf'), 0, int(1000000000.0 + 7))\nnCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)\nceil = lambda n, x: (n + x - 1) // x\n(osi, oso) = ('/home/priyanshu/Documents/cp/input.txt', '/home/priyanshu/Documents/cp/output.txt')\nif os.path.exists(osi):\n    sys.stdin = open(osi, 'r')\n    sys.stdout = open(oso, 'w')\ninput = sys.stdin.readline\n\ndef maps():\n    return map(int, input().split())\nsys.setrecursionlimit(500000)\nfor _ in range(int(input())):\n    n = int(input())\n    (a, b) = (list(maps()), list(maps()))\n    (d, ans) = ({a[i]: b[i] for i in range(n)}, 0)\n    while d:\n        ans += 1\n        (k, v) = d.popitem()\n        while k != v:\n            v = d.pop(v)\n    print(pow(2, ans, mod))", "def solve(permutation, n):\n    visited = [False] * n\n    cycles_count = 0\n    for i in range(n):\n        current = i\n        if not visited[current]:\n            cycles_count += 1\n        while not visited[current]:\n            visited[current] = True\n            current = permutation[current]\n    return 2 ** cycles_count\nt = int(input())\nMODULO = 10 ** 9 + 7\nfor _ in range(t):\n    n = int(input())\n    perm1 = list(map(lambda x: int(x) - 1, input().split()))\n    perm2 = list(map(lambda x: int(x) - 1, input().split()))\n    permutation = [0] * n\n    for i in range(n):\n        permutation[perm1[i]] = perm2[i]\n    print(solve(permutation, n) % MODULO)", "def l_a_p(n, row1, row2):\n    used = [False] * n\n    row2_number_to_id = {}\n    for (i, x) in enumerate(row2):\n        row2_number_to_id[x] = i\n    cycles = 0\n    i = 0\n    while i < n:\n        if not used[i]:\n            k = i\n            used[k] = True\n            last = row2[k]\n            next = -1\n            while last != next:\n                curr = row1[k]\n                k = row2_number_to_id[curr]\n                used[k] = True\n                next = row1[k]\n            cycles += 1\n        i += 1\n    return int(pow(2, cycles, int(1000000000.0 + 7)))\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        row1 = [int(x) for x in input().split()]\n        row2 = [int(x) for x in input().split()]\n        print(l_a_p(n, row1, row2))\nsolve()", "MOD = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    adj = [0] * n\n    vis = [0] * n\n    for i in range(n):\n        adj[a[i] - 1] = b[i] - 1\n    res = 1\n    for i in range(n):\n        if vis[i] == 0:\n            v = i\n            vis[v] = 1\n            while vis[adj[v]] == 0:\n                v = adj[v]\n                vis[v] = 1\n            res = res * 2 % MOD\n    print(res)", "mod = 10 ** 9 + 7\n\ndef solve(A, n):\n    goto = {}\n    for i in range(n):\n        goto[A[0][i]] = A[1][i]\n    cycle = 0\n    done = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if done[i]:\n            continue\n        cycle += 1\n        while done[i] == False:\n            nxt = goto[i]\n            done[i] = True\n            i = nxt\n    return pow(2, cycle, mod)\nfor case in range(int(input())):\n    n = int(input())\n    A = []\n    for i in range(2):\n        li = list(map(int, input().split()))\n        A.append(li)\n    ans = solve(A, n)\n    print(ans)", "def sol(A, B):\n    dic = {}\n    for (a, b) in zip(A, B):\n        dic[a] = b\n    visited = [False for _ in range(len(A) + 1)]\n    count = 0\n    for a in A:\n        if not visited[a]:\n            i = a\n            visited[i] = True\n            while not visited[dic[i]]:\n                visited[dic[i]] = True\n                i = dic[i]\n            count += 1\n    return 2 ** count % 1000000007\nx = int(input())\nfor _ in range(x):\n    y = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(sol(A, B))", "for _ in range(int(input())):\n    x = 1\n    n = int(input())\n    a = [list(map(int, input().split())) for col in range(2)]\n    pairs = [0] * (n + 1)\n    for i in range(n):\n        pairs[a[0][i]] = a[1][i]\n    marked = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not marked[i]:\n            x *= 2\n            x %= 1000000007\n            s = [i]\n            while True:\n                r = s.pop()\n                marked[r] = True\n                if not marked[pairs[r]]:\n                    s.append(pairs[r])\n                else:\n                    break\n    print(x)", "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if a[i] == b[i]:\n            print(0)\n            return\n    cc = 0\n    d = {}\n    for i in range(n):\n        d[a[i]] = b[i]\n    marked = [False] * (n + 1)\n    for x in a:\n        if not marked[x]:\n            cc += 1\n            z = x\n            while not marked[z]:\n                marked[z] = True\n                z = d[z]\n    ans = 1\n    for i in range(cc):\n        ans *= 2\n        ans %= 10 ** 9 + 7\n    print(ans)\n\ndef main():\n    for _ in range(int(input())):\n        solve()\nmain()", "for _ in range(int(input())):\n    count = 0\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    dicio = dict()\n    while count != n:\n        dicio[a[count]] = b[count]\n        count += 1\n    (valorDado, contador, matriz) = (1000000007, 0, [0] * n)\n    for i in range(1, n + 1):\n        if matriz[i - 1]:\n            continue\n        posicaoAtual = dicio[i]\n        matriz[i - 1] = 1\n        contador += 1\n        while posicaoAtual != i:\n            matriz[posicaoAtual - 1] = 1\n            posicaoAtual = dicio[posicaoAtual]\n    print(pow(2, contador, valorDado))", "m = int(input())\nc = 10 ** 9 + 7\nfor i in range(m):\n    n = int(input())\n    ar1 = list(map(int, input().split()))\n    ar2 = list(map(int, input().split()))\n    gr = dict()\n    nv = set(ar1)\n    for j in range(n):\n        gr[ar1[j]] = ar2[j]\n    result = 0\n    while len(nv) != 0:\n        a = nv.pop()\n        temp = 0\n        while a != temp:\n            if temp == 0:\n                temp = a\n            temp = gr[temp]\n            if a == temp:\n                break\n            nv.remove(temp)\n        result += 1\n    print(2 ** result % c)", "for _ in range(int(input())):\n    x = 0\n    n = int(input())\n    a = [list(map(int, input().split())) for col in range(2)]\n    pairs = [0] * (n + 1)\n    for i in range(n):\n        pairs[a[0][i]] = a[1][i]\n    marked = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not marked[i]:\n            x += 1\n            s = [i]\n            while True:\n                r = s.pop()\n                marked[r] = True\n                if not marked[pairs[r]]:\n                    s.append(pairs[r])\n                else:\n                    break\n    w = 1\n    for i in range(x):\n        w *= 2\n        w %= 1000000007\n    print(w)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    p = [None] * (n + 1)\n    for i in range(n):\n        p[a[i]] = i\n    c = 0\n    w = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not w[i]:\n            c += 1\n            q = [i]\n            qi = 0\n            while qi < len(q):\n                x = q[qi]\n                qi += 1\n                v = b[p[x]]\n                if not w[v]:\n                    w[v] = True\n                    q.append(v)\n    print(pow(2, c, int(1000000000.0 + 7)))\nfor i in range(int(input())):\n    solve()", "import math\n\ndef task():\n    n = int(input())\n    grid = []\n    grid.append(list(map(int, input().split())))\n    grid.append(list(map(int, input().split())))\n    pos = {}\n    done = set()\n    for i in range(n):\n        e = grid[0][i]\n        pos[e] = i\n    c = 0\n    for i in range(n):\n        e = grid[1][i]\n        if e in done:\n            continue\n        c += 1\n        temp = e\n        done.add(temp)\n        temp = grid[1][pos[e]]\n        while temp != e:\n            done.add(temp)\n            temp = grid[1][pos[temp]]\n    print(2 ** c % (10 ** 9 + 7))\nt = int(input())\nfor _ in range(t):\n    task()", "def solve(length, row1, row2):\n    edges = {}\n    for k in range(length):\n        edges[row1[k]] = row2[k]\n    cycles = 0\n    visited = set([])\n    for k in range(length):\n        if row1[k] in visited:\n            continue\n        cycles += 1\n        current = row1[k]\n        while current not in visited:\n            visited.add(current)\n            current = edges[current]\n    return 2 ** cycles % (10 ** 9 + 7)\ntests = int(input())\nfor test in range(tests):\n    length = int(input())\n    row1 = [int(inp) for inp in input().split()]\n    row2 = [int(inp) for inp in input().split()]\n    print(solve(length, row1, row2))", "R = input\nI = lambda : [*map(int, R().split())]\nfor _ in '*' * int(R()):\n    n = int(R())\n    q = {}\n    (a, b) = (I(), I())\n    for i in range(n):\n        q[a[i]] = b[i]\n    t = 0\n    for i in a:\n        j = i\n        if b[i - 1] != 0:\n            t += 1\n            while q[j] != i:\n                b[j - 1] = 0\n                j = q[j]\n            b[j - 1] = 0\n    print(pow(2, t, 10 ** 9 + 7))", "for _ in range(int(input())):\n    x = 0\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    pairs = {}\n    for i in range(n):\n        pairs[a[i]] = b[i]\n    marked = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not marked[i]:\n            x += 1\n            s = [i]\n            while True:\n                r = s.pop()\n                marked[r] = True\n                if not marked[pairs[r]]:\n                    s.append(pairs[r])\n                else:\n                    break\n    w = 1\n    for i in range(x):\n        w *= 2\n        w %= 1000000007\n    print(w)", "import sys\nsys.setrecursionlimit(10 ** 7)\nfor _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr1 = list(map(int, input().split()))\n    d1 = {}\n    d2 = {}\n    for i in range(n):\n        d1[arr[i]] = arr1[i]\n    vis = {}\n    count = 0\n    mod = 10 ** 9 + 7\n    for i in arr1:\n        if i not in vis:\n            j = d1[i]\n            vis[i] = True\n            while j not in vis:\n                vis[j] = True\n                j = d1[j]\n            count += 1\n    print(pow(2, count, 10 ** 9 + 7))", "import sys\nsys.setrecursionlimit(100000000)\n\ndef put(n):\n    global d1\n    global an\n    f = d1[n]\n    if f == 'stop':\n        return 5\n    d1[n] = 'stop'\n    if d1[f] == 'stop':\n        an = an * 2 % (10 ** 9 + 7)\n        return 1\n    put(f)\nfor ij in range(int(input())):\n    d1 = {}\n    an = 1\n    n = int(input())\n    f = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    for i in range(len(f)):\n        d1[f[i]] = s[i]\n    bil = set()\n    for i in range(1, n + 1):\n        sei = 'dd'\n        if i not in bil:\n            an = an * 2 % (10 ** 9 + 7)\n            sei = i\n            while sei not in bil:\n                bil.add(sei)\n                sei = d1[sei]\n    print(an)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    l = []\n    d = {}\n    for j in range(n):\n        l.append(0)\n        l1[j] -= 1\n        l2[j] -= 1\n        d[l1[j]] = l2[j]\n    c = 0\n    for j in range(n):\n        if l[l1[j]] == 0:\n            c += 1\n            a = l1[j]\n            while l[a] == 0:\n                l[a] = 1\n                a = d[a]\n    print(2 ** c % (10 ** 9 + 7))", "def solve(la, lb):\n    da = {a: i for (i, a) in enumerate(la)}\n    s = set()\n    c = 0\n    for a in la:\n        v = a\n        c += v not in s\n        while v not in s:\n            s |= {v}\n            v = lb[da[v]]\n    return pow(2, c, int(1000000000.0 + 7))\nfor _ in '_' * int(input()):\n    input()\n    print(solve([*map(int, input().split())], [*map(int, input().split())]))", "t = int(input())\nanswers = list()\nmodulus = 10 ** 9 + 7\nfor _ in range(t):\n    n = int(input())\n    a = map(int, input().split())\n    b = map(int, input().split())\n    edges = dict()\n    ans = 1\n    for (i, j) in zip(a, b):\n        edges[i] = j\n    used = set(range(1, n + 1))\n    while len(used) > 0:\n        elem = used.pop()\n        while edges[elem] in used:\n            used.remove(edges[elem])\n            elem = edges[elem]\n        ans = ans * 2 % modulus\n    answers.append(ans)\nfor k in range(t):\n    print(answers[k])", "for t in range(int(input())):\n    n = int(input())\n    a = [int(s) for s in input().split()]\n    b = [int(s) for s in input().split()]\n    c = [-1 for i in range(n)]\n    for i in range(n):\n        c[a[i] - 1] = b[i] - 1\n    count_loops = 0\n    for i in range(n):\n        if c[i] < 0:\n            continue\n        count_loops += 1\n        j = i\n        while True:\n            k = c[j]\n            c[j] = -1\n            j = k\n            if i == j:\n                break\n    res = 1\n    x = 10 ** 9 + 7\n    for i in range(count_loops):\n        res *= 2\n        res %= x\n    print(res)", "mas = list(map(int, input().split()))\nt = mas[0]\nfor j in range(t):\n    mas = list(map(int, input().split()))\n    n = mas[0]\n    mas1 = list(map(int, input().split()))\n    mas2 = list(map(int, input().split()))\n    dct = {mas1[i]: mas2[i] for i in range(n)}\n    start = 2\n    st = 1\n    s = 0\n    ok = True\n    for i in range(n):\n        st = dct.pop(st, -1)\n        if st == -1:\n            s += 1\n            okk = True\n            while okk:\n                st = dct.pop(start, -1)\n                start += 1\n                if st != -1:\n                    okk = False\n    pr = 1\n    for i in range(s + 1):\n        pr = pr * 2 % 1000000007\n    if ok == True:\n        print(pr)\n    else:\n        print(0)", "from collections import Counter, defaultdict, deque\nimport math\nfrom heapq import *\nimport sys\ninput = sys.stdin.readline\nMOD = 10 ** 9 + 7\n\ndef solve():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    look = dict()\n    for i in range(n):\n        look[a[i]] = i\n    unseen = set((x for x in range(n)))\n    p = 0\n    c = 0\n    while p < n:\n        if p not in unseen:\n            p += 1\n            continue\n        start = a[p]\n        cur = b[p]\n        unseen.remove(p)\n        while start != cur:\n            unseen.remove(look[cur])\n            cur = b[look[cur]]\n        c += 1\n    print(pow(2, c, MOD))\ntt = int(input())\nfor test in range(tt):\n    solve()", "import sys\n\ndef readnum():\n    input = sys.stdin.readline\n    a = list(map(int, input().split()))\n    return a\n\ndef printf(val):\n    sys.stdout.write(str(val) + '\\n')\n\ndef power(a, b, mod):\n    if b == 1:\n        return a\n    if b == 0:\n        return 1\n    ans = power(a, b // 2, mod)\n    ans *= ans\n    if b % 2:\n        ans *= a\n    ans = ans % mod\n    return ans\nt = readnum()[0]\nfor _ in range(t):\n    n = readnum()[0]\n    arr1 = readnum()\n    arr2 = readnum()\n    arr_rev = [0] * len(arr1)\n    starting_points = set([i for i in range(len(arr1))])\n    for i in range(len(arr1)):\n        arr_rev[arr1[i] - 1] = i\n    res = 0\n    while len(starting_points) > 0:\n        p = starting_points.pop()\n        end_p = p\n        next_p = -1\n        while next_p != end_p:\n            next_p = arr2[arr_rev[p]] - 1\n            if next_p == end_p:\n                break\n            starting_points.remove(next_p)\n            p = next_p\n        res += 1\n    print(power(2, res, 10 ** 9 + 7))", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    f = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    r = [0] * n\n    for i in range(n):\n        r[f[i] - 1] = i\n    ans = 1\n    d = [0] * n\n    for i in range(n):\n        if d[i] == 1:\n            continue\n        ans = ans * 2 % mod\n        j = i\n        while d[r[s[j] - 1]] == 0:\n            d[r[s[j] - 1]] = 1\n            j = r[s[j] - 1]\n    print(ans)", "import sys\nimport math\nimport heapq\n\ndef input():\n    return sys.stdin.readline().strip('\\n')\n\ndef I():\n    return input()\n\ndef II():\n    return int(input())\n\ndef MI():\n    return map(int, input().split())\n\ndef LI():\n    return list(map(int, input().split()))\n\ndef isPerfectSquare(x):\n    return int(math.sqrt(x)) ** 2 == x\nsys.setrecursionlimit(500000)\nfrom collections import OrderedDict\nMOD = 10 ** 9 + 7\nfor _ in range(II()):\n    graph = {}\n\n    def dfs(x):\n        if not visited[x]:\n            visited[x] = 1\n            dfs(graph[x])\n    n = II()\n    a = LI()\n    b = LI()\n    visited = [0] * (n + 1)\n    for i in range(n):\n        graph[a[i]] = b[i]\n    ans = 1\n    for i in range(n):\n        if visited[a[i]] == 0:\n            nxt = a[i]\n            while visited[nxt] == 0:\n                visited[nxt] = 1\n                nxt = graph[nxt]\n            ans = ans * 2 % MOD\n    print(ans)", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    n = int(input())\n    f = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    r = [0] * n\n    for i in range(n):\n        r[f[i] - 1] = i\n    ans = 1\n    d = set()\n    for i in range(n):\n        if i in d:\n            continue\n        ans = ans * 2 % mod\n        j = i\n        while r[s[j] - 1] not in d:\n            d.add(r[s[j] - 1])\n            j = r[s[j] - 1]\n    print(ans)", "iter = int(input())\nfor iters in range(iter):\n    n = int(input())\n    test_keys = [int(i) for i in input().split(' ')]\n    test_values = [int(i) for i in input().split(' ')]\n    dict_array = [0] * (n + 1)\n    for (i, j) in enumerate(test_keys):\n        dict_array[j] = test_values[i]\n    array = [False] * (n + 1)\n    number = 0\n    for i in range(1, n + 1):\n        if array[i] == False:\n            array[i] = True\n            found = False\n            a = i\n            start = a\n            while found != True:\n                b = dict_array[a]\n                array[b] = True\n                a = b\n                if b == start:\n                    found = True\n                    number = number + 1\n    print(2 ** number % (10 ** 9 + 7))", "def calc():\n    n = int(input())\n    p = list(map(int, input().split(' ')))\n    q = list(map(int, input().split(' ')))\n    parent = [-1] * (n + 1)\n    pinx = [-1] * (n + 1)\n    qinx = [-1] * (n + 1)\n    for i in range(n):\n        pinx[p[i]] = i\n        qinx[q[i]] = i\n    k = -1\n    for i in range(n):\n        if p[i] == q[i]:\n            print(0)\n            return\n        x = p[i]\n        if parent[x] == -1:\n            k += 1\n        while parent[x] == -1:\n            parent[x] = k\n            inx = pinx[x]\n            x = q[inx]\n    print(2 ** (k + 1) % 1000000007)\nt = int(input())\nfor _i in range(t):\n    calc()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    s = [0] * (n + 1)\n    al = set()\n    for i in range(1, n + 1):\n        al.add(i)\n    for i in range(n):\n        s[a[i]] = b[i]\n    cnt = 0\n    for i in range(1, n + 1):\n        if i not in al:\n            continue\n        else:\n            last = i\n            while last in al:\n                al.discard(last)\n                last = s[last]\n            cnt += 1\n    ans = 1\n    for i in range(cnt):\n        ans *= 2\n        ans = ans % (10 ** 9 + 7)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s0 = list(map(int, input().split()))\n    s1 = list(map(int, input().split()))\n    p = [0] * n\n    for i in range(n):\n        p[s0[i] - 1] = s1[i] - 1\n    b = [True] * n\n    r = 0\n    for i in range(n):\n        if b[i]:\n            r += 1\n            j = i\n            while b[j]:\n                b[j] = False\n                j = p[j]\n    res = 1\n    for i in range(r):\n        res = 2 * res % 1000000007\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d[a[i]] = b[i]\n    v = [False] * (n + 1)\n    x = 0\n    for i in range(1, n + 1):\n        if v[i] == False:\n            s = [i]\n            x += 1\n            while True:\n                r = s.pop()\n                v[r] = True\n                if v[d[r]] == False:\n                    s.append(d[r])\n                else:\n                    break\n    w = 1\n    for i in range(x):\n        w *= 2\n        w %= 1000000007\n    print(w)", "def main():\n\n    def input():\n        return sys.stdin.readline().strip('\\n')\n\n    def I():\n        return input()\n\n    def II():\n        return int(input())\n\n    def MI():\n        return map(int, input().split())\n\n    def LI():\n        return list(map(int, input().split()))\n\n    def isPerfectSquare(x):\n        return int(math.sqrt(x)) ** 2 == x\n    sys.setrecursionlimit(500000)\n    from collections import OrderedDict\n    MOD = 10 ** 9 + 7\n\n    def dfs(x):\n        if not visited[x]:\n            visited[x] = 1\n            dfs(graph[x])\n    for _ in range(II()):\n        n = II()\n        a = LI()\n        b = LI()\n        graph = {}\n        visited = [0] * (n + 1)\n        for i in range(n):\n            graph[a[i]] = b[i]\n        ans = 1\n        for i in range(n):\n            if visited[a[i]] == 0:\n                dfs(a[i])\n                ans = ans * 2 % MOD\n        print(ans)\nimport sys, threading\nimport bisect\nimport math\nimport itertools\nfrom sys import stdout\nimport heapq\nfrom queue import PriorityQueue\nsys.setrecursionlimit(2 ** 32 // 2 - 1)\nthreading.stack_size(1 << 27)\ninput = sys.stdin.readline\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy, sys\nfrom sys import stdin, stdout\n\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n\ndef nc():\n    return map(int, ns().split())\n\ndef narr():\n    return list(map(int, ns().split()))\n\ndef ns():\n    return input()\n\ndef ni():\n    return int(input())\nt = ni()\nfor _ in range(t):\n    n = ni()\n    a = narr()\n    b = narr()\n    vis = [False] * n\n    ind = [0] * n\n    ans = 1\n    mod = 1000000007\n    for i in range(n):\n        ind[a[i] - 1] = i\n    for i in range(n):\n        x = i\n        if not vis[x]:\n            ans = ans * 2 % mod\n        while not vis[x]:\n            vis[x] = True\n            x = ind[b[x] - 1]\n    print(ans)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d1 = dict()\n    mod = 1000000007\n    for i in range(n):\n        d1.setdefault(a[i], b[i])\n    c = 0\n    d2 = dict()\n    for i in range(n):\n        if not d2.get(a[i]):\n            d2.setdefault(a[i], 1)\n            prev = d1[a[i]]\n            a[i] = -1\n            while not d2.get(prev):\n                d2.setdefault(prev, 1)\n                prev = d1[prev]\n            c += 1\n    print(power(2, c, mod))", "t = input()\nmod = 1000000000.0 + 7\nfor i in range(int(t)):\n    n = input()\n    list_1 = input().split(' ')\n    list_2 = input().split(' ')\n    a = [False] * int(n)\n    b = [0] * int(n)\n    for i in range(int(n)):\n        list_1[i] = int(list_1[i]) - 1\n        list_2[i] = int(list_2[i]) - 1\n        b[int(list_1[i])] = int(list_2[i])\n    solution = 1\n    x = 0\n    for i in range(int(n)):\n        if not a[i]:\n            solution = solution * 2 % mod\n            x = i\n            while not a[x]:\n                a[x] = True\n                x = b[x]\n    print(int(solution))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    v1 = list(map(int, input().split()))\n    v2 = list(map(int, input().split()))\n    l = [0] * (n + 1)\n    for i in range(n):\n        l[v1[i]] = i\n    c = [-1] * n\n    w = -1\n    ans = 1\n    for i in range(n):\n        sz = 0\n        ptr = i\n        if c[ptr] == -1:\n            w += 1\n        while c[ptr] == -1:\n            c[ptr] = w\n            ptr = l[v2[ptr]]\n            sz += 1\n        if sz > 0:\n            ans *= 2\n            ans %= 1000000007\n    print(ans)", "a = []\nb = []\nva = []\nvb = []\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    va = [0] * (n + 1)\n    vb = [0] * (n + 1)\n    c = 0\n    for i in range(n):\n        if va[b[i]] == a[i]:\n            c += 1\n        elif va[b[i]] > 0 and vb[a[i]] > 0:\n            vb[va[b[i]]] = vb[a[i]]\n            va[vb[a[i]]] = va[b[i]]\n        elif va[b[i]] > 0:\n            va[a[i]] = va[b[i]]\n            vb[va[b[i]]] = a[i]\n        elif vb[a[i]] > 0:\n            vb[b[i]] = vb[a[i]]\n            va[vb[a[i]]] = b[i]\n        else:\n            va[a[i]] = b[i]\n            vb[b[i]] = a[i]\n    print(pow(2, c, 1000000007))", "T = int(input())\nfor i in range(T):\n    n = int(input())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    graph = {}\n    for i in range(n):\n        graph[arr1[i]] = i\n    seen = set()\n    count = 0\n    for i in range(n):\n        if i not in seen:\n            count += 1\n            while i not in seen:\n                seen.add(i)\n                (arr1[i], arr2[i]) = (arr2[i], arr1[i])\n                i = graph[arr1[i]]\n    ans = 2 ** count % (10 ** 9 + 7)\n    print(ans)", "from collections import deque, Counter\nfrom collections import defaultdict as dfd\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial\nfrom heapq import heapify, heappush, heappop\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef readfl():\n    return list(map(float, input().strip().split()))\n\ndef readffl():\n    return list(map(float, file.readline().strip().split()))\n\ndef solve():\n\n    def find(x):\n        while par[x] != x:\n            par[x] = par[par[x]]\n            x = par[x]\n        return x\n    for _ in range(nin()):\n        n = nin()\n        mat = [read() for i in range(2)]\n        par = [i for i in range(n + 1)]\n        for i in range(n):\n            par[find(mat[0][i])] = find(mat[1][i])\n        dic = dfd(int)\n        for i in range(1, n + 1):\n            dic[find(i)] += 1\n        ans = 0\n        for i in dic:\n            ans += 1\n        ans_.append(pow(2, ans, MOD))\nsolve()\nfor i in ans_:\n    print(i)", "from collections import deque, Counter\nfrom collections import defaultdict as dfd\nfrom bisect import bisect, bisect_left\nfrom math import sqrt, gcd, ceil, factorial\nfrom heapq import heapify, heappush, heappop\nMOD = 10 ** 9 + 7\ninf = float('inf')\nans_ = []\n\ndef nin():\n    return int(input())\n\ndef ninf():\n    return int(file.readline())\n\ndef st():\n    return input().strip()\n\ndef stf():\n    return file.readline().strip()\n\ndef read():\n    return list(map(int, input().strip().split()))\n\ndef readf():\n    return list(map(int, file.readline().strip().split()))\n\ndef readfl():\n    return list(map(float, input().strip().split()))\n\ndef readffl():\n    return list(map(float, file.readline().strip().split()))\n\ndef solve():\n\n    def find(x):\n        while par[x] != x:\n            par[x] = par[par[x]]\n            x = par[x]\n        return x\n    for _ in range(nin()):\n        n = nin()\n        mat = [read() for i in range(2)]\n        par = [i for i in range(n + 1)]\n        for i in range(n):\n            par[find(mat[0][i])] = find(mat[1][i])\n        st = set()\n        for i in range(1, n + 1):\n            st.add(find(i))\n        ans_.append(pow(2, len(st), MOD))\nsolve()\nfor i in ans_:\n    print(i)", "test_case_num = int(input())\nMODULE = 10 ** 9 + 7\nfor _ in range(test_case_num):\n    n = int(input())\n    cycles = 0\n    first_line = []\n    second_line = []\n    first_dict = {}\n    for (i, x) in enumerate(input().split()):\n        first_line.append(x)\n        first_dict[x] = i\n    for (i, x) in enumerate(input().split()):\n        second_line.append(x)\n    used_nums = set()\n    for (i, x) in enumerate(first_line):\n        if x in used_nums:\n            continue\n        else:\n            start = x\n            end = second_line[i]\n            used_nums.add(start)\n            used_nums.add(end)\n            cycles += 1\n            while start != end:\n                new_index = first_dict[end]\n                end = second_line[new_index]\n                used_nums.add(end)\n    answer = 2 ** cycles % MODULE\n    print(answer)", "def solve():\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    combined = zip(A, B)\n    combined = sorted(combined, key=lambda x: x[0])\n    B_perm = [x[1] for x in combined]\n    node___color = [-1 for x in B_perm]\n    color = 0\n    cycles = []\n    for start_node in range(n):\n        if node___color[start_node] != -1:\n            continue\n        node___color[start_node] = color\n        curr_node = start_node\n        cycle_size = 1\n        while True:\n            next_node = B_perm[curr_node] - 1\n            if next_node == start_node:\n                break\n            node___color[next_node] = color\n            cycle_size += 1\n            curr_node = next_node\n        cycles.append((cycle_size, color))\n        color += 1\n    print(pow(2, len(cycles), 10 ** 9 + 7))\nt = int(input())\nfor _ in range(t):\n    solve()", "def pow_h(base, degree, module):\n    ans = 1\n    while degree > 0:\n        if degree % 2 == 1:\n            ans *= base\n            ans = ans % module\n        base = base ** 2\n        base = base % module\n        degree //= 2\n    return ans\nt = int(input())\nfor k in range(t):\n    n = int(input())\n    a = [list(map(int, input().split())), list(map(int, input().split())), list(map(lambda p: 0, list(range(n))))]\n    place = list(range(n + 1))\n    for i in range(n):\n        place[a[0][i]] = i\n    cnt = 0\n    for i in range(n):\n        if a[2][i] == 0:\n            cnt += 1\n            a[2][i] = 1\n            j = a[1][i]\n            while place[j] != i:\n                a[2][place[j]] = i + 1000000\n                j = a[1][place[j]]\n    print(pow_h(2, cnt, 1000000007))", "for _ in range(int(input())):\n    n = int(input())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    l1i = [0] * n\n    l2i = [0] * n\n    v = [0] * n\n    c = 0\n    for i in range(n):\n        l1i[l1[i] - 1] = i\n    for i in range(n):\n        l2i[l2[i] - 1] = i\n    for j in range(n):\n        if v[j] == 0:\n            v[j] = 1\n            a1 = l1[j]\n            a2 = l2[j]\n            v[j] = 1\n            c += 1\n            while a1 != -1 and a2 != -1:\n                if a1 != -1:\n                    i2 = l2i[a1 - 1]\n                    if v[i2] == 0:\n                        v[i2] = 1\n                        p = l1[i2]\n                    else:\n                        p = -1\n                if a2 != -1:\n                    i1 = l1i[a2 - 1]\n                    if v[i1] == 0:\n                        v[i1] = 1\n                        q = l2[i1]\n                    else:\n                        q = -1\n                a1 = p\n                a2 = q\n    ans = 1\n    for i in range(c):\n        ans = 2 * ans % 1000000007\n    print(ans)", "t = int(input())\nm = 10 ** 9 + 7\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    apos = dict()\n    bpos = dict()\n    for i in range(n):\n        apos[a[i]] = i + 1\n        bpos[b[i]] = i + 1\n    cyc = 0\n    ans = 1\n    check = [-1] * (n + 1)\n    for i in range(n):\n        t = a[i]\n        if check[t] == -1:\n            while check[t] < 0:\n                check[t] = cyc\n                t = b[apos[t] - 1]\n            cyc += 1\n            ans = ans * 2 % m\n    print(ans)", "import math\nmod = 10 ** 9\nmod += 7\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    crr = [0 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        crr[arr[i - 1]] = brr[i - 1]\n    cnt = [0 for i in range(n + 1)]\n    ans = 0\n    dic = {}\n    for i in range(1, n + 1):\n        if not dic.get(i):\n            ans += 1\n            dic[i] = 1\n            dic[crr[i]] = 1\n            ones = 2\n            twos = 0\n            last = crr[i]\n            while ones != twos:\n                a1 = last\n                b1 = crr[last]\n                if dic.get(a1):\n                    dic[a1] += 1\n                    twos += 1\n                else:\n                    dic[a1] = 1\n                    ones += 1\n                if dic.get(b1):\n                    dic[b1] += 1\n                    twos += 1\n                else:\n                    dic[b1] = 1\n                    ones += 1\n                last = b1\n    print(pow(2, ans, mod))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    res = 0\n    s0 = list(map(int, input().split()))\n    s1 = list(map(int, input().split()))\n    p0 = [0] * n\n    p1 = [0] * n\n    for i in range(n):\n        s0[i] -= 1\n        p0[s0[i]] = i\n        s1[i] -= 1\n        p1[s1[i]] = i\n    b = [True] * n\n    r = 0\n    for i in range(n):\n        if b[i]:\n            r += 1\n            j = i\n            while b[j]:\n                b[j] = False\n                k = s1[j]\n                j = p0[k]\n    res = 1\n    for _ in range(r):\n        res = 2 * res % 1000000007\n    print(res)", "class Union:\n\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n + 1)]\n        self.size = [1] * (n + 1)\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        if x != y:\n            if self.size[x] < self.size[y]:\n                (x, y) = (y, x)\n            self.parent[y] = x\n            self.size[x] += self.size[y]\n\n    def count(self):\n        ans = 0\n        for i in range(self.n + 1):\n            if self.parent[i] == i and self.size[i] > 1:\n                ans += 1\n        return ans\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    obj = Union(n)\n    for i in range(n):\n        obj.union(obj.find(a[i]), obj.find(b[i]))\n    print(pow(2, obj.count(), 1000000007))", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nfor _ in range(int(input())):\n    n = int(input())\n    f = 1\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    d = {}\n    for i in range(n):\n        d.update({a[i]: b[i]})\n    for i in range(0, n):\n        if a[i] == b[i]:\n            print(0)\n            f = 0\n            break\n    if f == 1:\n        cnt = 0\n        visited = [0 for i in range(0, n + 1)]\n        fcnt = 0\n        for i in d:\n            v = d[i]\n            cnt = 0\n            while v != i and visited[i] == 0:\n                visited[v] = 1\n                v = d[v]\n                if cnt == 0:\n                    fcnt = fcnt + 1\n                cnt = 1\n        ans = power(2, fcnt, 10 ** 9 + 7)\n        print(ans % (10 ** 9 + 7))", "import sys\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    an = list(map(int, sys.stdin.readline().split()))\n    bn = list(map(int, sys.stdin.readline().split()))\n    dic_a = [-1 for _ in range(n + 1)]\n    dic_b = [-1 for _ in range(n + 1)]\n    for i in range(n):\n        dic_a[an[i]] = i\n        dic_b[bn[i]] = i\n    stack = []\n    valued = [False for _ in range(n + 1)]\n    ans = 0\n    for i in range(1, n + 1):\n        if not valued[an[i - 1]]:\n            ans += 1\n            stack.append((an[i - 1], 1))\n            stack.append((bn[i - 1], 0))\n            valued[an[i - 1]] = True\n            valued[bn[i - 1]] = True\n            while stack:\n                (x, y) = stack.pop()\n                if y:\n                    p = an[dic_b[x]]\n                    if not valued[p]:\n                        valued[p] = True\n                        stack.append((p, 1))\n                else:\n                    p = bn[dic_a[x]]\n                    if not valued[p]:\n                        valued[p] = True\n                        stack.append((p, 0))\n    print(2 ** ans % (10 ** 9 + 7))", "from collections import defaultdict\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        d = defaultdict(list)\n        for i in range(n):\n            d[a[i]].append(i)\n            d[b[i]].append(i)\n        taken = [0] * n\n        count = 0\n        for i in range(n):\n            if taken[i] == 0:\n                count += 1\n                initial = a[i]\n                taken[i] = 1\n                j = i\n                while a[i] != b[j]:\n                    tmp = d[b[j]]\n                    if tmp[0] != j:\n                        k = tmp[0]\n                    else:\n                        k = tmp[1]\n                    j = k\n                    taken[j] = 1\n        ans = 1\n        for i in range(count):\n            ans = ans * 2 % (10 ** 9 + 7)\n        print(ans)\nmain()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(int(1000000000.0))\n\ndef dfs(adj, root, visited):\n    stack = [root]\n    while len(stack):\n        root = stack.pop()\n        visited[root] = True\n        for i in adj[root]:\n            if visited[i] == False:\n                stack.append(i)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    adj = defaultdict(list)\n    for (i, j) in zip(a, b):\n        adj[i - 1].append(j - 1)\n    visited = [False] * n\n    components = 0\n    for i in range(n):\n        if visited[i] == False:\n            dfs(adj, i, visited)\n            components += 1\n    print(pow(2, components, int(1000000000.0 + 7)))", "mod = 7 + 10 ** 9\nfor _ in range(int(input())):\n    sfd = input()\n    l1 = [int(i) for i in input().split()]\n    l2 = [int(i) for i in input().split()]\n    vis = [0] * len(l1)\n    d1 = dict()\n    d2 = dict()\n    ct = 0\n    ans = 0\n    for i in range(len(l1)):\n        d1[l1[i]] = i\n    for i in range(len(l2)):\n        d2[l2[i]] = i\n    for i in range(len(l1)):\n        if vis[i] == 0:\n            st = l1[i]\n            c = st\n            part = l2[i]\n            ct = 0\n            vis[i] = 1\n            while part != st:\n                c = part\n                if ct % 2 == 0:\n                    part = l1[d1[c]]\n                    vis[d1[c]] = 1\n                else:\n                    part = l2[d1[c]]\n                ct += 1\n            ans = (ans + 1) % mod\n    print(2 ** ans % mod)", "from collections import defaultdict, deque\nmod = pow(10, 9) + 7\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    graph = defaultdict(list)\n    cnt = 1\n    for i in range(n):\n        if a[i] == b[i]:\n            cnt = 0\n            break\n        graph[a[i]].append(b[i])\n    if cnt == 0:\n        print(0)\n        continue\n    vis = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if vis[i] == False:\n            q = deque()\n            q.append(i)\n            while q:\n                s = q.popleft()\n                for nodes in graph[s]:\n                    if vis[nodes] == False:\n                        q.append(nodes)\n                        vis[nodes] = True\n            cnt = cnt % mod * (2 % mod) % mod\n    print(cnt)", "T = int(input())\nfor ti in range(T):\n    n = int(input())\n    allset = set(range(n))\n    visited = [0 for i in range(n)]\n    row1 = [int(x) - 1 for x in input().split(' ')]\n    row2 = [int(x) - 1 for x in input().split(' ')]\n    adj = [[] for i in range(n)]\n    for i in range(n):\n        adj[row1[i]].append(row2[i])\n    components = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        dfsstack = []\n        dfsstack.append(i)\n        components += 1\n        while len(dfsstack) > 0:\n            ele = dfsstack.pop()\n            visited[ele] = True\n            for nei in adj[ele]:\n                if visited[nei]:\n                    continue\n                else:\n                    dfsstack.append(nei)\n    ans = 1\n    for i in range(components):\n        ans = 2 * ans % (10 ** 9 + 7)\n    print(ans)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a1 = [int(i) for i in input().split(' ')]\n    a2 = [int(i) for i in input().split(' ')]\n    s = sorted(zip(a1, a2))\n    ch = [0] * n\n    k = 0\n    f = True\n    while f:\n        for i in range(n):\n            if ch[i] == 0:\n                ch[i] = 1\n                save = i\n                startv = s[i][0]\n                while s[i][1] != startv:\n                    i = s[i][1] - 1\n                    ch[i] = 1\n                k += 1\n                i = save\n        else:\n            f = False\n    print(2 ** k % (10 ** 9 + 7))", "import sys\nfrom collections import Counter\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\nsys.setrecursionlimit(20000)\n\nclass U:\n\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            self.parent[self.parent[y_root]] = self.parent[x_root]\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    A = get_ints()\n    B = get_ints()\n    dp = U(n)\n    for i in range(n):\n        dp.union(A[i], B[i])\n    for i in dp.parent:\n        dp.parent[i] = dp.find(dp.parent[i])\n    swappable_groups = len(set(dp.parent.values()))\n    print(2 ** swappable_groups % (10 ** 9 + 7))", "import sys\nimport glob\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nONLINE_JUDGE = bool(glob.glob('input*.txt'))\nif ONLINE_JUDGE:\n    sys.stdin = open(glob.glob('input*.txt')[0], 'r')\nfor test_var in range(int(input())):\n    graph = defaultdict(list)\n    n = int(input())\n    visited = [False] * (n + 1)\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    independent = 0\n    for i in range(n):\n        graph[arr1[i]].append(arr2[i])\n        graph[arr2[i]].append(arr1[i])\n    for num in arr1:\n        if not visited[num]:\n            stack = [num]\n            while stack:\n                u = stack.pop()\n                visited[u] = True\n                for v in graph[u]:\n                    if not visited[v]:\n                        stack.append(v)\n            independent += 1\n    print(pow(2, independent, 10 ** 9 + 7))", "import sys, threading\n\ndef main():\n    from collections import defaultdict\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        first = list(map(int, input().split()))\n        second = list(map(int, input().split()))\n        graph = defaultdict(list)\n        for idx in range(n):\n            (num1, num2) = (first[idx], second[idx])\n            graph[num1].append(num2)\n        seen = [False for _ in range(n)]\n\n        def dfs(start):\n            seen[start - 1] = True\n            for other in graph[start]:\n                if not seen[other - 1]:\n                    dfs(other)\n        ans = 0\n        for node in range(1, n + 1):\n            if not seen[node - 1]:\n                ans += 1\n                dfs(node)\n        print(2 ** ans % (10 ** 9 + 7))\nsys.setrecursionlimit(1 << 30)\nthreading.stack_size(1 << 27)\nmain_thread = threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "from collections import Counter\nimport string\nimport math\nimport bisect\nmod = 10 ** 9 + 7\nimport sys\nfrom fractions import Fraction\nfrom types import GeneratorType\nimport collections, sys, threading\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(10 ** 8)\n\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef vary(arrber_of_variables):\n    if arrber_of_variables == 1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables >= 2:\n        return map(int, sys.stdin.readline().split())\n\ndef makedict(var):\n    return dict(Counter(var))\n\ndef solve():\n\n    def dfs(node):\n        visited[node] = 1\n        for i in tree[node]:\n            if visited[i] == 0:\n                dfs(i)\n        return\n    testcases = vary(1)\n    for _ in range(testcases):\n        n = vary(1)\n        num1 = array_int()\n        num2 = array_int()\n        tree = [[] for i in range(n + 1)]\n        visited = [0] * (n + 1)\n        for i in range(n):\n            tree[num1[i]].append(num2[i])\n        pairs = 0\n        for i in range(1, n + 1):\n            if visited[i] == 0:\n                dfs(i)\n                pairs += 1\n        print(pow(2, pairs, 10 ** 9 + 7))\nthreading.Thread(target=solve).start()", "import sys\n\ndef dfs(g, vis, u):\n    st = [u]\n    vis[u] = 1\n    while st:\n        p = st.pop()\n        vis[p] = 1\n        for to in g[p]:\n            if not vis[to]:\n                st.append(to)\nfor _ in range(int(input())):\n    n = int(input())\n    l1 = list(map(int, input().split()))\n    l2 = list(map(int, input().split()))\n    g = [[] for i in range(n)]\n    for i in range(n):\n        g[l1[i] - 1].append(l2[i] - 1)\n        g[l2[i] - 1].append(l1[i] - 1)\n    no = 0\n    vis = [False] * (n + 1)\n    for i in range(n):\n        if vis[i] == False:\n            dfs(g, vis, i)\n            no += 1\n    m = 10 ** 9 + 7\n    print(pow(2, no, m))", "from collections import Counter\nimport string\nimport math\nimport bisect\nmod = 10 ** 9 + 7\nimport sys\nfrom fractions import Fraction\nfrom types import GeneratorType\nimport collections, sys, threading\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(10 ** 8)\n\ndef array_int():\n    return [int(i) for i in sys.stdin.readline().split()]\n\ndef vary(arrber_of_variables):\n    if arrber_of_variables == 1:\n        return int(sys.stdin.readline())\n    if arrber_of_variables >= 2:\n        return map(int, sys.stdin.readline().split())\n\ndef makedict(var):\n    return dict(Counter(var))\n\ndef solve():\n\n    def dfs(node):\n        visited[node] = 1\n        for i in tree[node]:\n            if visited[i] == 0:\n                dfs(i)\n    testcases = vary(1)\n    for _ in range(testcases):\n        n = vary(1)\n        num1 = array_int()\n        num2 = array_int()\n        tree = [[] for i in range(n + 1)]\n        visited = [0] * (n + 1)\n        for i in range(n):\n            tree[num1[i]].append(num2[i])\n        pairs = 0\n        for i in range(1, n + 1):\n            if visited[i] == 0:\n                dfs(i)\n                pairs += 1\n        print(pow(2, pairs, 10 ** 9 + 7))\nthreading.Thread(target=solve).start()", "def findParent(elem):\n    if parents[elem] == elem:\n        return elem\n    return findParent(parents[elem])\n\ndef union(elem1, elem2):\n    child = min(elem1, elem2)\n    parent = max(elem1, elem2)\n    parents[child] = parent\nfor _ in range(int(input())):\n    n = int(input())\n    arr1 = list(map(int, input().split()))\n    arr2 = list(map(int, input().split()))\n    parents = [i for i in range(n + 1)]\n    for i in range(n):\n        (p1, p2) = (findParent(arr1[i]), findParent(arr2[i]))\n        union(p1, p2)\n    for i in range(1, n + 1):\n        parents[i] = findParent(i)\n    distinctParents = len(set(parents[1:]))\n    print(pow(2, distinctParents, 10 ** 9 + 7))", "mod = 1000000007\nt = int(input())\nfor i in range(t):\n    count = 0\n    n = int(input())\n    q = input().split()\n    w = input().split()\n    a = [[int(q[j]), int(w[j])] for j in range(n)]\n    a.sort()\n    for j in range(n):\n        if a[j][0] != 0:\n            check = 0\n            ini = a[j][0]\n            while check == 0:\n                a[j][0] = 0\n                if a[j][1] == ini:\n                    count += 1\n                    check = 1\n                else:\n                    j = a[j][1] - 1\n    print(pow(2, count, mod))", "from math import sqrt, gcd, ceil, floor, log, factorial\nfrom itertools import permutations, combinations\nfrom collections import Counter, defaultdict\nimport collections, sys, threading\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(10 ** 8)\n\ndef solve():\n\n    def ii():\n        return int(input())\n\n    def si():\n        return input()\n\n    def mi():\n        return map(int, input().split())\n\n    def msi():\n        return map(str, input().split())\n\n    def li():\n        return list(mi())\n\n    def dfs(node, g, visited):\n        visited[node] = 1\n        for i in g[node]:\n            if visited[i] == 0:\n                dfs(i, g, visited)\n    t = ii()\n    for _ in range(t):\n        n = ii()\n        d1 = li()\n        d2 = li()\n        g = defaultdict(list)\n        for i in range(n):\n            g[d1[i]].append(d2[i])\n            g[d2[i]].append(d1[i])\n        visited = [0] * (n + 1)\n        cnt = 0\n        for i in range(1, n + 1):\n            if visited[i] == 0:\n                dfs(i, g, visited)\n                cnt = (cnt + 1) % (10 ** 9 + 7)\n        print(pow(2, cnt, 10 ** 9 + 7))\nthreading.Thread(target=solve).start()", "from collections import defaultdict\n\ndef pow(a, n, m):\n    if n == 0:\n        return 1\n    x = pow(a, n // 2, m)\n    if n % 2 == 0:\n        return x * x % m\n    else:\n        return x * x * a % m\n\ndef dfs(u, g, vis):\n    st = [u]\n    vis[u] = 1\n    while st:\n        p = st.pop()\n        vis[p] = 1\n        for to in g[p]:\n            if not vis[to]:\n                st.append(to)\nm = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    g = defaultdict(list)\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(n):\n        a[i] -= 1\n    for i in range(n):\n        b[i] -= 1\n        g[a[i]].append(b[i])\n        g[b[i]].append(a[i])\n    vis = [0 for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if not vis[i]:\n            ans += 1\n            dfs(i, g, vis)\n    print(pow(2, ans, m))", "class Dsu:\n\n    def __init__(this):\n        this._parent = {}\n        this._rank = {}\n\n    def make_set(this, v):\n        this._parent[v] = v\n        this._rank[v] = 0\n\n    def find_set(this, v):\n        if this._parent[v] == v:\n            return v\n        this._parent[v] = this.find_set(this._parent[v])\n        return this._parent[v]\n\n    def union_set(this, a, b):\n        a = this.find_set(a)\n        b = this.find_set(b)\n        if a != b:\n            if this._rank[a] < this._rank[b]:\n                (a, b) = (b, a)\n            this._parent[b] = a\n            if this._rank[a] == this._rank[b]:\n                this._rank[a] += 1\nMOD = int(1000000000.0 + 7)\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    puz_top = list(map(int, input().split()))\n    puz_bot = list(map(int, input().split()))\n    dsu = Dsu()\n    for i in range(1, n + 1):\n        dsu.make_set(i)\n    for i in range(n):\n        dsu.union_set(puz_top[i], puz_bot[i])\n    num_set = 0\n    set_id = {}\n    for i in range(1, n + 1):\n        if dsu.find_set(i) in set_id:\n            continue\n        set_id[dsu.find_set(i)] = True\n        num_set += 1\n    result = 1\n    for i in range(num_set):\n        result = result * 2 % MOD\n    print(result)", "a = int(input())\nfor x in range(a):\n    b = int(input())\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    l = 1\n    t = [0 for x in range(b)]\n    for x in range(b):\n        t[c[x] - 1] = d[x] - 1\n    vis = [-1 for y in range(b)]\n    l = 1\n    o = []\n    for x in range(b):\n        if vis[c[x] - 1] == -1:\n            if c[x] == d[x]:\n                vis[c[x] - 1] = 1\n            else:\n                o.append(c[x] - 1)\n                g = 1\n                l = l * 2\n                while g > 0:\n                    m = o.pop()\n                    g = 0\n                    vis[m] = 1\n                    if vis[t[m]] == 1:\n                        pass\n                    else:\n                        g = 1\n                        o.append(t[m])\n    print(l % (10 ** 9 + 7))"]