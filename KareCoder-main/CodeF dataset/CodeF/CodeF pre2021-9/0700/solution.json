["from collections import deque\nimport sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef MI1():\n    return map(int1, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n\n    def bfs(u):\n        q = deque([u])\n        res = [-1] * n\n        res[u] = 0\n        while q:\n            u = q.popleft()\n            for v in to[u]:\n                if res[v] != -1:\n                    continue\n                res[v] = res[u] + 1\n                q.append(v)\n        return res\n    for _ in range(II()):\n        (n, m, a, b, c) = MI()\n        (a, b, c) = (a - 1, b - 1, c - 1)\n        pp = LI()\n        to = [[] for _ in range(n)]\n        for _ in range(m):\n            (u, v) = MI1()\n            to[u].append(v)\n            to[v].append(u)\n        dist = []\n        for u in [a, b, c]:\n            dist.append(bfs(u))\n        cs = [0]\n        for p in sorted(pp):\n            cs.append(cs[-1] + p)\n        ans = 10 ** 16\n        for u in range(n):\n            d = dist[0][u] + dist[1][u] + dist[2][u]\n            if d > m:\n                continue\n            cur = cs[d] + cs[dist[1][u]]\n            if cur < ans:\n                ans = cur\n        print(ans)\nmain()", "from collections import deque\n\ndef readGraph(n, m):\n    adj = [set() for i in range(n + 1)]\n    for i in range(m):\n        (v1, v2) = [int(x) for x in input().split()]\n        adj[v1].add(v2)\n        adj[v2].add(v1)\n    return adj\n\ndef bfs(adj, src, n):\n    q = deque()\n    q.append(src)\n    visited = [False] * (n + 1)\n    distance = [0] * (n + 1)\n    visited[src] = True\n    while q:\n        ele = q.popleft()\n        for a in adj[ele]:\n            if visited[a] == False:\n                q.append(a)\n                distance[a] = distance[ele] + 1\n                visited[a] = True\n    return distance\n\ndef solve():\n    (n, m, a, b, c) = [int(x) for x in input().split()]\n    p = [0] + [int(x) for x in input().split()]\n    adj = readGraph(n, m)\n    dA = bfs(adj, a, n)\n    dB = bfs(adj, b, n)\n    dC = bfs(adj, c, n)\n    p.sort()\n    psum = [0] * (m + 1)\n    psum[1] = p[0]\n    for i in range(1, m + 1):\n        psum[i] = psum[i - 1] + p[i]\n    pay = 99999999999999999999999999999999\n    for D in range(1, n + 1):\n        DA = dA[D]\n        DB = dB[D]\n        DC = dC[D]\n        if DA + DB + DC <= m:\n            pay = min(pay, psum[DB] + psum[DA + DB + DC])\n    print(pay)\nt = int(input())\nfor i in range(t):\n    solve()", "from itertools import accumulate\nfrom collections import deque\n\ndef BFS(adj, level, s):\n    queue = deque([s])\n    level[s] = 0\n    while queue:\n        s = queue.popleft()\n        for i in adj[s]:\n            if level[i] == -1:\n                queue.append(i)\n                level[i] = level[s] + 1\n\ndef addEdge(adj, v, w):\n    adj[v].append(w)\n    adj[w].append(v)\nt = int(input())\nfor _ in range(t):\n    (n, m, a, b, c) = map(int, input().split(' '))\n    (a, b, c) = (a - 1, b - 1, c - 1)\n    p = [int(x) for x in input().split()]\n    p.sort()\n    cost = [0] + list(accumulate(p))\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = map(int, input().split(' '))\n        addEdge(adj, u - 1, v - 1)\n    (da, db, dc) = ([-1] * n, [-1] * n, [-1] * n)\n    BFS(adj, da, a)\n    BFS(adj, db, b)\n    BFS(adj, dc, c)\n    ans = 10 ** 18\n    for i in range(n):\n        x = da[i] + db[i] + dc[i]\n        if x <= m:\n            cx = cost[x] + cost[db[i]]\n            ans = min(ans, cx)\n    print(ans)", "from collections import deque\nt = int(input())\nfor _ in range(t):\n    (n, m, a, b, c) = map(int, input().split())\n    g = [[] for i in range(n + 5)]\n    cost = list(map(int, input().split(' ')))\n    cost.insert(0, 0)\n    cost.sort()\n    for i in range(m):\n        cost[i + 1] += cost[i]\n    for _ in range(m):\n        (u, v) = map(int, input().split(' '))\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(source):\n        dis = [-1] * (n + 1)\n        dis[source] = 0\n        q = deque([source])\n        while q:\n            cur = q.popleft()\n            for i in g[cur]:\n                if dis[i] == -1:\n                    dis[i] = 1 + dis[cur]\n                    q.append(i)\n        return dis\n    dis1 = []\n    dis2 = []\n    dis3 = []\n    dis1.extend(BFS(a))\n    dis2.extend(BFS(b))\n    dis3.extend(BFS(c))\n    ans = 2e+18\n    for i in range(1, n + 1):\n        temp = dis1[i] + dis2[i] + dis3[i]\n        if temp > m:\n            continue\n        ans = min(ans, cost[dis2[i]] + cost[temp])\n    print(ans)", "import collections\ninfty = 10 ** 15\n\ndef bfs(n, g, x):\n    dx = [infty] * (n + 1)\n    dx[x] = 0\n    visited = set([x])\n    queue = collections.deque([(x, 0)])\n    while queue:\n        (s, dist) = queue.popleft()\n        for v in g[s]:\n            if v not in visited:\n                visited.add(v)\n                dx[v] = dist + 1\n                queue.append((v, dx[v]))\n    return dx\nt = int(input())\nfor _ in range(t):\n    (n, m, a, b, c) = map(int, input().split())\n    p = list(map(int, input().split()))\n    g = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        g[x].append(y)\n        g[y].append(x)\n    da = bfs(n, g, a)\n    db = bfs(n, g, b)\n    dc = bfs(n, g, c)\n    p.sort()\n    psum = [0, p[0]]\n    for j in range(1, m):\n        psum.append(psum[-1] + p[j])\n    ans = infty\n    for q in range(1, n + 1):\n        if da[q] + db[q] + dc[q] <= m:\n            ans = min(ans, psum[da[q] + db[q] + dc[q]] + psum[db[q]])\n    print(ans)", "from collections import defaultdict, deque\n\ndef bfs(s, d):\n    d[s] = 0\n    que = deque([s])\n    while que:\n        v = que.popleft()\n        for nv in edges[v]:\n            if d[nv] == inf:\n                que.append(nv)\n                d[nv] = d[v] + 1\n\ndef solver():\n    price.sort()\n    pf = [0] * (m + 1)\n    for i in range(1, m + 1):\n        pf[i] = pf[i - 1] + price[i]\n    (da, db, dc) = ([inf] * (n + 1), [inf] * (n + 1), [inf] * (n + 1))\n    bfs(a, da)\n    bfs(b, db)\n    bfs(c, dc)\n    ans = inf\n    for i in range(1, n + 1):\n        if da[i] + db[i] + dc[i] > m:\n            continue\n        dx = db[i]\n        posans = pf[dx] + pf[da[i] + dc[i] + dx]\n        ans = min(ans, posans)\n    return ans\ninf = float('inf')\nt = int(input())\nfor _ in range(t):\n    (n, m, a, b, c) = map(int, input().split())\n    price = [0]\n    price.extend(map(int, input().split()))\n    edges = defaultdict(list)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        edges[u].append(v)\n        edges[v].append(u)\n    ans = solver()\n    print(ans)", "from collections import deque\n\ndef bfs(start, e, n):\n    dist = [-1] * n\n    queue = deque([start])\n    dist[start] = 0\n    while queue:\n        here = queue.popleft()\n        for next in e[here]:\n            if dist[next] == -1:\n                queue.append(next)\n                dist[next] = dist[here] + 1\n    return dist\nt = int(input())\nfor T in range(t):\n    (n, m, a, b, c) = map(int, input().split())\n    a -= 1\n    b -= 1\n    c -= 1\n    p = list(map(int, input().split()))\n    p.sort()\n    e = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        e[u].append(v)\n        e[v].append(u)\n    u = bfs(a, e, n)\n    v = bfs(b, e, n)\n    w = bfs(c, e, n)\n    psum = [0] + p\n    for i in range(m):\n        psum[i + 1] += psum[i]\n    ans = 10000000000000000\n    for x in range(n):\n        one = u[x]\n        two = v[x]\n        thr = w[x]\n        if one + two + thr > m:\n            continue\n        ans = min(ans, psum[two] + psum[one + two + thr])\n    print(ans)", "from itertools import accumulate\nfrom collections import deque\n\ndef BFS(adj, level, s):\n    queue = deque([s])\n    level[s] = 0\n    while queue:\n        s = queue.popleft()\n        for i in adj[s]:\n            if level[i] == -1:\n                queue.append(i)\n                level[i] = level[s] + 1\n\ndef addEdge(adj, v, w):\n    adj[v].append(w)\n    adj[w].append(v)\nt = int(input())\nfor _ in range(t):\n    (n, m, a, b, c) = map(int, input().split(' '))\n    (a, b, c) = (a - 1, b - 1, c - 1)\n    p = [int(x) for x in input().split()]\n    p.sort()\n    cost = [0] + list(accumulate(p))\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = map(int, input().split(' '))\n        addEdge(adj, u - 1, v - 1)\n    (da, db, dc) = ([-1] * n, [-1] * n, [-1] * n)\n    BFS(adj, da, a)\n    BFS(adj, db, b)\n    BFS(adj, dc, c)\n    ans = 10 ** 18\n    for i in range(n):\n        x = da[i] + db[i] + dc[i]\n        if x <= m:\n            cx = cost[x] + cost[db[i]]\n            ans = min(ans, cx)\n    print(ans)", "from itertools import accumulate\nfrom collections import deque\n\ndef BFS(adj, level, s):\n    queue = deque([s])\n    level[s] = 0\n    while queue:\n        s = queue.popleft()\n        for i in adj[s]:\n            if level[i] == -1:\n                queue.append(i)\n                level[i] = level[s] + 1\n\ndef addEdge(adj, v, w):\n    adj[v].append(w)\n    adj[w].append(v)\nt = int(input())\nfor _ in range(t):\n    (n, m, a, b, c) = map(int, input().split(' '))\n    (a, b, c) = (a - 1, b - 1, c - 1)\n    p = [int(x) for x in input().split()]\n    p.sort()\n    cost = [0] + list(accumulate(p))\n    adj = [[] for i in range(n)]\n    for i in range(m):\n        (u, v) = map(int, input().split(' '))\n        addEdge(adj, u - 1, v - 1)\n    (da, db, dc) = ([-1] * n, [-1] * n, [-1] * n)\n    BFS(adj, da, a)\n    BFS(adj, db, b)\n    BFS(adj, dc, c)\n    ans = 10 ** 18\n    for i in range(n):\n        x = da[i] + db[i] + dc[i]\n        if x <= m:\n            cx = cost[x] + cost[db[i]]\n            ans = min(ans, cx)\n    print(ans)", "from collections import deque\ng = [[] for y in range(int(200000.0 + 5))]\nq = int(input())\nwhile q > 0:\n    q -= 1\n    (n, m, a, b, c) = map(int, input().split())\n\n    def BFS(a):\n        List = []\n        dist = [-1] * (n + 1)\n        dist[a] = 0\n        List = deque([a])\n        while List:\n            u = List.popleft()\n            for v in g[u]:\n                if dist[v] < 0:\n                    dist[v] = dist[u] + 1\n                    List.append(v)\n        return dist\n    p = list(map(int, input().split()))\n    p.sort()\n    p.insert(0, 0)\n    for i in range(1, n + 1):\n        g[i].clear()\n    for i in range(1, m + 1):\n        p[i] = p[i] + p[i - 1]\n    for i in range(1, m + 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    dist1 = []\n    dist2 = []\n    dist3 = []\n    dist1.extend(BFS(a))\n    dist2.extend(BFS(b))\n    dist3.extend(BFS(c))\n    res = int(1e+17)\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] > m:\n            continue\n        res = min(res, p[dist2[i]] + p[dist1[i] + dist2[i] + dist3[i]])\n    print(res)", "import collections\nt = int(input())\n\ndef bfs(start):\n    dist = [-1 for j in range(n)]\n    dist[start] = 0\n    q = collections.deque([start])\n    while q:\n        node = q.popleft()\n        for nei in graph[node]:\n            if dist[nei] < 0:\n                dist[nei] = dist[node] + 1\n                q.append(nei)\n    return dist\nfor i in range(t):\n    (n, m, a, b, c) = map(int, input().split())\n    graph = collections.defaultdict(list)\n    price = [int(j) for j in input().split()]\n    price.sort()\n    fp = [0 for j in range(m + 1)]\n    for j in range(1, m + 1):\n        fp[j] = fp[j - 1] + price[j - 1]\n    for j in range(m):\n        (n1, n2) = map(int, input().split())\n        graph[n1 - 1].append(n2 - 1)\n        graph[n2 - 1].append(n1 - 1)\n    path1 = bfs(a - 1)\n    path2 = bfs(b - 1)\n    path3 = bfs(c - 1)\n    output = float('inf')\n    for j in range(n):\n        if path1[j] + path2[j] + path3[j] > m:\n            continue\n        output = min(output, fp[path2[j]] + fp[path1[j] + path2[j] + path3[j]])\n    print(output)", "import collections\ntests = int(input())\n\ndef bfs(start, edges):\n    q = collections.deque([start])\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    while len(q) > 0:\n        curr_node = q.popleft()\n        for (idx, neighbour) in enumerate(edges[curr_node]):\n            if dist[neighbour] == -1:\n                q.append(neighbour)\n                dist[neighbour] = dist[curr_node] + 1\n    return dist\nfor t in range(tests):\n    (n, m, a, b, c) = map(int, input().split(' '))\n    costs = map(int, input().split(' '))\n    costs = sorted(costs)\n    edges = [[] for i in range(n + 1)]\n    partial_sums = [0]\n    for (nod, cost) in enumerate(costs):\n        costs[nod] = cost\n        partial_sums.append(partial_sums[nod] + cost)\n    for edge in range(m):\n        (u, v) = map(int, input().split(' '))\n        edges[u].append(v)\n        edges[v].append(u)\n    dist = [[], [], []]\n    dist[0] = bfs(a, edges)\n    dist[1] = bfs(b, edges)\n    dist[2] = bfs(c, edges)\n    min_sum = 1 << 62\n    for i in range(1, n + 1, 1):\n        if dist[0][i] + dist[1][i] + dist[2][i] > m:\n            continue\n        min_sum = min(min_sum, partial_sums[dist[1][i]] + partial_sums[dist[0][i] + dist[1][i] + dist[2][i]])\n    print(min_sum)", "import collections\ntests = int(input())\n\ndef bfs(start, edges):\n    q = collections.deque([start])\n    D = [-1] * (n + 1)\n    D[start] = 0\n    while len(q) > 0:\n        curr_node = q.popleft()\n        for (idx, neighbour) in enumerate(edges[curr_node]):\n            if D[neighbour] < 0:\n                q.append(neighbour)\n                D[neighbour] = D[curr_node] + 1\n    return D\nfor t in range(tests):\n    (n, m, a, b, c) = map(int, input().split(' '))\n    costs = list(map(int, input().split(' ')))\n    costs.sort()\n    edges = [[] for i in range(n + 1)]\n    partial_sums = [0]\n    for (idx, cost) in enumerate(costs):\n        costs[idx] = cost\n        partial_sums.append(partial_sums[idx] + cost)\n    for edge in range(m):\n        (u, v) = map(int, input().split(' '))\n        edges[u].append(v)\n        edges[v].append(u)\n    D = [[] for i in range(3)]\n    D[0] = bfs(a, edges)\n    D[1] = bfs(b, edges)\n    D[2] = bfs(c, edges)\n    min_sum = 1 << 63\n    for i in range(1, n + 1, 1):\n        D_path = D[0][i] + D[1][i] + D[2][i]\n        if D_path > m:\n            continue\n        min_sum = min(min_sum, partial_sums[D[1][i]] + partial_sums[D[0][i] + D[1][i] + D[2][i]])\n    print(min_sum)", "import math\nfrom collections import defaultdict\nT = int(input())\n\ndef dfs(edges, node):\n    nodes = {node}\n    res = {node: 0}\n    visited = {node}\n    d = 0\n    while nodes:\n        d += 1\n        next_nodes = set()\n        for node in nodes:\n            for edge in edges[node]:\n                if edge in visited:\n                    continue\n                visited.add(edge)\n                next_nodes.add(edge)\n                res[edge] = d\n        nodes = next_nodes\n    return res\nfor t in range(T):\n    (N, M, A, B, C) = [int(i) for i in input().split()]\n    P = sorted([int(i) for i in input().split()])\n    pp = [0]\n    for p in P:\n        pp.append(pp[-1] + p)\n    edges = defaultdict(list)\n    for m in range(M):\n        (u, v) = [int(i) for i in input().split()]\n        edges[u].append(v)\n        edges[v].append(u)\n    dfsA = dfs(edges, A)\n    dfsB = dfs(edges, B)\n    dfsC = dfs(edges, C)\n    answer = math.inf\n    for m in range(1, N + 1):\n        if dfsA[m] + dfsB[m] + dfsC[m] < len(pp):\n            answer = min(answer, pp[dfsA[m] + dfsB[m] + dfsC[m]] + pp[dfsB[m]])\n    print(answer)", "import collections\ntests = int(input())\n\ndef bfs(start, edges):\n    q = collections.deque([start])\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    while len(q) > 0:\n        curr_node = q.popleft()\n        for (idx, neighbour) in enumerate(edges[curr_node]):\n            if dist[neighbour] == -1:\n                q.append(neighbour)\n                dist[neighbour] = dist[curr_node] + 1\n    return dist\nfor t in range(tests):\n    (n, m, a, b, c) = map(int, input().split(' '))\n    costs = map(int, input().split(' '))\n    costs = sorted(costs)\n    dist = [[-1, -1, -1] for i in range(n + 1)]\n    edges = [[] for i in range(n + 1)]\n    partial_sums = [0]\n    for (nod, cost) in enumerate(costs):\n        costs[nod] = cost\n        partial_sums.append(partial_sums[nod] + cost)\n    for edge in range(m):\n        (u, v) = map(int, input().split(' '))\n        edges[u].append(v)\n        edges[v].append(u)\n    dist = [[], [], []]\n    dist[0] = bfs(a, edges)\n    dist[1] = bfs(b, edges)\n    dist[2] = bfs(c, edges)\n    min_sum = 1 << 62\n    for i in range(1, n + 1, 1):\n        if dist[0][i] + dist[1][i] + dist[2][i] > m:\n            continue\n        min_sum = min(min_sum, partial_sums[dist[1][i]] + partial_sums[dist[0][i] + dist[1][i] + dist[2][i]])\n    print(min_sum)", "from collections import deque\nfrom itertools import accumulate\nfor _ in range(int(input())):\n    (n, m, a, b, c) = [int(x) for x in input().split()]\n    p = list(accumulate([0, *sorted((int(x) for x in input().split())), *(10 ** 9 for i in range(3 * n - 3 - m))]))\n    adj = [[] for i in range(n + 1)]\n    for e in range(m):\n        (u, v) = [int(x) for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    da = [-1 for i in range(n + 1)]\n    db = [-1 for i in range(n + 1)]\n    dc = [-1 for i in range(n + 1)]\n    for (s, d) in ((a, da), (b, db), (c, dc)):\n        q = deque([s])\n        d[s] = 0\n        while len(q) > 0:\n            u = q.popleft()\n            for v in adj[u]:\n                if d[v] == -1:\n                    d[v] = d[u] + 1\n                    q.append(v)\n\n    def rsq(L, R):\n        return p[R] - p[L - 1]\n    print(min((2 * rsq(1, db[x]) + rsq(db[x] + 1, db[x] + da[x] + dc[x]) for x in range(1, n + 1))))"]