["import sys\nt = int(sys.stdin.readline().rstrip())\n\ndef main():\n    for _ in range(t):\n        n = int(sys.stdin.readline().rstrip())\n        G = []\n        for _ in range(n):\n            (g, *a) = map(int, sys.stdin.readline().split())\n            G.append(a)\n        fixed = set()\n        no = []\n        for i in range(n):\n            cand = G[i]\n            for c in cand:\n                if c in fixed:\n                    continue\n                fixed.add(c)\n                break\n            else:\n                no.append(i + 1)\n        if not no:\n            yield 'OPTIMAL'\n        else:\n            yield 'IMPROVE'\n            to = min(set(range(1, n + 1)) - fixed)\n            da = no[0]\n            yield '{0} {1}'.format(da, to)\nans = main()\nprint(*ans, sep='\\n')", "import sys\nfrom math import *\nfrom collections import defaultdict\nfrom queue import deque\nfrom heapq import heappush, heappop\nlines = [line.strip() for line in sys.stdin.readlines()]\nt = int(lines[0])\ncur = 1\nfor tt in range(t):\n    n = int(lines[cur])\n    avail = [True for i in range(n + 1)]\n    a = -1\n    for i in range(1, 1 + n):\n        xs = list(map(int, lines[cur + i].split()))[1:]\n        found = False\n        for x in xs:\n            if avail[x]:\n                avail[x] = False\n                found = True\n                break\n        if a == -1 and (not found):\n            a = i\n    if a == -1:\n        print('OPTIMAL')\n    else:\n        for i in range(1, n + 1):\n            if avail[i]:\n                print('IMPROVE\\n%d %d' % (a, i))\n                break\n    cur += 1 + n", "ans = []\nfor _ in range(int(input())):\n    n = int(input())\n    u = []\n    for i in range(n):\n        s = list(map(lambda x: int(x) - 1, input().split()))\n        u.append(s[1:])\n    p = [0] * n\n    g = [0] * n\n    for i in range(n):\n        for j in u[i]:\n            if p[j] == 0:\n                g[i] = 1\n                p[j] = 1\n                break\n    if 0 not in p:\n        ans.append('OPTIMAL')\n    else:\n        i1 = -1\n        for i in range(n):\n            if p[i] == 0:\n                i1 = i\n                break\n        i2 = -1\n        for i in range(n):\n            if g[i] == 0:\n                i2 = i\n                break\n        if i1 in u[i2]:\n            a = 1 / 0\n        ans.append('IMPROVE')\n        ans.append(str(i2 + 1) + ' ' + str(i1 + 1))\nprint('\\n'.join(ans))", "t = int(input())\nout = ''\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    free = set([i for i in range(1, n + 1)])\n    daughters = []\n    for d in range(n):\n        info = [int(i) for i in input().split(' ')]\n        found = False\n        for i in range(1, info[0] + 1):\n            if info[i] in free:\n                free.remove(info[i])\n                found = True\n                break\n        if not found:\n            daughters.append(d + 1)\n    if len(daughters) == 0:\n        out += 'OPTIMAL\\n'\n        continue\n    out += f'IMPROVE\\n{daughters[0]} {free.pop()}\\n'\nprint(out)", "answer = ''\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    boys = [False for i in range(n)]\n    girs = []\n    for i in range(n):\n        new = list(map(int, input().split()))\n        if new == [0]:\n            girs.append(i + 1)\n        else:\n            ok = False\n            for j in range(new[0]):\n                ind = new[j + 1] - 1\n                if boys[ind] == False:\n                    boys[ind] = True\n                    ok = True\n                    break\n            if not ok:\n                girs.append(i + 1)\n    if girs == []:\n        answer += 'OPTIMAL\\n'\n    else:\n        for i in range(n):\n            if boys[i] == False:\n                boy = i + 1\n                break\n        answer += 'IMPROVE\\n'\n        answer += str(girs[0]) + ' ' + str(boy) + '\\n'\nprint(answer)", "list_ans = []\nfor _ in range(int(input())):\n    n = int(input())\n    list1 = []\n    set1 = set()\n    for i in range(n):\n        (a, *listx) = map(int, input().split())\n        for x in listx:\n            if x not in set1:\n                set1.add(x)\n                break\n        else:\n            list1.append(i + 1)\n    if len(list1) == 0:\n        list_ans.append('OPTIMAL')\n    else:\n        list_ans.append('IMPROVE')\n        a = list1[0]\n        for x in range(1, n + 1):\n            if x not in set1:\n                break\n        list_ans.append(' '.join([str(a), str(x)]))\nfor item in list_ans:\n    print(item)", "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\n\ndef LI():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef LS():\n    return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == '\\n':\n        return res[:-1]\n    return res\n\ndef IR(n):\n    return [I() for i in range(n)]\n\ndef LIR(n):\n    return [LI() for i in range(n)]\n\ndef SR(n):\n    return [S() for i in range(n)]\n\ndef LSR(n):\n    return [LS() for i in range(n)]\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    t = I()\n    for _ in range(t):\n        n = I()\n        f = [1] * (n + 1)\n        ans = None\n        for i in range(1, n + 1):\n            g = LI()[1:]\n            for j in g:\n                if f[j]:\n                    f[j] = 0\n                    break\n            else:\n                if ans == None:\n                    ans = i\n        if ans != None:\n            print('IMPROVE')\n            for i in range(1, n + 1):\n                if f[i]:\n                    break\n            print(ans, i)\n        else:\n            print('OPTIMAL')\n    return\nsolve()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    g = [0] * n\n    bused = [False] * n\n    gused = [False] * n\n    for i in range(n):\n        c = list(map(int, input().split()))\n        g[i] = []\n        for j in range(c[0]):\n            g[i].append(c[j + 1])\n    for i in range(n):\n        for j in range(len(g[i])):\n            if bused[g[i][j] - 1] == False:\n                bused[g[i][j] - 1] = True\n                gused[i] = True\n                break\n    k = -1\n    for i in range(n):\n        if bused[i] == False:\n            k = i\n            break\n    if k != -1:\n        for i in range(n):\n            if gused[i] == False:\n                print('IMPROVE')\n                print(i + 1, k + 1)\n                return\n    print('OPTIMAL')\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve()\nmain()", "from sys import stdin\nfrom heapq import *\ninput = stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    chk = [0] * (n + 1)\n    d = [0] * (n + 1)\n    s = [0] * (n + 1)\n    idx = [0] * (n + 1)\n    l = [[0]]\n    h = []\n    for x in range(1, n + 1):\n        t = [int(y) for y in input().split()]\n        if t[0] == 0:\n            l.append([])\n            continue\n        now = []\n        heappush(h, (t[1], x))\n        for y in t[1:]:\n            now.append(y)\n        l.append(now)\n    while True:\n        if len(h) == 0:\n            break\n        hnow = heappop(h)\n        if s[hnow[0]] == 0 and d[hnow[1]] == 0:\n            s[hnow[0]] = 1\n            d[hnow[1]] = 1\n        elif len(l[hnow[1]]) - 1 > idx[hnow[1]]:\n            idx[hnow[1]] += 1\n            heappush(h, (l[hnow[1]][idx[hnow[1]]], hnow[1]))\n    (dnow, snow) = (0, 0)\n    for x in range(1, n + 1):\n        if d[x] == 0:\n            dnow = x\n            break\n    for x in range(1, n + 1):\n        if s[x] == 0:\n            snow = x\n            break\n    if dnow == 0:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        print(dnow, snow)", "import sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n\n    def unusei():\n        for i in range(n):\n            if itoj[i] == -1:\n                return i\n        return -1\n\n    def unusej():\n        for j in range(n):\n            if jtoi[j] == -1:\n                return j\n        return -1\n    q = II()\n    for _ in range(q):\n        n = II()\n        itoj = [-1] * n\n        jtoi = [-1] * n\n        for i in range(n):\n            gg = LI()\n            for j in gg[1:]:\n                j -= 1\n                if jtoi[j] == -1:\n                    itoj[i] = j\n                    jtoi[j] = i\n                    break\n        ui = unusei()\n        if ui == -1:\n            print('OPTIMAL')\n        else:\n            print('IMPROVE')\n            uj = unusej()\n            print(ui + 1, uj + 1)\nmain()", "import sys\nLI = lambda : list(map(int, sys.stdin.readline().split()))\nMI = lambda : map(int, sys.stdin.readline().split())\nSI = lambda : sys.stdin.readline().strip('\\n')\nII = lambda : int(sys.stdin.readline())\nfor _ in range(II()):\n    (f, m) = (set(), set())\n    n = II()\n    for i in range(1, n + 1):\n        f.add(i)\n        for v in LI()[1:]:\n            if v not in m:\n                m.add(v)\n                f.remove(i)\n                break\n    if f:\n        for v in range(1, n + 1):\n            if v not in m:\n                print('IMPROVE')\n                print(f.pop(), v)\n                break\n    else:\n        print('OPTIMAL')", "from sys import stdin, stdout\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    d1 = {}\n    l = []\n    d = {}\n    for i in range(n):\n        l.append(list(map(int, stdin.readline().split()))[1:])\n    for i in range(n):\n        j = 0\n        if len(l[i]) != 0:\n            x = l[i][j]\n            while x in d:\n                j += 1\n                if j < len(l[i]):\n                    x = l[i][j]\n                else:\n                    break\n            d[x] = 1\n            if j < len(l[i]):\n                d1[i + 1] = 1\n    if len(d) == n:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        for i in range(n):\n            if i + 1 not in d1:\n                a = i + 1\n                break\n        for i in range(n):\n            if i + 1 not in d:\n                b = i + 1\n                break\n        print(a, b)", "from sys import stdin\ninput = stdin.readline\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    A = []\n    for j in range(n):\n        p = [int(j) for j in input().split()]\n        if p[0] > 0:\n            A.append(p[1:])\n        else:\n            A.append([])\n    pk = set()\n    left = None\n    for (x, j) in enumerate(A):\n        for k in j:\n            if k not in pk:\n                pk.add(k)\n                break\n        else:\n            if left == None:\n                left = x + 1\n    if left:\n        print('IMPROVE')\n        a = left\n        for j in range(1, n + 1):\n            if j not in pk:\n                print(a, j)\n                break\n    else:\n        print('OPTIMAL')", "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    a = [nl()[1:] for _ in range(n)]\n    mar = [-1] * n\n    g = [False] * n\n    for i in range(n):\n        for x in a[i]:\n            if not g[x - 1]:\n                mar[i] = x\n                g[x - 1] = True\n                break\n    if min(mar) > 0:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n    for i in range(n):\n        if mar[i] < 0:\n            for j in range(n):\n                if not g[j]:\n                    print(i + 1, j + 1)\n                    return\nT = ni()\nfor _ in range(T):\n    solve()", "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda : readline().rstrip()\nni = lambda : int(readline().rstrip())\nnm = lambda : map(int, readline().split())\nnl = lambda : list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n = ni()\n    a = [nl()[1:] for _ in range(n)]\n    mar = [-1] * n\n    g = [False] * n\n    for i in range(n):\n        for x in a[i]:\n            if not g[x - 1]:\n                mar[i] = x\n                g[x - 1] = True\n                break\n    if min(mar) > 0:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n    for i in range(n):\n        if mar[i] < 0:\n            for j in range(n):\n                if not g[j]:\n                    print(i + 1, j + 1)\n                    return\nT = ni()\nfor _ in range(T):\n    solve()", "from sys import stdin, exit, setrecursionlimit\nfrom math import ceil, log2\nsetrecursionlimit(10000000)\nfrom collections import deque\ninput = stdin.readline\nlmi = lambda : list(map(int, input().split()))\nmi = lambda : map(int, input().split())\nsi = lambda : input().strip('\\n')\nssi = lambda : input().strip('\\n').split()\nfor _ in range(int(input())):\n    g = [[]]\n    n = int(input())\n    for i in range(n):\n        g.append(sorted(lmi()[1:]))\n    bads = []\n    done = [0] * (n + 1)\n    for i in range(1, n + 1):\n        found = False\n        for j in g[i]:\n            if not done[j]:\n                done[j] = 1\n                found = True\n                break\n        if not found:\n            bads.append(i)\n    fe = -1\n    for i in range(1, n + 1):\n        if done[i] == 0:\n            fe = i\n            break\n    if fe == -1:\n        print('OPTIMAL')\n        continue\n    else:\n        print('IMPROVE')\n        print(bads[0], fe)", "T = int(input())\nn = [0] * T\nm = [0] * T\nns = [0] * T\nk = [0] * T\nfor t in range(T):\n    n[t] = int(input())\n    ns[t] = [0] * n[t]\n    k[t] = [0] * n[t]\n    for i in range(n[t]):\n        ns[t][i] = [int(i) for i in input().split(' ')]\n        k[t][i] = ns[t][i].pop(0)\n\ndef ans(n, k, ns):\n    pri = [1] * n\n    dtpr = [1] * n\n    s = [-1] * n\n    for i in range(n):\n        for j in range(k[i]):\n            if pri[ns[i][j] - 1] and s[i] == 0:\n                s[i] = ns[i][j]\n                break\n            if pri[ns[i][j] - 1]:\n                pri[ns[i][j] - 1] = 0\n                dtpr[i] = 0\n                s[i] = 0\n    if 1 not in pri:\n        return 'OPTIMAL'\n    return str('IMPROVE\\n' + str(dtpr.index(1) + 1) + ' ' + str(pri.index(1) + 1))\nfor t in range(T):\n    print(ans(n[t], k[t], ns[t]))", "import sys\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    a = []\n    for i in range(n):\n        l = list(map(int, sys.stdin.readline().split()))\n        a.append(l[1:])\n    visited = [0] * (n + 1)\n    girl = [0] * (n + 1)\n    for i in range(len(a)):\n        for j in range(len(a[i])):\n            if visited[a[i][j]] == 0:\n                visited[a[i][j]] = 1\n                girl[i] = 1\n                break\n    visited.pop(0)\n    if visited.count(1) == n:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        for i in range(len(girl)):\n            if girl[i] == 0:\n                print(i + 1, end=' ')\n                break\n        for i in range(len(visited)):\n            if visited[i] == 0:\n                print(i + 1)\n                break", "t = int(input())\notvet = []\nfor h in range(t):\n    n = int(input())\n    g1 = []\n    g = [0] * n\n    for i in range(n):\n        g1.append(input().split())\n        g1[i].pop(0)\n        g[i] = [int(item) for item in g1[i]]\n    prince = [0] * n\n    nope = []\n    for i in range(n):\n        for k in range(len(g[i])):\n            x = g[i][k]\n            if prince[x - 1] == 0:\n                prince[x - 1] = 1\n                break\n        else:\n            nope.append(i)\n    if 0 in prince:\n        otvet.append([nope[0] + 1, prince.index(0) + 1])\n    else:\n        otvet.append([-1, -1])\nfor i in range(t):\n    if otvet[i] == [-1, -1]:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        print(otvet[i][0], otvet[i][1])", "n = int(input())\nli_final = []\nfor i in range(n):\n    n1 = int(input())\n    li_3 = [[int(l) for l in input().split()] for k in range(n1)]\n    li_final.append(li_3)\nfor i in range(n):\n    li_1 = li_final[i]\n    n1 = len(li_1)\n    li_2 = [False] + [True] * (n1 + 1)\n    li_3 = [False] * (n1 + 1)\n    for k in range(n1):\n        for j in range(1, len(li_1[k])):\n            if li_2[li_1[k][j]]:\n                li_2[li_1[k][j]] = False\n                li_3[k + 1] = True\n                break\n    for l in range(1, n1 + 1):\n        if li_3[l] == False:\n            print('IMPROVE')\n            print(l, li_2.index(True))\n            break\n    else:\n        print('OPTIMAL')", "def more_couples(test):\n    princess = test[1]\n    n = test[0]\n    if n == 0:\n        return ('OPTIMAL', ())\n    ledger = [False for x in range(n)]\n    empty = 0\n    for p in princess:\n        if len(p) == 0:\n            empty += 1\n            continue\n        current_min = min(p)\n        while len(p) > 0 and ledger[current_min - 1]:\n            p.remove(current_min)\n            if len(p) > 0:\n                current_min = min(p)\n        ledger[current_min - 1] = True\n    available = 0\n    for i in range(len(ledger)):\n        if not ledger[i]:\n            available = i + 1\n            break\n    for i in range(len(princess)):\n        if len(princess[i]) == 0:\n            return ('IMPROVE', (i + 1, available))\n    return ('OPTIMAL', ())\nt = int(input())\ntests = []\nfor _ in range(t):\n    n = int(input())\n    princes = []\n    for _ in range(n):\n        princes.append(list(map(int, input().split()))[1:])\n    tests.append((n, princes))\nfor test in tests:\n    res = more_couples(test)\n    print(res[0])\n    if res[0] == 'IMPROVE':\n        print(f'{res[1][0]} {res[1][1]}')", "t = int(input())\notvet = []\nfor h in range(t):\n    n = int(input())\n    g1 = []\n    g = [0] * n\n    for i in range(n):\n        g1.append(input().split())\n        g1[i].pop(0)\n        g[i] = [int(item) for item in g1[i]]\n    prince = [0] * n\n    nope = []\n    for i in range(n):\n        for k in range(len(g[i])):\n            x = g[i][k]\n            if prince[x - 1] == 0:\n                prince[x - 1] = 1\n                break\n        else:\n            nope.append(i)\n    if 0 in prince:\n        otvet.append([nope[0] + 1, prince.index(0) + 1])\n    else:\n        otvet.append([-1, -1])\nfor i in range(t):\n    if otvet[i] == [-1, -1]:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        print(otvet[i][0], otvet[i][1])", "import sys\n\ndef printMissing(arr, low, high):\n    s = set(arr)\n    for x in range(low, high + 1):\n        if x not in s:\n            print(x, end=' ')\n            break\ninput = sys.stdin.readline\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    prin = dict()\n    for n in range(N):\n        a = [int(i) for i in input().split(' ')]\n        for i in range(1, a[0] + 1):\n            try:\n                prin[a[i]]\n            except:\n                prin[a[i]] = n + 1\n                break\n    if len(prin) < N:\n        print('IMPROVE')\n        printMissing(prin.values(), 1, N)\n        printMissing(prin.keys(), 1, N)\n        print('')\n    else:\n        print('OPTIMAL')", "t = int(input())\nans = []\nfor i in range(t):\n    d = set()\n    q = []\n    n = int(input())\n    for j in range(n):\n        a = list(map(int, input().split()))\n        a.pop(0)\n        a.sort()\n        for g in a:\n            if not g in d:\n                q += [g]\n                d.add(g)\n                break\n        else:\n            q += [0]\n    if len(d) == n:\n        ans.append(['OPTIMAL'])\n    else:\n        r = set((z for z in range(1, n + 1)))\n        for j in range(n):\n            if q[j] == 0:\n                ans.append(['IMPROVE', j + 1, min(r - d)])\n                break\nfor i in range(t):\n    print(ans[i][0])\n    if ans[i][0] == 'IMPROVE':\n        print(ans[i][1], ans[i][2])", "t = int(input())\ns = []\nwhile t:\n    t -= 1\n    n = int(input())\n    a = [0 for i in range(n)]\n    d = [True for i in range(n)]\n    for i in range(n):\n        ok = True\n        for ij in input().split():\n            if not ok:\n                j = int(ij)\n                if d[j - 1]:\n                    d[j - 1] = False\n                    a[i] = 1\n                    break\n            ok = False\n    sol = []\n    d = [i + 1 for i in range(n) if d[i]]\n    a = [i + 1 for i in range(n) if a[i] == 0]\n    if a == [] or d == []:\n        s.append(['OPTIMAL'])\n    else:\n        n = len(a)\n        m = len(d)\n        i = 0\n        j = 0\n        while i < n and j < m:\n            sol.append([a[i], d[j]])\n            break\n            i += 1\n            j += 1\n        s.append(['IMPROVE', sol])\nfor i in s:\n    if len(i) == 1:\n        print(*i)\n    else:\n        print(i[0])\n        for j in i[1]:\n            print(*j)", "n = int(input())\nfor i in range(n):\n    empty = []\n    t = int(input())\n    found = [0] * t\n    for j in range(t):\n        preference = list(map(int, input().split()))[1:]\n        flag = True\n        for k in preference:\n            if found[k - 1] == 0:\n                found[k - 1] = 1\n                flag = False\n                break\n        if flag == True:\n            empty += [j]\n    if len(empty) == 0:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        for i in range(t):\n            if found[i] == 0:\n                print(str(empty[0] + 1) + ' ' + str(i + 1))\n                break", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    used = [False] * n\n    lohi = []\n    for i in range(1, n + 1):\n        boo = False\n        arr = list(map(int, input().split()))\n        for j in range(1, len(arr)):\n            if used[arr[j] - 1] == False:\n                used[arr[j] - 1] = True\n                boo = True\n                break\n        if boo == False:\n            lohi.append(i)\n    if len(lohi) == 0:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        r = used.index(False)\n        print(f'{lohi[0]} {r + 1}')", "for _ in range(int(input())):\n    range_n = range(1, int(input()) + 1)\n    available_women = set()\n    available_men = set()\n    for i in range_n:\n        available_women.add(i)\n        available_men.add(i)\n    for woman in range_n:\n        wanted_men = input().split()[1:]\n        for man in wanted_men:\n            man = int(man)\n            if man in available_men:\n                available_women.remove(woman)\n                available_men.remove(man)\n                break\n    if not available_women:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        print(f'{next(iter(available_women))} {next(iter(available_men))}')", "def solve():\n    n = int(input())\n    prince = [False] * n\n    improved = []\n    for i in range(n):\n        picks = list(map(int, input().split()))\n        milgya = False\n        for j in range(1, len(picks)):\n            if not prince[picks[j] - 1]:\n                milgya = True\n                prince[picks[j] - 1] = True\n                break\n        if not milgya:\n            improved.append(i + 1)\n    if improved == []:\n        print('OPTIMAL')\n        return\n    print('IMPROVE')\n    print(improved[0], prince.index(False) + 1)\n    return\nt = int(input())\nwhile t != 0:\n    res = solve()\n    t -= 1", "for _ in range(int(input())):\n    n = int(input())\n    d = {}\n    for i in range(n):\n        d[i] = [int(x) for x in input().split()][1:]\n    (gr, br) = ([False] * n, [False] * n)\n    for (i, j) in d.items():\n        for k in j:\n            if gr[k - 1] == False:\n                gr[k - 1] = br[i] = True\n                break\n    if False in gr and False in br:\n        print('IMPROVE')\n        print(br.index(False) + 1, gr.index(False) + 1)\n    else:\n        print('OPTIMAL')", "n_test_cases = int(input())\nfor test_case in range(n_test_cases):\n    n = int(input())\n    (daughters, kingdoms) = ([0] * n, [0] * n)\n    for i in range(n):\n        for j in input().split()[1:]:\n            j = int(j)\n            if not daughters[i] and (not kingdoms[j - 1]):\n                daughters[i] = kingdoms[j - 1] = True\n                break\n    try:\n        a = daughters.index(0)\n        b = kingdoms.index(0)\n        print('IMPROVE')\n        print('{} {}'.format(a + 1, b + 1))\n    except:\n        print('OPTIMAL')", "t = int(input())\nnumber = 0\nwhile number != t:\n    n = int(input())\n    princes = [0 for _ in range(n + 1)]\n    (flag, otherFlag) = (0, 1)\n    princes[0] = 1\n    for i in range(n):\n        x = list(map(int, input().split()))\n        count = 1\n        simpleInit = x[0] + 1\n        while count != simpleInit:\n            if princes[x[count]] == 0:\n                princes[x[count]] = 1\n                break\n            count += 1\n        if count == simpleInit:\n            if otherFlag == 1:\n                flag = i + 1\n                otherFlag = 0\n    if flag == 0:\n        print('OPTIMAL')\n    else:\n        posicaoZero = princes.index(0)\n        print('IMPROVE')\n        print('%d %d' % (flag, posicaoZero))\n    number += 1", "for _ in range(int(input())):\n    n = int(input())\n    remk = [True] * n\n    remd = [True] * n\n    c = 0\n    for j in range(n):\n        for i in list(map(int, input().split()))[1:]:\n            if remk[i - 1]:\n                remk[i - 1] = False\n                remd[j] = False\n                c += 1\n                break\n    if c == n:\n        print('OPTIMAL')\n    else:\n        print('IMPROVE')\n        (low, lo) = (0, 0)\n        while low < n:\n            if remd[low]:\n                while not remk[lo]:\n                    lo += 1\n                print(low + 1, lo + 1)\n                lo += 1\n                break\n            low += 1"]