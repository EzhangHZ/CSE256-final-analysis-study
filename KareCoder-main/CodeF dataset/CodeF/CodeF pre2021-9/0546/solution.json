["from itertools import accumulate\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    k += 1\n    cnt = [0] * (k * 2)\n    l = list(map(int, input().split()))\n    for (i, (a, b)) in enumerate(zip(l, l[:-1 - n // 2:-1]), 1):\n        if a > b:\n            (a, b) = (b, a)\n        cnt[a + 1] -= 1\n        cnt[a + b] -= 1\n        cnt[a + b + 1] += 1\n        cnt[b + k] += 1\n    print(n + min(accumulate(cnt)))", "from itertools import accumulate\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    cnt = [0] * (k * 2 + 1)\n    l = list(map(int, input().split()))\n    for (i, (a, b)) in enumerate(zip(l, l[:-1 - n // 2:-1]), 1):\n        if a > b:\n            (a, b) = (b, a)\n        cnt[a] -= 1\n        cnt[a + b - 1] -= 1\n        cnt[a + b] += 1\n        cnt[b + k] += 1\n    print(n + min(accumulate(cnt)))", "from collections import Counter\nimport sys\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n    return int(sys.stdin.readline())\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef SI():\n    return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        (n, k) = MI()\n        aa = LI()\n        cnt = [0] * (2 * k + 2)\n        for i in range(n // 2):\n            (a, b) = (aa[i], aa[n - 1 - i])\n            if a > b:\n                (a, b) = (b, a)\n            cnt[0] += 2\n            cnt[a + 1] += -1\n            cnt[a + b] += -1\n            cnt[a + b + 1] += 1\n            cnt[b + k + 1] += 1\n        for i in range(2 * k + 1):\n            cnt[i + 1] += cnt[i]\n        print(min(cnt))\nmain()", "from collections import defaultdict\nfrom itertools import accumulate\n\ndef solve(a, n, k):\n    pairs = [(min(x, y), max(x, y)) for (x, y) in zip(a[:n], a[::-1][:n])]\n    one_change = [(x + 1, y + k) for (x, y) in pairs]\n    changes = [0] * (2 * k + 2)\n    for (a, b) in one_change:\n        changes[a] += 1\n        changes[b + 1] -= 1\n    changes = list(accumulate(changes))\n    for (x, y) in pairs:\n        changes[x + y] += 1\n    print(2 * n - max(changes[2:2 * k + 1]))\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    solve(a, n // 2, k)", "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (n, k) = map(int, input().split())\n        nums = list(map(int, input().split()))\n        dp = [0] * (2 * k + 2)\n        for i in range(n // 2):\n            (a, b) = (nums[i], nums[n - 1 - i])\n            if a > b:\n                (a, b) = (b, a)\n            s = a + b\n            lo = s - (b - 1)\n            hi = s + (k - a)\n            dp[lo] -= 1\n            dp[s] -= 1\n            dp[s + 1] += 1\n            dp[hi + 1] += 1\n        mn = n\n        cur = n\n        for i in range(2, 2 * k + 1):\n            cur += dp[i]\n            mn = min(cur, mn)\n        print(mn)\nmain()", "def solve(a, k):\n    half = len(a) // 2\n    buckets = [0 for x in range(2 * (k + 2))]\n    for i in range(half):\n        min_value = min(a[i], a[~i])\n        max_value = max(a[i], a[~i])\n        buckets[1] += 2\n        buckets[min_value + 1] -= 1\n        buckets[min_value + max_value] -= 1\n        buckets[min_value + max_value + 1] += 1\n        buckets[max_value + k + 1] += 1\n    curr = 0\n    result = 99999999999999999999\n    for i in buckets[1:]:\n        curr += i\n        result = min(result, curr)\n    return result\nfor i in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    print(solve(a, k))", "def solve():\n    (n, k) = [int(i) for i in input().split()]\n    v = [int(i) for i in input().split()]\n    sum = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        x = v[i]\n        y = v[n - i - 1]\n        if y > x:\n            (x, y) = (y, x)\n        sum[x + y] += 1\n        sum[x + k + 1] -= 1\n        sum[y + 1] += 1\n        sum[x + y + 1] -= 1\n    pos = -1\n    mx = -9999999\n    for i in range(len(sum)):\n        sum[i] += sum[i - 1]\n        if sum[i] > mx:\n            mx = sum[i]\n            pos = i\n    elem = pos\n    c = 0\n    for i in range(n // 2):\n        x = v[i]\n        y = v[n - i - 1]\n        if y > x:\n            (x, y) = (y, x)\n        if elem >= y + 1 and elem <= x + k:\n            if x + y != elem:\n                c += 1\n        else:\n            c += 2\n    print(c)\nt = int(input())\nwhile t:\n    t -= 1\n    solve()", "for _ in range(int(input())):\n    (n, k) = [int(j) for j in input().split()]\n    a = [int(x) for x in input().split()]\n    lst = [n] + [0] * (k * 2)\n    for i in range(n // 2):\n        (x, y) = sorted((a[i], a[-(i + 1)]))\n        lst[x] -= 1\n        lst[x + y - 1] -= 1\n        lst[x + y] += 1\n        lst[k + y] += 1\n    for i in range(2 * k):\n        lst[i + 1] += lst[i]\n    print(min(lst))", "def task(n, k, a):\n    sums = {}\n    maxk = k * 2 + 2\n    mins = [0] * maxk\n    maxs = [0] * maxk\n    half = int(n / 2)\n    for i in range(0, half):\n        c = a[i]\n        d = a[n - 1 - i]\n        suma = c + d\n        if not suma in sums:\n            sums[suma] = 0\n        sums[suma] += 1\n        mins[min(c, d) + 1] += 1\n        maxs[max(c, d) + k + 1] += 1\n    value = 0\n    best = half\n    for i in range(0, maxk):\n        value += mins[i] - maxs[i]\n        if i in sums:\n            one_swap = value - sums[i]\n            two_swaps = half - value\n            swaps = one_swap + 2 * two_swaps\n            best = min(best, swaps)\n    print(best)\nt = int(input())\nfor i in range(0, t):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    task(n, k, a)", "def run(lst, n, k):\n    pref = [0 for i in range(2 * k + 2)]\n    for i in range(int(n / 2)):\n        l = lst[i]\n        r = lst[n - i - 1]\n        menor = min(l, r)\n        maior = max(l, r)\n        pref[1] += 2\n        pref[menor + 1] -= 1\n        pref[l + r] -= 1\n        pref[l + r + 1] += 1\n        pref[maior + k + 1] += 1\n    for i in range(1, len(pref)):\n        pref[i] += pref[i - 1]\n    print(min(pref[2:-1]))\ni = int(input())\nfor _ in range(i):\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    run(lst, n, k)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    L = list(map(int, input().split()))\n    prefix = [0] * (2 * K + 2)\n    prefix[1] = N\n    for i in range(N // 2):\n        (x, y) = sorted((L[i], L[~i]))\n        prefix[x + 1] -= 1\n        prefix[x + y] -= 1\n        prefix[x + y + 1] += 1\n        prefix[y + K + 1] += 1\n    for i in range(1, 2 * K + 2):\n        prefix[i] += prefix[i - 1]\n    print(min(prefix[2:]))", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    c = [n] + [0] * k * 2\n    for i in range(n // 2):\n        (x, y) = sorted((a[i], a[~i]))\n        c[x] -= 1\n        c[x + y - 1] -= 1\n        c[x + y] += 1\n        c[k + y] += 1\n    for i in range(k * 2):\n        c[i + 1] += c[i]\n    print(min(c))", "def answer():\n    s = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        s[a[i] + a[n - i - 1]] += 1\n        s[a[i] + a[n - i - 1] + 1] -= 1\n        s[min(a[i], a[n - i - 1]) + 1] += 1\n        s[max(a[i], a[n - i - 1]) + k + 1] -= 1\n    ans = 1000000000.0\n    e_less = 0\n    for i in range(2 * k + 1):\n        e_less += s[i]\n        opp = n - e_less\n        ans = min(ans, opp)\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(answer())", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    c = [n] + [0] * (k * 2)\n    for i in range(n // 2):\n        (x, y) = sorted((a[i], a[-(i + 1)]))\n        c[x] -= 1\n        c[x + y - 1] -= 1\n        c[x + y] += 1\n        c[k + y] += 1\n    for i in range(k * 2):\n        c[i + 1] += c[i]\n    print(min(c))", "t1 = int(input())\nfor x in range(t1):\n    (n, k) = map(int, input().split())\n    t = list(map(int, input().split()))\n    el_sum = [0] * (2 * k + 2)\n    for y in range(0, n // 2):\n        l = t[y]\n        r = t[n - y - 1]\n        el_sum[0] += 2\n        el_sum[l + r] -= 1\n        el_sum[l + r + 1] += 1\n        el_sum[min(l, r) + 1] -= 1\n        el_sum[max(l, r) + k + 1] += 1\n    for y in range(2 * k + 1):\n        el_sum[y + 1] += el_sum[y]\n    print(min(el_sum))", "t = int(input())\nfor _ in range(t):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    s = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        x = a[i]\n        y = a[n - i - 1]\n        s[2] += 2\n        s[min(x, y) + 1] -= 1\n        s[max(x, y) + k + 1] += 1\n        s[x + y] -= 1\n        s[x + y + 1] += 1\n    for i in range(2, 2 * k + 2):\n        s[i] += s[i - 1]\n    print(min(s[2:]))", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    L = list(map(int, input().split()))\n    prefix = [0] * (2 * K + 2)\n    prefix[1] = N\n    for i in range(N // 2):\n        (x, y) = sorted((L[i], L[N - i - 1]))\n        prefix[x + 1] -= 1\n        prefix[x + y] -= 1\n        prefix[x + y + 1] += 1\n        prefix[y + K + 1] += 1\n    for i in range(1, 2 * K + 2):\n        prefix[i] += prefix[i - 1]\n    print(min(prefix[1:]))", "inp = input\nli = list\niinp = lambda : int(inp())\nent = lambda : map(int, inp().split())\nlient = lambda : [int(i) for i in inp().split()]\nli0 = lambda x: [0 for i in range(x)]\nstent = lambda : [i for i in inp()]\nmi = min\nma = max\nl = len\nt = iinp()\nfor _ in range(t):\n    (lon, valormax) = ent()\n    numeros = lient()\n    s = [0] * (2 * valormax + 2)\n    for i in range(lon // 2):\n        puntero1 = numeros[i]\n        puntero2 = numeros[lon - i - 1]\n        s[2] += 2\n        s[mi(puntero1, puntero2) + 1] -= 1\n        s[ma(puntero1, puntero2) + valormax + 1] += 1\n        s[puntero1 + puntero2] -= 1\n        s[puntero1 + puntero2 + 1] += 1\n    for i in range(2, 2 * valormax + 2):\n        s[i] += s[i - 1]\n    print(mi(s[2:]))", "from itertools import accumulate\nfor t in range(int(input())):\n    (n, k) = map(int, input().strip().split())\n    arr = list(map(int, input().strip().split()))\n    b = [0] * (2 * k + 2)\n    c = [0] * (2 * k + 1)\n    for i in range(n // 2):\n        (x, y) = sorted([arr[i], arr[~i]])\n        b[x + 1] += 1\n        b[y + k + 1] -= 1\n        c[x + y] += 1\n    b = list(accumulate(b))\n    d = [0] * (2 * k + 1)\n    for i in range(2 * k + 1):\n        d[i] = n - c[i] - b[i]\n    d[0] = n\n    d[1] = n\n    print(min(d))", "from bisect import bisect, bisect_left, bisect_right\n\ndef solve():\n    (n, k) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    ocr = {}\n    mpv = [None] * (n // 2)\n    spv = [None] * (n // 2)\n    for i in range(n // 2):\n        x = ar[i] + ar[n - i - 1]\n        mpx = max(ar[i], ar[n - i - 1]) + k\n        spx = min(ar[i], ar[n - i - 1]) + 1\n        spv[i] = spx\n        mpv[i] = mpx\n        if x in ocr:\n            ocr[x] += 1\n        else:\n            ocr[x] = 1\n    mpv.sort()\n    spv.sort()\n    best = n // 2\n    for (x, oc) in ocr.items():\n        over = bisect_left(mpv, x, 0, len(mpv))\n        under = n // 2 - bisect_right(spv, x, 0, len(spv))\n        cur = n // 2 - oc + over + under\n        if cur < best:\n            best = cur\n    print(best)\nt = int(input())\nfor _ in range(t):\n    solve()", "import bisect\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        line = input().split()\n        (n, k) = (int(line[0]), int(line[1]))\n        nums = list(map(int, input().split()))\n        dic = {}\n        min_ = []\n        max_ = []\n        for i in range(n // 2):\n            dic[nums[i] + nums[n - i - 1]] = dic.get(nums[i] + nums[n - i - 1], 0) + 1\n            min_.append(min(nums[i], nums[n - i - 1]))\n            max_.append(max(nums[i], nums[n - i - 1]))\n        min_.sort()\n        max_.sort()\n        m = len(min_)\n        ans = m\n        for key in dic:\n            res = 0\n            left = bisect.bisect_left(max_, key - k)\n            res += left * 2\n            right = bisect.bisect_right(min_, key - 1)\n            res += (m - right) * 2\n            res += m - left - (m - right) - dic[key]\n            ans = min(ans, res)\n        print(ans)\nmain()", "def answer():\n    s = [0] * (2 * k + 1)\n    ele_l = [0] * (2 * k + 1)\n    sub = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        s[a[i] + a[n - i - 1]] += 1\n        ele_l[min(a[i], a[n - i - 1]) + 1] += 1\n        sub[max(a[i], a[n - i - 1]) + k + 1] -= 1\n    ans = 1000000000.0\n    e_less = 0\n    for i in range(2 * k + 1):\n        e_less += ele_l[i] + sub[i]\n        opp = n - e_less - s[i]\n        ans = min(ans, opp)\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(answer())", "n = int(input())\nfor i in range(n):\n    h = list(map(int, input().rstrip().split()))\n    N = h[0]\n    K = h[1]\n    h = list(map(int, input().rstrip().split()))\n    t = [0] * (2 * K + 2)\n    for i in range(N // 2):\n        t[h[i] + h[N - i - 1]] -= 1\n        t[h[i] + h[N - i - 1] + 1] += 1\n        t[max(h[i], h[N - i - 1]) + K + 1] += 1\n        t[min(h[i], h[N - i - 1]) + 1] -= 1\n    v = N\n    minv = N\n    for i in range(2 * K + 2):\n        v += t[i]\n        if v < minv:\n            minv = v\n    print(minv)", "import sys\nsys.setrecursionlimit(10 ** 9)\ninput = sys.stdin.readline\nfrom collections import deque\nt = int(input())\nfor ii in range(t):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    d = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        a = l[i]\n        b = l[n - 1 - i]\n        p = min(a, b)\n        q = max(a, b)\n        mi = p + 1\n        ma = q + k\n        d[0] += 2\n        d[mi - 1] -= 2\n        d[mi - 1] += 1\n        d[p + q - 1] -= 1\n        d[p + q] += 1\n        d[ma] -= 1\n        d[ma] += 2\n        d[-1] -= 2\n    for i in range(2 * k + 1):\n        d[i + 1] += d[i]\n    print(min(d[:-1]))\nsys.exit()\nN = 5\nes = [[1, 2, 3], [0, 2], [0, 1], [0, 4], [3]]\ncolors = [0 for i in range(N)]\n\ndef dfs(v, color):\n    print(v, color)\n    colors[v] = color\n    for to in es[v]:\n        if colors[to] == color:\n            return False\n        if colors[to] == 0 and (not dfs(to, -color)):\n            return False\n    return True\n\ndef is_bipartite():\n    return dfs(0, 1)\nprint(is_bipartite())", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        x = a[i] + a[n - i - 1]\n        (p, q) = (min(a[i], a[n - i - 1]), max(a[i], a[n - i - 1]))\n        b[p + 1] -= 1\n        b[q + k + 1] += 1\n    for i in range(2, 2 * k + 1):\n        b[i] += b[i - 1]\n    for i in range(n // 2):\n        x = a[i] + a[n - i - 1]\n        b[x] -= 1\n    ans = min(b)\n    print(ans + n)", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    price = [0] * (2 * k + 5)\n    for i in range(n // 2):\n        price[2] += 2\n        s = min(a[i], a[n - i - 1])\n        l = max(a[i], a[n - i - 1])\n        price[s + 1] -= 1\n        price[s + l] -= 1\n        price[s + l + 1] += 1\n        price[l + k + 1] += 1\n    sum = 0\n    maxi = 1000000000000.0\n    for i in price[2:2 * k + 2]:\n        sum += i\n        maxi = min(maxi, sum)\n    print(maxi)", "for t in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    price = [0] * (2 * k + 5)\n    for i in range(n // 2):\n        price[2] += 2\n        s = min(a[i], a[n - i - 1])\n        l = max(a[i], a[n - i - 1])\n        price[s + 1] -= 1\n        price[s + l] -= 1\n        price[s + l + 1] += 1\n        price[l + k + 1] += 1\n    sum = 0\n    maxi = 1000000000000.0\n    for i in price[2:2 * k + 2]:\n        sum += i\n        maxi = min(maxi, sum)\n    print(maxi)", "for i in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [int(i) for i in input().split()]\n    c = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        x = a[i]\n        y = a[n - i - 1]\n        maxi = max(x, y) + k\n        mini = min(x, y) + 1\n        c[x + y] -= 1\n        c[x + y + 1] += 1\n        c[mini] += 1\n        c[maxi + 1] -= 1\n        c[2] += 2\n        c[mini] -= 2\n        c[maxi + 1] += 2\n        c[2 * k + 1] -= 2\n    ans = []\n    cur = 0\n    for i in range(2, 2 * k + 1):\n        cur += c[i]\n        ans.append(cur)\n    print(min(ans))", "def run(lst, n, k):\n    ans = float('inf')\n    cnt = [0 for i in range(int(2 * k + 1))]\n    for i in range(int(n / 2)):\n        soma = lst[i] + lst[n - i - 1]\n        cnt[soma] += 1\n    pref = [0 for i in range(int(2 * k + 2))]\n    for i in range(int(n / 2)):\n        menor = min(lst[i] + 1, lst[n - i - 1] + 1)\n        maior = max(lst[i] + k, lst[n - i - 1] + k)\n        pref[menor] += 1\n        pref[maior + 1] -= 1\n    for i in range(1, len(pref) - 1):\n        pref[i] += pref[i - 1]\n    for i in range(1, len(pref) - 1):\n        pref[i] = n - cnt[i] - pref[i]\n    print(min(pref[2:-1]))\ni = int(input())\nfor _ in range(i):\n    (n, k) = map(int, input().split())\n    lst = list(map(int, input().split()))\n    run(lst, n, k)", "from collections import defaultdict\nimport sys\nstream = sys.stdin\nt = int(stream.readline())\nfor line in stream:\n    (n, k) = line.split()\n    (n, k) = map(int, (n, k))\n    sums_rating = defaultdict(int)\n    open_close = defaultdict(int)\n    numbers = stream.readline().split()\n    for i in range(n // 2):\n        n1 = int(numbers[i])\n        n2 = int(numbers[-(i + 1)])\n        sums_rating[n1 + n2] += 1\n        mini = min(n1, n2)\n        maxi = max(n1, n2)\n        open_close[mini + 1] += 1\n        open_close[maxi + k + 1] -= 1\n    curr_modifier = 0\n    best_result = -float('inf')\n    for i in range(2, 2 * k + 1):\n        curr_modifier += open_close[i]\n        if sums_rating[i] + curr_modifier > best_result:\n            best_result = sums_rating[i] + curr_modifier\n    print(n - best_result)", "import sys\n\ndef input():\n    return sys.stdin.readline()\nfor _ in range(int(input().strip())):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    common_values = [0 for _ in range(2 * k + 2)]\n    for i in range(n // 2):\n        (a, b) = (nums[i], nums[n - 1 - i])\n        common_values[a + b - max(a, b) + 1] -= 1\n        common_values[a + b] -= 1\n        common_values[a + b + 1] += 1\n        common_values[a + b - min(a, b) + k + 1] += 1\n    common_values[1] = n\n    minimum = n\n    for i in range(2, 2 * k + 1):\n        common_values[i] += common_values[i - 1]\n        minimum = min(minimum, common_values[i])\n    print(minimum)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    li = [0] * (2 * k)\n    pref = [0] * (2 * k)\n    c = []\n    if n == 2:\n        print(0)\n        continue\n    for i in range(n // 2):\n        li[a[i] + a[-i - 1] - 1] += 1\n    for i in range(n // 2):\n        (x, y) = (a[i], a[-i - 1])\n        range_min = min(x, y) + 1\n        range_max = max(x, y) + k\n        pref[range_min - 1] += 1\n        if range_max <= 2 * k - 1:\n            pref[range_max] -= 1\n    for i in range(1, len(pref)):\n        pref[i] += pref[i - 1]\n    for i in range(2 * k):\n        c.append(n - pref[i] - li[i])\n    print(min(c))", "for test in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = [*map(int, input().split())]\n    breakdown = [(a[i], a[n - 1 - i]) for i in range(n // 2) if not (a[i] > k and a[n - 1 - i] > k)]\n    update = n - 2 * len(breakdown)\n    score = [0 for value in range(2 * k + 2)]\n    for pair in breakdown:\n        (a, b) = pair\n        if a <= k and b <= k:\n            score[2] += 2\n            score[min(a, b) + 1] -= 1\n            score[max(a, b) + k + 1] += 1\n            score[a + b] -= 1\n            score[a + b + 1] += 1\n        elif a >= k:\n            score[2] += 2\n            score[b + 1] -= 1\n            score[b + k + 1] += 1\n        elif b >= k:\n            score[2] += 2\n            score[a + 1] -= 1\n            score[a + k + 1] += 1\n    control = 0\n    minimum = n\n    for key in score[2:2 * k + 1]:\n        control += key\n        minimum = min(minimum, control)\n    print(update + minimum)", "for _ in range(int(input().strip())):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    common_values = [0 for _ in range(2 * k + 2)]\n    for i in range(n // 2):\n        (a, b) = (nums[i], nums[n - 1 - i])\n        common_values[a + b - max(a, b) + 1] -= 1\n        common_values[a + b] -= 1\n        common_values[a + b + 1] += 1\n        common_values[a + b - min(a, b) + k + 1] += 1\n    common_values[1] = n\n    minimum = n\n    for i in range(2, 2 * k + 1):\n        common_values[i] += common_values[i - 1]\n        minimum = min(minimum, common_values[i])\n    print(minimum)", "import itertools\nnumcases = int(input())\n\ndef minmoves(asum, a, k):\n    count = {x: 0 for x in range(2 * k + 1)}\n    ans = 1000000\n    moves = 0\n    for sum in asum:\n        count[sum] = count[sum] + 1\n    rangex = [0 for i in range(2 * k + 2)]\n    (lower, upper) = (0, 0)\n    for i in range(int(n / 2)):\n        lower = min(a[i], a[n - 1 - i]) + 1\n        upper = max(a[i], a[n - 1 - i]) + k\n        rangex[lower] += 1\n        rangex[upper + 1] -= 1\n    prefix = list(itertools.accumulate(rangex))\n    for i in range(2, 2 * k + 1):\n        moves = prefix[i] - count[i] + 2 * (n / 2 - prefix[i])\n        if moves < ans:\n            ans = moves\n    return ans\nfor z in range(numcases):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    asum = []\n    sols = []\n    for i in range(int(n / 2)):\n        asum.append(a[i] + a[n - 1 - i])\n    ans = minmoves(asum, a, k)\n    print(int(ans))", "testCases = int(input())\nwhile testCases > 0:\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))[:n]\n    length = 2 * k + 1\n    (opened, closed, exist) = ([0] * length, [0] * length, [0] * length)\n    for i in range(int(n / 2)):\n        (L, R) = (a[i], a[n - 1 - i])\n        exist[L + R] += 1\n        opened[1 + min(L, R)] += 1\n        closed[k + max(L, R)] += 1\n    (Answer, inside) = (10 ** 9, 0)\n    for i in range(length):\n        inside += opened[i]\n        Answer = min(Answer, n - exist[i] - inside)\n        inside -= closed[i]\n    print(Answer)\n    testCases -= 1", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    Arr = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        mi = min(l[i], l[n - i - 1])\n        ma = max(l[i], l[n - i - 1])\n        Arr[mi + ma] -= 1\n        Arr[1] += 2\n        Arr[mi + 1] -= 1\n        Arr[mi + ma + 1] += 1\n        Arr[ma + k + 1] += 1\n    ans = 2e+18\n    for t in range(1, len(Arr)):\n        Arr[t] = Arr[t] + Arr[t - 1]\n        ans = min(ans, Arr[t])\n    print(ans)", "for i in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    arr = [int(i) for i in input().split()]\n    d = {}\n    na = [0 for i in range(2 * k + 2)]\n    for i in range(n // 2):\n        d[arr[i] + arr[-1 - i]] = d.get(arr[i] + arr[-1 - i], 0) + 1\n        na[max(arr[i], arr[-1 - i]) + k + 1] += -1\n        na[min(arr[i], arr[-1 - i]) + 1] += 1\n    for i in range(1, 2 * k + 2):\n        na[i] += na[i - 1]\n    key = list(d.keys())\n    ans = n\n    for i in key:\n        ans = min(ans, na[i] + (n // 2 - na[i]) * 2 - d[i])\n    print(min(ans, max(na) + (n // 2 - max(na)) * 2))", "from bisect import bisect, bisect_left, bisect_right\n\ndef solve():\n    (n, k) = map(int, input().split())\n    ar = list(map(int, input().split()))\n    ocr = {}\n    mpv = [None] * (n // 2)\n    spv = [None] * (n // 2)\n    for i in range(n // 2):\n        x = ar[i] + ar[n - i - 1]\n        mpx = max(ar[i], ar[n - i - 1]) + k\n        spx = min(ar[i], ar[n - i - 1]) + 1\n        spv[i] = spx\n        mpv[i] = mpx\n        if x in ocr:\n            ocr[x] += 1\n        else:\n            ocr[x] = 1\n    mpv.sort()\n    spv.sort()\n    items = [(v, k) for (k, v) in ocr.items()]\n    items.sort()\n    items.reverse()\n    best = n // 2\n    for (ocr, x) in items:\n        over = bisect_left(mpv, x, 0, len(mpv))\n        under = n // 2 - bisect_right(spv, x, 0, len(spv))\n        cur = n // 2 - ocr + over + under\n        if cur < best:\n            best = cur\n    print(best)\nt = int(input())\nfor _ in range(t):\n    solve()", "def RA():\n    l = input().split()\n    return [int(s) for s in l]\n\ndef solve():\n    (n, k) = RA()\n    arr = RA()\n    scores = [[0, 0, 0] for i in range(2 * k + 1)]\n    for i in range(n // 2):\n        a = arr[i]\n        b = arr[n - i - 1]\n        mini = min(a, b) + 1\n        maxi = a + b + k - min(a, b)\n        scores[mini][0] += 1\n        scores[a + b][1] += 1\n        scores[maxi][2] += 1\n    needChange = n\n    best = needChange\n    for i in range(2, 2 * k + 1):\n        needChange -= scores[i][0]\n        best = min(best, needChange - scores[i][1])\n        needChange += scores[i][2]\n    print(best)\nt = int(input())\nfor i in range(t):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    test = int(input())\n    for _ in range(test):\n        (n, k) = map(int, input().split())\n        arr = [int(x) for x in input().split()]\n        zeromove = [0 for i in range(2 * k + 2)]\n        onemove = [0 for i in range(2 * k + 2)]\n        for idx in range(0, n // 2):\n            zeromove[arr[idx] + arr[n - idx - 1]] += 1\n            left = min(arr[idx], arr[n - idx - 1]) + 1\n            right = max(arr[idx], arr[n - idx - 1]) + k\n            onemove[left] += 1\n            onemove[right + 1] -= 1\n        ans = n\n        for pairsum in range(2, 2 * k + 1):\n            onemove[pairsum] += onemove[pairsum - 1]\n            zero = zeromove[pairsum]\n            one = onemove[pairsum] - zero\n            two = n // 2 - one - zero\n            ans = min(ans, one + 2 * two)\n            assert one >= 0\n            assert two >= 0\n        print(ans)\nmain()", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    stats = {}\n    for i in range(n // 2):\n        (a1, an) = (a[i], a[n - i - 1])\n        x = a1 + an\n        stats[x - max(a1, an) + 1] = stats.get(x - max(a1, an) + 1, 0) - 1\n        stats[x] = stats.get(x, 0) - 1\n        stats[x + 1] = stats.get(x + 1, 0) + 1\n        stats[x + (k - min(a1, an)) + 1] = stats.get(x + (k - min(a1, an)) + 1, 0) + 1\n    min_sum = n\n    cur_sum = n\n    for (k, diff) in sorted(stats.items(), key=lambda xx: xx[0]):\n        cur_sum += diff\n        if cur_sum < min_sum:\n            min_sum = cur_sum\n    print(min_sum)", "import sys\n\ndef input():\n    return sys.stdin.readline()[:-1]\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    cum = [0 for _ in range(2 * k + 2)]\n    for i in range(n // 2):\n        (x, y) = (a[i], a[n - i - 1])\n        cum[2] += 2\n        cum[min(x, y) + 1] -= 1\n        cum[x + y] -= 1\n        cum[x + y + 1] += 1\n        cum[max(x, y) + k + 1] += 1\n        cum[2 * k + 1] -= 2\n    ans = n\n    for i in range(2, 2 * k + 1):\n        cum[i] += cum[i - 1]\n        ans = min(ans, cum[i])\n    print(ans)", "from sys import stdin, exit\ninput = stdin.readline\n\ndef i():\n    return input()\n\ndef ii():\n    return int(input())\n\ndef iis():\n    return map(int, input().split())\n\ndef liis():\n    return list(map(int, input().split()))\n\ndef print_array(a):\n    print(' '.join(map(str, a)))\nt = ii()\nfor _ in range(t):\n    (n, k) = iis()\n    a = liis()\n    counter = {}\n    poss = []\n    add = [0 for i in range(2 * k + 2)]\n    rem = [0 for i in range(2 * k + 2)]\n    alt = [0 for i in range(2 * k + 2)]\n    for i in range(n // 2):\n        ini = a[i]\n        fim = a[n - i - 1]\n        mini = 1 + min(ini, fim)\n        maxi = k + max(ini, fim)\n        alt[ini + fim] += 1\n        add[mini] += 1\n        rem[maxi + 1] += 1\n    count = 0\n    for i in range(2, len(add) - 1):\n        count += add[i] - rem[i]\n        two = (n // 2 - count) * 2\n        poss.append(count - alt[i] + two)\n    print(min(poss))", "t = int(input())\nfor x in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    pair_sum = [0 for y in range(2 * k + 2)]\n    i = 0\n    while i < n // 2:\n        pair_sum[2] += 2\n        pair_sum[min(a[i], a[n - i - 1]) + 1] += -1\n        pair_sum[max(a[i], a[n - i - 1]) + k + 1] += 1\n        pair_sum[a[i] + a[n - i - 1]] += -1\n        pair_sum[a[i] + a[n - i - 1] + 1] += 1\n        i += 1\n    min_val = pair_sum[2]\n    for i in range(3, 2 * k + 1):\n        pair_sum[i] += pair_sum[i - 1]\n        if pair_sum[i] < min_val:\n            min_val = pair_sum[i]\n    print(min_val)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    lowpen = [0 for j in range(k)]\n    highpen = [0 for j in range(k)]\n    Reward = [0 for j in range(2 * k - 1)]\n    for j in range(0, n // 2):\n        a = min(nums[j], nums[n - j - 1])\n        b = max(nums[j], nums[n - j - 1])\n        lowpen[a - 1] += 1\n        highpen[b - 1] += 1\n        Reward[a + b - 2] += 1\n    for j in range(1, k):\n        lowpen[k - 1 - j] += lowpen[k - j]\n        highpen[j] += highpen[j - 1]\n    for j in range(1, k):\n        Reward[j - 1] -= lowpen[j]\n    for j in range(k, 2 * k - 1):\n        Reward[j] -= highpen[j - k]\n    print(n // 2 - max(Reward))", "from sys import stdin\nfrom functools import lru_cache, cmp_to_key\nfrom itertools import accumulate, product, permutations, combinations, combinations_with_replacement\nfrom collections import Counter, deque\nfrom bisect import bisect_left, bisect_right\n\ndef solver():\n    line = stdin.readline()\n    [n, k] = [*map(int, line.split())]\n    line = stdin.readline()\n    nums = [*map(int, line.split())]\n    (mn, mx, sum) = ([], [], [])\n    for i in range(n // 2):\n        mn.append(min(nums[i], nums[n - 1 - i]))\n        mx.append(max(nums[i], nums[n - 1 - i]))\n        sum.append(nums[i] + nums[n - 1 - i])\n    mn.sort()\n    mx.sort()\n    cnt = [n // 2] * (2 * k + 1)\n    for i in range(k + 1):\n        pos = bisect_left(mn, i)\n        cnt[i] += n // 2 - pos\n    for i in range(k + 1, k * 2 + 1):\n        pos = bisect_left(mx, i - k)\n        cnt[i] += pos\n    for i in sum:\n        cnt[i] -= 1\n    res = min(cnt)\n    print('{}'.format(res))\n\ndef main():\n    T = int(stdin.readline())\n    for case_num in range(T):\n        solver()\nmain()", "def solve(n, k, ls):\n    ans = n\n    sums = []\n    constant = [0] * (2 * k + 1)\n    for i in range(int(n / 2)):\n        s = ls[i] + ls[n - i - 1]\n        constant[s] += 1\n    minmax = [0] * (2 * k + 1)\n    for i in range(int(n / 2)):\n        a = ls[i]\n        b = ls[n - i - 1]\n        min_sum = min(a, b) + 1\n        max_sum = max(a, b) + k\n        minmax[min_sum] += 1\n        if max_sum == 2 * k:\n            continue\n        minmax[max_sum + 1] -= 1\n    for i in range(1, 2 * k + 1):\n        minmax[i] += minmax[i - 1]\n    for x in range(2, 2 * k + 1):\n        ans = min(ans, minmax[x] - constant[x] + (int(n / 2) - minmax[x]) * 2)\n    return ans\nno = int(input())\nfor i in range(no):\n    (n, k) = tuple(map(int, input().strip().split()))\n    ls = list(map(int, input().strip().split()))\n    print(solve(n, k, ls))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    x = [0 for i in range(2 * k + 2)]\n    for i in range(n // 2):\n        x[k + max(l[i], l[n - 1 - i]) + 1] -= 1\n        x[1 + min(l[i], l[n - 1 - i])] += 1\n    low = 0\n    high = 0\n    maxfreq = 0\n    for i in range(1, 2 * k + 1):\n        x[i] += x[i - 1]\n    for i in range(1, 2 * k + 1):\n        if x[i] > maxfreq:\n            maxfreq = x[i]\n            (low, high) = (i, i)\n        elif x[i] == maxfreq:\n            high = i\n    d = {}\n    maxchanges = 0\n    for i in range(n // 2):\n        s = l[i] + l[n - 1 - i]\n        if s in d:\n            d[s] += 1\n        else:\n            d[s] = 1\n        changes = d[s] + x[s]\n        if changes > maxchanges:\n            maxchanges = changes\n    print(n - max(maxchanges, max(x)))", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    cntx = [0] * (2 * k + 1)\n    prefx = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        cntx[a[i] + a[n - i - 1]] += 1\n        prefx[min(a[i], a[n - i - 1]) + 1] += 1\n        prefx[max(a[i], a[n - i - 1]) + k + 1] += -1\n    ans = n\n    p = 0\n    for i in range(2, 2 * k + 1):\n        p += prefx[i]\n        ans = min(ans, p - cntx[i] + (n // 2 - p) * 2)\n    print(ans)", "import sys\n\ndef solve():\n    (n, k) = [int(x) for x in input().split()]\n    li = [int(x) for x in input().split()]\n    zero_changes = [0] * (2 * k + 1)\n    for i in range(n // 2):\n        zero_changes[li[i] + li[n - i - 1]] += 1\n    one_changes = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        maxp = max(li[i], li[n - i - 1]) + k\n        minp = min(li[i], li[n - i - 1]) + 1\n        one_changes[minp] += 1\n        one_changes[maxp + 1] -= 1\n    for i in range(3, 2 * k + 1):\n        one_changes[i] += one_changes[i - 1]\n    minm = sys.maxsize\n    for i in range(2, 2 * k + 1):\n        zero = zero_changes[i]\n        one = one_changes[i] - zero\n        two = n // 2 - one - zero\n        total_cost = 2 * two + 1 * one + 0 * zero\n        minm = min(minm, total_cost)\n    print(minm)\nt = int(input())\nfor i in range(t):\n    solve()", "inf = float('inf')\nT = int(input())\nfor i in range(T):\n    (N, K) = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = [0] * (2 * K + 1)\n    C = [0] * (2 * K + 2)\n    for i in range(N // 2):\n        (a, b) = (A[i], A[N - i - 1])\n        if a > b:\n            (a, b) = (b, a)\n        B[a + b] += 1\n        C[a + 1] += 1\n        C[K + b + 1] -= 1\n    ans = inf\n    M = 0\n    for k in range(1, 2 * K + 1):\n        C[k] += C[k - 1]\n        (b, c) = (B[k], C[k])\n        a = c - b + 2 * (N // 2 - c)\n        ans = min(ans, a)\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    dic1 = {}\n    li = [0] * (2 * k + 2)\n    ar = list(map(int, input().split()))\n    for i in range(n // 2):\n        x = ar[i]\n        y = ar[-(i + 1)]\n        big = max(x, y)\n        sma = min(x, y)\n        x = x + y\n        if x in dic1:\n            dic1[x] += 1\n        else:\n            dic1[x] = 1\n        li[sma + 1] += 1\n        li[big + k + 1] -= 1\n    for i in range(1, 2 * k + 2):\n        li[i] += li[i - 1]\n    br = []\n    for j in range(1, 2 * k + 2):\n        br.append(li[j] - dic1.get(j, 0) + (n // 2 - li[j]) * 2)\n    print(min(br))", "for _ in '_' * int(input()):\n    ((n, k), a) = eval('[*map(int,input().split())],' * 2)\n    c = [n] + [0] * k * 2\n    for i in range(n // 2):\n        (x, y) = sorted((a[i], a[~i]))\n        c[x] -= 1\n        c[x + y - 1] -= 1\n        c[x + y] += 1\n        c[k + y] += 1\n    for i in range(k * 2):\n        c[i + 1] += c[i]\n    print(min(c))", "t = int(input())\nfor a in range(t):\n    (n, k) = map(int, input().split())\n    nums = list(map(int, input().split()))\n    lookUp = dict()\n    sumMinMax = []\n    values = [0 for c in range(2 * k + 2)]\n    for b in range(n // 2):\n        pairSum = nums[b] + nums[n - b - 1]\n        if pairSum in lookUp:\n            lookUp[pairSum] += 1\n        else:\n            lookUp[pairSum] = 1\n        sumMinMax.append([pairSum, 1 + min(nums[b], nums[n - b - 1]), k + max(nums[b], nums[n - b - 1])])\n        values[1 + min(nums[b], nums[n - b - 1])] += 1\n        values[k + max(nums[b], nums[n - b - 1]) + 1] -= 1\n    sumPrevious = 0\n    for c in range(len(values)):\n        values[c] += sumPrevious\n        sumPrevious = values[c]\n    best = 0\n    for key in lookUp:\n        actual = lookUp[key] - (n // 2 - values[key])\n        if actual > best:\n            best = actual\n    print(n // 2 - best)", "for _ in '_' * int(input()):\n    ((n, k), a) = eval('[*map(int,input().split())],' * 2)\n    c = [n] + [0] * k * 2\n    for i in range(n // 2):\n        (x, y) = sorted((a[i], a[~i]))\n        c[x] -= 1\n        c[x + y - 1] -= 1\n        c[x + y] += 1\n        c[k + y] += 1\n    for i in range(k * 2):\n        c[i + 1] += c[i]\n    print(min(c))", "import sys\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    lim = 2 * k + 2\n    l = list(map(int, input().split()))\n    (cnt, val) = ([0] * lim, [0] * lim)\n    for i in range(n // 2):\n        (a, b) = (l[i], l[n - i - 1])\n        cnt[a + b] += 1\n        val[max(a + k, b + k) + 1] -= 1\n        val[min(a + 1, b + 1)] += 1\n    ans = 10 ** 12\n    for i in range(1, 2 * k + 1):\n        val[i] += val[i - 1]\n    for s in range(2, lim):\n        ans = min(ans, val[s] - cnt[s] + 2 * (n // 2 - val[s]))\n    print(ans)", "q = int(input())\nfor _ in range(q):\n    (n, k) = map(int, input().split())\n    s = [int(i) for i in input().split()]\n    cost0 = [0] * (2 * k + 1)\n    cost1 = [0] * (2 * k + 1)\n    for i in range(n // 2):\n        cost0[s[i] + s[n - i - 1]] += 1\n        cost1[min(s[i], s[n - i - 1]) + 1] += 1\n        if max(s[i], s[n - i - 1]) < k:\n            cost1[max(s[i], s[n - i - 1]) + k + 1] -= 1\n    for i in range(3, 2 * k + 1):\n        cost1[i] += cost1[i - 1]\n    ans = n\n    for x in range(2, 2 * k + 1):\n        cost = n - cost1[x] - cost0[x]\n        ans = min(ans, cost)\n    print(ans)", "def main():\n    t = int(input())\n    while t > 0:\n        (n, k) = map(int, input().split())\n        arr = [int(e) for e in input().split()]\n        mp = {}\n        vec = []\n        for i in range(int(n / 2)):\n            if arr[i] + arr[n - i - 1] not in mp:\n                mp[arr[i] + arr[n - i - 1]] = 0\n            mp[arr[i] + arr[n - 1 - i]] += 1\n            vec.append([min(arr[i], arr[n - i - 1]), max(arr[i], arr[n - i - 1])])\n        pre = [0 for i in range(2 * k + 10)]\n        for (f, s) in vec:\n            l = f + 1\n            r = s + k\n            pre[l] += 1\n            pre[r + 1] -= 1\n        sum = 0\n        for i in range(0, 2 * k + 10):\n            sum += pre[i]\n            pre[i] = sum\n        ans = n\n        for x in range(2, 2 * k + 1):\n            cnt0 = mp.get(x)\n            if cnt0 == None:\n                cnt0 = 0\n            cnt1 = pre[x] - cnt0\n            cnt2 = n / 2 - cnt0 - cnt1\n            ans = min(ans, cnt1 + 2 * cnt2)\n        print(int(ans))\n        t -= 1\nmain()", "def main():\n    t = int(input())\n    while t > 0:\n        (n, k) = map(int, input().split())\n        arr = [int(e) for e in input().split()]\n        mp = {}\n        vec = []\n        for i in range(int(n / 2)):\n            if arr[i] + arr[n - i - 1] not in mp:\n                mp[arr[i] + arr[n - i - 1]] = 0\n            mp[arr[i] + arr[n - 1 - i]] += 1\n            vec.append([min(arr[i], arr[n - i - 1]), max(arr[i], arr[n - i - 1])])\n        pre = [0 for i in range(2 * k + 10)]\n        for (f, s) in vec:\n            l = f + 1\n            r = s + k\n            pre[l] += 1\n            pre[r + 1] -= 1\n        sum = 0\n        for i in range(0, 2 * k + 10):\n            sum += pre[i]\n            pre[i] = sum\n        ans = n\n        for x in range(2, 2 * k + 1):\n            cnt0 = mp.get(x)\n            if cnt0 == None:\n                cnt0 = 0\n            cnt1 = pre[x] - cnt0\n            cnt2 = n / 2 - cnt0 - cnt1\n            ans = min(ans, cnt1 + 2 * cnt2)\n        print(int(ans))\n        t -= 1\nmain()", "from sys import stdin\nimport sys\nfor _ in range(int(stdin.readline())):\n    (n, k) = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n    count = [0] * (2 * k + 1)\n    for i in range(n // 2):\n        count[arr[i] + arr[n - 1 - i]] += 1\n    prev = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        left = min(arr[i], arr[n - 1 - i]) + 1\n        right = max(arr[i], arr[n - i - 1]) + k\n        prev[left] += 1\n        prev[right + 1] -= 1\n    for i in range(1, 2 * k + 2):\n        prev[i] += prev[i - 1]\n    ans = 1000000\n    for i in range(2, 2 * k + 1):\n        ans = min(ans, prev[i] - count[i] + (n // 2 - prev[i]) * 2)\n    print(ans)", "for i in range(int(input())):\n    (n, k) = [int(x) for x in input().split()]\n    arr = [int(x) for x in input().split()]\n    cnt = [0 for i in range(2 * k + 5)]\n    pref = cnt[:]\n    for i in range(n // 2):\n        cnt[arr[i] + arr[n - i - 1]] += 1\n        mnSum = min(arr[i], arr[n - i - 1]) + 1\n        mxSum = max(arr[i], arr[n - i - 1]) + k\n        pref[mnSum] += 1\n        pref[mxSum + 1] -= 1\n    for i in range(1, len(pref)):\n        pref[i] += pref[i - 1]\n    ans = n\n    for i in range(len(pref)):\n        cur = pref[i] - cnt[i] + (n // 2 - pref[i]) * 2\n        ans = min(ans, cur)\n    print(ans)", "import sys\nfrom os import path\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    dic = {i: 0 for i in range(2, 2 * k + 5)}\n    pref = [0] * (2 * k + 5)\n    for i in range(n // 2):\n        (l, r) = (min(a[i], a[n - i - 1]), max(a[i], a[n - i - 1]))\n        dic[l + r] += 1\n        pref[l + 1] += 1\n        pref[r + k + 1] -= 1\n    for i in range(2, 2 * k + 1):\n        pref[i] += pref[i - 1]\n    ans = n\n    for i in range(2, 2 * k + 1):\n        chng0 = dic[i]\n        chng1 = pref[i] - chng0\n        chng2 = n // 2 - chng0 - chng1\n        ans = min(ans, chng1 + chng2 * 2)\n    print(ans)", "from sys import stdin, exit\ninput = stdin.readline\n\ndef i():\n    return input()\n\ndef ii():\n    return int(input())\n\ndef iis():\n    return map(int, input().split())\n\ndef liis():\n    return list(map(int, input().split()))\n\ndef print_array(a):\n    print(' '.join(map(str, a)))\nt = ii()\nfor _ in range(t):\n    (n, k) = iis()\n    a = liis()\n    counter = {}\n    poss = []\n    for i in range(n // 2):\n        ini = a[i]\n        fim = a[n - i - 1]\n        if ini <= k and fim <= k:\n            if ini + fim not in counter:\n                counter[ini + fim] = 0\n            counter[ini + fim] += 1\n    add = [0 for i in range(2 * k + 2)]\n    rem = [0 for i in range(2 * k + 2)]\n    alt = [0 for i in range(2 * k + 2)]\n    for i in range(n // 2):\n        ini = a[i]\n        fim = a[n - i - 1]\n        mini = 1 + min(ini, fim)\n        maxi = k + max(ini, fim)\n        alt[ini + fim] += 1\n        add[mini] += 1\n        rem[maxi + 1] += 1\n    count = 0\n    for i in range(2, len(add) - 1):\n        count += add[i] - rem[i]\n        two = (n // 2 - count) * 2\n        poss.append(count - alt[i] + two)\n    print(min(poss))", "def inp():\n    return int(input())\n\ndef inlt():\n    return list(map(int, input().split()))\n\ndef insr():\n    s = input()\n    return list(s[:len(s) - 1])\n\ndef invr():\n    return map(int, input().split())\n\ndef findmin(x, y):\n    if x < y:\n        return x\n    return y\n\ndef findmax(x, y):\n    if x > y:\n        return x\n    return y\nt = inp()\nfor i in range(0, t):\n    (n, k) = invr()\n    a = list(invr())\n    (min, max) = (0, 0)\n    f = [0] * (2 * k + 2)\n    cnt = [0] * (2 * k + 1)\n    for j in range(0, int(n / 2)):\n        cnt[a[j] + a[n - j - 1]] = cnt[a[j] + a[n - j - 1]] + 1\n        min = findmin(a[j], a[n - j - 1]) + 1\n        max = findmax(a[j], a[n - j - 1]) + k\n        f[min] = f[min] + 1\n        f[max + 1] = f[max + 1] - 1\n    for j in range(1, 2 * k + 1):\n        f[j] = f[j] + f[j - 1]\n    result = 999999\n    for l in range(2, 2 * k + 1):\n        q = f[l] - cnt[l] + (n / 2 - f[l]) * 2\n        if result > q:\n            result = q\n    print(int(result))", "A = [0 for x in range(400005)]\nt = int(input())\n\ndef mymin(a, b):\n    if a < b:\n        return a\n    else:\n        return b\n\ndef mymax(a, b):\n    if a > b:\n        return a\n    else:\n        return b\nfor tests in range(t):\n    [n, k] = input().split()\n    n = int(n)\n    k = int(k)\n    B = input().split()\n    for i in range(2, 2 * k + 1):\n        A[i] = 0\n    n2 = int(n / 2)\n    for i in range(n2):\n        B[i] = int(B[i])\n        B[n - 1 - i] = int(B[n - 1 - i])\n        mi = mymin(B[i], B[n - 1 - i])\n        ma = mymax(B[i], B[n - 1 - i])\n        A[2] += 2\n        A[mi + 1] -= 1\n        A[mi + ma] -= 1\n        if mi + ma + 1 <= 2 * k:\n            A[mi + ma + 1] += 1\n        if ma + k + 1 <= 2 * k:\n            A[ma + k + 1] += 1\n    ans = n\n    for i in range(2, 2 * k + 1):\n        A[i] += A[i - 1]\n        if A[i] < ans:\n            ans = A[i]\n    print(ans)", "import sys\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    lim = 2 * k + 2\n    l = list(map(int, input().split()))\n    (cnt, val) = ([0] * lim, [0] * lim)\n    for i in range(n // 2):\n        (a, b) = (l[i], l[n - i - 1])\n        cnt[a + b] += 1\n        val[max(a + k, b + k) + 1] -= 1\n        val[min(a + 1, b + 1)] += 1\n    ans = 10 ** 12\n    for i in range(1, 2 * k + 1):\n        val[i] += val[i - 1]\n    for s in range(2, lim):\n        ans = min(ans, val[s] - cnt[s] + 2 * (n // 2 - val[s]))\n    print(ans)", "t = int(input())\nfor x in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    arr_0 = [0 for i in range(2 * k + 1)]\n    arr_1 = [0 for i in range(2 * k + 2)]\n    for i in range(n // 2):\n        min_no = min(arr[i], arr[n - i - 1])\n        max_no = max(arr[i], arr[n - i - 1])\n        arr_0[min_no + max_no] += 1\n        l_ind = min_no + 1\n        r_ind = max_no + k\n        arr_1[l_ind] += 1\n        arr_1[r_ind + 1] -= 1\n    for i in range(2, 2 * k + 2):\n        arr_1[i] += arr_1[i - 1]\n    ans = 10000000\n    for i in range(2, 2 * k + 1):\n        cur_ans = arr_1[i] - arr_0[i] + 2 * (n // 2 - arr_1[i])\n        if cur_ans < ans:\n            ans = cur_ans\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    sum_costs = [n // 2] * (k * 2 + 1)\n    lower_penalties = [0] * (k * 2 + 1)\n    upper_penalties = [0] * (k * 2 + 1)\n    for (ai, aj) in zip(a[:n // 2], reversed(a[n // 2:])):\n        sum_costs[ai + aj] -= 1\n        lower_penalties[min(ai, aj)] += 1\n        if max(ai, aj) < k:\n            upper_penalties[max(ai, aj) + k + 1] += 1\n    for j in range(k * 2 - 1, -1, -1):\n        lower_penalties[j] += lower_penalties[j + 1]\n    for j in range(1, k * 2 + 1):\n        upper_penalties[j] += upper_penalties[j - 1]\n    for j in range(k * 2 + 1):\n        sum_costs[j] += lower_penalties[j] + upper_penalties[j]\n    print(min(sum_costs[2:]))", "t = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    cntx = [0] * (2 * k + 1)\n    for i in range(int(n / 2)):\n        cntx[a[i] + a[n - i - 1]] += 1\n    rangex = [0] * (2 * k + 2)\n    for i in range(int(n / 2)):\n        rangex[min(a[i], a[n - i - 1]) + 1] += 1\n        rangex[max(a[i], a[n - i - 1]) + k + 1] -= 1\n    for i in range(1, len(rangex)):\n        rangex[i] += rangex[i - 1]\n    mini = 1000000\n    for i in range(2, 2 * k + 1):\n        curr = rangex[i] - cntx[i] + 2 * (int(n / 2) - rangex[i])\n        if mini > curr:\n            mini = curr\n    print(mini)", "for _ in '_' * int(input()):\n    ((n, k), a) = eval('[*map(int,input().split())],' * 2)\n    c = [n] + [0] * k * 2\n    for i in range(n // 2):\n        (x, y) = sorted((a[i], a[~i]))\n        c[x] -= 1\n        c[x + y - 1] -= 1\n        c[x + y] += 1\n        c[k + y] += 1\n    for i in range(k * 2):\n        c[i + 1] += c[i]\n    print(min(c))", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nt = int(input())\n\ndef inc(n, arr, l, r):\n    if l <= r and l >= 0:\n        arr[l] += n\n        if r + 1 <= len(arr) - 1:\n            arr[r + 1] -= n\nfor i1 in range(t):\n    (n, k) = list(map(int, input().split(' ')))\n    l1 = list(map(int, input().split(' ')))\n    arr = [0] * (2 * k + 1)\n    for i in range(n // 2):\n        z1 = l1[i]\n        z2 = l1[n - i - 1]\n        s = z1 + z2\n        min1 = min(z1, z2)\n        max1 = max(z1, z2)\n        if s != 2 * k:\n            (l, r) = (s + k - min1 + 1, 2 * k)\n            inc(2, arr, l, r)\n            (l, r) = (s + 1, s + k - min1)\n            inc(1, arr, l, r)\n        (l, r) = (s - (max1 - 1), s - 1)\n        inc(1, arr, l, r)\n        (l, r) = (0, s - (max1 - 1) - 1)\n        inc(2, arr, l, r)\n    for i in range(1, len(arr)):\n        arr[i] += arr[i - 1]\n    print(min(arr))", "def foo(n, data, k):\n    farr = [0] * (2 * k + 1)\n    sarr = [0] * (2 * k + 2)\n    i = 0\n    while i < n // 2:\n        farr[data[i] + data[size - i - 1]] += 1\n        i += 1\n    i = 0\n    while i < n // 2:\n        sarr[min(data[i], data[size - i - 1]) + 1] += 1\n        sarr[max(data[i], data[size - i - 1]) + k + 1] -= 1\n        i += 1\n    i = 1\n    while i < 2 * k + 1:\n        sarr[i] += sarr[i - 1]\n        i += 1\n    i = 0\n    minimum = int(2 * 1000000.0)\n    while i <= k * 2:\n        minimum = min(minimum, sarr[i] - farr[i] + 2 * (n // 2 - sarr[i]))\n        i += 1\n    print(minimum)\ntest = int(input())\nwhile test:\n    (size, k) = [int(x) for x in input().split()]\n    data = [int(i) for i in input().split()]\n    foo(size, data, k)\n    test -= 1", "cnt = [0] * int(400000.0 + 5)\nf = [0] * int(400000.0 + 5)\nq = int(input())\nwhile q > 0:\n    q -= 1\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(n // 2):\n        j = n - 1 - i\n        if a[i] > a[j]:\n            temp = a[i]\n            a[i] = a[j]\n            a[j] = temp\n        cnt[max(a[i] + 1, 2)] -= 1\n        cnt[min(a[j] + k + 1, 2 * k + 1)] += 1\n        f[a[i] + a[j]] += 1\n    temp = n\n    res = int(2000000000.0)\n    for i in range(2, 2 * k + 1):\n        temp += cnt[i]\n        res = min(res, temp - f[i])\n    for i in range(n // 2):\n        j = n - 1 - i\n        if a[i] > a[j]:\n            swap(a[i], a[j])\n        cnt[max(a[i] + 1, 2)] = 0\n        cnt[min(a[j] + k + 1, 2 * k + 1)] = 0\n        f[a[i] + a[j]] = 0\n    print(res)", "def solve(n, k, a):\n    maxv = {i: 0 for i in range(2, 2 * k + 1)}\n    minv = {i: 0 for i in range(2, 2 * k + 1)}\n    exactv = {i: 0 for i in range(2, 2 * k + 1)}\n    for i in range(n // 2):\n        (x, y) = (a[i], a[-1 - i])\n        (x, y) = (min(x, y), max(x, y))\n        exactv[x + y] += 1\n        minv[x + 1] += 1\n        maxv[y + k] += 1\n    rs = 0\n    for i in range(2, 2 * k + 1):\n        rs += minv[i]\n        minv[i] = rs\n    rs = 0\n    for i in range(2 * k, 1, -1):\n        rs += maxv[i]\n        maxv[i] = rs\n    return min([n // 2 - minv[i] + (n // 2 - maxv[i]) + (n // 2 - exactv[i]) for i in range(2, 2 * k + 1)])\nt = int(input().strip())\nfor _ in range(t):\n    (n, k) = list(map(int, input().strip().split()))\n    a = list(map(int, input().strip().split()))\n    print(solve(n, k, a))", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    freq = [0 for i in range(2 * k + 5)]\n    freq2 = [0 for i in range(2 * k + 5)]\n\n    def check(ans1):\n        ans = float('inf')\n        best = 0\n        for i in range(1, 2 * k + 5):\n            tmp = 0\n            for j in range(n // 2):\n                if a[j] + a[n - j - 1] != i:\n                    if i - a[j] >= 1 and i - a[j] <= k:\n                        tmp += 1\n                    elif i - a[n - j - 1] >= 1 and i - a[n - j - 1] <= k:\n                        tmp += 1\n                    else:\n                        tmp += 2\n            if tmp < ans:\n                best = i\n            ans = min(ans, tmp)\n        return ans\n    for i in range(n // 2):\n        freq[min(a[n - 1 - i], a[i]) + 1] -= 1\n        freq[0] += 1\n        freq[max(a[n - 1 - i], a[i]) + k + 1] += 1\n    for i in range(n // 2):\n        freq2[a[i] + a[n - i - 1]] += 1\n    ans = float('inf')\n    for i in range(1, 2 * k + 1):\n        freq[i] += freq[i - 1]\n        ans = min(ans, freq[i] + n // 2 - freq2[i])\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = []\n    (i, j) = (0, n - 1)\n    while i < j:\n        p.append((min(a[i], a[j]), max(a[i], a[j])))\n        i += 1\n        j -= 1\n    pref = [0] * (2 * k + 2)\n    freq = [0] * (2 * k + 2)\n    for pair in p:\n        freq[pair[0] + pair[1]] += 1\n        pref[pair[0] + 1] += 1\n        pref[pair[1] + k + 1] -= 1\n    for m in range(2, 2 * k + 2):\n        pref[m] += pref[m - 1]\n    smin = 10 ** 9\n    for m in range(2, 2 * k + 1):\n        one = pref[m] - freq[m]\n        two = n // 2 - pref[m]\n        smin = min(smin, one + two * 2)\n    print(smin)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    p = []\n    (i, j) = (0, n - 1)\n    while i < j:\n        p.append((min(a[i], a[j]), max(a[i], a[j])))\n        i += 1\n        j -= 1\n    pref = [0] * (2 * k + 2)\n    freq = [0] * (2 * k + 2)\n    for pair in p:\n        freq[pair[0] + pair[1]] += 1\n        pref[pair[0] + 1] += 1\n        pref[pair[1] + k + 1] -= 1\n    for m in range(2, 2 * k + 2):\n        pref[m] += pref[m - 1]\n    smin = 10 ** 9\n    for m in range(2, 2 * k + 1):\n        one = pref[m] - freq[m]\n        two = n // 2 - pref[m]\n        smin = min(smin, one + two * 2)\n    print(smin)", "import os\nfrom collections import defaultdict\n\ndef f(nums, k):\n    n = len(nums)\n    n2 = n // 2\n    p = defaultdict(int, {})\n    mi = defaultdict(int, {})\n    ma = defaultdict(int, {})\n    for i in range(n2):\n        p[nums[i] + nums[n - i - 1]] += 1\n        mi[min(nums[i], nums[n - i - 1])] += 1\n        ma[max(nums[i], nums[n - i - 1])] += 1\n    mlx = 0\n    mgx = 0\n    cost = n\n    for x in range(2 * k + 1):\n        mlx += mi[x - 1]\n        mgx += ma[x - k - 1]\n        cost = min(n - mlx - p[x] + mgx, cost)\n    return cost\n\ndef pp(input):\n    n_test = int(input())\n    for i in range(n_test):\n        k = int(input().split()[1])\n        print(f(list(map(int, input().split())), k))\nif 'paalto' in os.getcwd():\n    from string_source import string_source\n    s = string_source('4\\n4 2\\n1 2 1 2\\n4 3\\n1 2 2 1\\n8 7\\n6 1 1 7 6 3 4 6\\n6 6\\n5 2 6 1 3 4')\n    pp(s)\nelse:\n    pp(input)", "from collections import defaultdict\nimport sys\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    l = list(map(int, input().split()))\n    m = []\n    d = defaultdict(int)\n    for i in range(n // 2):\n        d[l[i] + l[n - i - 1]] += 1\n    p = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        p[min(l[i], l[n - i - 1]) + 1] += 1\n        p[max(l[i], l[n - i - 1]) + k + 1] -= 1\n    for i in range(1, 2 * k + 2):\n        p[i] += p[i - 1]\n    ans = sys.maxsize\n    for i in range(2, 2 * k + 1):\n        ans = min(ans, p[i] - d[i] + 2 * (n // 2 - p[i]))\n    print(ans)", "from collections import deque\nfrom collections import OrderedDict\nimport math\nmaxValue = 2 * 100000 + 2\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    arrIn = input().split()\n    dp = [0] * (2 * max(k + 1, n + 1))\n    dp1 = [0] * (2 * max(k + 1, n + 1))\n    for i in range(len(arrIn)):\n        arrIn[i] = int(arrIn[i])\n    for i in range(len(arrIn) // 2):\n        x = arrIn[i]\n        y = arrIn[len(arrIn) - i - 1]\n        dp[2] += 2\n        dp[min(x, y) + 1] -= 2\n        dp[min(x, y) + 1] += 1\n        dp[x + y] -= 1\n        dp[x + y + 1] += 1\n        dp[max(x, y) + k + 1] -= 1\n        dp[max(x, y) + k + 1] += 2\n    for i in range(1, k * 2 + 1):\n        dp1[i] = dp1[i - 1] + dp[i]\n    answer = maxValue\n    for i in range(2, k * 2 + 1):\n        answer = min(answer, dp1[i])\n    print(answer)", "t = int(input())\n\ndef oco(l):\n    d = {}\n    for el in l:\n        if el in d:\n            d[el] += 1\n        else:\n            d[el] = 1\n    return d\nfor test in range(t):\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    psum = [a[i] + a[n - i - 1] for i in range(len(a) // 2)]\n    pmax = [k + max(a[i], a[n - i - 1]) for i in range(len(a) // 2)]\n    pmax.sort()\n    pmin = [1 + min(a[i], a[n - i - 1]) for i in range(len(a) // 2)]\n    pmin.sort()\n    di = oco(psum)\n    itma = 0\n    itmi = 0\n    ans = [0 for i in range(2 * k - 1)]\n    for i in range(len(ans)):\n        while itma < len(pmax):\n            if pmax[itma] >= i + 2:\n                break\n            itma += 1\n        while itmi < len(pmin):\n            if pmin[itmi] > i + 2:\n                break\n            itmi += 1\n        ans[i] = n + itma - itmi\n        if i + 2 in di:\n            ans[i] -= di[i + 2]\n    print(min(ans))", "t = int(input())\nwhile t:\n    (n, k) = map(int, input().rstrip().split())\n    a = list(map(int, input().rstrip().split()))\n    p = [0 for i in range(2 * k + 2)]\n    f = p.copy()\n    for i in range(n // 2):\n        f[a[i] + a[n - i - 1]] += 1\n        p[min(a[i], a[n - i - 1]) + 1] += 1\n        p[max(a[i], a[n - i - 1]) + k + 1] -= 1\n    s = 0\n    for i in range(len(p)):\n        s += p[i]\n        p[i] = s\n    ans = float('inf')\n    for i in range(2, 2 * k + 1):\n        ans = min(ans, p[i] - f[i] + (n // 2 - p[i]) * 2)\n    print(ans)\n    t -= 1", "t = int(input())\nfor _ in range(t):\n    [n, k] = map(int, input().split())\n    a = [*map(int, input().split())]\n    cnt = [0] * (2 * k)\n    intervals = [0] * (2 * k)\n    for i in range(n // 2):\n        v = a[i] + a[n - i - 1]\n        cnt[v - 1] += 1\n        ma = max(a[i], a[n - i - 1])\n        mi = min(a[i], a[n - i - 1])\n        intervals[mi] += 1\n        if ma + k < 2 * k:\n            intervals[ma + k] -= 1\n    for i in range(1, 2 * k):\n        intervals[i] += intervals[i - 1]\n    ans = 1000000000.0\n    for i in range(1, 2 * k):\n        ans = min(ans, intervals[i] - cnt[i] + (n // 2 - intervals[i]) * 2)\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    up = 2 * k + 2\n    count = [0] * up\n    bounds = [0] * up\n    for i in range(n // 2):\n        (minm, maxm) = (min(a[i] + 1, a[n - i - 1] + 1), max(a[i] + k, a[n - i - 1] + k))\n        count[minm + maxm - 1 - k] += 1\n        bounds[maxm + 1] -= 1\n        bounds[minm] += 1\n    for i in range(1, up - 1):\n        bounds[i] += bounds[i - 1]\n    ans = 10 ** 7\n    for i in range(2, up):\n        ans = min(ans, bounds[i] - count[i] + 2 * (n // 2 - bounds[i]))\n    print(ans)", "from itertools import accumulate\ntests = int(input())\nfor t in range(tests):\n    (n, k) = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    p = [(a[i], a[n - i - 1]) for i in range(n // 2)]\n    r = [(min(a, b) + 1, +1) for (a, b) in p] + [(a + b, +1) for (a, b) in p] + [(a + b + 1, -1) for (a, b) in p] + [(max(a, b) + k + 1, -1) for (a, b) in p]\n    print(n - max(list(accumulate([x for (_, x) in sorted(r)]))))", "t = int(input())\nfor i1 in range(t):\n    (n, k) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    sums = [0] * (2 * k + 2)\n    arr = [0] * (2 * k + 2)\n    pref = [0] * (2 * k + 2)\n    for i2 in range(0, n // 2):\n        temp = a[i2] + a[n - i2 - 1]\n        sums[temp] += 1\n        arr[min(a[i2], a[n - i2 - 1]) + 1] += 1\n        arr[max(a[i2], a[n - i2 - 1]) + k + 1] -= 1\n    temp = 0\n    for i2 in range(len(arr)):\n        temp += arr[i2]\n        pref[i2] = temp\n    result = 90000000000.0\n    for i2 in range(len(arr)):\n        temp = pref[i2] - sums[i2] + 2 * (n // 2 - pref[i2])\n        result = min(temp, result)\n    print(result)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    freq = {i: 0 for i in range(2, 2 * k + 1)}\n    pref = [0] * (2 * k + 10)\n    for i in range(n // 2):\n        (l, r) = (min(a[i], a[n - 1 - i]), max(a[i], a[n - 1 - i]))\n        freq[l + r] += 1\n        pref[l + 1] += 1\n        pref[r + k + 1] -= 1\n    ans = n\n    for i in range(2, 2 * k + 1):\n        pref[i] += pref[i - 1]\n        ans = min(ans, pref[i] - freq[i] + 2 * (n // 2 - pref[i]))\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    cnt_zero = [0] * (2 * k + 5)\n    cnt_zero_or_one = [0] * (2 * k + 5)\n    (i, j) = (0, n - 1)\n    while i < j:\n        actual_sum = a[i] + a[j]\n        cnt_zero[actual_sum] += 1\n        min_sum = min(a[i], a[j]) + 1\n        max_sum = max(a[i], a[j]) + k\n        cnt_zero_or_one[min_sum] += 1\n        cnt_zero_or_one[max_sum + 1] -= 1\n        i += 1\n        j -= 1\n    for i in range(1, len(cnt_zero_or_one)):\n        cnt_zero_or_one[i] += cnt_zero_or_one[i - 1]\n    ans = 2 ** 31\n    for x in range(2, len(cnt_zero_or_one)):\n        cnt_one_only = cnt_zero_or_one[x] - cnt_zero[x]\n        cnt_two = n / 2 - cnt_zero_or_one[x]\n        ans = min(ans, cnt_one_only + cnt_two * 2)\n    print(int(ans))", "testCases = int(input())\nwhile testCases > 0:\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))[:n]\n    (opened, closed, exist) = ({}, {}, {})\n    for i in range(2 * k + 1):\n        opened[i] = closed[i] = exist[i] = 0\n    for i in range(int(n / 2)):\n        (L, R) = (a[i], a[n - 1 - i])\n        exist[L + R] += 1\n        opened[1 + min(L, R)] += 1\n        closed[k + max(L, R)] += 1\n    (Answer, inside) = (10 ** 9, 0)\n    for i in range(2 * k + 1):\n        inside += opened[i]\n        Answer = min(Answer, n - exist[i] - inside)\n        inside -= closed[i]\n    print(Answer)\n    testCases -= 1", "import sys\nlines = sys.stdin.readlines()\nT = int(lines[0].strip())\nfor t in range(T):\n    (n, k) = map(int, lines[2 * t + 1].strip().split(' '))\n    nums = list(map(int, lines[2 * t + 2].strip().split(' ')))\n    noChange = {}\n    oneChange = {}\n    for i in range(2, 2 * k + 4):\n        noChange[i] = 0\n        oneChange[i] = 0\n    for i in range(n // 2):\n        l = nums[i]\n        r = nums[-i - 1]\n        noChange[l + r] += 1\n        oneChange[min(l, r) + 1] += 1\n        oneChange[l + r] -= 1\n        oneChange[l + r + 1] += 1\n        oneChange[max(l, r) + k + 1] -= 1\n    for i in range(3, 2 * k + 4):\n        oneChange[i] += oneChange[i - 1]\n    res = n\n    for i in range(2, 2 * k + 3):\n        tmp = n - oneChange[i] - 2 * noChange[i]\n        res = min(tmp, res)\n    print(res)", "import collections\nimport operator\nn = int(input())\nfor i in range(n):\n    mk = [int(i) for i in input().split(' ')]\n    m = mk[0]\n    k = mk[1]\n    ll = [int(i) for i in input().split(' ')]\n    rr = [0] * (2 * k + 2)\n    pref = [0] * (2 * k + 2)\n    lt = [0] * (2 * k + 2)\n    for i in range(m // 2):\n        rr[ll[i] + ll[m - 1 - i]] += 1\n    for i in range(m // 2):\n        a = min(ll[i] + 1, ll[m - 1 - i] + 1)\n        b = max(ll[i] + k, ll[m - i - 1] + k) + 1\n        pref[a] += 1\n        pref[b] -= 1\n    for i in range(1, 2 * k + 1):\n        pref[i] += pref[i - 1]\n    ans = m\n    for i in range(2, 2 * k + 1):\n        ans = min(ans, pref[i] - rr[i] + (m // 2 - pref[i]) * 2)\n    print(ans)", "for _ in range(int(input())):\n    (n, k) = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    count0 = [0] * (2 * k + 1)\n    pre_arr = [0] * (2 * k + 2)\n    for i in range(n // 2):\n        p1 = arr[i]\n        p2 = arr[n - i - 1]\n        l = min(p1, p2) + 1\n        r = max(p1, p2) + k\n        count0[p1 + p2] += 1\n        pre_arr[l] += 1\n        pre_arr[r + 1] -= 1\n    for i in range(1, 2 * k + 2):\n        pre_arr[i] += pre_arr[i - 1]\n    ans = float('INF')\n    for i in range(2, 2 * k + 1):\n        c0 = count0[i]\n        c1 = pre_arr[i] - c0\n        c2 = n // 2 - c0 - c1\n        ans = min(ans, c1 + 2 * c2)\n    print(ans)", "t = int(input())\nfor i in range(0, t):\n    (n, k) = map(int, input().split())\n    l1 = list(map(int, input().split()))\n    l2 = [0] * (2 * k + 2)\n    d = {}\n    for y in range(0, n // 2):\n        l = min(l1[y], l1[n - y - 1]) + 1\n        r = max(l1[y], l1[n - y - 1]) + k\n        l2[l] += 1\n        l2[r + 1] -= 1\n        sum = l1[y] + l1[n - y - 1]\n        if sum in d.keys():\n            d[sum] += 1\n        else:\n            d[sum] = 1\n    l1 = [l2[0]]\n    for y in range(1, len(l2)):\n        l1.append(l1[-1] + l2[y])\n    m = 10000000\n    for j in range(2, 2 * k + 1):\n        a = 0\n        c = 0\n        if j in d.keys():\n            a = d[j]\n        b = l1[j] - a\n        c = n // 2 - b - a\n        if b + 2 * c < m:\n            m = b + 2 * c\n    print(m)", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    arr = list(map(int, input().split()))\n    prefix = [0] * (2 * k + 10)\n    pairArr = [[min(arr[i], arr[n - i - 1]), max(arr[i], arr[n - i - 1])] for i in range(n // 2)]\n    keep = defaultdict(int)\n    for i in range(len(pairArr)):\n        l = pairArr[i][0] + 1\n        r = pairArr[i][1] + k\n        keep[pairArr[i][0] + pairArr[i][1]] += 1\n        prefix[l] += 1\n        prefix[r + 1] -= 1\n    s = 0\n    for i in range(2 * k + 10):\n        s += prefix[i]\n        prefix[i] = s\n    ans = float('inf')\n    which_x = 0\n    for x in range(2, 2 * k + 1):\n        c0 = keep[x]\n        c1 = prefix[x] - c0\n        c2 = n // 2 - c1 - c0\n        count = c2 * 2 + c1\n        if ans > count:\n            ans = count\n            which_x = x\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(map(int, input().split()))\n    cost = [0 for i in range(2 * k + 2)]\n    d = [0 for i in range(2 * k + 2)]\n    mn = 10 ** 9\n    h = 0\n    now_cost = 0\n    m = {i: 0 for i in range(2, 2 * k + 1)}\n    for i in range(n // 2):\n        b = a[i] + a[n - 1 - i]\n        m[b] += 1\n        d[1 + min(a[i], a[n - 1 - i])] += 1\n        d[k + max(a[i], a[n - 1 - i]) + 1] -= 1\n        cost[k + max(a[i], a[n - 1 - i]) + 1] -= 1\n        cost[1 + min(a[i], a[n - i - 1])] += 1\n    h = 0\n    for i in range(2, 2 * k + 1):\n        h += d[i]\n        now_cost += cost[i]\n        mn = min(mn, now_cost + 2 * (n // 2 - h) - m[i])\n    print(mn)", "for _ in range(int(input())):\n    (n, k) = [int(s) for s in input().split()]\n    arr = [int(s) for s in input().split()]\n    f1 = [0] * (2 * k + 1)\n    f2 = [0] * (2 * k + 1)\n    f3 = [0] * (2 * k + 1)\n    for i in range(n // 2):\n        a = arr[i]\n        b = arr[n - i - 1]\n        f1[a + b] += 1\n        f2[max(a, b) + k] += 1\n        f3[1 + min(a, b)] += 1\n    for i in range(2, 2 * k + 1):\n        f2[i] += f2[i - 1]\n        f3[i] += f3[i - 1]\n    ans = int(1000000000.0)\n    for i in range(1, 2 * k + 1):\n        ans = min(ans, n // 2 - f1[i] + f2[i - 1] + f3[2 * k] - f3[i])\n    print(ans)", "t = int(input())\ncnt = 0\nwhile cnt < t:\n    cnt += 1\n    (n, k) = [int(i) for i in input().split()]\n    a = [int(i) for i in input().split()]\n    c = []\n    for i in range(n // 2):\n        c.append((min(a[i] + 1, a[n - i - 1] + 1), -1))\n        c.append((max(a[i] + k, a[n - i - 1] + k) + 1, 1))\n    for i in range(n // 2):\n        c.append((a[i] + a[n - i - 1], -1))\n        c.append((a[i] + a[n - i - 1] + 1, 1))\n    d = {}\n    for i in range(len(c)):\n        d[c[i][0]] = d.get(c[i][0], 0) + c[i][1]\n    counter = n\n    val_res = n\n    for (key, val) in sorted(list(d.items())):\n        counter += val\n        if val_res > counter:\n            val_res = counter\n    print(val_res)"]