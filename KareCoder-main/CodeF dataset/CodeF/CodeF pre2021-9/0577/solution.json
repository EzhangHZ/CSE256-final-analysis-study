["T = int(input())\nfor iw in range(T):\n    (n, m) = map(int, input().split())\n    ans = 0\n    X = [-1] * (n + 1)\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if x != y:\n            ans += 1\n            X[x] = y\n    for i in range(1, n + 1):\n        if X[i] > 0:\n            t = i\n            while X[i] > 0:\n                x = X[i]\n                X[i] = 0\n                i = x\n                if i == t:\n                    ans += 1\n                    break\n    print(ans)", "def main():\n    arr = [0] * 100001\n    for _ in range(int(input())):\n        (size, count) = map(int, input().split())\n        for i in range(count):\n            (x, y) = map(int, input().split())\n            arr[x] = y\n        cycles = 0\n        petly = 0\n        for i in range(1, size + 1):\n            if arr[i] == i:\n                petly += 1\n                arr[i] = 0\n            k = i\n            while arr[k] != 0:\n                temp = arr[k]\n                arr[k] = 0\n                k = temp\n                if arr[k] == i:\n                    cycles += 1\n                    break\n        print(count - petly + cycles)\nmain()", "def main():\n    out = ''\n    arr = [0] * 100001\n    for _ in range(int(input())):\n        (size, count) = map(int, input().split())\n        for i in range(count):\n            (x, y) = map(int, input().split())\n            arr[x] = y\n        cycles = 0\n        petly = 0\n        for i in range(1, size + 1):\n            if arr[i] == i:\n                petly += 1\n                arr[i] = 0\n            k = i\n            while arr[k] != 0:\n                temp = arr[k]\n                arr[k] = 0\n                k = temp\n                if arr[k] == i:\n                    cycles += 1\n                    break\n        out += str(count - petly + cycles) + '\\n'\n    print(out)\nmain()", "def find(i):\n    k = i\n    if p[i] == -1:\n        return 0\n    while 1:\n        if p[i] == -1:\n            break\n        if p[i] == k:\n            break\n        l = i\n        t = p[i]\n        i = t\n        p[l] = -1\n    if p[i] == -1:\n        return 0\n    return 1\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    c = 0\n    p = [-1] * (n + 1)\n    for i in range(n + 1):\n        p[i] = -1\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if x != y:\n            c += 1\n            p[y] = x\n    an = 0\n    v = 0\n    for i in range(n + 1):\n        if p[i] != -1 and find(i) == 1:\n            p[i] = -1\n            v += 1\n    print(c + v)", "def solve():\n    (n, m) = map(int, input().split())\n    graph = dict()\n    result = int()\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        graph[x] = [y, False]\n    for (key, value) in graph.items():\n        if value[1] == False:\n            graph[key][1] = True\n            follow = graph[key][0]\n            if follow != key:\n                while True:\n                    if follow in graph and graph[follow][1] == False:\n                        graph[follow][1] = True\n                        result += 1\n                        follow = graph[follow][0]\n                        if follow == key:\n                            result += 1\n                            break\n                    else:\n                        break\n                result += 1\n    print(result)\n\ndef main():\n    for _ in range(int(input())):\n        solve()\nmain()", "t = int(input())\nfor j in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    arr = [-1 for i in range(n + 1)]\n    vis = [True for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(k) for k in input().split()]\n        if x != y:\n            vis[x] = False\n            arr[x] = y\n    vis[0] = True\n    ans = 0\n    for i in range(n + 1):\n        if vis[i] == False:\n            start = arr[i]\n            vis[i] = True\n            count = 1\n            while vis[start] == False:\n                vis[start] = True\n                count += 1\n                start = arr[start]\n                if start == i:\n                    count += 1\n            ans += count\n    print(ans)", "def getfather(x, father):\n    tmp_father = x\n    if father[x] != x:\n        tmp_father = getfather(father[x], father)\n    else:\n        tmp_father = x\n    father[x] = tmp_father\n    return tmp_father\nT = int(input().strip())\nfor _ in range(T):\n    line = input().strip().split()\n    (n, m) = (int(line[0]), int(line[1]))\n    result = 0\n    father = [idx for idx in range(n + 1)]\n    for _x in range(m):\n        line = input().strip().split()\n        (x, y) = (int(line[0]), int(line[1]))\n        if x == y:\n            continue\n        t1 = getfather(x, father)\n        t2 = getfather(y, father)\n        if t1 != t2:\n            result += 1\n            father[t1] = t2\n        else:\n            result += 2\n    print(result)", "def dsu(x):\n    p = x\n    while v[x] != x:\n        x = v[x]\n    v[p] = x\n    return x\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    v = [i for i in range(n + 1)]\n    ans = 0\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        if a == b:\n            continue\n        ans += 1\n        p = dsu(a)\n        q = dsu(b)\n        if p != q:\n            v[p] = v[q]\n        else:\n            ans += 1\n    print(ans)", "def dsu(x):\n    p = x\n    while v[x] != x:\n        x = v[x]\n    v[p] = x\n    return x\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    ans = 0\n    v = [i for i in range(n + 1)]\n    ans = 0\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        if a == b:\n            continue\n        ans += 1\n        p = dsu(a)\n        q = dsu(b)\n        if p != q:\n            v[p] = v[q]\n        else:\n            ans += 1\n    print(ans)", "arr = [0] * 100001\nfor _ in range(int(input())):\n    (size, count) = map(int, input().split())\n    for i in range(count):\n        (x, y) = map(int, input().split())\n        arr[x] = y\n    cycles = 0\n    petly = 0\n    for i in range(1, size + 1):\n        if arr[i] == i:\n            petly += 1\n            arr[i] = 0\n        k = i\n        while arr[k] != 0:\n            temp = arr[k]\n            arr[k] = 0\n            k = temp\n            if arr[k] == i:\n                cycles += 1\n                break\n    print(count - petly + cycles)", "for _ in range(int(input())):\n    (n, m) = [int(x) for x in input().split()]\n    l = [None] * (n + 1)\n    for _ in range(m):\n        (x, y) = [int(x) for x in input().split()]\n        l[x] = y\n    ans = 0\n    visited = [False] * (n + 1)\n    for i in range(n + 1):\n        if l[i] == None or l[i] == i or visited[i]:\n            continue\n        (tmp, cnt) = (l[i], 1)\n        visited[i] = True\n        while tmp != i and tmp != None and (visited[tmp] == False):\n            visited[tmp] = True\n            tmp = l[tmp]\n            cnt += 1\n        cnt += tmp == i\n        cnt -= tmp == None\n        ans += cnt\n    print(ans)", "t = int(input())\nfor j in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    arr = [-1 for i in range(n + 1)]\n    vis = [True for i in range(n + 1)]\n    for i in range(m):\n        (x, y) = [int(k) for k in input().split()]\n        if x != y:\n            vis[x] = False\n            arr[x] = y\n    vis[0] = True\n    ans = 0\n    for i in range(n + 1):\n        if vis[i] == False:\n            start = arr[i]\n            vis[i] = True\n            count = 1\n            while vis[start] == False:\n                vis[start] = True\n                count += 1\n                start = arr[start]\n                if start == i:\n                    count += 1\n            ans += count\n    print(ans)", "class Solution:\n\n    def __init__(self, n: int, m: int):\n        self.parent = list(range(n + 1))\n        self.count = m\n\n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x: int, y: int):\n        if x == y:\n            self.count -= 1\n            return\n        x_p = self.find(x)\n        y_p = self.find(y)\n        if x_p == y_p:\n            self.count += 1\n        else:\n            self.parent[x_p] = y_p\n\n    def get_count(self):\n        return self.count\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, m) = input().split(' ')\n    (n, m) = (int(n), int(m))\n    so = Solution(n, m)\n    for _ in range(m):\n        (x, y) = input().split(' ')\n        (x, y) = (int(x), int(y))\n        so.union(x, y)\n    print(so.get_count())", "import sys\nimport math, bisect, operator\n(inf, m) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\nfor tt in range(int(input())):\n    (x, y) = map(int, input().split())\n    l = [0] * (x + 1)\n    v = [0] * (x + 1)\n    for i in range(y):\n        (a, b) = map(int, input().split())\n        l[a] = b\n    c = 0\n    for i in range(1, x + 1):\n        if l[i] != i:\n            temp = i\n            while v[temp] != 1 and l[temp] != 0:\n                c += 1\n                v[temp] = 1\n                temp = l[temp]\n                if temp == i:\n                    c += 1\n                    break\n    print(c)", "def move_nu(allPoints, m):\n    n = len(allPoints)\n    xlab = [-1] * m\n    ylab = [-1] * m\n    xexi = [0] * m\n    exnum = 0\n    xynum = 0\n    for point in allPoints:\n        xlab[point[0] - 1] = point[1] - 1\n        ylab[point[1] - 1] = point[0] - 1\n    for point in allPoints:\n        x0 = point[0] - 1\n        y0 = point[1] - 1\n        if xexi[x0]:\n            continue\n        if x0 == y0:\n            xynum += 1\n            continue\n        y1 = y0\n        x1 = x0\n        while xexi[x1] == 0 and xlab[x1] != -1:\n            xexi[x1] = 1\n            x1 = y1\n            y1 = xlab[x1]\n        if xlab[x1] != -1:\n            exnum += 1\n        elif ylab[x0] != -1:\n            x1 = ylab[x0]\n            while x1 != -1 and xexi[x1] == 0:\n                xexi[x1] = 1\n                x1 = ylab[x1]\n    return n - xynum + exnum\nn = int(input())\nans = []\nfor i in range(n):\n    ll = input().split()\n    allpoints = []\n    for j in range(int(ll[1])):\n        allpoints.append(tuple(map(int, input().split())))\n    ans.append(move_nu(allpoints, int(ll[0])))\nfor i in ans:\n    print(i)", "import sys\nif not sys.warnoptions:\n    import warnings\n    warnings.simplefilter('ignore')\n\ndef ii():\n    return int(input())\n\ndef li():\n    return [int(i) for i in input().split()]\n\ndef ls():\n    return [i for i in input().split()]\nfor t in range(ii()):\n    (n, m) = li()\n    store = [-1 for i in range(n)]\n    for i in range(m):\n        (x, y) = li()\n        x -= 1\n        y -= 1\n        store[x] = y\n    vis = [0 for i in range(n)]\n    ans = 0\n    for i in range(n):\n        if store[i] != -1:\n            if store[i] != i:\n                ans += 1\n                root = i\n                cnt = 0\n                while vis[root] == 0:\n                    vis[root] = 1\n                    if store[root] == -1:\n                        break\n                    else:\n                        cnt += 1\n                        root = store[root]\n                if root == i and cnt > 0:\n                    ans += 1\n            else:\n                vis[i] = 1\n        else:\n            vis[i] = 1\n    print(ans)", "for l in range(int(input())):\n    (n, m) = map(int, input().split())\n    res = 0\n    table = dict()\n    for i in range(m):\n        (a, b) = map(int, input().split())\n        table[a] = [b, False]\n    for key in table:\n        if table[key][1] == False:\n            table[key][1] = True\n            temp_key = table[key][0]\n            if key != temp_key:\n                while True:\n                    if table.get(temp_key):\n                        if table[temp_key][1] == True:\n                            break\n                        res += 1\n                        table[temp_key][1] = True\n                        temp_key = table[temp_key][0]\n                        if temp_key == key:\n                            res += 1\n                            break\n                    else:\n                        break\n                res += 1\n    print(res)", "for _ in range(int(input())):\n    (n, m) = list(map(int, input().split(' ')))\n    rook_poses = {}\n    for _ in range(m):\n        (x, y) = tuple(map(int, input().split(' ')))\n        if x != y:\n            rook_poses[x] = y\n    num_moves = 0\n    cycle = set()\n    unvisited = set(rook_poses.keys())\n    while unvisited:\n        x = unvisited.pop()\n        cycle.add(x)\n        y = rook_poses[x]\n        num_moves += 1\n        while y in unvisited:\n            x = y\n            unvisited.remove(x)\n            cycle.add(x)\n            y = rook_poses[x]\n            num_moves += 1\n        if y in cycle:\n            num_moves += 1\n        cycle.clear()\n    print(num_moves)", "t = int(input())\nfor j in range(0, t):\n    (n, m) = map(int, input().split())\n    c = 0\n    g = {}\n    p = []\n    d = {}\n    for kk in range(0, m):\n        (a, b) = map(int, input().split())\n        if a != b:\n            p.append(a)\n            g[a] = b\n            d[a] = 0\n    cc = 0\n    for tt in p:\n        s = tt\n        o = s\n        fl = 0\n        if d[o] == 0:\n            while o in d and d[o] == 0:\n                cc += 1\n                d[o] = 1\n                if o in g:\n                    if g[o] == s:\n                        fl = 1\n                        break\n                    o = g[o]\n                else:\n                    fl = 0\n                    break\n            if fl == 1:\n                cc += 1\n    print(cc + c)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().strip().split())\n    xs = set()\n    ys = set()\n    xd = []\n    yd = []\n    x = [0] * (n + 1)\n    y = [0] * (n + 1)\n    for _ in range(m):\n        (i, j) = map(int, input().strip().split())\n        xd.append(i)\n        yd.append(j)\n        x[i] = j\n        y[j] = i\n        xs.add(i)\n        ys.add(j)\n    count = 0\n    for i in range(m):\n\n        def inner():\n            if xd[i] == yd[i]:\n                return 0\n            if x[xd[i]] == 0:\n                return 0\n            if xd[i] not in ys:\n                lc = 1\n                num = x[xd[i]]\n                x[xd[i]] = 0\n                while num in xs:\n                    lc += 1\n                    t = x[num]\n                    x[num] = 0\n                    num = t\n                return lc\n            else:\n                lc = 1\n                num = x[xd[i]]\n                x[xd[i]] = 0\n                while num in xs:\n                    if x[num] == 0:\n                        return lc + 1\n                    lc += 1\n                    t = x[num]\n                    x[num] = 0\n                    num = t\n                lc += 1\n                num = y[xd[i]]\n                x[y[xd[i]]] = 0\n                while num in ys:\n                    lc += 1\n                    t = y[num]\n                    x[y[num]] = 0\n                    num = t\n                return lc\n            return 0\n        count += inner()\n    print(count)", "import sys, threading\nsys.setrecursionlimit(500000)\nthreading.stack_size(134217728)\nfrom collections import defaultdict\n\ndef solve():\n\n    def dfs(node, visited, parent, an):\n        visited[node] = 1\n        for v in g[node]:\n            if visited[v] == 0:\n                dfs(v, visited, node, an)\n            elif v != parent:\n                an[0] = 1\n    f = 0\n    t = int(input())\n    for i in range(t):\n        g = defaultdict(list)\n        (n, m) = map(int, input().split())\n        p = 0\n        for j in range(m):\n            (u, v) = map(int, sys.stdin.readline().split())\n            if u != v:\n                g[u].append(v)\n                g[v].append(u)\n                p = p + 1\n        visited = [0] * (n + 1)\n        for j in range(1, n + 1):\n            if visited[j] == 0 and j in g:\n                an = [0]\n                dfs(j, visited, -1, an)\n                p = p + an[0]\n        print(p)\nthreading.Thread(target=solve).start()", "class UnionFind:\n\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.n = n\n        self.setCount = n\n\n    def findset(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.findset(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x: int, y: int) -> bool:\n        (x, y) = (self.findset(x), self.findset(y))\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            (x, y) = (y, x)\n        self.parent[y] = x\n        self.size[x] += self.size[y]\n        self.setCount -= 1\n        return True\n\n    def connected(self, x: int, y: int) -> bool:\n        (x, y) = (self.findset(x), self.findset(y))\n        return x == y\nT = int(input())\nwhile T:\n    (n, m) = map(int, input().split(' '))\n    uf = UnionFind(n)\n    ok = 0\n    huan = 0\n    for _ in range(m):\n        (x, y) = map(int, input().split(' '))\n        if x == y:\n            ok += 1\n        elif not uf.unite(x - 1, y - 1):\n            huan += 1\n    print(m + huan - ok)\n    T -= 1", "sa = lambda : input()\nsb = lambda : int(input())\nsc = lambda : input().split()\nsd = lambda : list(map(int, input().split()))\nse = lambda : float(input())\n\nclass Disjoint_SU:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n\n    def lake_de(self, a):\n        if a == self.parent[a]:\n            return a\n        self.parent[a] = self.lake_de(self.parent[a])\n        return self.parent[a]\n\n    def jod(self, a, b):\n        x = self.lake_de(a)\n        y = self.lake_de(b)\n        if x == y:\n            return True\n        if self.size[x] > self.size[y]:\n            self.size[x] += self.size[y]\n            self.parent[y] = x\n        else:\n            self.size[y] += self.size[x]\n            self.parent[x] = y\n        return False\n\ndef hnbhai():\n    (n, m) = sd()\n    obj = Disjoint_SU(n)\n    total = 0\n    for i in range(m):\n        (x, y) = sd()\n        x -= 1\n        y -= 1\n        if x == y:\n            continue\n        total += 1\n        if obj.jod(x, y):\n            total += 1\n    print(total)\nfor _ in range(sb()):\n    hnbhai()", "def untie(r, c, d, i, x, y, e):\n    res = 0\n    u = i\n    t = set()\n    (ux, uy) = d[u]\n    if ux == uy:\n        return (0, set([u]))\n    while 1:\n        if not ux in c or c[ux] in e:\n            t.add(u)\n            res += 1\n            return (res, t)\n        res += 1\n        t.add(u)\n        u = c[ux]\n        (ux, uy) = d[u]\n        if u == i:\n            res += 1\n            return (res, t)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    r = {}\n    c = {}\n    d = []\n    res = 0\n    e = set()\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        r[x] = i\n        c[y] = i\n        d += [[x, y]]\n    for i in range(m):\n        (x, y) = d[i]\n        if i in e:\n            continue\n        (a, b) = untie(r, c, d, i, x, y, e)\n        e = e.union(b)\n        res += a\n    print(res)", "t = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().strip().split())\n    xs = set()\n    ys = set()\n    xd = []\n    yd = []\n    x = [0] * (n + 1)\n    y = [0] * (n + 1)\n    for _ in range(m):\n        (i, j) = map(int, input().strip().split())\n        xd.append(i)\n        yd.append(j)\n        x[i] = j\n        y[j] = i\n        xs.add(i)\n        ys.add(j)\n    count = 0\n    for i in range(m):\n\n        def inner():\n            if xd[i] == yd[i]:\n                return 0\n            if x[xd[i]] == 0:\n                return 0\n            if xd[i] not in ys:\n                lc = 1\n                num = x[xd[i]]\n                x[xd[i]] = 0\n                while num in xs:\n                    lc += 1\n                    t = x[num]\n                    x[num] = 0\n                    num = t\n                return lc\n            else:\n                lc = 1\n                num = x[xd[i]]\n                x[xd[i]] = 0\n                while num in xs:\n                    if x[num] == 0:\n                        return lc + 1\n                    lc += 1\n                    t = x[num]\n                    x[num] = 0\n                    num = t\n                lc += 1\n                num = y[xd[i]]\n                x[y[xd[i]]] = 0\n                while num in ys:\n                    lc += 1\n                    t = y[num]\n                    x[y[num]] = 0\n                    num = t\n                return lc\n            return 0\n        count += inner()\n    print(count)", "lm = lambda : list(map(int, input().split()))\nii = lambda : int(input())\n\nclass sabar_karo:\n\n    def __init__(self, n):\n        self.baap = [i for i in range(n)]\n        self.aukat = [1 for _ in range(n)]\n\n    def pata_karo(self, a):\n        if a == self.baap[a]:\n            return a\n        self.baap[a] = self.pata_karo(self.baap[a])\n        return self.baap[a]\n\n    def daya(self, a, b):\n        x = self.pata_karo(a)\n        y = self.pata_karo(b)\n        a = x\n        b = y\n        if x == y:\n            return True\n        elif self.aukat[a] > self.aukat[b]:\n            self.aukat[a] += self.aukat[b]\n            self.baap[b] = a\n        else:\n            self.aukat[b] += self.aukat[a]\n            self.baap[a] = b\n        return False\n\ndef ruko_jara():\n    (n, m) = lm()\n    x = sabar_karo(n)\n    ans = 0\n    for _ in range(m):\n        (u, v) = lm()\n        if u == v:\n            continue\n        ans += 1\n        if x.daya(u - 1, v - 1):\n            ans += 1\n    print(ans)\nfor _ in range(ii()):\n    ruko_jara()", "import sys, threading\nsys.setrecursionlimit(500000)\nthreading.stack_size(134217728)\nfrom collections import defaultdict\n\ndef solve():\n\n    def dfs(node, visited, parent, loop):\n        visited[node] = 1\n        for v in graph[node]:\n            if visited[v] == 0:\n                dfs(v, visited, node, loop)\n            elif v != parent:\n                loop[0] = 1\n    for _ in range(int(input())):\n        (n, m) = map(int, input().split())\n        ans = 0\n        graph = defaultdict(list)\n        for i in range(m):\n            (x, y) = map(int, input().split())\n            if x != y:\n                graph[x].append(y)\n                graph[y].append(x)\n                ans += 1\n        visited = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if visited[i] == 0 and i in graph:\n                loop = [0]\n                dfs(i, visited, -1, loop)\n                ans += loop[0]\n        print(ans)\nthreading.Thread(target=solve).start()", "import sys, threading\nsys.setrecursionlimit(500000)\nthreading.stack_size(134217728)\nfrom collections import defaultdict\n\ndef solve():\n\n    def dfs(node, visited, parent, an):\n        visited[node] = 1\n        for v in g[node]:\n            if visited[v] == 0:\n                dfs(v, visited, node, an)\n            elif v != parent:\n                an[0] = 1\n    f = 0\n    t = int(input())\n    for i in range(t):\n        g = defaultdict(list)\n        (n, m) = map(int, input().split())\n        p = 0\n        for j in range(m):\n            (u, v) = map(int, input().split())\n            if u != v:\n                g[u].append(v)\n                g[v].append(u)\n                p = p + 1\n        visited = [0] * (n + 1)\n        for j in range(1, n + 1):\n            if visited[j] == 0 and j in g:\n                an = [0]\n                dfs(j, visited, -1, an)\n                p = p + an[0]\n        print(p)\nthreading.Thread(target=solve).start()", "from collections import defaultdict\nimport sys\nt = int(input())\nsys.setrecursionlimit(100000000)\n\ndef rek():\n    while stack:\n        k = stack.pop()\n        (a, b) = k\n        tmp[0] += 1\n        w[k] = True\n        if ver[a]:\n            if not w[ver[a]]:\n                w[ver[a]] = True\n                stack.append(ver[a])\n        else:\n            check[0] = False\n        if st[b]:\n            if not w[st[b]]:\n                w[st[b]] = True\n                stack.append(st[b])\n        else:\n            check[0] = False\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    (st, ver) = (defaultdict(tuple), defaultdict(tuple))\n    ar = []\n    for _ in range(m):\n        (a, b) = map(int, input().split())\n        q = (a, b)\n        ar.append(q)\n        st[a] = q\n        ver[b] = q\n    res = 0\n    w = defaultdict(bool)\n    for (a, b) in ar:\n        if a != b and (not w[a, b]):\n            tmp = [0]\n            check = [True]\n            stack = [(a, b)]\n            rek()\n            if check[0]:\n                tmp[0] += 1\n            res += tmp[0]\n    print(res)", "T = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    lim = 10 ** 5 + 10\n    A = [-1] * lim\n    ans = 0\n    flag = 0\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        if flag == 0:\n            flag = 1\n            res = x\n        if x != y:\n            ans += 1\n            A[x] = y\n        flag = 0\n        x = res\n        while True:\n            temp = A[x]\n            if temp == -1:\n                break\n            if temp == res:\n                ans += 1\n                break\n            x = temp\n    print(ans)", "import sys, threading\nsys.setrecursionlimit(200000)\nthreading.stack_size(10 ** 8)\nfrom collections import defaultdict as dd\n\ndef dfs(x, y):\n    global v, adj, b, c, d\n    v[x] = 1\n    c += 1\n    for i in adj[x]:\n        if not v[i]:\n            dfs(i, x)\n        elif i != y and y != -1 or (i == y and d[i, x] == 2):\n            b += 2\n            d[i, x] = 1\n            d[x, i] = 1\n\ndef main():\n    global v, adj, b, c, d\n    for t in range(int(input())):\n        (n, m) = map(int, input().split())\n        adj = [[] for i in range(n + 1)]\n        a = 0\n        b = 0\n        c = 0\n        v = [0] * (n + 1)\n        d = dd(int)\n        for i in range(m):\n            (x, y) = map(int, input().split())\n            if x != y:\n                adj[x].append(y)\n                adj[y].append(x)\n                d[x, y] += 1\n                d[y, x] += 1\n            else:\n                a += 1\n        ans = 0\n        for j in range(1, n + 1):\n            if not v[j]:\n                c = 0\n                dfs(j, -1)\n                ans += c - 1\n        print(ans + b)\nz = threading.Thread(target=main)\nz.start()\nz.join()", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    lim = 10 ** 5 + 10\n    A = [-1] * lim\n    ans = 0\n    flag = 0\n    for i in range(k):\n        (x, y) = map(int, input().split())\n        if flag == 0:\n            flag = 1\n            res = x\n        if x != y:\n            ans += 1\n            A[x] = y\n        flag = 0\n        x = res\n        while True:\n            temp = A[x]\n            if temp == -1:\n                break\n            if temp == res:\n                ans += 1\n                break\n            x = temp\n    print(ans)", "import sys\n\ndef main():\n    (n, m) = map(int, input().split())\n    dct = dict()\n    dots_visited = set()\n    o = 0\n    dct_dots = dict()\n    dots = []\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if x != y:\n            if x in dct_dots:\n                dct_dots[x].append(o)\n            else:\n                dct_dots[x] = [o]\n            if y in dct_dots:\n                dct_dots[y].append(o)\n            else:\n                dct_dots[y] = [o]\n            dct[o] = set()\n            dots.append([x, y])\n            o += 1\n    for i in dct_dots:\n        if len(dct_dots[i]) == 2:\n            dct[dct_dots[i][0]].add(dct_dots[i][1])\n            dct[dct_dots[i][1]].add(dct_dots[i][0])\n    cnt = 0\n    for dot in range(o):\n        if not dot in dots_visited:\n            to_go = set()\n            to_go.add(dot)\n            st = set()\n            while len(to_go) != 0:\n                dt = to_go.pop()\n                st.add(dt)\n                dots_visited.add(dt)\n                for i in dct[dt]:\n                    if not i in dots_visited:\n                        to_go.add(i)\n            ways = set()\n            for i in st:\n                ways.add(dots[i][0])\n                ways.add(dots[i][1])\n            cnt += len(st)\n            if len(ways) <= len(st):\n                cnt += 1\n    print(cnt)\nt = int(input())\nfor i in range(t):\n    main()", "class UFS:\n\n    def __init__(self):\n        self.parent = {}\n\n    def add(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n\n    def find(self, x):\n        root = x\n        while self.parent[root] != root:\n            root = self.parent[root]\n        while x != root:\n            (x, self.parent[x]) = (self.parent[x], root)\n        return root\n\n    def isConnected(self, x, y):\n        rootx = self.find(x)\n        rooty = self.find(y)\n        return rootx == rooty\n\n    def union(self, x, y):\n        rootx = self.find(x)\n        rooty = self.find(y)\n        if rootx != rooty:\n            self.parent[rootx] = rooty\n\ndef solution(indexs):\n    ufs = UFS()\n    ans = 0\n    for (i, j) in indexs:\n        if i == j:\n            continue\n        ans += 1\n        ufs.add((i, i))\n        ufs.add((j, j))\n        ufs.add((i, j))\n        if ufs.isConnected((i, i), (j, j)):\n            ans += 1\n        ufs.union((i, i), (i, j))\n        ufs.union((j, j), (i, j))\n    return ans\nT = int(input())\nwhile T:\n    T -= 1\n    (n, m) = list(map(int, input().split()))\n    indexs = []\n    while m:\n        (i, j) = list(map(int, input().split()))\n        indexs.append((i, j))\n        m -= 1\n    ans = solution(indexs)\n    print(ans)"]