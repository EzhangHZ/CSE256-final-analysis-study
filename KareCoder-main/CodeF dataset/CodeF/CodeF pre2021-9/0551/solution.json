["from bisect import bisect_left\n\ndef take_closest(myList, myNumber):\n    pos = bisect_left(myList, myNumber)\n    if pos == 0:\n        return myList[0]\n    if pos == len(myList):\n        return myList[-1]\n    before = myList[pos - 1]\n    after = myList[pos]\n    if after - myNumber < myNumber - before:\n        return after\n    else:\n        return before\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    f = []\n    a.sort()\n    c.sort()\n    b.sort()\n    for x in a:\n        y = take_closest(b, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in b:\n        y = take_closest(a, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in c:\n        y = take_closest(b, x)\n        z = take_closest(a, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(min(f))", "from bisect import bisect_left as bl\n\ndef take_closest(mylist, mynumber):\n    pos = bl(mylist, mynumber)\n    if pos == 0:\n        return mylist[0]\n    if pos == len(mylist):\n        return mylist[-1]\n    before = mylist[pos - 1]\n    after = mylist[pos]\n    if after - mynumber < mynumber - before:\n        return after\n    else:\n        return before\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    (a, b, c) = (sorted(list(map(int, input().split()))) for _ in range(3))\n    ans = []\n    for x in a:\n        y = take_closest(b, x)\n        z = take_closest(c, x)\n        ans.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in b:\n        y = take_closest(a, x)\n        z = take_closest(c, x)\n        ans.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in c:\n        y = take_closest(b, x)\n        z = take_closest(a, x)\n        ans.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(min(ans))", "from bisect import bisect_left as bl\n\ndef take_closest(mylist, mynumber):\n    pos = bl(mylist, mynumber)\n    if pos == 0:\n        return mylist[0]\n    if pos == len(mylist):\n        return mylist[-1]\n    before = mylist[pos - 1]\n    after = mylist[pos]\n    if after - mynumber < mynumber - before:\n        return after\n    else:\n        return before\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    (a, b, c) = (sorted(list(map(int, input().split()))) for _ in range(3))\n    ans = []\n    for x in a:\n        y = take_closest(b, x)\n        z = take_closest(c, x)\n        ans.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in b:\n        y = take_closest(a, x)\n        z = take_closest(c, x)\n        ans.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in c:\n        y = take_closest(b, x)\n        z = take_closest(a, x)\n        ans.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(min(ans))", "from bisect import bisect_left\n\ndef take_closest(myList, myNumber):\n    pos = bisect_left(myList, myNumber)\n    if pos == 0:\n        return myList[0]\n    if pos == len(myList):\n        return myList[-1]\n    before = myList[pos - 1]\n    after = myList[pos]\n    if after - myNumber < myNumber - before:\n        return after\n    else:\n        return before\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    f = []\n    a.sort()\n    c.sort()\n    b.sort()\n    for x in a:\n        y = take_closest(b, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in b:\n        y = take_closest(a, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in c:\n        y = take_closest(b, x)\n        z = take_closest(a, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(min(f))", "from bisect import bisect_left\n\ndef fun(arr, val):\n    pos = bisect_left(arr, val)\n    if pos == 0:\n        return arr[0]\n    elif pos == len(arr):\n        return arr[-1]\n    else:\n        left = arr[pos - 1]\n        if val - left < arr[pos] - val:\n            return left\n        else:\n            return arr[pos]\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    wr = sorted(list(map(int, input().split())))\n    wg = sorted(list(map(int, input().split())))\n    wb = sorted(list(map(int, input().split())))\n    m = 10 ** 20\n    for x in wr:\n        y = fun(wg, x)\n        z = fun(wb, x)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for y in wg:\n        x = fun(wr, y)\n        z = fun(wb, y)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for z in wb:\n        y = fun(wg, z)\n        x = fun(wr, z)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(m)", "from bisect import bisect_left\n\ndef take_closest(myList, myNumber):\n    pos = bisect_left(myList, myNumber)\n    if pos == 0:\n        return myList[0]\n    if pos == len(myList):\n        return myList[-1]\n    before = myList[pos - 1]\n    after = myList[pos]\n    if after - myNumber < myNumber - before:\n        return after\n    else:\n        return before\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    f = []\n    a.sort()\n    c.sort()\n    b.sort()\n    for x in a:\n        y = take_closest(b, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in b:\n        y = take_closest(a, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in c:\n        y = take_closest(b, x)\n        z = take_closest(a, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(min(f))", "from bisect import bisect_left\n\ndef take_closest(myList, myNumber):\n    pos = bisect_left(myList, myNumber)\n    if pos == 0:\n        return myList[0]\n    if pos == len(myList):\n        return myList[-1]\n    before = myList[pos - 1]\n    after = myList[pos]\n    if after - myNumber < myNumber - before:\n        return after\n    else:\n        return before\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    f = []\n    a.sort()\n    c.sort()\n    b.sort()\n    for x in a:\n        y = take_closest(b, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in b:\n        y = take_closest(a, x)\n        z = take_closest(c, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for x in c:\n        y = take_closest(b, x)\n        z = take_closest(a, x)\n        f.append((x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(min(f))", "from bisect import bisect_left\n\ndef fun(arr, val):\n    pos = bisect_left(arr, val)\n    if pos == 0:\n        return arr[0]\n    elif pos == len(arr):\n        return arr[-1]\n    else:\n        left = arr[pos - 1]\n        if val - left < arr[pos] - val:\n            return left\n        else:\n            return arr[pos]\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    wr = sorted(list(map(int, input().split())))\n    wg = sorted(list(map(int, input().split())))\n    wb = sorted(list(map(int, input().split())))\n    m = 10 ** 20\n    for x in wr:\n        y = fun(wg, x)\n        z = fun(wb, x)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for y in wg:\n        x = fun(wr, y)\n        z = fun(wb, y)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for z in wb:\n        y = fun(wg, z)\n        x = fun(wr, z)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(m)", "from bisect import bisect_left\n\ndef fun(arr, val):\n    pos = bisect_left(arr, val)\n    if pos == 0:\n        return arr[0]\n    elif pos == len(arr):\n        return arr[-1]\n    else:\n        left = arr[pos - 1]\n        if val - left < arr[pos] - val:\n            return left\n        else:\n            return arr[pos]\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    wr = sorted(list(map(int, input().split())))\n    wg = sorted(list(map(int, input().split())))\n    wb = sorted(list(map(int, input().split())))\n    m = float('inf')\n    for x in wr:\n        y = fun(wg, x)\n        z = fun(wb, x)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for y in wg:\n        x = fun(wr, y)\n        z = fun(wb, y)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for z in wb:\n        y = fun(wg, z)\n        x = fun(wr, z)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(m)", "from bisect import bisect_left\n\ndef fun(arr, val):\n    pos = bisect_left(arr, val)\n    if pos == 0:\n        return arr[0]\n    elif pos == len(arr):\n        return arr[-1]\n    else:\n        left = arr[pos - 1]\n        if val - left < arr[pos] - val:\n            return left\n        else:\n            return arr[pos]\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    wr = sorted(list(map(int, input().split())))\n    wg = sorted(list(map(int, input().split())))\n    wb = sorted(list(map(int, input().split())))\n    m = 10 ** 20\n    for x in wr:\n        y = fun(wg, x)\n        z = fun(wb, x)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for y in wg:\n        x = fun(wr, y)\n        z = fun(wb, y)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for z in wb:\n        y = fun(wg, z)\n        x = fun(wr, z)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(m)", "import bisect\nimport math\n\ndef solve(a, b, c):\n    ans = float('inf')\n    for i in b:\n        if a[0] > i or c[-1] < i:\n            continue\n        mx = bisect.bisect_right(a, i) - 1\n        mz = bisect.bisect_left(c, i)\n        minn = (i - a[mx]) * (i - a[mx]) + (i - c[mz]) * (i - c[mz]) + (a[mx] - c[mz]) * (a[mx] - c[mz])\n        if minn < ans:\n            ans = minn\n    return ans\nt = int(input())\nfor i in range(t):\n    (x, y, z) = map(int, input().split())\n    r = sorted(list(map(int, input().split())))\n    g = sorted(list(map(int, input().split())))\n    b = sorted(list(map(int, input().split())))\n    print(min(solve(r, g, b), solve(b, g, r), solve(r, b, g), solve(g, b, r), solve(g, r, b), solve(b, r, g)))", "def cases(array1, array2, array3):\n    n1 = len(array1)\n    n2 = len(array2)\n    n3 = len(array3)\n    currmin = 0\n    currmax = 0\n    ans = 92523523623423452323623\n    for ele in array2:\n        while currmin + 1 < n1 and array1[currmin + 1] <= ele:\n            currmin += 1\n        while currmax + 1 < n3 and array3[currmax] < ele:\n            currmax += 1\n        if array1[currmin] > ele and ele > array3[currmax]:\n            continue\n        ans = min(ans, (ele - array1[currmin]) ** 2 + (ele - array3[currmax]) ** 2 + (array1[currmin] - array3[currmax]) ** 2)\n    return ans\nfor _ in range(int(input())):\n    (n1, n2, n3) = map(int, input().split())\n    array1 = list(map(int, input().split()))\n    array2 = list(map(int, input().split()))\n    array3 = list(map(int, input().split()))\n    array1.sort()\n    array2.sort()\n    array3.sort()\n    t1 = cases(array1, array2, array3)\n    t2 = cases(array1, array3, array2)\n    t3 = cases(array2, array1, array3)\n    t4 = cases(array2, array3, array1)\n    t5 = cases(array3, array1, array2)\n    t6 = cases(array3, array2, array1)\n    print(min(t1, t2, t3, t4, t5, t6))", "import bisect\nimport math\n\ndef solve(a, b, c):\n    ans = float('inf')\n    for i in b:\n        if a[0] > i or c[-1] < i:\n            continue\n        mx = bisect.bisect_right(a, i) - 1\n        mz = bisect.bisect_left(c, i)\n        minn = (i - a[mx]) ** 2 + (i - c[mz]) ** 2 + (a[mx] - c[mz]) ** 2\n        if minn < ans:\n            ans = minn\n    return ans\nt = int(input())\nfor i in range(t):\n    (x, y, z) = map(int, input().split())\n    r = sorted(list(map(int, input().split())))\n    g = sorted(list(map(int, input().split())))\n    b = sorted(list(map(int, input().split())))\n    print(min(solve(r, g, b), solve(b, g, r), solve(r, b, g), solve(g, b, r), solve(g, r, b), solve(b, r, g)))", "t = int(input())\nfor u in range(t):\n    (a, b, c) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    for i in range(len(a)):\n        a[i] = [a[i], 0]\n    for i in range(len(b)):\n        b[i] = [b[i], 1]\n    for i in range(len(c)):\n        c[i] = [c[i], 2]\n    a.extend(b)\n    a.extend(c)\n    a.sort(key=lambda x: x[0])\n    maxi = float('inf')\n    start = 0\n    end = 0\n    dic = {0: -1, 1: -1, 2: -1}\n    while end < len(a):\n        dic[a[end][1]] = end\n        if dic[0] != -1 and dic[1] != -1 and (dic[2] != -1):\n            if dic[0] == start:\n                dic[0] = -1\n            if dic[1] == start:\n                dic[1] = -1\n            if dic[2] == start:\n                dic[2] = -1\n            start += 1\n            if dic[0] == -1 or dic[1] == -1 or dic[2] == -1:\n                for i in range(start, end):\n                    temp = (a[start - 1][0] - a[i][0]) ** 2 + (a[start - 1][0] - a[end][0]) ** 2 + (a[end][0] - a[i][0]) ** 2\n                    if temp < maxi:\n                        maxi = temp\n        else:\n            end += 1\n    print(maxi)", "import bisect\n\ndef near(li, el, le):\n    xx = bisect.bisect_left(li, el)\n    if xx == le:\n        return li[-1]\n    elif xx == 0:\n        return li[0]\n    elif abs(li[xx - 1] - el) >= abs(li[xx] - el):\n        return li[xx]\n    else:\n        return li[xx - 1]\n\ndef ansf(x, y, z):\n    return (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2\nfor _ in range(int(input())):\n    (r, g, b) = map(int, input().split())\n    rr = list(map(int, input().split()))\n    rr.sort()\n    gg = list(map(int, input().split()))\n    gg.sort()\n    bb = list(map(int, input().split()))\n    bb.sort()\n    ans = float('inf')\n    for i in range(r):\n        x1 = near(bb, rr[i], b)\n        x2 = near(gg, rr[i], g)\n        ans = min(ans, ansf(rr[i], x1, x2))\n    for i in range(g):\n        x1 = near(rr, gg[i], r)\n        x2 = near(bb, gg[i], b)\n        ans = min(ans, ansf(gg[i], x1, x2))\n    for i in range(b):\n        x1 = near(rr, bb[i], r)\n        x2 = near(gg, bb[i], g)\n        ans = min(ans, ansf(bb[i], x1, x2))\n    print(ans)", "import sys\nlines = sys.stdin.readlines()\nT = int(lines[0].strip())\nfor t in range(T):\n    (a, b, c) = map(int, lines[4 * t + 1].strip().split(' '))\n    As = list(map(int, lines[4 * t + 2].strip().split(' ')))\n    Bs = list(map(int, lines[4 * t + 3].strip().split(' ')))\n    Cs = list(map(int, lines[4 * t + 4].strip().split(' ')))\n    As.sort()\n    Bs.sort()\n    Cs.sort()\n\n    def solve(arr1, arr2, arr3):\n        (L1, L2, L3) = (len(arr1), len(arr2), len(arr3))\n        pt1 = 0\n        pt2 = 0\n        minDiff = 3 * 10 ** 18\n        for i in range(L3):\n            if pt1 >= L1 or pt2 >= L2:\n                break\n            num = arr3[i]\n            while pt2 < L2 and arr2[pt2] < num:\n                pt2 += 1\n            if pt2 >= L2:\n                break\n            if arr1[pt1] > num:\n                continue\n            while pt1 + 1 < L1 and arr1[pt1 + 1] <= num:\n                pt1 += 1\n            minDiff = min(minDiff, (num - arr1[pt1]) ** 2 + (num - arr2[pt2]) ** 2 + (arr1[pt1] - arr2[pt2]) ** 2)\n        return minDiff\n    minDiff = min(solve(As, Bs, Cs), solve(As, Cs, Bs), solve(Bs, Cs, As), solve(Bs, As, Cs), solve(Cs, As, Bs), solve(Cs, Bs, As))\n    print(minDiff)", "import sys\nlines = sys.stdin.readlines()\nT = int(lines[0].strip())\nfor t in range(T):\n    (a, b, c) = map(int, lines[4 * t + 1].strip().split(' '))\n    As = list(map(int, lines[4 * t + 2].strip().split(' ')))\n    Bs = list(map(int, lines[4 * t + 3].strip().split(' ')))\n    Cs = list(map(int, lines[4 * t + 4].strip().split(' ')))\n    As.sort()\n    Bs.sort()\n    Cs.sort()\n\n    def solve(arr1, arr2, arr3):\n        (L1, L2, L3) = (len(arr1), len(arr2), len(arr3))\n        pt1 = 0\n        pt2 = 0\n        minDiff = 3 * 10 ** 18\n        for i in range(L3):\n            if pt1 >= L1 or pt2 >= L2:\n                break\n            num = arr3[i]\n            while pt2 < L2 and arr2[pt2] < num:\n                pt2 += 1\n            if pt2 >= L2:\n                break\n            if arr1[pt1] > num:\n                continue\n            while pt1 + 1 < L1 and arr1[pt1 + 1] <= num:\n                pt1 += 1\n            minDiff = min(minDiff, (num - arr1[pt1]) ** 2 + (num - arr2[pt2]) ** 2 + (arr1[pt1] - arr2[pt2]) ** 2)\n        return minDiff\n    minDiff = min(solve(As, Bs, Cs), solve(As, Cs, Bs), solve(Bs, Cs, As), solve(Bs, As, Cs), solve(Cs, As, Bs), solve(Cs, Bs, As))\n    print(minDiff)", "import math\nimport sys\n\ndef F(a, b, c):\n    return (a - b) * (a - b) + (a - c) * (a - c) + (b - c) * (b - c)\nt = int(input())\nmaxx = 10000000000000000000000000\nfor _ in range(t):\n    (R, G, B) = map(int, input().split())\n    r = list(map(int, input().split()))\n    g = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    r.sort()\n    g.sort()\n    b.sort()\n    x = 0\n    y = 0\n    z = 0\n    ans = maxx\n    while x < R - 1 or y < G - 1 or z < B - 1:\n        ans = min(ans, F(r[x], g[y], b[z]))\n        d1 = maxx\n        d2 = maxx\n        d3 = maxx\n        if x < R - 1:\n            d1 = F(r[x + 1], g[y], b[z])\n        if y < G - 1:\n            d2 = F(r[x], g[y + 1], b[z])\n        if z < B - 1:\n            d3 = F(r[x], g[y], b[z + 1])\n        if d1 <= d2 and d1 <= d3:\n            x += 1\n        elif d2 <= d1 and d2 <= d3:\n            y += 1\n        else:\n            z += 1\n    ans = min(ans, F(r[x], g[y], b[z]))\n    print(ans)", "import sys\nimport collections\nimport threading\nimport itertools\n\ndef main():\n    testn = int(input())\n    for _ in range(testn):\n        (nr, ng, nb) = map(int, input().split())\n        r = sorted(list(map(int, input().split())))\n        g = sorted(list(map(int, input().split())))\n        b = sorted(list(map(int, input().split())))\n        (i, j, k) = (0, 0, 0)\n        ans = (r[i] - g[j]) ** 2 + (g[j] - b[k]) ** 2 + (b[k] - r[i]) ** 2\n        permut3 = itertools.permutations([r, g, b])\n        for (first, second, third) in permut3:\n            (i, j, k) = (0, 0, 0)\n            for j in range(len(second)):\n                while i < len(first) - 1 and first[i + 1] <= second[j]:\n                    i += 1\n                while k < len(third) - 1 and third[k] < second[j]:\n                    k += 1\n                tmp = (first[i] - second[j]) ** 2 + (second[j] - third[k]) ** 2 + (third[k] - first[i]) ** 2\n                if tmp < ans:\n                    ans = tmp\n        print(ans)\ninput = sys.stdin.readline\nsys.setrecursionlimit(2097152)\nmain()", "import sys, bisect\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    input()\n    R = sorted(list(map(int, input().split())))\n    G = sorted(list(map(int, input().split())))\n    B = sorted(list(map(int, input().split())))\n    best = 10 ** 24\n    for (r, g, b) in ((R, G, B), (G, R, B), (B, G, R)):\n        for x in r:\n            i = bisect.bisect(g, x)\n            y = g[i] if i < len(g) and (x - g[i]) ** 2 < (x - g[i - 1]) ** 2 else g[i - 1]\n            i = bisect.bisect(b, x)\n            z = b[i] if i < len(b) and (x - b[i]) ** 2 < (x - b[i - 1]) ** 2 else b[i - 1]\n            best = min(best, (x - y) ** 2 + (x - z) ** 2 + (y - z) ** 2)\n    print(best)", "import bisect\n\ndef left(arr, x):\n    pos = bisect.bisect_right(arr, x)\n    if pos == 0:\n        return arr[0]\n    return arr[pos - 1]\n\ndef right(arr, x):\n    pos = bisect.bisect_left(arr, x)\n    if pos >= len(arr) - 1:\n        return arr[-1]\n    return arr[pos]\n\ndef sums(x, y, z):\n    return (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2\n\ndef sol(R, G, B):\n    minsum = 10 ** 20\n    for i in range(len(G)):\n        x = G[i]\n        y = left(R, x)\n        z = right(B, x)\n        count = sums(x, y, z)\n        if count < minsum:\n            minsum = count\n    return minsum\nt = int(input())\nfor _ in range(t):\n    (nr, ng, nb) = map(int, input().split())\n    R = list(map(int, input().split()))\n    G = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    R.sort()\n    G.sort()\n    B.sort()\n    print(min(sol(R, G, B), sol(B, G, R), sol(G, R, B), sol(B, R, G), sol(R, B, G), sol(G, B, R)))", "import bisect\nfrom itertools import permutations\nfor _ in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    r = sorted(list(map(int, input().split())))\n    g = sorted(list(map(int, input().split())))\n    b = sorted(list(map(int, input().split())))\n    all = [r, g, b]\n    ans = float('inf')\n    for a in permutations(all):\n        for i in a[0]:\n            (j, k) = (bisect.bisect(a[1], i) - 1, min(len(a[2]) - 1, bisect.bisect_left(a[2], i)))\n            ans = min(ans, (i - a[1][j]) ** 2 + (i - a[2][k]) ** 2 + (a[1][j] - a[2][k]) ** 2)\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (r, g, b) = map(int, input().split())\n    R = list(map(int, input().split()))\n    G = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    R.sort()\n    G.sort()\n    B.sort()\n    INF = 10 ** 20\n    (h1, h2, h3) = (INF, INF, INF)\n    ans = 0\n    first = 0\n    second = 0\n    third = 0\n    while first < r and second < g and (third < b):\n        if first == 0 and second == 0 and (third == 0):\n            ans = (R[first] - G[second]) ** 2 + (B[third] - G[second]) ** 2 + (B[third] - R[first]) ** 2\n        if third != b - 1:\n            h3 = (R[first] - G[second]) ** 2 + (B[third + 1] - G[second]) ** 2 + (B[third + 1] - R[first]) ** 2\n        if second != g - 1:\n            h2 = (R[first] - G[second + 1]) ** 2 + (B[third] - G[second + 1]) ** 2 + (B[third] - R[first]) ** 2\n        if first != r - 1:\n            h1 = (R[first + 1] - G[second]) ** 2 + (B[third] - G[second]) ** 2 + (B[third] - R[first + 1]) ** 2\n        h = min(h1, h2, h3)\n        if h == h1:\n            ans = min(ans, h1)\n            first += 1\n        elif h == h2:\n            ans = min(ans, h2)\n            second += 1\n        elif h == h3:\n            ans = min(ans, h3)\n            third += 1\n        (h1, h2, h3) = (INF, INF, INF)\n    print(ans)", "import sys\nfrom bisect import bisect_right as bi_r, bisect_left as bi_l\nfrom itertools import permutations\nt = int(sys.stdin.readline().rstrip())\n\ndef cost(r, g, b):\n    return (r - g) ** 2 + (g - b) ** 2 + (b - r) ** 2\n\ndef main():\n    for _ in range(t):\n        (a, b, c) = map(int, sys.stdin.readline().split())\n        R = sorted(map(int, sys.stdin.readline().split()))\n        G = sorted(map(int, sys.stdin.readline().split()))\n        B = sorted(map(int, sys.stdin.readline().split()))\n        res = []\n        for (X, Y, Z) in permutations([R, G, B]):\n            for x in X:\n                y = Y[max(bi_r(Y, x) - 1, 0)]\n                z = Z[min(bi_l(Z, x), len(Z) - 1)]\n                res.append(cost(x, y, z))\n        print(min(res))\nmain()", "from bisect import bisect_left, bisect_right\nt = int(input())\nfor _ in range(t):\n    (nr, ng, nb) = map(int, input().split(' '))\n    r = sorted(list(map(int, input().split(' '))))\n    g = sorted(list(map(int, input().split(' '))))\n    b = sorted(list(map(int, input().split(' '))))\n    rgb = [r, g, b]\n    o = 10 ** 9 ** 2\n    for m in range(3):\n        for l in range(3):\n            if m != l:\n                r = 3 - m - l\n                for mi in range(len(rgb[m])):\n                    x = rgb[m][mi]\n                    yi = bisect_left(rgb[l], x)\n                    zi = bisect_right(rgb[r], x)\n                    if yi == len(rgb[l]) or zi == 0:\n                        continue\n                    y = rgb[l][yi]\n                    z = rgb[r][zi - 1]\n                    o = min(o, (x - y) ** 2 + (x - z) ** 2 + (y - z) ** 2)\n    print(o)", "t = int(input())\nfor i in range(t):\n    (r, g, b) = map(int, input().split())\n    R = list(map(int, input().split()))\n    G = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    R.sort()\n    G.sort()\n    B.sort()\n    INF = 10 ** 20\n    (h1, h2, h3) = (INF, INF, INF)\n    ans = 0\n    first = 0\n    second = 0\n    third = 0\n    while first < r and second < g and (third < b):\n        if first == 0 and second == 0 and (third == 0):\n            ans = (R[first] - G[second]) ** 2 + (B[third] - G[second]) ** 2 + (B[third] - R[first]) ** 2\n        if third != b - 1:\n            h3 = (R[first] - G[second]) ** 2 + (B[third + 1] - G[second]) ** 2 + (B[third + 1] - R[first]) ** 2\n        if second != g - 1:\n            h2 = (R[first] - G[second + 1]) ** 2 + (B[third] - G[second + 1]) ** 2 + (B[third] - R[first]) ** 2\n        if first != r - 1:\n            h1 = (R[first + 1] - G[second]) ** 2 + (B[third] - G[second]) ** 2 + (B[third] - R[first + 1]) ** 2\n        h = min(h1, h2, h3)\n        if h == h1:\n            ans = min(ans, h1)\n            first += 1\n        elif h == h2:\n            ans = min(ans, h2)\n            second += 1\n        elif h == h3:\n            ans = min(ans, h3)\n            third += 1\n        (h1, h2, h3) = (INF, INF, INF)\n    print(ans)", "from bisect import bisect_left\n\ndef fun(arr, val):\n    pos = bisect_left(arr, val)\n    if pos == 0:\n        return arr[0]\n    elif pos == len(arr):\n        return arr[-1]\n    else:\n        left = arr[pos - 1]\n        if val - left < arr[pos] - val:\n            return left\n        else:\n            return arr[pos]\nfor t in range(int(input())):\n    (nr, ng, nb) = map(int, input().split())\n    wr = sorted(list(map(int, input().split())))\n    wg = sorted(list(map(int, input().split())))\n    wb = sorted(list(map(int, input().split())))\n    m = float('inf')\n    for x in wr:\n        y = fun(wg, x)\n        z = fun(wb, x)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for y in wg:\n        x = fun(wr, y)\n        z = fun(wb, y)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    for z in wb:\n        y = fun(wg, z)\n        x = fun(wr, z)\n        m = min(m, (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2)\n    print(m)", "from bisect import bisect\n\ndef calculate(v1, v2, v3):\n    return (v1 - v2) ** 2 + (v2 - v3) ** 2 + (v3 - v1) ** 2\n\ndef final(a, b_list, c):\n    final_close = bisect(b_list, (a + c) / 2)\n    if final_close == 0:\n        return calculate(a, b_list[final_close], c)\n    if final_close == len(b_list):\n        return calculate(a, b_list[final_close - 1], c)\n    else:\n        return min(calculate(a, b_list[final_close], c), calculate(a, b_list[final_close - 1], c))\n\ndef solve():\n    (n_r, n_g, n_b) = [int(x) for x in input().split()]\n    r = [int(x) for x in input().split()]\n    g = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    r.sort()\n    g.sort()\n    b.sort()\n    best = int(1e+21)\n    for ele in r:\n        close_g = bisect(g, ele)\n        if close_g != 0:\n            best = min(best, final(ele, b, g[close_g - 1]))\n        if close_g != n_g:\n            best = min(best, final(ele, b, g[close_g]))\n        close_b = bisect(b, ele)\n        if close_b != 0:\n            best = min(best, final(ele, g, b[close_b - 1]))\n        if close_b != n_b:\n            best = min(best, final(ele, g, b[close_b]))\n    print(best)\n    return\nt = int(input())\nfor i in range(t):\n    solve()", "from bisect import bisect_left, bisect_right\n\ndef getf(a, b, c):\n    return (a - b) ** 2 + (b - c) ** 2 + (a - c) ** 2\n\ndef getcondition(low_arr, mid_arr, high_arr):\n    s = 10 ** 20\n    for i in mid_arr:\n        x_p = bisect_right(high_arr, i)\n        x = 10 ** 9\n        if x_p != len(high_arr):\n            x = min(x, high_arr[x_p])\n        if x_p != 0:\n            x = min(x, high_arr[x_p - 1])\n        y = -10 ** 9\n        y_ptr = bisect_left(low_arr, i)\n        if y_ptr != 0:\n            y = max(y, low_arr[y_ptr - 1])\n        if y_ptr != len(low_arr):\n            y = max(y, low_arr[y_ptr])\n        curr = getf(i, x, y)\n        if curr < s:\n            s = curr\n    return s\nfor _ in range(int(input())):\n    (r, g, b) = map(int, input().split())\n    red = sorted(list(map(int, input().split())))\n    green = sorted(list(map(int, input().split())))\n    blue = sorted(list(map(int, input().split())))\n    ans = []\n    ans.append(getcondition(red, blue, green))\n    ans.append(getcondition(green, blue, red))\n    ans.append(getcondition(red, green, blue))\n    ans.append(getcondition(blue, green, red))\n    ans.append(getcondition(blue, red, green))\n    ans.append(getcondition(green, red, blue))\n    print(min(ans))", "import bisect\n\ndef final_solve(R, G, B):\n    ans1 = []\n    for i in range(len(R)):\n        j = bisect.bisect(G, R[i])\n        if j < len(G) and abs(R[i] - G[j]) < abs(R[i] - G[j - 1]):\n            y = G[j]\n        else:\n            y = G[j - 1]\n        m = bisect.bisect(B, R[i])\n        if m < len(B) and abs(R[i] - B[m]) < abs(R[i] - B[m - 1]):\n            z = B[m]\n        else:\n            z = B[m - 1]\n        ans1.append(solve(R[i], y, z))\n    return min(ans1)\n\ndef solve(x, y, z):\n    return (x - y) ** 2 + (y - z) ** 2 + (z - x) ** 2\nt = int(input())\nans = []\nfor s in range(t):\n    (nr, ng, nb) = [int(x) for x in input().split()]\n    r = [int(x) for x in input().split()]\n    g = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    r.sort()\n    g.sort()\n    b.sort()\n    ans.append(min(final_solve(r, g, b), final_solve(r, b, g), final_solve(g, b, r), final_solve(g, r, b), final_solve(b, r, g), final_solve(b, g, r)))\nfor it in ans:\n    print(it)"]